[
    {
        "title": "Permutation Sequence",
        "question_content": "The set [1, 2, 3, ...,&nbsp;n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\t\"123\"\n\t\"132\"\n\t\"213\"\n\t\"231\"\n\t\"312\"\n\t\"321\"\n\nGiven n and k, return the kth permutation sequence.\n&nbsp;\nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9\n\t1 <= k <= n!",
        "solutions": [
            {
                "id": 22507,
                "title": "explain-like-i-m-five-java-solution-in-o-n",
                "content": "**EDIT: I\\'m tired of some of you commenting on the O(n)-ness of this and especially those of you with snarky condescending tones. It\\'s not difficult to implement your own data structure that can do O(1) \"list\" remove. I\\'m not going to put all that code here and dilute the the main solution which is the pattern of solving the permutations. The description on the pattern is already long enough as it is. If you can\\'t figure out how to do an O(1) remove, then you shouldn\\'t be doing this problem in the first place. Those of you commenting condescendingly, take a freaking break from leetcoding all day. Those of you with kind words and thanks, you\\'re welcome and thanks for taking the time to read through the somewhat long description.**\\n\\nI\\'m sure somewhere can be simplified so it\\'d be nice if anyone can let me know. The pattern was that:\\n\\nsay n = 4, you have {1, 2, 3, 4}\\n\\nIf you were to list out all the permutations you have \\n\\n1 + (permutations of 2, 3, 4)\\n<br>2 + (permutations of 1, 3, 4)\\n<br>3 + (permutations of 1, 2, 4)\\n<br>4 + (permutations of 1, 2, 3)\\n\\n<br>We know how to calculate the number of permutations of n numbers... n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the \\n\\n3 + (permutations of 1, 2, 4) subset. \\n\\nTo programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3.\\n\\nThen the problem repeats with less numbers.\\n\\nThe permutations of {1, 2, 4} would be:\\n\\n1 + (permutations of 2, 4)\\n<br>2 + (permutations of 1, 4)\\n<br>4 + (permutations of 1, 2)\\n\\nBut our k is no longer the 14th, because in the previous step, we\\'ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be...\\n\\nk = k - (index from previous) * (n-1)! = k - 2*(n-1)! = 13 - 2*(3)! = 1\\n\\nIn this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We\\'re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. \\n\\nMeaning: index to get number from is k / (n - 2)!  = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1\\n\\n<br>so the numbers we have so far is 3, 1... and then repeating without explanations.\\n\\n<br>{2, 4}\\n<br>k = k - (index from pervious) * (n-2)! = k - 0 * (n - 2)! = 1 - 0 = 1;\\n<br>third number\\'s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1... from {2, 4}, index 1 has 4\\n<br>Third number is 4\\n\\n<br>{2}\\n<br>k = k - (index from pervious) * (n - 3)! = k - 1 * (4 - 3)! = 1 - 1 = 0;\\n<br>third number\\'s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0... from {2}, index 0 has 2\\n<br>Fourth number is 2\\n\\n<br>Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding.\\n\\n\\n\\n    public class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        // factorial[] = {1, 1, 2, 6, 24, ... n!}\\n        \\n        // create a list of numbers to get indices\\n        for(int i=1; i<=n; i++){\\n            numbers.add(i);\\n        }\\n        // numbers = {1, 2, 3, 4}\\n        \\n        k--;\\n        \\n        for(int i = 1; i <= n; i++){\\n            int index = k/factorial[n-i];\\n            sb.append(String.valueOf(numbers.get(index)));\\n            numbers.remove(index);\\n            k-=index*factorial[n-i];\\n        }\\n        \\n        return String.valueOf(sb);\\n    }\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 696595,
                "title": "c-very-easy-and-detailed-explanation-idea-code",
                "content": "Let us first take an example to under the idea:\\nSuppose n = 4.\\nSo we have elements  - 1,2,3,4\\nThere are total n!= 4! = 24 permutations possible. We can see a specific pattern here:\\n\\n```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope you enjoyed it. If there is any blunder kindly let me know.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22512,
                "title": "share-my-python-solution-with-detailed-explanation",
                "content": "The idea is as follow:\\n\\nFor permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, ... and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, ...\\n\\ntake n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue.\\n\\n    import math\\n    class Solution:\\n        # @param {integer} n\\n        # @param {integer} k\\n        # @return {string}\\n        def getPermutation(self, n, k):\\n            numbers = range(1, n+1)\\n            permutation = ''\\n            k -= 1\\n            while n > 0:\\n                n -= 1\\n                # get the index of current digit\\n                index, k = divmod(k, math.factorial(n))\\n                permutation += str(numbers[index])\\n                # remove handled number\\n                numbers.remove(numbers[index])\\n    \\n            return permutation",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 22508,
                "title": "an-iterative-solution-for-reference",
                "content": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 22544,
                "title": "easy-understand-most-concise-c-solution-minimal-memory-required",
                "content": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22665,
                "title": "clean-java-solution",
                "content": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 696910,
                "title": "c-100-time-space-efficient-iterative-solution-detailed-explanation-with-example",
                "content": "The approach is mathematical. The idea is to keep selecting a digit and eliminating it from further selection based on value of K. \\n\\nFor example:\\n\\n**Given, N = 4, K = 9**\\n\\nThere are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\nThere are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\nSimilarly, there are 6 numbers starting with 3 and 6 numbers starting with 4.\\n\\n**This is because when we have chosen one place out of 4 places (as N=4), there are 3 places remaining to be filled and those 3 places can be filled in 6 ways or (N-1)! ways.**\\n\\nSo, we have to keep identifying which digit to choose. \\n\\nInitially, we have to choose a digit from **{1,2,3,4}.**\\n\\nSince K = 9, meaning it belongs to second set of six numbers and hence, would begin with 2.\\n\\n**Now, first place is chosen as 2 and output string becomes \"2\". \\nThis means we have eliminated 6 choices starting with 1 (1234, 1243, 1324, 1342, 1423, 1432).**\\n\\nNow, K would be updated as **K = 9 - 6 = 3.**\\n\\nWe now have to identify remaining 3 places with the digits **{1,3,4}** and with **K = 3.**\\n\\nThere are 2 numbers starting with 1: 134, 143\\nThere are 2 numbers starting with 3: 314, 341\\nThere are 2 numbers starting with 4: 413, 431\\n\\nThis is because when we have chosen one place out of 3 available places, there are 2 places remaining to be filled and those 2 places can be filled in 2 ways.\\n\\n**Since, K = 3, meaning it belongs to second set of two numbers and hence, answer would be appended with \"3\" and output string becomes \"23\". \\nThis means we have eliminated 2 choices starting with 1 (134, 143).**\\n\\nNow, K would be updated as K = 3 - 2 = 1.\\n\\nWe now have to identify remaining 2 places with the digits **{1,4}** with **K = 1.**\\n\\nThere is 1 number starting with 1: 14\\nThere is 1 number starting with 4: 41\\n\\nThis is because when we have chosen one place out of 2 available places, there is only 1 place remaining to be filled and that 1 place can be only be filled in 1 ways.\\n\\n**Since, K = 1, meaning it belongs to first set of one number and hence, answer would be appended with \"14\" and output string becomes \"2314\".**\\n\\n**Therefore, final answer becomes \"2314\".**\\n\\nHope it helps! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502436,
                "title": "c-100-fastest-solution-best-approach-with-good-explanation-easy-to-understand-1",
                "content": "**Intution:-**\\n\\nSince this is permutaion we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numers. Now the problem is shorter. We can repeat the technique that was used previously untl all the positions are filled.\\n\\n**On Paper Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/0e4a79f7-809b-40b3-8f55-c89f81297d35_1661835688.8905008.jpeg)\\n\\n\\n**Approach**\\n\\n**STEP 1:**\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\n* The 0th \\u2013 5th permutation will start with 1 \\n* The 6th \\u2013 11th permutation will start with 2\\n* The 12th \\u2013 17th permutation will start with 3 \\n* The 18th \\u2013 23rd permutation will start with 4.\\n\\n\\t(For better understanding refer to the picture below.) \\n![image](https://lh5.googleusercontent.com/DgoKjAy6h0xfEl2LcWJ_aDg93Q0_gXEZkwVjH13b52VEkUtJXhrHjkav0GM5HJV8XyoRTsjN4CZrA8hCJt634hG-7vy6BP_xdpZ7HlPF_PAGCOXqNDPT0ikc_fOaQ90ktFZhPI9g)\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n![image](https://lh4.googleusercontent.com/p62qRS1NYnrf8_DPQd3xg8mKTx-OZQ0otukMXtq7RF4xVr_xz4m569bOtFRTrh3QbTldIPMYi0Cco84dRdiH5nYxMppIYRib5drCzGc2fcXiTzrYEIyZLuDmzHjR1KhrYBt9P4_s)\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\n* The 0th \\u2013 1st sequence starts with 1 \\n* The 2nd \\u2013 3rd sequence starts with 2 \\n* The 4th \\u2013 5th sequence starts with 4\\n\\n![image](https://lh5.googleusercontent.com/nv-M9Ju-zoy_O7wtTb8jZZf8f5q4fdr9X987UspvacgJB4E-pVdm-3n4aT5M67KUsBp3LAFNbzNesnBFKz4f5dJoGGhuj51WpulR9dR8zPY821Uu1skTSQ7y4RCfJlfK4HDdD3p-)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n![image](https://lh4.googleusercontent.com/kLizY46WNhTvnZDI4mvG-U1JJ6k_cLVD8UbkczsXeUMKf-xA8CWP_3_8DB-i_YgwQ6gBnSn6HxGfYeym9F4Qf24t6ckMhCWTqsxeUS0ExmM5nP-P4f2Az609jOKui5Cq3mc9ApZg)\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\n* The  0th sequence starts with 1 \\n* The  1st sequence. starts with 2\\n\\n![image](https://lh4.googleusercontent.com/XSVzdDLZjo7kL5vSOEL6WYrmk7t1JqnzLCV67tYFbWBey5s0UiJ0nKFuL_sYYIqEpy2WE9x4ez-am_P4k-6ytuAEx7i1ZGmm2WtTROgS7QRa8HwxT48my-87VuhAq2VtbIs96448)\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n\\n![image](https://lh6.googleusercontent.com/ywkmQGIHcK0gpydKJ6PrNH1nTmnfFv7otGzzBTeWSOw9965Mq61wperoFrRi54fVoedVKFG5n2WG9fzbnzMQhGBOzniNsGZw87pnVyFsipAYeda7Rl6CTc2A-zmzpoIO7nWtOS3G)\\n\\n**STEP 4:** \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/de57d8f1-b056-43f1-a511-7092eef574a3_1661822303.9951882.png)\\nThis is the point where we place 2 in the last position and stop.\\n![image](https://assets.leetcode.com/users/images/854d11a9-624b-492a-a9f7-0cc6ae5b1d99_1661822341.666998.png)\\n**The final answer is 3412.**\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Code Dry run:-**\\n![image](https://assets.leetcode.com/users/images/8e2c1e09-bb27-48df-8888-0912df17f2a2_1661835737.2826996.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696390,
                "title": "python-math-solution-oneliner-both-o-n-2-expained",
                "content": "The simplest way to solve this problem is use backtracking, where you just generate all sequences, with complexity `O(k) = O(n!)`. We can do better. Let us consider an example: `n=6`, `k=314`. How we can find the first digit? There are `5! = 120` permutations, which start with `1`, there are also `120` permutations, which start with `2`, and so on. `314 > 2*120` and `314 < 3*120`, so it means, that the fist digit we need to take is `3`. So we build first digit of our number, remove it from list of all digits `digits` and continue:\\n\\n1. `k = 314-2*5! = 74`, `n - 1 = 5`, `d = 3`, build number so far `3`, `digits = [1,2,4,5,6]`\\n2. `k = 74-3*4! = 2`, `n - 1 = 4`, `d = 0`, build number so far `35`, `digits = [1,2,4,6]`\\n3. `k = 2-0*3! = 2`, `n - 1 = 3`, `d = 0`, build number so far `351`, `digits = [2,4,6]`\\n4. `k = 2-1*2! = 0`, `n - 1 = 2`, `d = 2`, build number so far `3512`, `digits = [4,6]`\\n5. `k = 0-1*1! = 0`, `n - 1 = 1`, `d = 2`, build number so far `35126`, `digits = [4]`\\n6. Finally, we have only one digit left, output is `351264`.\\n\\n**Complexity**. I keep list of `n` digits, and then delete them one by one. Complexity of one deletion is `O(n)`, so overall complexity is `O(n^2)`. Note, that it can be improved to `O(n log n)` if we use SortedList, but it just not worth it, `n` is too small.\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n\\n### Oneliner\\nHere it is, with `O(n^2)` complexity!\\n\\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22524,
                "title": "sharing-my-straightforward-c-solution-with-explanation",
                "content": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "codeTag": "Unknown"
            },
            {
                "id": 22554,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22650,
                "title": "0ms-c-12-line-concise-solution-no-recursion-no-helper-function",
                "content": "Attached please find my solution.\\n\\nIdea:\\n\\n- For an n-element permutation, there are (n-1)! permutations started with '1', (n-1)! permutations started with '2', and so forth. Therefore we can determine the value of the first element.\\n\\n- After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth.\\n\\nComplexities:\\n\\n- Time complexity: O(n^2)   \\n\\n- Space complexity: O(n)\\n\\n==\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }\\n            \\n            // let k be zero base\\n            --k;\\n            \\n            // the main part.\\n            string ret(n, 0);\\n            for (int idx = 0; idx < n; ++idx) {\\n                int select = k / fract[idx];\\n                k %= fract[idx];\\n                ret[idx] = dict[select];\\n                dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22546,
                "title": "simple-0s-c-solution",
                "content": "since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster.\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            --k;\\n            for (int i = n; i >= 1; --i) {\\n                int j = k / f[i - 1];\\n                k %= f[i - 1];\\n                res.push_back(nums[j]);\\n                nums.erase(nums.begin() + j);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 1305852,
                "title": "c-recursive-solution-maths-explained-0ms-faster-than-100",
                "content": "**Question is to find the Kth permutation of a given number.**\\n\\nNaive approach to solve this problem is to store all the possible permutations in an array and then simply return the kth one. This approach works perfectly fine but is having poor time complexity \\uD83D\\uDE11\\n\\nThe most optimised approach of this question (according me) is rather than traversing on each and every possible permutation, we should only go to the kth one !! Rather than making an array, recursive function should just return the perfect one i.e. the kth one. \\uD83D\\uDE42\\uD83D\\uDD25\\n\\nNow the question is, How can we do that ?? How can we reach directly to the kth permutation ? And the answer to this question is, by simply using a little bit of maths \\uD83D\\uDD22 .\\n\\n**MATHS EXPLANATION**\\n\\nWe know that number of permutations of a given number is simply calculated as n! where n is the number of digits of number n. To conclude, we can assure that number with n digits will have n! permutations and we can further say that it will have n groups of (n-1)! permutations.\\n\\nWe can simply see in this figure that we can make n groups of (n-1)! and we can check in which group kth permutation will lie.\\n\\n![image](https://assets.leetcode.com/users/images/463493a4-f198-4e4b-b890-2f99560aff07_1625003760.0458527.png)\\n\\nAfter finding the most suitable group for the kth permutation, we will then do the same for that group as well and in that case, there will be (n-1) groups for (n-2)! permutations.\\n\\nWe will keep doing the same recursively until we find the best result i.e kth permutation.\\n\\nHere is the code for the problem : \\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\nI am still not sure if this is the best solution even after 0ms and faster than 100 % . Do upvote if you liked my approach ! All the best ! Happy Learning.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257221,
                "title": "c-solution-with-comments-brute-force-and-optimal-easy-understanding",
                "content": "***Please Upvote if it helps you...***\\n![image](https://assets.leetcode.com/users/images/308215da-c176-4c85-9e1d-0200c754cf7f_1657345920.9695845.gif)\\n\\n***\\n***Solution 1: Brute Force Solution***\\n***\\n***\\n***Approach:***\\n***\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n***\\n***\\n***C++ Code:-***\\n***\\n```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\\n***\\n***\\n***Time complexity: O(N!  N) +O(N! Log N!)***\\n\\n***Reason:***  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n***Space complexity: O(N)*** \\n\\n***Reason:*** Result stored in a vector, we are auxiliary space taken by recursion\\n***\\n***\\n***Solution 2:(Optimal Approach)***\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n***\\n***Intuition:***\\n\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter. We can repeat the technique that was used previously until all the positions are filled. The technique is explained below.\\n***\\n***\\n***Approach:***\\n\\n***STEP 1:***\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/d01d09a0-37d2-4152-89ec-87dadd9ac1c1_1657345602.0382993.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n![image](https://assets.leetcode.com/users/images/ba557ff2-c1cb-45a3-99f9-26eee5183535_1657345592.8419704.png)\\n***\\n\\n***STEP 2:***\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n![image](https://assets.leetcode.com/users/images/971c94d9-7368-4160-b681-9ae4fb1c2688_1657345583.4629538.png)\\n\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n***\\n\\n***STEP 3:***\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n![image](https://assets.leetcode.com/users/images/e75d4c48-36b5-4952-aebf-805e73a66da5_1657345575.3617208.png)\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n***\\n\\n\\n***STEP 4:***\\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/0c53bf48-30eb-4f5a-9ca7-5a1995a0da9a_1657345567.3807125.png)\\n\\n\\nThis is the point where we place 2 in the last position and stop.\\n***\\n\\n***The final answer is 3412.***\\n***\\n***\\n\\nC++ Code:-\\n***\\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```\\n***\\n***\\n***Time Complexity: O(N)  O(N) = O(N^2)***\\n\\n***Reason:*** We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are storing  the numbers in a data structure(here vector)\\n***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22597,
                "title": "does-anyone-have-a-better-idea-share-my-accepted-python-code-here",
                "content": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "codeTag": "Java"
            },
            {
                "id": 2992652,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\\n\\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2777028,
                "title": "permutation-sequence-java-solution-1-bruteforce-approach-2-optimal-approach",
                "content": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557729,
                "title": "java-solution-with-complete-explanation",
                "content": "\\n**Solution 1: Brute Force Solution**\\n\\n**Approach:**  \\n\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n\\n```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\\n\\n**Output:**\\n\\nThe Kth permutation sequence is 213\\n\\n**Time complexity: O(N! * N) +O(N! Log N!)**\\n\\n**Reason**:  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n**Space complexity: O(N) **\\n\\n*Reason: Result stored in a vector, we are auxiliary space taken by recursion*\\n\\n**Solution 2: (Optimal Approach)**\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n\\n**Intuition -**\\n\\nI am following 0 - indexing so if K = 17, i.e., the answer is 16th permutation.\\nStore n numbers in a list -> [1, 2, 3, 4]\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. \\nFirst, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter\\nWe can repeat the technique that was used previously until all the positions are filled.\\n\\n**Approach:** \\n\\n**STEP 1**:\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/35d54383-2d3f-42a6-82bf-f38511ab8c31_1662819193.3723998.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n[![image](https://assets.leetcode.com/users/images/7f02a0f1-1adc-48ba-ac37-364bdc169b25_1662819176.872596.png)\\n](http://)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n[![image](https://assets.leetcode.com/users/images/3fb9e3ce-cae1-43b7-9280-4ae73933cdaa_1662819149.794847.png)\\n](http://)\\n\\n\\n**STEP 4**: \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n\\n[![image](https://assets.leetcode.com/users/images/735de33d-78fc-4ec9-86ac-d19b026cffa5_1662819077.3672447.png)\\n](http://)\\nThis is the point where we place 2 in the last position and stop.\\n\\n\\nThe final answer is \"3412\".\\n\\n**Code-**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N) * O(N) = O(N^2)**\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n**Space Complexity: O(N) **\\n\\nReason: We are storing  the numbers in a data structure(here vector)\\n\\n**Do Upvote :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191348,
                "title": "c-0ms-100-with-algorithm-explanation",
                "content": "as we know \n    4! = 24 = 4*(3!) \nthat means the first layer looks like\n   '1'[][][],'2'[][][],'3'[][][],'4'[][][]\n then we can search which position number 9 will be at this layer:\n    position = 9/3! = 1.5 \n and we know  the first number position will be [1.5] = 2, which represent '2'[][][],we know the first number is '2'\n    the remainder is 9%3! = 3\n then we use this number enter next layer:\n    '1'[][],'3'[][],'4'[][]\n     position = 3/2! = 1.5\n     [1.5] = 2 which represent '3'[][], we know the second number is '3'\n......\n    repeat until we get remainder 0, that means we need to take Maximum arrangement in this layer.\nso reverse and append to result.\nsorry my english is pool\n![image](https://assets.leetcode.com/users/somone23412/image_1541753944.png)\n```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```",
                "codeTag": "C++"
            },
            {
                "id": 696782,
                "title": "python3-solution-explained-with-a-tip-for-faster-execution-beats-99-8",
                "content": "My solution is basically the same with the many others but here is another explanation:\\n\\nLet\\'s go over an example:\\n```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\\nAs you can see first digit changes after 6 occurances which is (n-1)! and the second digit changes after 2 occurances  which is (n-2)!. Similarly third digit changes after 1 occurances which is (n-3)!. Is this a coincidance? Of course not. Since it is a permutation we compute it like this:\\n```(n)(n-1)(n-2)...(1)```  each paranthesis represents a digit. for the first place, we have n options. After using one of the numbers, we cannot use it again. So we have n-1 number options for the second place. In the end we multiply them to get the total number of permutations. Let\\'s say we picked \\'1\\' for the first place. now we have (n-1)! options for the rest of the number. This is why at each step a number is repeated that many time. \\n\\nLet\\'s go back to our example:\\n\\nSince the first digit is repeated (n-1)! times, by dividing the k by n we can find our first digit. Division must be integer division because we are only interested in the integer part.\\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\\nNumbers that we can use as digits are = ```[1,2,...,n]```\\n\\nSo, our first digit is the digit at index 1 which is ```2```. We take the digit at 1 because our list is sorted so we are sure that the second smallest digit is at index 1.\\n\\nSince we used ```2```, we need to remove it from our list and k takes the value of the remainder. You can think of lit ike this: we decided on our first digit so we can discard that part and deal with the rest of the number. As you can see the problem is the same! but this time we have (n-2)! instead of (n-1)!, k=remainder and we have one less number in our list. \\n\\n\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\\n\\n**Tips:**\\n*  Don\\'t make ```ans``` a string because strings are not modified in place. It creates another copy of the string which makes your code slower. Instead of string, use a list which is pretty easy to append at the end, and then concatenate them in the end with join function.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\n```(n)(n-1)(n-2)...(1)```\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\n```[1,2,...,n]```\n```2```\n```2```\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\n```ans```",
                "codeTag": "Java"
            },
            {
                "id": 1309839,
                "title": "editorial-easy-explanation",
                "content": "# ****using some maths\\n**for ex: you have n = 4\\nthen there will be 4! permutations and k=17\\nthen if we are using 0 based index then we have to find 16th index\\nNow as it is lexicographically sorted\\nthen first digit 1 , other digits {2,3,4} permutations then\\nfirst digit 2 , other digits {1,3,4} perm then\\nfirst digit 3 , other digits{1,2,4}+ {}\\nfirst digit 4 , other digits{1,2,3}**\\n**Now for {1,3,4} there will be 3! = 6 perm\\nand so on for other 3\\nso if we have to find 16 it will start from 3 as 0-5 start from 1\\n6-11 start from 2  12-17 start from 3 and 18-23 from 4\\nNow as we fixed first place as 3,___,___,___\\nWe will  find second place digit which will be \\n1 {2,4} perms + 2{1,4} perms + 4{1,2} perms\\nNow {2,4} will be 2! perms i.e 2 so first two will start from 1 next two from 2 and last two from 4 we have to find  16-12 ->4th term  which will start from 4 because 0based indexing(0,1,2,3,4)\\nso Now 3,4,___,____ two digits left to find \\n1{2} and 2{1} NOw 12 + 4 16 gone 17th term is 1{2} \\nso 3,4,1,2\\nSimple formula if n=4 start from 3! ,2!,1!\\n                    k=17 first index will be k/3!\\n\\t\\t\\t\\t\\tand next k will be k%3!\\n\\t\\t\\t\\t\\tNow you can see from code you will understand it easily:**\\n\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# ****Do upvote!!\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22518,
                "title": "c-backtracking-stl-math-solutions",
                "content": "**Solution 1.** Backtracking\\n\\nRun Time: 266ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\\n***\\n**Solution 2.** Using STL\\n\\nRun Time: 119ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n***\\n**Solution 3.** Math. C++ version of this [thread](https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n)\\n\\nRun Time: 3ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761329,
                "title": "c-hinglish-easy-explanation-recursion-interview-prep",
                "content": "# Approach\\n- Explained properly in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(n^2)$ `n for placing them in n positions` and another `n for removing from vector`.\\n\\n- Space complexity: $O(n)$ just a `vector`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22659,
                "title": "python-concise-solution",
                "content": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1738840,
                "title": "solution-swift-permutation-sequence-test-cases",
                "content": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912564,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696542,
                "title": "c-easy-with-next-permutation",
                "content": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500712,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Some facts about permutation:\\n\\t* For `n`, it has `n!` permutations\\n2. Use `k` to find which permutation set it\\'s in, and keep deciding inner permutation sets.\\n\\n```\\nn = 4, k = 9\\n```\\n\\n| Current K: 9 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |   [2,3,4]   |       3! = 6      |        |\\n| 2            |   [1,3,4]   |       3! = 6      | <----- |\\n| 3            |   [1,2,4]   |       3! = 6      |        |\\n| 4            |   [1,2,3]   |       3! = 6      |        |\\n\\n| Current K: 3 |      |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |    [3,4]    |       2! = 2      |        |\\n| 3            |    [1,4]    |       2! = 2      | <----- |\\n| 4            |    [1,2]    |       2! = 2      |        |\\n\\n| Current K: 1 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |     [4]     |       1! = 1      | <----- |\\n| 4            |     [1]     |       1! = 1      |        |\\n\\n| Current K: 0 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 4            |      []     |                   | <----- |\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nn = 4, k = 9\\n```\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22621,
                "title": "an-efficient-java-solution-without-extra-space-or-previous-calculation-of-factorial",
                "content": "This problem consists of two parts.\\n\\nPart one, find the array A[0..n-1] that satisfies:\\n\\n**k-1  =  (n-1)!*A[0]  +  (n-2)!*A[1]  + ... +  2!*A[n-3]  +  1!*A[n-2]  +  0!*A[n-1]**\\n\\nand **0 <= A[i] < n-i** (so the last item in the formula above is always 0).\\n\\nIt's obvious that the array A[0..n-1] can be calculated either from 0 to n-1 or reversely. In order to avoid previous calculation of factorial, A[0..n-1] is calculated from end to start here.\\n\\nPart two, translate A[0..n-1] into final sequence number. A[0..n-1] can be translated from end to start step by step, just like the mathematical solution of Joseph Circle.\\n\\n    public class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}\\n    \\t\\t\\tk -= k % fact;\\n    \\t\\t}\\n    \\t\\treturn new String(result);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3690575,
                "title": "o-1-time-complexity-god-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```\\n\\n[]https://leetcode.com/problems/pascals-triangle/discuss/3638748/O(1)-time-complexity-god-solution\\nprevious code leetcode 118. Pascal\\'s Triangle",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392423,
                "title": "backtracking-recursion-base-solution-in-c",
                "content": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 22540,
                "title": "share-my-easy-understand-solution-with-comments-java",
                "content": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500616,
                "title": "python-20ms-clean-code",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971501,
                "title": "c-next-permutation-best-o-n-log-n-by-set-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ STL makes such question so easy. Use iota to create a char array.\\nThen use next_permutation k-1 times to find the answer!\\n\\nnext_permutation takes $O(n)$ time to find the next permutation.\\n\\nThe second method does not use next_permutation, but calculates the permutations by successively using divisions over factorials. \\n\\nFor fast performance, the C++ set (ordered set) is used  A recurive version and  an iterative version are provided. Both of them beat 100% with runtime 0 ms!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on English if necessary]\\n[https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV](https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV)\\n# Why using set not array?\\nBecause in the code, it is necessary to erase elements from container in the middle. If array is used, the time for it is $O(n)$ which is too costly. An erase and an insert cost $O(\\\\log n)$, it is the right data structure for implementation.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log n)$$ for 2nd and 3rd solutions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code using next_permutation which is slow but accepted\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\\n# Code computing the permutations by successively using divisions over factorials beats 100% with runtime 0 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\\n# Code for iterative version\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```\\n![DALL\\xB7E 2023-08-23 11.18.53 - there are 3 dogs and 2 doghouses in realistic style.png](https://assets.leetcode.com/users/images/765dfa5f-111a-4a55-b6ea-56420c62cf3d_1693223500.3463383.png)\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807334,
                "title": "2-ms-java-explained",
                "content": "# Intuition\\nDivide and conquer\\u274C\\nRemove and conquer\\u2714\\n\\n# Approach\\nIn this code you have to only understand three lines \\nlets start with \\n1. ans = ans + num.get(k/fact); \\nSo lets take an example 1 as example , we have given n = 3 and k = 3\\nif we pick 1 then we left with 2 , 3;\\nif we pick 2 then we left with 1 , 3;\\nas we know permutation of n is n!,when we pick any number then picked number is not counted factorial of remaing number is stored, thats why \\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\nby this our factorial is 2 .\\nthere is factorial of n-1.\\nlets reduce the k by  1 because we have 0-based indexing , according to 0 based index we need now 2nd permutation\\nk = 2.\\nnow if we say what is k/fact , which gives us the starting value of our kth permutaion , which means 2/2 is 1 and we have to add 1th index value to our ans , now our ans is updated to 2.\\n2. lets understand this k = k % fact, \\nas we added 1 th index value to our ans , we have surity that if we pick 1th index then the permutations of remaining 2 elements give us next index to our ans , means\\nif we pick 2 then remaing is [1,3] then we have to find kth permutataion from this and so how can we update our k , so can it gives us value what we needed ,\\ncurrect k = 2 and fact  = 2,after 2 = 2 % 2, we have k = 0,which means we have our remaining value in 0th permutaion of remaining element [1,3].\\n3. fact = fact / num.size();\\nas we get our first value , so we have to remove it from our list , as we added   num.get(k/fact) to our ans , we have to remove it now ,\\nby this we removed it num.remove(k/fact); as in previous step we updated our k and elements left 2 so we have to also update our factorial also .\\nsee uf we have n =3 then factorial is 6\\nn = 2 then factorial is 2\\nn= 1 factorial is 1 , \\nand we know we will choose 1 value from our n then there is n-1 left , so we have to find factorial of n-1 , you will understand this after this,as we removed 2 we have remaing elements \\n[1,3] and k =0\\nwe know we will choose one element from this and find permutaions of remaining elements,\\n0th = we will choose 1 and find permutaion of [3]\\n1th  = we will choose 3 and find permutation of [1]\\nso why we need factorial of n-1, by this current fact = 2 and after removing 1th index from num size of our list is also 2 .\\n2 = 2 / 2 , nothing but 1.\\n- Now we are ready to pick our next value  new k = 0 , new list size is 2 and fact = 1.\\nans = ans + num.get(0/1), so we choose 0th index value from our list and remove it from list , now updated ans is 21.\\nAfter this we again update the value of k and fact , by steps i mention earlier new k is also 0  new fact is also 1 and new size of list is 1 ,  after this only one remaing value in our list is 1 we add it to ans and remove it from list which make list  0 \\n if(num.size()==0)break; and when this condition is checkec it break the infintie loop and return the ans .\\n\\nThank You , if any step i am wrong or unable to make clear concept forgive me \\uD83D\\uDE4F.\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775078,
                "title": "python-just-6-lines-to-build-it-digit-by-digit-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs remainder calculation to get permutation\\'s most significant digit on each iteration. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment**.  Every time we generate yet another `(n-1)!` permutations, the digit in the n-th position (starting from the left, 1-based indexing) increases by 1. Thus, to obtain digits in all positions, we simply reverse this logic.\\n\\n```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895093,
                "title": "java-mathy-solution-explained-100-recursive-thinking",
                "content": "Given n = 4, k = 9, we know that there at 6 permutation sequences that start with `1`\\n\\nThere are **6** because after the first number there are 3 numbers for the `2nd` position and 2 numbers for the `3th` position and 1 number for the `4th`\\n\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n...\\n`4XXX`\\n\\nKnowing this, we know we need to find the 9th sequence in this 24 sequences.\\nSince we know for k,\\n\\n`0-5`  starts with 1\\n`6-11` starts with 2\\n`12-18` starts with 3\\n`19-24` starts with 4\\n\\nSince 9 in the range of `6-12` we know the first character will be 2. We can calculate this with `k/(current_sample_size) * (groups of number)` (8/24 * 4) = 1\\n*since our list is 0 indexed we subtract 1 from k initally*\\n\\n*The tricky part here is figuring out the rest of the numbers*. \\n\\nNote that we after using the number `2`, we are left with `[1,3,4]` we just need to know where `9` lives on the second level\\n\\nGiven we are in the second quadrant, we know the first 2 numbers starts with first element in `[1,3,4]`, 2 for second element and so now.\\n\\n`1XX`\\n`1XX`\\n`3XX`\\n`3XX`\\n`4XX`\\n`4XX`\\nfor k,\\n`0-1`  starts with 1\\n`2-3` starts with 4\\n`4-5` starts with 3\\n\\nto find where 9 (really 8) sits between `6 -11`. We can subtract `8` by the left boundry `6` to transform `6 < 8 < 11` to `0 < 2 < 5`. We can reuse the last index we\\'ve calculated to find the left boundry by `(product/n * index)`\\nResize our product because now our sample size is reduced to 6. Our index 2 in this sample size correspond to the first instance  of `3XX`\\nReusing previous method to calculate index `(2/6) * 3 = 1`. Now we can go back to our List, grab and remove the element with index = 1. Which leaves us with `[1,4]`\\n\\nRepeat for next iteration: \\nrecalculate k: `2 - (2 * 2) = 0` (transform previous`(2 < 2< 3)` -> `0 < 0 < 1`)\\nresize product to 2 or *(2 * 1)*\\ncalculate for index in list: `0/2 * 2 = 0`\\nlist is now [4]\\nOur String is now 231\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```\\n\\n`Time: O(n^2)`\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696867,
                "title": "c-100-time-80-space-fully-explained-and-easy-to-understand-iterative-solution",
                "content": "The base idea is that the first character can be found knowing that it is repeated `(n - 1)!` times.\\n\\nIf you have `1234` as your own base, for example, all the permutations starting with, say, `2`, are going to be like this:\\n\\n`2134`\\n`2143`\\n`2314`\\n`2341`\\n`2413`\\n`2431`\\n\\nSince you can indeed only permutate remaining `n - 1` elements `(n - 1)!` times.\\n\\nSo you will have 6 permutations startins with `1`, 6 starting with `2` and so on.\\n\\nOnce you get the first character, the problem is just a replica of itself (being careful to remove the first character you just found, in the above case would be `2`) and considering a new `k` as the remainder of the division by `(n - 1)!`, so, in my code: `k %= fact[n]`.\\n\\nRinse and repeat until you either have no more characters left to assign (in my code it would have been `!chars.size()`) or slightly more efficient to compute at each loop, until `n`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIt might be fun also to turn it into recursive, although I guess it will take more memory for no significant gain; also, \\nI am wondering if I can avoid having a vector at all - probably so, but would complicate my logic significantly.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480959,
                "title": "java-100-100-o-n-2-o-n-with-explanation",
                "content": "See code comments for explanation\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\nTime complexity: O(n^2). Calculating factorials is O(n). Getting the correct num based on offset is upper-bounded at n + (n - 1) + ... + 1 or O(n^2).\\nSpace complexity: O(n). Both factorials and used arrays are n length.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22506,
                "title": "c-clean-code-with-explanation",
                "content": "1. Given n digits there will be total of `(n * (n-1) * ... * 2 * 1)` different permutations. - the 1st digit you have `n` options, 2nd digit you have `n-1`, ... last digit you only have `1` option.\\n2. Your choices to pick different number at each digit will form different groups of permutations. Example: Your choice for the `n` different number at the `1st` digit will result in `n` groups of permutations, start with `1` ~ `n`. and each group will contain `(n-1) * ... * 2 * 1)` permutations which can be further divided into n-1 groups, and so on...\\n3. Given `0-based` sequence index `k`, what is the 1st `number` of the `k`th permutation depend on which `group` it is in, and this can be calculated by `k / $group_size`, which is `k / ((n-1)*...*2*1)`, and within that group, its index will be `k % ((n-1)*...*2*1)`, and `k` should be updated as that.\\n4. Once 1st number is determined, the 2nd number can be determined by which sub-group it belongs to within the first level group, which again can be calculated by `k / $group_size`.\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954305,
                "title": "best-o-n-n-solution",
                "content": "# Approach\\nMath\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843054,
                "title": "5-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091180,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013756,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921581,
                "title": "15-ms-easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n) -> Linear\\n- Space complexity: O(n) -> To store the list[]\\n\\n# Code\\n```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445529,
                "title": "python-o-n-2-96-faster",
                "content": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```\\nIf you find it usefull ,do upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 698758,
                "title": "0ms-c-solution-explained",
                "content": "This problem can be solved with recursive approach. \\n\\n### OBSERVATION:\\n* Given n, we\\'ll be having (n-1)! permutations starting with 1, (n-1)! permutations starting with 2, and so on.. So, each block is of size (n-1!).\\n* So, this can be used to find out the first digit of the required sequence. Say, n=4 and k=15, then, k/(n-1!) = 2.5 so, the required permutation will be lying somewhere in the 3rd block. So, the number starts with 3.\\n\\n### APPROACH:\\n* Kth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\n* We can find the first digit in the sequence, and then apply the same technique to keep finding the first digit of the remaining part of the sequence until the whole sequence is found.\\n\\n### EXAMPLE:\\n*  We can find the first digit in the number and keep updating n and k to find the first digit in the remaining part of the number.\\n*  Say, n=4 and k=15. Now, nums = {1,2,3,4}.  ind = ceil(k/(n-1!) = 3. So, num is 3{}{}{}. \\n*  k = k%(n-1!), n=n-1\\n*  Now, n=3, k=3. nums={1,2,4}. ind = ceil(3/2) = 2. So, num is 32{}{}.\\n*  n=2,k=1, nums={1,4}. ind = ceil(1/2) = 1. So, num is 321{}.\\n*  n=1, k=1, nums = {4}. ind=ceil(1/1)=1. So, nums is 3214.\\n\\n#### NOTE:  \\n* Think about the case when k becomes zero before n. When does this happen? k becomes zero when n-1!=k (coz, k = k%n-1!). This means that this is the last element in the corresponding block, and obviously in this case, the remaining part of the permutation is going to be all the remaining digits arranged in descending order. \\n* eg: n=3,k=2.  \\n\\n### PSEUDOCODE:\\n```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\\n\\n### MY CODE:\\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```\\n\\nPS: This is not O(n) solution... It takes O(n^2) coz the erase() function of vector will always create a new vector array and copy the original value to it except the erased one...\\n\\n\\n",
                "solutionTags": [],
                "code": "```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696851,
                "title": "python-3-just-a-function-composition-fully-explained",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```\\n\\nThe solution just get composed from the existing function toolset following the thought train:\\n\\n`list(\"123456789\"[0:n])` elements of a permutation\\n\\n`permutations(list(\"123456789\"[0:n]))` **lazy** sequence of all permutations\\n\\n`enumerate(permutations(list(\"123456789\"[0:n])), start=1)` the same, but now each permutation is wrapped into a tuple with its order number, starting with `1`\\n\\n`dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n]))))` the same, but with first `k - 1` permutations skipped\\n\\n`next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))` the tuple having number `k` and the associated sought permutation\\n\\n`\\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])` converting the permutation from this tuple to string, mission accomplished!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268361,
                "title": "python-two-solutions-backtracking-40ms-and-math-36ms",
                "content": "Approach 1:  backtracking.\\nfirstly, we permute and count, got one and `k-=1`, when k==0, that is the kth. But it\\'s too slow, consider that, we permute`1234`,  when choose `1`, there are `a = factorial(len(rest))` permutations, if k > a, we don\\'t need permute starts with `1`. And minus the total `a`.\\n\\u6B64\\u9898\\u548C 46.Permutations \\u5F88\\u50CF\\uFF0C\\u4F46\\u662F\\u4F60\\u4E0D\\u80FD\\u5168\\u6392\\u51FA\\u6765\\u518D\\u901A\\u8FC7\\u7D22\\u5F15\\u6C42\\uFF0C\\u90A3\\u6837\\u4F1A\\u8D85\\u65F6\\u3002\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\\n\\nApproach 2:  math\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Backtracking"
                ],
                "code": "```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22539,
                "title": "java-recursive-and-iterative",
                "content": "Iterative:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nRecursive:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22610,
                "title": "share-my-0ms-c-solution-with-explanation",
                "content": "The question is:\\n\\nThe **set *[1,2,3,\\u2026,n]*** contains a total of ***n !*** ***unique* permutations**.\\n\\nBy listing and labeling all of the permutations ***in order***,\\nWe get the following sequence (ie, for ***n = 3***):\\n\\n - 1  \"***1*** 23\"\\n - 2  \"***1*** 32\"\\n - 3  \"***2*** 13\"\\n - 4  \"***2*** 31\"\\n - 5  \"***3*** 12\"\\n - 6  \"***3*** 21\"\\n\\nGiven ***n*** and ***k***, return the ***kth*** permutation sequence.\\n\\n**IMPORTANT : note the equation *N ! = N \\xd7 (N - 1) !***\\n\\nHere, ***3 ! = 3 \\xd7 2 !***, Let's get into the problem when ***n = 3***.\\n\\n***First***, we need to get the ***TOP DIGIT***. As listed above, the ***TOP DIGIT*** can be ***1, 2 or 3***.\\n\\n***1st*** and ***2nd*** 's ***TOP DIGIT*** is ***1***.\\n\\n***3rd*** and ***4th*** 's ***TOP DIGIT*** is ***2***.\\n\\n***5th*** and ***6th*** 's ***TOP DIGIT*** is ***3***.\\n\\nThe total ***n !*** is divided into ***3 parts***.\\n\\nDo you find some ***regularities*** when ***n = 3***?\\n\\nIf not, we can ***minus k by 1***, set p = k - 1, and then? \\n\\n - If ***p / (n - 1) ! = 0 (k = 1 and 2)*** , ***TOP DIGIT*** is ***1***.\\n - If ***p/ (n - 1) ! = 1 (k = 3 and 4)*** , ***TOP DIGIT*** is ***2***.\\n - If ***p / (n - 1) ! = 2 (k = 5 and 6)*** , ***TOP DIGIT*** is ***3***.\\n\\nAnd this is the ***FIRST RULE***. \\n\\n----------\\n## FIRST RULE ##\\n\\n***n !*** can be ***DIVIDED*** into ***n PARTS***, and the ***TOP DIGIT*** of ***pth (starts with 0) PART*** equals to ***p / (n - 1) ! + 1***\\n\\n----------\\n**Q** : how about the ***REST***?\\n\\n**A** : If the ***FIRST TOP DIGIT*** is determined, the same method can be used to find the ***SECOND TOP DIGIT***, and the ***THIRD TOP DIGIT ......***, but a little bit ***DIFFERENT***.\\n\\nFor example, if the ***FIRST TOP DIGIT A0*** is determined, \\n\\nthe total number of ***unique* permutations *STARTS WITH A0*** is ***(n - 1) !***.\\n\\nAs the ***FIRST RULE***, ***(n - 1) !*** can be ***DIVIDED*** into ***n - 1 PARTS***, and the ***TOP DIGIT*** of ***p' th PART*** equals to ***p'   / (n - 2) ! + 1***\\n\\n**NOTICE**: here ***p'*** is the **INTERNAL** sequence number of the unique permutations which ***starts with A0***\\n\\n----------\\n## SECOND RULE ##\\n\\n***p'*** is ***p*** in the ***SECOND ROUND***, and ***p' = p % (n - 1) !***\\n\\nWe can find the ***SECOND TOP DIGIT A1*** by calculate ***p' / (n - 2) ! + 1***,\\n\\nand ***p*** in the ***THIRD ROUND*** is ***p''***, and ***p'' = p' % (n - 2) !***\\n\\n***..............................***\\n\\nThis is the ***SECOND RULE***.\\n\\n----------\\n**Q** : Which number will be used as ***A0, A1, ...* (the *TOP DIGITS*)**?\\n\\n**A** : At the ***FIRST ROUND***, ***TOP DIGIT A0*** equals to  ***p / (n - 1) ! + 1***.\\n\\nWhen a number in [1,9] is ***USED*** as ***A0***, \\n\\nwe need to find the ***p' / (n - 2) ! + 1* SMALLEST** number in the ***REST*** to be ***A1***,\\n\\nand we need to find the ***p'' / (n - 3) ! + 1* SMALLEST** number in the ***REST*** to be ***A2***,\\n\\n***...................................***\\n\\n**IMPORTANCE** : To get this, a **size of *9 VECTOR*** should be set as a ***GLOBAL VARIABLE*** (or ***DATA MEMBER***), and let its ***q th*** element to be ***q + 1***\\n\\nNo matter which number is removed from the vector, its ***q th*** element will ***ALWAYS*** be the ***q th*** ***SMALLEST*** of the rest.\\n\\n----------\\n**Q** : When will the loop ***STOPs***?\\n\\n**A** : Each round we calculate ***p(m) = p(m - 1) % (n - m) !***,\\n\\nand there are ***n - m* *DIGITs*** which are **NOT** determined.\\n\\nIf ***n - m = 2***, there will be ***2* *DIGITs*** which are **NOT** determined,\\n\\nwhich means there are ***ONLY 2*** numbers left in the ***VECTOR***.\\n\\nNow, we can directly set the ***LAST DIGIT*** and the ***2nd LAST DIGIT***.\\n\\nWhen ***n - m = 2***, if p(m) = 0, the ***SMALLER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***1st element of the vector*** and the ***2nd LAST DIGIT*** the ***0th***.\\n\\nif p(m) = 1, the ***LARGER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***0th element of the vector*** and the ***2nd LAST DIGIT*** the ***1st***.\\n\\n----------\\n\\n***My code:***\\n\\n    class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }\\n\\n    void numberStrList(int n)\\n    {\\n           rtn = string (n, '0');\\n           record = vector<int>(n,1);\\n           for(int i = 0; i < record.size(); i++)\\n           {\\n                 record[i] += i;\\n           }\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        numberStrList(n);\\n        //start from 0\\n        k = k - 1;\\n        \\n        if(n == 1)\\n        {\\n             if(k == 0)\\n             {\\n                 return \"1\";\\n             }\\n             return \"\";\\n        }\\n        for(int i = 1; i < n - 1; i++)\\n        {\\n              rtn[i - 1] += record[k / factorial(n - i)];\\n              record.erase (record.begin() + k / factorial(n - i));\\n              k = k % factorial(n - i);\\n        }\\n        rtn[n - 2] += record[k^0];\\n        rtn[n - 1] += record[k^1];\\n        return rtn;\\n      }\\n     private:\\n     vector<int> record;\\n     string rtn;\\n     };",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 22605,
                "title": "python-i-think-this-is-clean-code-with-some-of-my-explanation",
                "content": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "solutionTags": [],
                "code": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "codeTag": "Java"
            },
            {
                "id": 22633,
                "title": "easy-to-understand-solution-with-sample",
                "content": "    class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }\\n            \\n            return result;\\n        }\\n        \\n    public:\\n        string getPermutation(int n, int k) {\\n            // 1234, 1243, 1324, 1342, 1423,1432,\\n            // n*(n-1)!\\n            // k/(n-1)!\\n            // k= k%(n-1)!\\n            // 123: n=3, k=4  => k=4-1 (for indexing from 0)\\n            // 3/(2!)=1, head[1]==2, k%(2!) = 1\\n            // 1/(1!)=1, head[1]==3, k%(1!) = 0\\n            // 0/(0!)=0, head[0]=1\\n            vector<int> result;        \\n            vector<int> nums;\\n            for(int i=1;i<=n;++i) {\\n                nums.push_back(i);\\n            }\\n            \\n            k=k-1;\\n            for(int i=0;i<n;++i) {\\n                int perms = getPermutationNumber(n-1-i);\\n                int index = k/perms;\\n                result.push_back(nums[index]);\\n                k%=perms;\\n                nums.erase(nums.begin()+index);\\n            }\\n            \\n            string s=\"\";\\n            for(int i=0;i<result.size();++i) {\\n                s += std::to_string(result[i]);\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3473883,
                "title": "after-looking-this-you-won-t-belive-this-is-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/057ba9ba-66e9-4bf2-9008-3b80680d7aca_1682949102.7328444.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091157,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013753,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376420,
                "title": "c-solution-4-approaches-stl-backtracking-iterative-recursion",
                "content": "**1st Appraoch\\n(USING STL - next_permutation)**\\n```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\\n\\n***2nd Approach- Backtracking (TLE)***\\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\\n\\n***Optimal Approach (  RECURSIVE)***\\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\\n\\n***Optimal Approach (Iterative)***\\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738232,
                "title": "c-math-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697280,
                "title": "java-clean-code-o-n-time-complexity-0-ms-time-98-57-faster",
                "content": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696369,
                "title": "1ms-easy-to-understand-solution",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 431424,
                "title": "simple-java-solution-using-backtracking",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348350,
                "title": "java-solution-with-explanation",
                "content": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "solutionTags": [],
                "code": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "codeTag": "Unknown"
            },
            {
                "id": 309634,
                "title": "swift-88-beat-factorial-trix-trixy-hobbits-m-a-t-h-l-o-l",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```\\n\\nThis is the same concept as previous solutions. \\n\\nIt is all stemmed from the fact that there are N! permutations for 1...N",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309606,
                "title": "c-100-beat-drooling-slackers-community-college-burnouts-copy-paste-awesome",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```\\n\\nPermutations of ABCD\\n\\nA + Permutations(BCD)\\nB + Permutations(ACD)\\nC + Permutations(ABD)\\nD + Permutations(ABC)\\n\\nPermutations of BCD\\n\\nB + Permutations(CD)\\nC + Permutations(BD)\\nD + Permutations(BC)\\n\\nThere are X! permutations in every X length subsequence. So just copy the solution from the other kid. This won\\'t help you code any video game.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278289,
                "title": "java-1ms-factorial-solution-with-detailed-explanation",
                "content": "Apparently, there are ```n!``` different permutations for given ```n```. Suppose ```m``` is the first element, then there are ```n - 1!``` permuations for the rest ```n - 1``` numbers. The case is similar to the second element to the nth element. \\n\\nWith that in mind, we can calculate the ```kth``` permutation from the first element to ```nth``` element. \\nAt first, we save ```1``` to ```n``` in a list ```num``` ascendently. \\nThen we traverse from ```1``` to ```n```,  the index of the ```ith``` element in ```num``` equals to ```k / (n - i)!``` and ```k``` is updated to ```k % (n - i)```. The picked element is then removed from the list.\\nKeep traversing until ```k = 0```. Then we add the rest elements in ```num``` to the ```kth``` permutation.\\n\\nThis solution has two tricks:\\n1. Use a list to save candidate elements\\n2. Set k to k - 1 (synchronize index) can simplify the calculation\\n\\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n!```\n```n```\n```m```\n```n - 1!```\n```n - 1```\n```kth```\n```nth```\n```1```\n```n```\n```num```\n```1```\n```n```\n```ith```\n```num```\n```k / (n - i)!```\n```k```\n```k % (n - i)```\n```k = 0```\n```num```\n```kth```\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190680,
                "title": "6ms-java-solution",
                "content": "Let's say n = 5 and k = 40;\nCurrently we have the following individual numbers:\n```\n1 2 3 4 5\n```\nAmong **n!** = **120** permutations **(n-1)!** = **24** of them will begin with **\"1\"**, the next **24** of them will begin with **\"2\"**, the next **24** will begin with **\"3\"** and so on.\nIn which case **40th** element will begin with **\"2\"**.\n\nNow the problem becomes among the following numbers, what is the 40 - 24 = **16th** permutation:\n\n```\n1 3 4 5\n```\nThe length of this set is 4, so **(4-1)!** = **6** of them will begin with **\"1\"**, the next **6** will begin with **\"3\"** and the next **6** wil begin with **\"4\"**.\nIn which case **16th** element will begin with a **\"4\"**.\n\nNow the problem is what is the 16 - 12 = **4th** permutation of the following set:\n\n```\n1 3 5\n```\n\n**2** of them will begin with a **\"1\"** and **3rd** and **4th** permutation will begin with a **\"3\"** and we need the **2nd** permutation from the remaining set which is:\n\n```\n1 5\n```\n**1st** permutation will begin with a **\"1\"** and **2nd** will begin with **\"5\"**.\n\nOverall result is:\n```\n24351\n```\n\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n1 2 3 4 5\n```\n```\n1 3 4 5\n```\n```\n1 3 5\n```\n```\n1 5\n```\n```\n24351\n```\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 22614,
                "title": "44ms-python-solution",
                "content": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 4033541,
                "title": "c-solution-beates-100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490124,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437099,
                "title": "java-solution-beats-100-sometimes-98-non-recursive",
                "content": "# Intuition\\nIterative traversal and removal of elemnents from the bucket\\n# Approach\\nthe appraoch is based upon how u take benifit of factorial\\n\\n# Complexity\\n- Time complexity:\\nO(N) beats 100%\\n\\n- Space complexity:\\n    beats 83%\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309989,
                "title": "3ms-n-n-c-short-sweet-code-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308352,
                "title": "java-beats-99-6-1ms-runtime-recursion",
                "content": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249501,
                "title": "1-liner-code-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Using the `Permutations` to find all the possible permutations.\\n2. Sorting in the ascending order.\\n3. Getting the `k-1` th value, which is a tuple\\n4. Converting that tuple in string format.\\n5. Returning the result.\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243187,
                "title": "c-recursion-backtracking-easy-brute-force-21-space-5-time",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028305,
                "title": "c-easy-to-understand-beats-100-percent-o-n-2",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731831,
                "title": "c-0ms-recursive-solution",
                "content": "The basic idea is to decrease the search space. Now, what does this mean, Actually if we want to place a number at the first position then it will be having (n-1)! ways to do it. So, let us take an example:\\n\\nn = 4 and k=9\\n\\nso, for suppose if we assume our answer will be having \\'1\\' at 1st position. Now let us write the possibilites:\\n\\n1 2 3 4\\n1 2 4 3\\n1 3 2 4\\n1 3 4 2\\n1 4 2 3\\n1 4 3 2\\n\\nand our k value is 9 but the number of possible ways with 1 are only 6. So 1 can\\'t be at first position.\\n\\nNow let us check for \\'2\\' but this time our k will be (9-6 = 3) [beacuse we will not again look into possiblilites of \\'1\\'].\\n\\nif we take 2 then 3-6<0, So here we can conclude that our answer will be having 2 at it\\'s first position. And similarly we will be checking for remaining\\n\\n\\n```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175708,
                "title": "simple-mathematical-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```\\nPlease upvote if you find it useful! :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121902,
                "title": "cpp-recursion-easy-solution",
                "content": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1978590,
                "title": "faster-than-91-people-with-explanation-simple-maths-of-probability",
                "content": "This is a simple approach of probability:\\n\\nThe explainattion goes something like this:\\nn= 4, k =9\\n\\nWe have an array = [1, 2, 3, 4]\\nand then we have 4 empty spaces to fill\\n_ _ _ _ _ \\n\\nSo considering that we are filling in position one with any of the numbers, we will then have a possibility of filling out the other 3 places by 3! ways.\\n\\nlet\\'s say we choose 1 to be put in position 1. Therefore 1 can be tied with 3! other solutions. We then can safely assume that if we choose 1 in position 1, then we will eliminate 6 possibilities. \\n1 : 1 - 6\\n2 : 7 - 12\\n3: 13 - 18 \\nBut we have 9 as the value of k, that means that we will have to go up the array and choose 2. \\n\\nThe array now becomes [1, 3, 4] as 2 was already picked up to be placed at position 1. \\n\\n_ _ _ _ _ \\n\\nNow that we have made a good assumption of choosing 2, we narrowed down our search. We can then go to the next place and hence we will also have to narrow down our search space\\nhence : k = k % 2! \\n\\nwe did 2! as there are 3 places to be filled in and we are checking which block of combinations it will fit in\\n\\nWe can keep repeating these steps till we have a value in arr. \\n\\n\\n```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760283,
                "title": "recursive-backtracking-solution-java",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750234,
                "title": "c-not-the-best-but-easiest-solution-136-200ms",
                "content": "**When I mean easiest solution, it is! The best solution for this problem uses recursion, and you can as close as a 0ms of runtime. However, this approach to the problem uses brute force.**\\n\\nBasically, the main idea is get all the permutations and iterate them.\\n1.- Get the string with the number, from 1 to n.\\nExamples:\\n&emsp;n = 3\\n&emsp;string = \"123\"\\n\\n&emsp;n = 5\\n&emsp;string = \"12345\"\\n\\n2.- Set the counter to 1. This will help us when to stop the permutations loop.\\n3.- Using a while loop we will sort the permutations by ascending order.\\n4.- Every cycle check if our counter is equal than k, if it is return the string else increase the var.\\n\\n*Documentation*\\nnext_permutation: https://en.cppreference.com/w/cpp/algorithm/next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489898,
                "title": "java-solution-iterative-o-n-time-complexity",
                "content": "If the string is \"1234\", the possible permutations are 24 i.e. (4!)\\nBased on the value of k, we can come to a conclusion about the first digit of the kth permutation\\n\\nIf k=6, the kth permutation of \"1234\" is \"1432\"\\nTo get the answer -\\n-----> get the first_digit + do the operation on the remaining string with a new k\\n\\n**How to calculate the first digit?**\\nIf (K%(n-1)! == 0) --> then first element will be at ([k/(n-1)!] -1) index\\nelse --> first element will be at [k/(n-1)!] index\\n\\nexample n=3, so string =\"123\" answer is \"321\" if k=6 and \"312\" if k=5\\nwhen k = 6 --> 6%2! is equal to 0. then the first  element is at ((6/2)- 1) i.e. at 2nd index (\"3\")\\nwhen k = 5 --> 5%2 is not equal to 0, then the first element is at 5/2 i.e 2nd index (\"3)\\n\\n\\nafter calculating the first digit, we can update the k and apply the same operation to the remaining string\\n**How to update k?**\\nif (K%(n-1)! == 0) --> k = (n-1)!\\nelse --> k = k%(n-1)!\\n\\nin the above example when k =6 --> k= (3-1)! = 2\\nwhen k = 5 --> k = 5%(3-1)! = 1\\nremaining string = \"12\"\\n\\nFor second element --> \\nk becomes 2 (for k=6) -- 2%1! is equal to 0, then second element is at index 2/1 -1 i.e. 1 (\"2\")\\nk becomes 1 (for k=5) -- 1%1! is equal to 0, then second element is at index 1/1 -1 i.e. 0 (\"1\")\\n\\nwhen n=1\\nwe have to add it in the answer and return the answer\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287258,
                "title": "c-recursive-solution-100-faster-fully-explained",
                "content": "- If example we have n = 4: (1 2 3 4); so total number of permutation is 4\\\\*3\\\\*2\\\\*1 = n! = 24 = fact\\n- so let k = 17, i.e. we wants 17th permutation; \\n- so how we start: we fix 1 => so total permutaion  with 1 as first index is 3! = 6 = fact< k so we decrease k as k =k-fact = 17 - 6 = 11, we move to 2 and do same; k=k-fact = 11 - 6 = 5 then 3, but here fact = 6 > k;\\n- so we get that \"3\" is our first index\\n- so we fix, mark 3 as visited, fact = fact/(m-1) and recur to smaller string and do same\\n\\n```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```\\n\\n##### If you have any doubt then feel free to ask them below in comment section, also please give this a upvote as it motivates me post more such solutions.\\n",
                "solutionTags": [],
                "code": "```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139402,
                "title": "backtrack-cpp-solution-that-doesn-t-give-tle",
                "content": "I\\'m posting this solution as I couldn\\'t find a standard backtracking solution in any of the posts. This solution is not the fastest, but it\\'s simple and based on the backtracking template and good to know. \\nFew important points:\\n1) Sort the string which you are going to permute so that permutations are generated in a lexicographical manner\\n2) Pass the string by value, as sorting will change the order and caller will not be able to \"swap\" with right index\\n3) As soon as the kth permutation is found, terminate the backtracking (Though, it\\'s passing if we don\\'t terminate, takes more time of course)\\n```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```\\n\\nOther approach that worked for me:\\n- Reuse the solution from https://leetcode.com/problems/next-permutation/ and call getPermutation k-1 times and return the final string. \"k-1\" because we begin with the first permutation sequence and need to permute k-1 times. This runs much faster than the backtrack solution discussed in this post.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022904,
                "title": "c-easy-iterative-solutions-100-faster-with-o-n-time-complextiy",
                "content": "This solution is not efficient as it consumes so much memory....its just to develop the thought process \\n```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```\\nHere is the efficient solution(100% faster, O(N) time complexity), its a bit mathematical here we will find the required string by dividing all the permutations in to different parts according to the first element\\neg s= \"123\" can be divided as -\\n123 132\\n213  231\\n312 321\\n```\\nclass Solution {\\npublic:\\n    int fact(int n) {\\n        int ans=1;\\n        for(int i=1; i<=n; i++) ans*=i;\\n        return ans;\\n    }\\n    \\n    void solve(int k, string s, string& ans) {    \\n        int total_size=0, part_size, n, temp;  \\n        while(s.size()>2) {\\n            n= s.size();\\n            total_size= fact(n);\\n            part_size= total_size/n;\\n            \\n            temp= (k-1)/part_size;\\n            \\n            if(k%part_size==0)\\n                k=part_size;\\n            else\\n                k= k%part_size;\\n        \\n            ans+= s[temp];\\n            s.erase(temp, 1);           \\n        }\\n        cout<<s;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string ans, s=\"\";        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, s, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798148,
                "title": "c-solution-for-all-similar-questions",
                "content": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711640,
                "title": "0ms-dfs-solution-c-with-inline-comments-o-n-time-and-space",
                "content": "I didn\\'t find a similar solution to this, so I thought i\\'d share :) \\n\\nThe idea is to recurse only into states the kth permutation will be in:\\n```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698157,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697306,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 403067,
                "title": "simplest-cpp-with-explanation",
                "content": "This is a classic math problem.\\nconsider n =3\\n1. Number of permuttions of length n (n digits here) are n!. eg: 3!=6\\n2. It can also be written as n*(n-1)!   eg: 3*(3-1)! = 6\\n3. So there are n groups with (n-1)! permutations in each group.\\n eg: for n=3 there will be 3 groups with ((n-1)! which is) 2 permutation in each group \\n group1 = {123, 132}\\n group2 = {213, 231}\\n group3 = {312, 321}\\nSo the basic math is to identify the group which will contain Kth permutation and then select the element at that index and then repeat the steps for lesser n and k\\n\\nfor n = 3, our first permutaion is \"123\" and k=3 our answer will be 213. how?\\n\\nfrist pass - \\nk = k/fact(n-1)! which is ceil(3/2!) -> 2 so select index 2 (0 based) from the first string which is \"2\";\\nnow k = k%fact(n-1) which is 3%2! -> 1\\nn-- which is 2\\nnow our string is = \"13\", we removed 2\\n\\nsecond pass - \\nk = k/(n-1)! --> 1/1! --> 1 --> index1 in str--> \"1\"\\nk = k%(n-1)! --> 1%1 --> 0(in this case we set k to be (n-1)! which is 1)\\nn-- which is 1\\nnow our string is \"3\"since we removed 1\\n\\nthird pass:\\nk = k = k/(n-1)! --> 1/0! --> 1 --> index1 in str--> \"3\"\\n\\nso one by one we removed 3,2 and 1 from our initial sequence.\\n\\n```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 371641,
                "title": "100-percent-time-and-memory-with-explanation",
                "content": "Explanation:\\n1.  Since n! = n * (n-1)! we can imagine that the possible permutations are divided into n groups of size (n-1)! each\\n2.  Now we have to find the right group where kth permutation exists which we find by using `int idx = k % f == 0 ? k/f - 1 : k/f;`\\n3.  Now within the group of (n-1)! total permutations we want to find `k = k-(idx*f);` th permutation and for that we apply the same logic again \\n\\n```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310294,
                "title": "c-memorize-solution-follow-the-cook-book-make-a-mean-potato-pie",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```\\n\\nHot ziggity. It\\'s on fire bro.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309503,
                "title": "simple-python-solution-with-thinking-process-beat-99-69",
                "content": "For the permutations of n, \\nthe first (n-1)! permutations are [1] + permutations of {2, 3, ..., n},\\nthe next (n-1)! permutations are [2] + permutations of {1, 3, ..., n},\\n... and so on. \\n```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297433,
                "title": "python-8-ms-faster-than-100-of-solutions-10-lines-of-code",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170412,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22600,
                "title": "java-iterative-solution",
                "content": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22653,
                "title": "another-solution-in-java-with-explanation-no-loop-no-swap-easy-understanding-200ms",
                "content": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22670,
                "title": "c-0ms-observation-solution",
                "content": "    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            string ans;\\n            vector<int> remain;\\n            for (int i = 1; i <= n; ++i) {\\n                remain.push_back(i);\\n            }\\n            for (int i = n; i > 0; --i) {\\n                int j = ((k - 1) % mloop[i]) / mloop[i - 1];\\n                ans += (remain[j] + '0');\\n                remain.erase(remain.begin() + j);\\n            }\\n            return ans;\\n        }\\n    };\\n\\n    ()1234           (1)234         (12)34        (123)4\\n    1 1234           1 234           1 34     =>    1 4\\n    2 1243           2 243     =>    2 43\\n    3 1324           3 324\\n    4 1342  =>       4 3....\\n    5 1423\\n    6 1432\\n    7 2134\\n    8 2......",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 22678,
                "title": "c-4ms-recursive-solution-with-explanation",
                "content": "\\n\\n    // We have to return the k-th permutation \\n    // in lexicographic order.\\n    //\\n    // We can take a recursive approach.\\n    // The lexicographic order means that first\\n    // we have those starting with digit 1 then\\n    // those starting with 2 and so on until\\n    // digit n.\\n    // \\n    // For example, for n = 4, we have: \\n    // k   perm\\n    // --------\\n    // 1   1234\\n    // 2   1243\\n    // 3   1324\\n    // 4   1342\\n    // 5   1423\\n    // 6   1432\\n    //\\n    // 7   2134\\n    // 8   2143\\n    // 9   2314\\n    // 10  2341\\n    // 11  2413\\n    // 12  2431\\n    // \\n    // 13  3124\\n    // 14  3142\\n    // 15  3214\\n    // 16  3241\\n    // 17  3412\\n    // 18  3421\\n    // \\n    // 19  4123\\n    // 20  4132\\n    // 21  4213\\n    // 22  4231\\n    // 23  4312\\n    // 24  4321\\n    //\\n    // Since there are n digits, the number of all \\n    // permutations starting with a given digit d\\n    // is equal to (n-1)!.\\n    // Given k, the permutation order number,\\n    // we can determine which one is the first \\n    // digit d: d = [(k-1)/(n-1)!]+1;\\n    // \\n    // Once we determined the first digit\\n    // we recursively determine the remaining\\n    // digits.\\n    // \\n    // We keep all digits in a vector: {1,2,3,...,n}.\\n    // Once we determine a digit we remove it\\n    // from there and recursively solve\\n    // the problem for the remaining n-1 digits.\\n    // The formula above to determine the digit\\n    // is written slightly different in code\\n    // such that instead of the digit we first\\n    // get its index in this vector.\\n    //\\n    // From k we can also determine k for the\\n    // n-1 problem as: prevK = k%prevFact.\\n    // This is the order number within the \\n    // current digit's group.\\n    //\\n    // Now we can recursively solve the problem \\n    // for n-1 and prevK and determine the rest \\n    // of the digits.\\n    //\\n    class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }\\n    \\n        string getPermutation(int n, int k, vector<int>& digits)\\n        {\\n            if (n == 1)\\n            {\\n                return to_string(digits[0]);\\n            }\\n    \\n            int prevFact = factorial(n - 1);\\n    \\n            int idx = (k - 1) / prevFact;\\n            int d = digits[idx];\\n    \\n            digits.erase(digits.begin() + idx);\\n    \\n            int prevK = k%prevFact;\\n            if (prevK == 0)\\n                prevK = prevFact;\\n    \\n            string prev = getPermutation(n - 1, prevK, digits);\\n    \\n            return to_string(d) + prev;\\n        }\\n    \\n    public:\\n        string getPermutation(int n, int k)\\n        {\\n            vector<int> digits;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                digits.push_back(i);\\n            }\\n    \\n            return getPermutation(n, k, digits);\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4061982,
                "title": "python-10ms-solution",
                "content": "# Intuition\\nFor this problem, my first realization was that for each starting number there are (n-1)! possibilites. Eg:\\n\\nn=4\\nfor the starting number 1 the possiblities are:\\n1,2,3,4\\n1,2,4,3\\n1,3,2,4\\n1,3,4,2\\n1,4,2,3\\n1,4,3,2\\nThere are 6 possibilities which is the same as 3!\\nSo with this, we should be able to through each digit and to find the proper number permutation. \\n\\n# Approach\\nSomething to realize is that you can you can find the starting number for the permutation by doing k/(n-1)!\\nThis is because for each possible starting number 1-n, there are (n-1)! possibilities, so if we divide k by this, we will get the starting number. \\n\\nSo you keep doing this for each digit. We divide k by (n-1)!, then add the integer part. K will then become whatever the remainder is, because we are subtracting that many possiblities. \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050510,
                "title": "permutation-sequence-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972282,
                "title": "most-optimal-solution-without-using-recursion-and-backtracking-with-complete-exaplanation",
                "content": "\\n\\n# Approach\\nThe given solution aims to find the kth permutation sequence of numbers from 1 to n. It uses a mathematical approach to determine the digits of the kth permutation by repeatedly calculating the factorial of (n-1), identifying the next digit in the permutation, and updating the remaining digits.\\n\\nHere\\'s the explanation of the solution steps:\\n\\n1. Calculate the factorial of (n-1) to determine the count of permutations that can be formed with the remaining digits.\\n2. Create a list called nums containing numbers from 1 to n.\\n3. Adjust k to be 0-based (k = k - 1).\\n4. Repeatedly find the next digit in the permutation by dividing k by the current factorial value. This indicates which digit from the remaining digits list should be added to the answer.\\n5. Remove the selected digit from the nums list.\\n6. Update k by taking the remainder after division by the current factorial value.\\n7. Update the factorial value by dividing it by the size of the nums list.\\n8. Repeat steps 4-7 until all digits are added to the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803225,
                "title": "best-solution-possible-world-record-iq-10000",
                "content": "# Intuition\\nSolve more problems you will get the intuition. \\n\\n# Approach\\nArey bindu, dekh agar n=5 hai toh agar mai kisi ek number from 1-5 ko first element banata hu toh 4! options hoga each ka. \\n\\nAgar k = 59 hai, then k = (24 + 24 + 11). \\nThat means starting mai 3 ayega and uske ander permutions hoga further.\\nWhi dekh le re thoda. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546130,
                "title": "beats-100-0ms-cpp-intuitive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477699,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370125,
                "title": "c-beats-100-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298632,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293254,
                "title": "easy-4-steps-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176505,
                "title": "beats-99-7-60-permutation-sequence-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere, we use a simple factorial approach. First, we calculate all the factorials up to n, and use that to find the next number to add to the result. We start from the last factorial and keep adding numbers to the result, decrementing k and removing the selected number from the list. This continues until all numbers have been added to the result and k becomes 0. We return the result as a single string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133297,
                "title": "recursion-easy-approach-c",
                "content": "# Intuition\\nJust keep fixing the position of element by finding their relevant group. Then remove that fixed element from the data strucuture i.e. vector. Check for remaining elements until vector is empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106468,
                "title": "6ms-o-n-2-efficient-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028301,
                "title": "c-easy-to-understand-beats-100-percent",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023786,
                "title": "python-beats-98-easy-optimum-solution",
                "content": "**This is optimum question **\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823057,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822830,
                "title": "5-lines-only-easy-to-understand-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817166,
                "title": "c-simple-solution-using-stl-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a string\\n2. base case where k=1\\n3. find next permutation until k=1\\n4. when u reach k=1 break the loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788320,
                "title": "python-solution-iterative-approach-98-76-faster",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751645,
                "title": "c-stl-next-permutaton-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750757,
                "title": "permutation-sequence",
                "content": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 2702315,
                "title": "no-recursion-c-solution",
                "content": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679895,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673298,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502001,
                "title": "c-easy-soln-60-permutation-sequence",
                "content": "**Dry Run for better understanding**\\n\\n\\t// if n is 4 then factorial of 3 will be calculated i.e. 6 let say n=4 and k=17  \\n\\t// intially we calculate factorial of n-1 and store the numbers upto n in nums  \\n\\t// nums={1,2,3,4}; fact=6\\n\\t// There are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\n\\t// There are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\n\\t// There are 6 numbers starting with 3: 3124, 3142,3214,3241,3412,3421  (ans i.e 3412 will lie here)\\n\\t// There are 6 numbers starting with 4: 4123, 4132, 4213, 4231, 4312, 4321\\n\\t// 0 based indexing asign k=k-1\\n\\t// since in the 3rd set(2nd index) ans is lying which can be calculated as\\n\\t// nums[k/fact]=nums[16/6]=>nums[2]\\n\\t// since nums[2] is 3 our first num is 3 add it to the ans \\n\\t// k=k%fact since next time there will total 6 element 2 starting from 1 ,two from 2 and two from 4\\n\\t// k=16%4 , fact is also updated as fact=6/3 process will be repeated until nums.size()=0\\n\\n**Code**\\n```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```\\n\\n**Time Complexity: O(n^2)**\\nsince erase fun is used for each element which will take O(n) ans O(n) for every element traversal\\n**Space Complexity: O(n)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436376,
                "title": "java-optimized-solution",
                "content": "### **Approach : Brute Force**\\n**Will Give TLE**\\n```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\\n\\n\\n### **Optimal solution**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394981,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation Sequence.\\nMemory Usage: 6.1 MB, less than 16.64% of C++ online submissions for Permutation Sequence.\\n\\n```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382280,
                "title": "c-0ms-best-solution-easily-understandable",
                "content": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```\\n\\n \\n\\n\\n![image](https://assets.leetcode.com/users/images/643a4983-d04a-44af-9a1f-64d21a7962ae_1659691279.1827478.png)\\n",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336078,
                "title": "c-stl-next-permutation-easy-100",
                "content": "Easy **STL function**!\\n```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322038,
                "title": "c-beginner-s-friendly-solution-understandable-approach",
                "content": "**Please Upvote the Solution**\\n\\nCode->\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHappy Coding :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228028,
                "title": "c-very-easy-explanation-with-example",
                "content": "\\t/*\\n\\tExample:\\n\\n\\tn = 4 and k = 9\\n\\n\\tnumber of combination \\n\\n\\t1234    2134    3124    4123\\n\\t1243    2143    3142    4132\\n\\t1324    2314    3214    4213\\n\\t1342    2342    3241    4231\\n\\t1423    2413    3412    4312\\n\\t1432    2431    3421    4321\\n\\n\\tsince we want the 9 the permutaion we have to do the permutaion 8 time since 1st combination\\n\\tis considered 1\\n\\tk = 8\\n\\tans = \"\";\\n\\n\\tvalue of i = 1; //initially\\n\\tnow how many columns needs to be skipped for first digit of ans is (n-i)!\\n\\tso number of the value (smaller) to skip = k/(n-1)!\\n\\there 8/(4-i)! = 8/6 = 1; \\n\\tnew k value = k%(n-i) = 8%(4-1)! = 2\\n\\tans = \"2\"\\n\\n\\trepeation the same process i = 2\\n\\t2/(4-2)! = 2/1 = 2\\n\\tans = \"23\"\\n\\tk = 0\\n\\n\\ti = 3\\n\\t0/(4-3)! = 0\\n\\tans = \"231\"\\n\\n\\ti = 4\\n\\t0/(4-4)! = 0\\n\\tans = \"2314\"\\n\\n\\tresult = \"2314\"\\n\\t*/\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tstring getPermutation(int n, int k) {\\n\\n\\n\\t\\t\\t//factorial of n to get the total number of arrangement possible\\n\\t\\t\\t//with n numbers\\n\\t\\t\\tint ttlArgmtPsbl = factorial(n); //total arrangement possible for n digits\\n\\n\\n\\t\\t\\t//since we want to get the number we will se after k permutation \\n\\t\\t\\t//ans we are counting the initial arrangement as 1\\n\\t\\t\\tk--;\\n\\n\\t\\t\\t//to remove loop means the same arrangement is occuring more than once.\\n\\t\\t\\tk = k%ttlArgmtPsbl;\\n\\n\\t\\t\\t//to skip the number after which we will get the number which is supposed to \\n\\t\\t\\t//be there in that place.\\n\\t\\t\\tvector<bool> rec(n, true);\\n\\n\\n\\t\\t\\t//resulting string\\n\\t\\t\\tstring ans = \"\";\\n\\n\\n\\t\\t\\tfor(int i = n; i>=1; i--){\\n\\n\\t\\t\\t\\t//to get the column of the number after a position when a number is fixed\\n\\t\\t\\t\\t//at that position.\\n\\t\\t\\t\\tttlArgmtPsbl = ttlArgmtPsbl/i; \\n\\n\\t\\t\\t\\t//fixing the first element and figuring\\n\\t\\t\\t\\t//out how many column (where the number less than it which are unoccupied are\\n\\t\\t\\t\\t//at that position) have to be skipped (reffer to the example)\\n\\t\\t\\t\\t//(+1 to get the the exact index)\\n\\n\\t\\t\\t\\t//smaller and available no. to skip\\n\\t\\t\\t\\tint smlaAvlnumbertoskp = k/ttlArgmtPsbl + 1; \\n\\n\\t\\t\\t\\t//to store the index number.\\n\\t\\t\\t\\tint ix = 0;\\n\\n\\t\\t\\t\\t//to get the ixdex value by skipping the available smaller number.\\n\\t\\t\\t\\tfor(int j = 0; j<rec.size(); j++){\\n\\t\\t\\t\\t\\tif(!smlaAvlnumbertoskp){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(rec[j]){\\n\\t\\t\\t\\t\\t\\tsmlaAvlnumbertoskp--;\\n\\t\\t\\t\\t\\t\\tix = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//number at ix is to be added to ans string\\n\\n\\t\\t\\t\\tk = k%ttlArgmtPsbl; //reduce the width of the column\\n\\n\\t\\t\\t\\t//set the number at ix to unavailable.\\n\\t\\t\\t\\trec[ix] = false;\\n\\n\\t\\t\\t\\t//add number at ix to ans.\\n\\t\\t\\t\\tans += to_string(ix+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133515,
                "title": "without-recursion-simple-mathematics",
                "content": "feel free to ask any queries in the comments!******\\n\\n![image](https://assets.leetcode.com/users/images/a5872874-51df-42d4-8e49-ed44bd7b93f3_1654838871.1433494.jpeg)\\n\\n\\n```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```**",
                "solutionTags": [],
                "code": "```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2130821,
                "title": "cpp-code-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099414,
                "title": "c-solution-recursion",
                "content": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<str.size();i++) {\\n            string ros=str.substr(0,i)+str.substr(i+1);\\n            ans=kthPermutation(ros, res+str[i], k);\\n            \\n            if(k==0)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string str=\"\";\\n        for(int i=1;i<=n;i++)\\n            str+=to_string(i);\\n        \\n        return kthPermutation(str, \"\", k);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2066901,
                "title": "perfect-use-of-stl-c",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2036385,
                "title": "3ms-java-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint groups = fact/n;\\n\\t\\t\\t\\tres[0]+=lis.get(k/groups);\\n\\t\\t\\t\\tlis.remove(k/groups);\\n\\t\\t\\t\\tkthPermutaionUtil(n-1,k%groups,lis,groups,res); \\n\\t\\t\\t}\\n\\t\\t\\tpublic String getPermutation(int n, int k) {\\n\\t\\t\\t\\tString[] res = {\"\"};\\n\\t\\t\\t\\tArrayList<Integer> lexographical_list = new ArrayList<Integer>();\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfact=fact*(i+1);\\n\\t\\t\\t\\t\\tlexographical_list.add(i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println(fact);\\n\\t\\t\\t\\tSystem.out.println(lexographical_list);\\n\\t\\t\\t\\tkthPermutaionUtil(n,k-1,lexographical_list,fact,res);\\n\\t\\t\\t\\treturn res[0];\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2036380,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//This runs if we have more than 1 digit in digits array\\n\\t\\t\\t\\tint index = k/fact[n-1]; //Defines no of blocks to skip (each block of size fact[n-1])\\n\\n\\t\\t\\t\\tif(k%fact[n-1]==0)  //We need convert 1 based indexing to 0 based.So, decrese index by 1\\n\\t\\t\\t\\t\\tindex-=1;\\n\\n\\t\\t\\t\\tans+=to_string(digits[index]);  //Add new character\\n\\t\\t\\t\\tdigits.erase(digits.begin()+index);    //Erase digit after using\\n\\n\\t\\t\\t\\tk -= fact[n-1]*index;  //Decrease K value\\n\\t\\t\\t\\tsolve(ans,n-1,k);\\n\\t\\t\\t}\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\t\\t//Store all factorials from 0 to N\\n\\t\\t\\t\\t\\tfact.push_back(1);\\n\\t\\t\\t\\t\\tint f=1;\\n\\t\\t\\t\\t\\tfor(int i=1;i<n;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tf*=i;\\n\\t\\t\\t\\t\\t\\tfact.push_back(f);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//Push your digits in array\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;++i)\\n\\t\\t\\t\\t\\t\\tdigits.push_back(i);\\n\\n\\t\\t\\t\\t\\tstring ans = \"\";\\n\\t\\t\\t\\t\\tsolve(ans,n,k); \\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2032054,
                "title": "c-east-to-unserstand-stl-implementation-easy",
                "content": "Very basic and easy to unserstand another way can be using backtracking\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841505,
                "title": "c-solution-using-stl",
                "content": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1801155,
                "title": "c-5-line-solution-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737773,
                "title": "java-short-clean-math-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730928,
                "title": "simple-recursive-solution-in-java",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666830,
                "title": "another-solution-for-same-approach",
                "content": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nAt each index find the maximum number that can fit, and substract the permutations which we skipped to come to the maximum digit at this index.\\n\\nThe only difference is I used a set container instead of a vector which helps optimise the memory used.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1613182,
                "title": "6-line-cpp-code-using-inbuilt-func",
                "content": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1541480,
                "title": "recursive-and-optimized-detailed-solutions",
                "content": "**As we can see the order of permutations is actually sorted**\\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\\n no fo permutations n!=6;\\n0.\"123\"\\n1.\"132\"\\n2.\"213\"\\n3.\"231\"\\n4.\"312\"\\n5.\"321\"\\n\\n**In brute force approach we will simply create all permutations using recursion and store all in vector and then sort them in increasing order to get answer.**\\n\\n**TC:->O(n!) and S.C->O(n)**\\n```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\\n**optimized approach**\\n**TC:->O(n) and S.C->O(n)**\\nThe approach is mathematical\\nhere let suppose n=3..so n-1!=2;\\n **the first two start with zero index ..**\\n*for k=1,2....  k-=1  ...k=0,k=1  num[k/n-1!]==0/2=0;or1/2=0; so we have to take 0th index from original \"123\"..**so we have res=\"1\" and rest =\"2,3\".**. \\n\"123\"\\n\"132\"*\\n **after that the next two start with one index ..**\\n *for k=3,4....  k-=1  ...k=2,k=3  num[k/n-1!]==2/2=1;or3/2=1; so we have to take 1th index from original \"123\"..**so we have res=\"2\" and rest =\"1,3\".. **\\n\"213\"\\n\"231\"*\\n**after that the next two start with two index ..**\\n*for k=5,6....  k-=1  ...k=4,k=5  num[k/n-1!]==4/2=2;or5/2=2; so we have to take 2th index from original \"123\"..**so we have res=\"3\" and rest =\"2,3\"..**\\n\"312\"\\n\"321*\\n\\n**and also updating value of k and fact each time so on...till rest array size!=0.**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496484,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438806,
                "title": "10-line-code-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }\\n        for(int i =1 ; i<k;i++){\\n            next_permutation(str.begin(), str.end()); \\n        }\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1438394,
                "title": "c-math-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343701,
                "title": "easy-c-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        k = k-1;\\n        \\n        \\n        while(true)\\n        {\\n            result += to_string(arr[k/comb]);\\n            \\n            arr.erase(arr.begin()+(k/comb));\\n            \\n            if(arr.size()==0)\\n                break;\\n            \\n            k = k%comb;\\n            comb = comb/arr.size();\\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1300779,
                "title": "python-maths-logic-with-explanation-90-runtime",
                "content": "\\nTo make things simpler, we start index everything from 0\\nTheory:\\n(1) We begin from the left-most digit for the final answer\\n(2) We create a ***list*** , that contains all digit from 1 to ***n*** (in ascending order)\\n(3) We split the possible permutations into different groups according to their \\'leading\\' digits\\n(4) We discover which n*th* group [ ***int(k/(len(List)-1)!)*** ] that the final answer lies within\\n(5) We append the \\'leading\\' digit of the n*th* group into our final answer\\n(6) We update ***k*** ( ***k=k%(len(list)-1)!*** ) and remove the n*th* element from ***list***\\n(7) Repeat steps 3 - 6 until ***list*** is empty\\n\\t\\n***Sample Case: n=4, k=15 (0-indexed)***\\t\\n\\t\\n### Stage 1\\n\\t\\n\\tList = [1,2,3,4]\\n\\tGroup 0: 1234,1243,1324,1342,1423,1432 (where k=0~5) \\n\\tGroup 1: 2134,2143,2314,2341,2413,2431 (where k=6~11)\\n\\tGroup 2: 3124,3142,3214,3241,3412,3421 (where k=12~17)\\n\\tGroup 3: 4123,4132,4213,4231,4312,4321 (where k=18~23)\\n\\t\\nwe can confirm that the final answer lies within **Group [int(k/(len(List)-1)!)] = 2**\\nsince we know the answer is in Group 2, meaning the 1st digit of the answer is \\'3\\' (equivalent to the value of ***List[2]*** ), answer = **3 _ _ _**\\nwe update **k=k%(len(List)-1)!=3** , remove ***List[2]***\\n\\n### Stage 2\\n\\n\\tList = [1,2,4]\\n\\tGroup 0: 124,142 (where k=0~1)\\n\\tGroup 1: 214,241 (where k=2~3)\\n\\tGroup 2: 412,421 (where k=4~5)\\n\\nwe can decude the answer lies within **Group [int(k/(len(List)-1)!)] = 1**\\nwe can confirm that the 2nd digit is \\'2\\' (equivalent to the value of ***List[1]*** ), answer = **3 2 _ _**\\nwe update **k = k%(len(List)-1)!=1**, remove ***List[1]*** \\n\\n### Stage 3\\n\\n\\tList = [1,4]\\n\\tGroup 0: 14 (where k=0)\\n\\tGroup 1: 41 (where k=1)\\n\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 1**, 3rd digit is ***List[1]*** , which is \\'4\\', answer = **3 2 4** _\\nwe update **k = k%(len(List)-1)! = 0**, remove ***List[1]*** \\n\\t\\n### Stage 4\\n\\t\\n\\tList = [1]\\n\\tGroup 0: 1 (where k=0)\\n\\t\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 0**, 4th digit is ***List[0]*** , which is \\'1\\', answer = **3 2 4 1**\\nAfter we remove ***List[0]*** , ***list*** becomes empty, terminate the loop\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```\\n\\nKindly upvote this post if you think the solution is helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298638,
                "title": "c-simple-and-short-solution-100-speed-explained",
                "content": "First thing to say, It was quite a long time when I first solved this. \\nAnd when I reviewed this question and saw my solution, I want to share it.\\nBut I\\'m not completely sure if it wasn\\'t \"copied\" (or the idea wasn\\'t copied) from other place.\\nIf it is, please let me know.\\n\\n**Jump back to the solution.** The idea is very simple.\\nLet\\'s say we are working on the first element of the answer.\\nFor the permutation from small to large, clearly the first element will change from **\\'1\\'** to **\\'n\\'**.\\n\\nHow much steps of permutation will it be between every first element changing?\\nObviously it\\'s the number of permutations of the rest of the sequence.\\nThe number will be **(n - 1)!**.\\nSo all we need to do is to calculate **k / (n - 1)!** and we\\'ll get the index of **\\'1\\'** to **\\'n\\'** for the first element.\\n\\nThen with the same logic, we work on the second element.\\nThe **k** now will become  **k % (n - 1)!** from the last round. The available characters to choose will be **\\'1\\'** to **\\'n\\'** and erase already used ones.\\n\\n\\n```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2053052,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 2004225,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1998497,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1997177,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1986133,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1922327,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1912940,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1862902,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1850409,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1843550,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            }
        ]
    },
    {
        "title": "Intersection of Two Linked Lists",
        "question_content": "<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>\n\n<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" />\n<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>\n\n<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>\n\n<ul>\n\t<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>\n\t<li><code>listA</code> - The first linked list.</li>\n\t<li><code>listB</code> - The second linked list.</li>\n\t<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>\n\t<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>\n</ul>\n\n<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>Output:</strong> Intersected at &#39;8&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>Output:</strong> Intersected at &#39;2&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>Output:</strong> No intersection\n<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>\n\t<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= skipB &lt;&nbsp;n</code></li>\n\t<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>\n\t<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?",
        "solutions": [
            {
                "id": 49785,
                "title": "java-solution-without-knowing-the-difference-in-len",
                "content": "I found most solutions here preprocess linkedlists to get the difference in len. \\nActually we don't care about the \"value\" of difference, we just want to make sure two pointers reach the intersection node at the same time.\\n\\nWe can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null\\n\\nBelow is my commented Java code:\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        //boundary check\\n        if(headA == null || headB == null) return null;\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        //if a & b have different len, then we will stop the loop after second iteration\\n        while( a != b){\\n        \\t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\\n            a = a == null? headB : a.next;\\n            b = b == null? headA : b.next;    \\n        }\\n        \\n        return a;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "I found most solutions here preprocess linkedlists to get the difference in len. \\nActually we don't care about the \"value\" of difference, we just want to make sure two pointers reach the intersection node at the same time.\\n\\nWe can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null\\n\\nBelow is my commented Java code:\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        //boundary check\\n        if(headA == null || headB == null) return null;\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        //if a & b have different len, then we will stop the loop after second iteration\\n        while( a != b){\\n        \\t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\\n            a = a == null? headB : a.next;\\n            b = b == null? headA : b.next;    \\n        }\\n        \\n        return a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49789,
                "title": "my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *p1 = headA;\\n        ListNode *p2 = headB;\\n            \\n        if (p1 == NULL || p2 == NULL) return NULL;\\n    \\n        while (p1 != NULL && p2 != NULL && p1 != p2) {\\n            p1 = p1->next;\\n            p2 = p2->next;\\n\\n            //\\n            // Any time they collide or reach end together without colliding \\n            // then return any one of the pointers.\\n            //\\n            if (p1 == p2) return p1;\\n\\n            //\\n            // If one of them reaches the end earlier then reuse it \\n            // by moving it to the beginning of other list.\\n            // Once both of them go through reassigning, \\n            // they will be equidistant from the collision point.\\n            //\\n            if (p1 == NULL) p1 = headB;\\n            if (p2 == NULL) p2 = headA;\\n        }\\n            \\n        return p1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *p1 = headA;\\n        ListNode *p2 = headB;\\n            \\n        if (p1 == NULL || p2 == NULL) return NULL;\\n    \\n        while (p1 != NULL && p2 != NULL && p1 != p2) {\\n            p1 = p1->next;\\n            p2 = p2->next;\\n\\n            //\\n            // Any time they collide or reach end together without colliding \\n            // then return any one of the pointers.\\n            //\\n            if (p1 == p2) return p1;\\n\\n            //\\n            // If one of them reaches the end earlier then reuse it \\n            // by moving it to the beginning of other list.\\n            // Once both of them go through reassigning, \\n            // they will be equidistant from the collision point.\\n            //\\n            if (p1 == NULL) p1 = headB;\\n            if (p2 == NULL) p2 = headA;\\n        }\\n            \\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49798,
                "title": "concise-python-code-with-comments",
                "content": "    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            if headA is None or headB is None:\\n                return None\\n    \\n            pa = headA # 2 pointers\\n            pb = headB\\n    \\n            while pa is not pb:\\n                # if either pointer hits the end, switch head and continue the second traversal, \\n                # if not hit the end, just move on to next\\n                pa = headB if pa is None else pa.next\\n                pb = headA if pb is None else pb.next\\n    \\n            return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None\\n    \\n    # the idea is if you switch head, the possible difference between length would be countered. \\n    # On the second traversal, they either hit or miss. \\n    # if they meet, pa or pb would be the node we are looking for, \\n    # if they didn't meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            if headA is None or headB is None:\\n                return None\\n    \\n            pa = headA # 2 pointers\\n            pb = headB\\n    \\n            while pa is not pb:\\n                # if either pointer hits the end, switch head and continue the second traversal, \\n                # if not hit the end, just move on to next\\n                pa = headB if pa is None else pa.next\\n                pb = headA if pb is None else pb.next\\n    \\n            return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None\\n    \\n    # the idea is if you switch head, the possible difference between length would be countered. \\n    # On the second traversal, they either hit or miss. \\n    # if they meet, pa or pb would be the node we are looking for, \\n    # if they didn't meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None",
                "codeTag": "Java"
            },
            {
                "id": 1093014,
                "title": "c-four-different-solutions",
                "content": "### 1. Brute Force Solution\\nTime Complexity : ` O(m * n)`\\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *temp;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\ttemp = headB;\\n\\t\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\t\\n### 2. HashMap Solution\\nTime Complexity : ` O(m + n)`\\nSpace Complexity : `O(m)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tunordered_map<ListNode*, int> m;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\tm[headA]++;\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(headB != NULL){\\n\\t\\t\\t\\tif(m[headB] > 0){\\n\\t\\t\\t\\t\\treturn headB;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\n### 3. Length Difference Solution\\nTime Complexity : ` O(m + n)` \\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tint n = 0;\\n\\t\\t\\tint m = 0;\\n\\t\\t\\tListNode* ptr1 = headA;\\n\\t\\t\\tListNode* ptr2 = headB;\\n\\t\\t\\twhile(ptr1 != NULL){\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(ptr2 != NULL){\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tint t = abs(n - m);\\n\\t\\t\\tif(n > m){\\n\\t\\t\\t\\twhile(t){\\n\\t\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t\\t\\tt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\twhile(t){\\n\\t\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t\\t\\tt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(headA != NULL and headB != NULL){\\n\\t\\t\\t\\tif(headA == headB){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\n### 4. Two-Pointers Solution\\nTime Complexity : ` O(m + n)`\\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *ptr1 = headA;\\n\\t\\t\\tListNode *ptr2 = headB;\\n\\t\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ptr1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *temp;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\ttemp = headB;\\n\\t\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 49792,
                "title": "concise-java-solution-o-1-memory-o-n-time",
                "content": "1, Get the length of the two lists.\\n\\n2, Align them to the same start point.\\n\\n3, Move them together until finding the intersection point, or the end null\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = length(headA), lenB = length(headB);\\n        // move headA and headB to the same start point\\n        while (lenA > lenB) {\\n            headA = headA.next;\\n            lenA--;\\n        }\\n        while (lenA < lenB) {\\n            headB = headB.next;\\n            lenB--;\\n        }\\n        // find the intersection until end\\n        while (headA != headB) {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n    \\n    private int length(ListNode node) {\\n        int length = 0;\\n        while (node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        return length;\\n    }",
                "solutionTags": [],
                "code": "1, Get the length of the two lists.\\n\\n2, Align them to the same start point.\\n\\n3, Move them together until finding the intersection point, or the end null\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = length(headA), lenB = length(headB);\\n        // move headA and headB to the same start point\\n        while (lenA > lenB) {\\n            headA = headA.next;\\n            lenA--;\\n        }\\n        while (lenA < lenB) {\\n            headB = headB.next;\\n            lenB--;\\n        }\\n        // find the intersection until end\\n        while (headA != headB) {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n    \\n    private int length(ListNode node) {\\n        int length = 0;\\n        while (node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        return length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3176186,
                "title": "solution",
                "content": "```C++ []\\n int init = []\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::ofstream out(\"user.out\");\\n    for(string s; getline(std::cin, s);)\\n    {\\n        if(s[0] != \\'0\\') out << \"Intersected at \\'\" << s << \"\\'\\\\n\";\\n        else out << \"No intersection\\\\n\";\\n        for(int i = 0; i < 4; ++i) getline(std::cin, s);\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*,int>mpp;\\n    for (auto p = headA ; p!=NULL ; p = p->next){\\n        mpp[p]=p->val;\\n    }\\n    for (auto p = headB ; p!=NULL ; p = p->next){\\n        if (mpp.find(p)!=mpp.end()) return p;\\n    }\\n    return NULL;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        stackA = [\\'A\\']\\n        stackB = [\\'B\\']\\n\\n        while headA or headB:\\n            if headA:\\n                stackA.append(headA)\\n                headA = headA.next\\n\\n            if headB:\\n                stackB.append(headB)\\n                headB = headB.next\\n\\n        prev = None\\n        while stackA and stackB:\\n            nodeA = stackA.pop(-1)\\n            nodeB = stackB.pop(-1)\\n\\n            if nodeA != nodeB:\\n                return prev\\n\\n            prev = nodeA\\n```\\n\\n```Java []\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n int init = []\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::ofstream out(\"user.out\");\\n    for(string s; getline(std::cin, s);)\\n    {\\n        if(s[0] != \\'0\\') out << \"Intersected at \\'\" << s << \"\\'\\\\n\";\\n        else out << \"No intersection\\\\n\";\\n        for(int i = 0; i < 4; ++i) getline(std::cin, s);\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*,int>mpp;\\n    for (auto p = headA ; p!=NULL ; p = p->next){\\n        mpp[p]=p->val;\\n    }\\n    for (auto p = headB ; p!=NULL ; p = p->next){\\n        if (mpp.find(p)!=mpp.end()) return p;\\n    }\\n    return NULL;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        stackA = [\\'A\\']\\n        stackB = [\\'B\\']\\n\\n        while headA or headB:\\n            if headA:\\n                stackA.append(headA)\\n                headA = headA.next\\n\\n            if headB:\\n                stackB.append(headB)\\n                headB = headB.next\\n\\n        prev = None\\n        while stackA and stackB:\\n            nodeA = stackA.pop(-1)\\n            nodeB = stackB.pop(-1)\\n\\n            if nodeA != nodeB:\\n                return prev\\n\\n            prev = nodeA\\n```\n```Java []\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092898,
                "title": "js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to store each node reference in a data structure until we saw the same one twice, but that would take **O(N) extra space**.\\n\\nIn order to solve this problem with only **O(1) extra space**, we\\'ll need to find another way to align the two linked lists. More importantly, we need to find a way to line up the *ends* of the two lists. And the easiest way to do that is to concatenate them in opposite orders, **A+B** and **B+A**. This way, the ends of the two original lists will align on the second half of each merged list.\\n\\n![Visual 1](https://i.imgur.com/hcpocCV.png)\\n\\n![Visual 2](https://i.imgur.com/dDUjSPk.png)\\n\\nThen we just need to check if at some point the two merged lists are pointing to the same node. In fact, even if the two merged lists don\\'t intersect, the value of **a** and **b** will be the same (**null**) when we come to the end of the merged lists, so we can use that as our exit condition.\\n\\nWe just need to make sure to string **headB** onto **a** and vice versa if one (but not both) list ends.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.7MB** (beats 98% / 95%).\\n```javascript\\nvar getIntersectionNode = function(headA, headB) {\\n    let a = headA, b = headB\\n    while (a !== b) {\\n        a = !a ? headB : a.next\\n        b = !b ? headA : b.next\\n    }\\n    return a\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **156ms / 29.3MB** (beats 88% / 88%).\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 41.6MB** (beats 98% / 88%).\\n```java\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 14.5MB** (beats 96% / 96%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        while (a != b) {\\n            a = !a ? headB : a->next;\\n            b = !b ? headA : b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getIntersectionNode = function(headA, headB) {\\n    let a = headA, b = headB\\n    while (a !== b) {\\n        a = !a ? headB : a.next\\n        b = !b ? headA : b.next\\n    }\\n    return a\\n};\\n```\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```\n```java\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        while (a != b) {\\n            a = !a ? headB : a->next;\\n            b = !b ? headA : b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116221,
                "title": "visual-explanation-one-pass-java",
                "content": "### Logic:\\nThe intuition behind a one-pass solution to this question can be quite tricky to grasp. I hope that my visual explanation below can aid in your understanding of this approach! Let\\'s get started.\\n\\nFirst let\\'s use the below linked lists A and B as our example. The blue circles represent nodes that belong strictly to list A, the green circles represent nodes that belong strictly to list B, and the red circles are the nodes they share in common. The first red node in this case is the intersection point.\\n\\n![image](https://assets.leetcode.com/users/images/6330aba4-624d-4d17-9a29-2363af7596e3_1654509991.8164506.png)\\n\\nNow, as you may have realised when attempting this problem, the main difficulty comes from the lists being of different lengths. As such, we can\\'t just loop through both lists one node at a time and check for equality since we\\'re not guarranteed that their lengths before the interection point are the same.\\n\\n**Observation 1:**\\nA key observation here is that, if that if we visualise both lists as separate lists, their tail nodes are identical both in value and in quantity.\\n\\n![image](https://assets.leetcode.com/users/images/2a35b0b4-2902-4ec2-bb8a-cf7835a42ea2_1654510005.172662.png)\\n\\nDamn, if only the nodes before the interesction had the same length as well. That would make our one-pass solution really simple! \\n\\n> Interview tip: If there\\'s certain trait or behaviour that you would like the question/input to have, try and enforce it by manipulating the datastructure. \\n\\nIn this case, we would like the lengths before the intersection to be equal as well. That way, we would only need to loop through both lists with the guarrantee that both lists will reach the intersection node at the same time.\\n\\n**Observation 2:**\\nThe next observation is that, while both lists may be of different lenghts, `list A + list B` has the same length as `list B + list A`. \\n\\n![image](https://assets.leetcode.com/users/images/681dec00-018d-4631-b699-389fe1301a66_1654510021.4787977.png)\\n\\nIf in our one-pass solution we perform two simultaneous loops (first go through list A and then through list B, and another going through list B then list A), we are not only guarranteed to be looping through combined lists of the same length but we\\'re also guarranteed that the last nodes of both iterations will be our red nodes.\\n\\n### What if there\\'s no intersection?\\nIn that case, we would like for our loop will stop when we\\'ve reached the end of both combined lists. That is, when both our node pointers are null. Luckily, as you\\'ll see in the code, our while loop\\'s exist condition accounts for this edge case as well.\\n\\nAwesome! Now we have everything we need to start coding.\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    ListNode ptrA = headA, ptrB = headB;\\n    while (ptrA != ptrB) { // loop until we found the first common node\\n        ptrA = ptrA == null ? headB : ptrA.next; // once we\\'re done with A, move to B\\n        ptrB = ptrB == null ? headA : ptrB.next; // once we\\'re done with B, move to A\\n\\t}\\n\\treturn ptrA;\\n}\\n```\\n**Time Complexity:** `O(A + B)` where A and B are the lengths of each linked list.\\n**Space Complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    ListNode ptrA = headA, ptrB = headB;\\n    while (ptrA != ptrB) { // loop until we found the first common node\\n        ptrA = ptrA == null ? headB : ptrA.next; // once we\\'re done with A, move to B\\n        ptrB = ptrB == null ? headA : ptrB.next; // once we\\'re done with B, move to A\\n\\t}\\n\\treturn ptrA;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49799,
                "title": "simple-c-solution-5-lines",
                "content": "Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *cur1 = headA, *cur2 = headB;\\n        while(cur1 != cur2){\\n            cur1 = cur1?cur1->next:headB;\\n            cur2 = cur2?cur2->next:headA;\\n        }\\n        return cur1;\\n    }",
                "solutionTags": [],
                "code": "Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *cur1 = headA, *cur2 = headB;\\n        while(cur1 != cur2){\\n            cur1 = cur1?cur1->next:headB;\\n            cur2 = cur2?cur2->next:headA;\\n        }\\n        return cur1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3432461,
                "title": "c-2-approaches-beats-92-loop-o-1-space",
                "content": "# Intuition\\nThe problem states that we need to find the intersection of two linked lists without changing their original structure.\\n\\n# Approach 1\\n1. Find the length of both the linked lists.\\n2. Traverse the bigger linked list until the remaining nodes count becomes equal to the smaller one\\'s.\\n3. Traverse both the heads together. If both of them are same then the intersecting node is found.\\n\\n# Complexity\\n- Time complexity: O(n) where n>m\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        int len = 0;\\n        while(head){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB) return NULL;\\n\\n        //step1\\n        int lenA = length(headA), lenB = length(headB);\\n\\n        //step2\\n        if(lenA>lenB){\\n            while(lenA>lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        else if(lenA<lenB){\\n            while(lenA<lenB){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n        \\n        //step 3\\n        while(headA && headB){\\n            if(headA==headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n# Approach 2 \\nPrerequisite : [https://leetcode.com/problems/linked-list-cycle-ii/]()\\n\\nIn this approach, we can simply convert this problem into a loop problem.\\n1. Find the tail.\\n2. Connect the tail with any of the head which creates a loop.\\n3. Using the other head, find intersection point of the loop.\\n4. Undo the loop, by setting `tail->next = NULL`\\n5. Return the intersection node.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //getting the tail\\n        ListNode* tail = headA;\\n        while(tail->next){\\n            tail = tail->next;\\n        }\\n\\n        //creating a loop\\n        tail->next = headA;\\n\\n        //detecting and finding the intersection\\n        ListNode *fast = headB, *slow = headB;\\n\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n\\n            if(slow==fast) {\\n                slow = headB;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                //undoing the loop\\n                tail->next = NULL;\\n                return slow;\\n            };\\n        }\\n        tail->next = NULL;\\n        return NULL;\\n    }\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/a8052144-9a2e-4d47-9037-ccf7539df2d7_1681909702.2563934.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        int len = 0;\\n        while(head){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB) return NULL;\\n\\n        //step1\\n        int lenA = length(headA), lenB = length(headB);\\n\\n        //step2\\n        if(lenA>lenB){\\n            while(lenA>lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        else if(lenA<lenB){\\n            while(lenA<lenB){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n        \\n        //step 3\\n        while(headA && headB){\\n            if(headA==headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49846,
                "title": "python-solution-for-intersection-of-two-singly-linked-lists",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            curA,curB = headA,headB\\n            lenA,lenB = 0,0\\n            while curA is not None:\\n                lenA += 1\\n                curA = curA.next\\n            while curB is not None:\\n                lenB += 1\\n                curB = curB.next\\n            curA,curB = headA,headB\\n            if lenA > lenB:\\n                for i in range(lenA-lenB):\\n                    curA = curA.next\\n            elif lenB > lenA:\\n                for i in range(lenB-lenA):\\n                    curB = curB.next\\n            while curB != curA:\\n                curB = curB.next\\n                curA = curA.next\\n            return curA\\n\\n\\nThe solution is straightforward: maintaining two pointers in the lists under the constraint that both lists have the same number of nodes starting from the pointers. We need to calculate the length of each list though. So O(N) for time and O(1) for space.",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            curA,curB = headA,headB\\n            lenA,lenB = 0,0\\n            while curA is not None:\\n                lenA += 1\\n                curA = curA.next\\n            while curB is not None:\\n                lenB += 1\\n                curB = curB.next\\n            curA,curB = headA,headB\\n            if lenA > lenB:\\n                for i in range(lenA-lenB):\\n                    curA = curA.next\\n            elif lenB > lenA:\\n                for i in range(lenB-lenA):\\n                    curB = curB.next\\n            while curB != curA:\\n                curB = curB.next\\n                curA = curA.next\\n            return curA\\n\\n\\nThe solution is straightforward: maintaining two pointers in the lists under the constraint that both lists have the same number of nodes starting from the pointers. We need to calculate the length of each list though. So O(N) for time and O(1) for space.",
                "codeTag": "Java"
            },
            {
                "id": 2116127,
                "title": "python-easy-2-approaches-o-1-space",
                "content": "1. ## **Hashset**\\n\\nThe algorithm is:\\n1. Store all the elements of `headA` in a hashset\\n2. Iterate through the `headB` and check for the first match and then return it.\\n\\n**Time - O(n+m)**\\n**Space - O(n)**\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next\\n\\n        return None\\n```\\n\\n2. ## **Two Pointers**\\n\\nThis is to answer the follow-up question. For this approach, we will initialize two pointers which is pointing to heads of each Linked List. Then we will make these pointers run through both the Linked Lists ie. `n + m` length. By doing so, we will hit an intersection point.\\n\\n**Time - O(n+m)**\\n**Space - O(1)**\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        one = headA\\n        two = headB\\n\\n        while one != two:\\n            one = headB if one is None else one.next\\n            two = headA if two is None else two.next\\n        return one\\n```\\n\\n\\n**Note:**(*Added this part, as some leetcoders had issues reproducing the inputs locally.*)\\nThe line `one != two` compares the hashes of two objects.  The problem description states that both the inputs have the same tail i.e both LLs merge at some point. This means that `one==two` incase of intersection. So it means `hash(one)==hash(two)`. In your locally created inputs, if you are creating two separate LLs with same values for the tail, It doesn\\'t mean their hashes will be the same.\\n\\n> ListNode(8) != ListNode(8) \\ni.e. hash(ListNode(8)) != hash(ListNode(8))\\ni.e. 284711280 !=284711048. # hash generated from the two objects.\\n\\nFor locally generating the test input, you can do the following:\\n```\\ntail = createLL([8,4,5])\\nheadA=createLL([4, 1])\\nheadB=createLL([5,6,1])\\n\\nlast_nodeA = move_to_lastNode(headA)\\nlast_nodeA.next=tail\\n\\nlast_nodeB = move_to_lastNode(headB)\\nlast_nodeB.next=tail\\n```\\n\\n--- \\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next\\n\\n        return None\\n```\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        one = headA\\n        two = headB\\n\\n        while one != two:\\n            one = headB if one is None else one.next\\n            two = headA if two is None else two.next\\n        return one\\n```\n```\\ntail = createLL([8,4,5])\\nheadA=createLL([4, 1])\\nheadB=createLL([5,6,1])\\n\\nlast_nodeA = move_to_lastNode(headA)\\nlast_nodeA.next=tail\\n\\nlast_nodeB = move_to_lastNode(headB)\\nlast_nodeB.next=tail\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092935,
                "title": "python-short-but-difficult-solution-explained",
                "content": "The idea of solution is the following:\\n1. Calculate lengths of both lists and evaluate difference.\\n2. Make this number of steps for the longest list, pointer `p1` and pointer `p2` put to start of short list.\\n3. Move pointers `p1` and `p2` one by one until we have the same value: it will be either common element or it will be `None` element.\\n\\nSuprasingly all this can be done in one loop: let us look at the line\\n`currB = headA if currB is None else currB.next`. \\nWhat we are doing here is when some list finishes we start to traverse another list. Imagine the case:\\n\\nFirst list has `a` elements before intersection and `b` elements after intersection.\\nSecond list has `c` elements before intersection and `b` elements after intersection, and `c > a`.\\n\\n1. On the first step we will reach end of first list and for the second list we will be `c-a` elements before end.\\n2. On the second step our short list ended, so now we start to traverse long list and after `c-a` steps one of the pointers will be in the beginning of short list and another will be `c-a` steps from the long list.\\n3. Finally, we move both pointers with speed one and either we will have common element or they both reach the end in the same time and in this case they will have common `None` element.\\n\\n**Complexity**: we traverse both lists twice, so we will make no more than `2n + 2m = O(m+n)`. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        currA, currB = headA, headB\\n        \\n        while currA != currB:\\n            currB = headA if currB is None else currB.next\\n            currA = headB if currA is None else currA.next\\n            \\n        return currA\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        currA, currB = headA, headB\\n        \\n        while currA != currB:\\n            currB = headA if currB is None else currB.next\\n            currA = headB if currA is None else currA.next\\n            \\n        return currA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49805,
                "title": "share-my-simple-java-solution-o-n-time-o-1-space",
                "content": "1. Scan both lists\\n2. For each list once it reaches the end, continue scanning the other list\\n3. Once the two runner equal to each other, return the position\\n\\nTime O(n+m), space O(1)\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\t\\tif( null==headA || null==headB )\\n    \\t\\t\\treturn null;\\n    \\t\\t\\n    \\t\\tListNode curA = headA, curB = headB;\\n    \\t\\twhile( curA!=curB){\\n    \\t\\t\\tcurA = curA==null?headB:curA.next;\\n    \\t\\t\\tcurB = curB==null?headA:curB.next;\\n    \\t\\t}\\n    \\t\\treturn curA;\\n        }",
                "solutionTags": [],
                "code": "1. Scan both lists\\n2. For each list once it reaches the end, continue scanning the other list\\n3. Once the two runner equal to each other, return the position\\n\\nTime O(n+m), space O(1)\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\t\\tif( null==headA || null==headB )\\n    \\t\\t\\treturn null;\\n    \\t\\t\\n    \\t\\tListNode curA = headA, curB = headB;\\n    \\t\\twhile( curA!=curB){\\n    \\t\\t\\tcurA = curA==null?headB:curA.next;\\n    \\t\\t\\tcurB = curB==null?headA:curB.next;\\n    \\t\\t}\\n    \\t\\treturn curA;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 49899,
                "title": "c-solution-using-xor-trick",
                "content": "**Graphical explanation**\\n\\nStart from this:\\n\\n           (p) a1 \\u2192 a2\\n                       \\u2198\\n                         X \\u2192 c1 \\u2192 c2\\n                       \\u2197            \\n      (q) b1 \\u2192 b2 \\u2192 b3\\nfollow p, reversing links as you go:\\n\\n              a1 \\u2190 a2\\n                      \\u2196\\n                        X \\u2190 c1 \\u2190 c2 (p)\\n                      \\u2197            \\n     (q) b1 \\u2192 b2 \\u2192 b3\\nnow reverse q:\\n\\n          (q) a1 \\u2192 a2\\n                      \\u2198\\n                        X \\u2190 c1 \\u2190 c2 (p)\\n                      \\u2199            \\n         b1 \\u2190 b2 \\u2190 b3\\nthen reverse p again:\\n\\n          (q) a1 \\u2192 a2\\n                      \\u2198\\n                        X \\u2192 c1 \\u2192 c2\\n                      \\u2197            \\n     (p) b1 \\u2192 b2 \\u2192 b3\\n\\nNotice that p and q are swapped, but the list structure is back to what it was in the beginning.\\n\\nNow the key observation: each node in branches a, b and c has been visited exactly twice, while X has been visited three times. We can thus use the well known trick: we keep an accumulator and XOR it to each address we visit along the way. In the end, the accumulator will contain the address of the only node visited an odd number of times, that is X.\\n\\nWhat if the lists don't meet? In that case we have already reversed p twice, reverting it to its initial state, so we only need to reverse q a second time as well and return null.\\n\\n**Code**\\n\\n\\n    class Solution {\\n        uintptr_t acc = 0;\\n    \\n        ListNode* reverse(ListNode *head) {\\n            ListNode *prev = nullptr, *tmp;\\n            while (head) {\\n                acc ^= reinterpret_cast<uintptr_t> (head);\\n                tmp = head->next;\\n                head->next = prev;\\n                prev = head;\\n                head = tmp;\\n            }\\n            return prev;\\n        }\\n        \\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            ListNode *p = headA, *q = headB;\\n            p = reverse(p);\\n            q = reverse(q);\\n            p = reverse(p);\\n            if (q != headA) q = reverse(q);\\n            return reinterpret_cast<ListNode*> (acc);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        uintptr_t acc = 0;\\n    \\n        ListNode* reverse(ListNode *head) {\\n            ListNode *prev = nullptr, *tmp;\\n            while (head) {\\n                acc ^= reinterpret_cast<uintptr_t> (head);\\n                tmp = head->next;\\n                head->next = prev;\\n                prev = head;\\n                head = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 49800,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "At the first glance, the problem seems a bit hard for me. Because I have no idea how to locate the meeting point of the 2 different linked-list. After seeing some related implementation. \\nI got the idea and let me explain the details for you:\\nWe set 2 pointers \"curA\" and \"curB\" to point to linked-list headA and headB.\\nThen set the \\n\\n         [#length of linked-list headA]=L1\\n\\n         [#length of linked-list headB]=L2\\n\\n         assuming that L1<L2\\n\\nso, the curA will first move the tail of the headA, we have moved step T=L1\\n\\nby setting the curA to headB we move the curA and the curB at the same time\\n\\n           [#distance-from-curB-to-tail]=L2-L1\\n\\nwhen we move the curB to the tail of the headB then we set the curB to the headA, at the same time, \\n\\n            [#distance-from-headB-to-curA]=L2-L1\\n\\nSo we have the\\n  \\n            [#distance-from-curB-to-meet-point] ==  [#distance-from-curA-to-meet-point]\\n\\nWe just move the curA and curB at the same time, then we get the meeting point .\\n\\nThe only corner cases happen when the 2 linked-list do not meet, so we need to return NULL once the \\n\\n          curA==NULL and curB==NULL before to change the curA and curB\\n\\nHere is my implementation .\\n\\n   \\n\\n     class Solution {\\n        public:\\n            ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n                if(!headA || !headB)    return NULL;\\n                ListNode *curA=headA, *curB=headB;\\n                while(curA && curB){\\n                    if(curA==curB)  return curA;\\n                    curA=curA->next;\\n                    curB=curB->next;\\n                    /*corner cases for my code :\\n                    when the 2 linked-list do not meet, all the 2 pointers will be NULL at the same time.\\n                    the 2 pointers can be NULL at the same time, if we continue processing, the loop will\\n                    never end*/\\n                    if(curA==curB)  return curA;\\n                    if(curA==NULL)  curA=headB;\\n                    if(curB==NULL)  curB=headA;\\n                }\\n                return curA;\\n            }\\n        };\\n\\n\\nPS: This post deserves your up votes !",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n                if(!headA || !headB)    return NULL;\\n                ListNode *curA=headA, *curB=headB;\\n                while(curA && curB){\\n                    if(curA==curB)  return curA;\\n                    curA=curA->next;\\n                    curB=curB->next;\\n                    /*corner cases for my code :\\n                    when the 2 linked-list do not meet, all the 2 pointers will be NULL at the same time.\\n                    the 2 pointers can be NULL at the same time, if we continue processing, the loop will\\n                    never end*/\\n                    if(curA==curB)  return curA;\\n                    if(curA==NULL)  curA=headB;\\n                    if(curB==NULL)  curB=headA;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2116500,
                "title": "c-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* t1=headA;\\n        ListNode* t2=headB;\\n        int l1=1;\\n        int l2=1;\\n        while (t1->next){\\n            l1+=1;\\n            t1=t1->next;\\n        }\\n        while (t2->next){\\n            l2+=1;\\n            t2=t2->next;\\n        }\\n        if (t1!=t2){\\n            return NULL;\\n        }\\n        int move1 = max(0,l1-l2);\\n        int move2 = max(0,l2-l1);\\n        while (move1>0){\\n            headA=headA->next;\\n            move1--;\\n        }\\n        while (move2>0){\\n            headB=headB->next;\\n            move2--;\\n        }\\n        while (headA!=headB){\\n            headB=headB->next;\\n            headA=headA->next;\\n        }\\n        return headA;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/cbc7173a-fa3b-49a8-bece-dded253851ab_1654485855.096025.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* t1=headA;\\n        ListNode* t2=headB;\\n        int l1=1;\\n        int l2=1;\\n        while (t1->next){\\n            l1+=1;\\n            t1=t1->next;\\n        }\\n        while (t2->next){\\n            l2+=1;\\n            t2=t2->next;\\n        }\\n        if (t1!=t2){\\n            return NULL;\\n        }\\n        int move1 = max(0,l1-l2);\\n        int move2 = max(0,l2-l1);\\n        while (move1>0){\\n            headA=headA->next;\\n            move1--;\\n        }\\n        while (move2>0){\\n            headB=headB->next;\\n            move2--;\\n        }\\n        while (headA!=headB){\\n            headB=headB->next;\\n            headA=headA->next;\\n        }\\n        return headA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49838,
                "title": "5-line-python-solution",
                "content": "\\nHere are my 5 line solution:\\n\\n    def getIntersectionNode(self, headA, headB):\\n        p, q = headA, headB;\\n        while p != q:\\n            p = p.next if p else headB;\\n            q = q.next if q else headA;\\n        return p;",
                "solutionTags": [],
                "code": "\\nHere are my 5 line solution:\\n\\n    def getIntersectionNode(self, headA, headB):\\n        p, q = headA, headB;\\n        while p != q:\\n            p = p.next if p else headB;\\n            q = q.next if q else headA;\\n        return p;",
                "codeTag": "Python3"
            },
            {
                "id": 255597,
                "title": "javascript",
                "content": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if (!headA || !headB) return null;\\n    var curA = headA;\\n    var curB = headB;\\n    while (curA != curB) {\\n        curA = curA == null ? headB : curA.next;\\n        curB = curB == null ? headA : curB.next;\\n    }\\n    return curA;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if (!headA || !headB) return null;\\n    var curA = headA;\\n    var curB = headB;\\n    while (curA != curB) {\\n        curA = curA == null ? headB : curA.next;\\n        curB = curB == null ? headA : curB.next;\\n    }\\n    return curA;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249917,
                "title": "python-two-pointers",
                "content": "Suppose there are two linked lists A and B with an intersection I starting at node X. The length of intersection is L, A\\'s length is L1+L and B\\'s is L2+L.\\nAnd we have two pointers, **a** and **b**, walk through A and B in such way that **a** first walks through A then switch to B while **b** first walks through B then switch to A.\\n\\nIn such manner, when **a** and **b** have walked a distance of L1+L2+L, **a** has walked through |A|+|B-I| (L1+L+L2) and reaches X while **b** has walked through |B|+|A-I| (L2+L+L1) and reaches X as well. Therefore, both **a** and **b** points to the start node of intersection when they first meet each other (a == b).\\n\\nMeanwhile, if A and B has no intersection (L = 0), **a** reaches the end of B and **b** reaches the end of A. Both of them point to None (a==b==None), which is also what to return. So we can combine two cases in such way:\\n```\\ndef getIntersectionNode(headA, headB):\\n\\ta, b = headA, headB\\n\\twhile a != b:\\n\\t\\ta = a.next if a else headB\\n\\t\\tb = b.next if b else headA\\n\\treturn a\\n```\\nThe time complexity is O(L1+L2+L) and space complexity if O(1)",
                "solutionTags": [],
                "code": "```\\ndef getIntersectionNode(headA, headB):\\n\\ta, b = headA, headB\\n\\twhile a != b:\\n\\t\\ta = a.next if a else headB\\n\\t\\tb = b.next if b else headA\\n\\treturn a\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 49913,
                "title": "concise-48ms-c-solution-with-description-and-comment-on-trees",
                "content": "The idea is to first fast forward each pointer to the end to find their distances from the end. Then we can fast forward the farther pointer so they're the same distance from the end. Finally we can fast forward both at the same time until they coincide.\\n\\nThis same exact approach can also be used to find the least common ancestor (LCA) of two nodes in a tree where nodes have parent pointers.\\n\\n    class Solution {\\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n            auto currA = headA, currB = headB;\\n            int countA = 0, countB = 0;\\n            \\n            while (currA) { \\n                currA = currA->next, countA++;\\n            }\\n            while (currB) {\\n                currB = currB->next, countB++;\\n            }\\n            int diff = std::abs(countA - countB);\\n            if (countB > countA) { swap(headA, headB); }\\n            while (diff--) { \\n                headA = headA->next;\\n            }\\n            while (headA != headB) {\\n                headA = headA->next, headB = headB->next;\\n            }\\n            return headA;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n            auto currA = headA, currB = headB;\\n            int countA = 0, countB = 0;\\n            \\n            while (currA) { \\n                currA = currA->next, countA++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50030,
                "title": "my-c-accepted-solution-with-o-n-time-and-o-1-memory-72ms",
                "content": "The main idea of this solution is using the values of the intersecting nodes.\\n\\nFirst, calculate the total amount of value of nodes in listB.\\n\\nSecond, add 1 to all the nodes in listA.\\n\\nThird, re-calculate the total amount of value in listB.\\n\\nIf there exists some nodes intersecting, the re-calculated amount must be different from the previous one, otherwise, there is no any node intersecting. And we can also derive the first intersecting node through the difference between two amounts.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tmp = headB;\\n        int amoutB = 0,lengthB=0;\\n    \\n        //calculate the amount of values in listB and get the length of listB\\n        while (tmp!=NULL)\\n        {\\n            amoutB += tmp->val;\\n            lengthB ++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //add 1 value to all nodes in listA\\n        tmp = headA;\\n        while (tmp!=NULL)\\n        {\\n            tmp->val++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //re-calculate the amount of values in listB again\\n        tmp = headB;\\n        int newamoutB = 0;\\n        while (tmp!=NULL)\\n        {\\n            newamoutB += tmp->val;\\n            tmp = tmp->next;\\n        }\\n        tmp = headA;\\n    \\n        //subtract 1 from all the nodes in listA\\n        while (tmp!=NULL)\\n        {\\n            tmp->val--;\\n            tmp = tmp->next;\\n        }\\n        \\n        //if two amounts are the same, there is no node intersecting\\n        if(newamoutB==amoutB)\\n           return NULL;\\n        //the difference of two amounts means the number of intersecting nodes, \\n        //we can get the first one by comparing it with number of nodes in listB\\n        else\\n        {\\n            tmp = headB;\\n            for(int i=0; i<lengthB-(newamoutB-amoutB);i++)\\n                tmp = tmp->next;\\n            return tmp;\\n        }\\n    \\n    }",
                "solutionTags": [],
                "code": "The main idea of this solution is using the values of the intersecting nodes.\\n\\nFirst, calculate the total amount of value of nodes in listB.\\n\\nSecond, add 1 to all the nodes in listA.\\n\\nThird, re-calculate the total amount of value in listB.\\n\\nIf there exists some nodes intersecting, the re-calculated amount must be different from the previous one, otherwise, there is no any node intersecting. And we can also derive the first intersecting node through the difference between two amounts.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tmp = headB;\\n        int amoutB = 0,lengthB=0;\\n    \\n        //calculate the amount of values in listB and get the length of listB\\n        while (tmp!=NULL)\\n        {\\n            amoutB += tmp->val;\\n            lengthB ++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //add 1 value to all nodes in listA\\n        tmp = headA;\\n        while (tmp!=NULL)\\n        {\\n            tmp->val++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //re-calculate the amount of values in listB again\\n        tmp = headB;\\n        int newamoutB = 0;\\n        while (tmp!=NULL)\\n        {\\n            newamoutB += tmp->val;\\n            tmp = tmp->next;\\n        }\\n        tmp = headA;\\n    \\n        //subtract 1 from all the nodes in listA\\n        while (tmp!=NULL)\\n        {\\n            tmp->val--;\\n            tmp = tmp->next;\\n        }\\n        \\n        //if two amounts are the same, there is no node intersecting\\n        if(newamoutB==amoutB)\\n           return NULL;\\n        //the difference of two amounts means the number of intersecting nodes, \\n        //we can get the first one by comparing it with number of nodes in listB\\n        else\\n        {\\n            tmp = headB;\\n            for(int i=0; i<lengthB-(newamoutB-amoutB);i++)\\n                tmp = tmp->next;\\n            return tmp;\\n        }\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1903925,
                "title": "4-approaches-with-optimisation-easy-to-understand",
                "content": "**Approach I - Brute Force**\\n*Time - O(mn),  Space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        while(headA!=null)\\n        {\\n            ListNode temp = headB;\\n            while(temp!=null)\\n            {\\n                if(temp==headA)\\n                    return headA;\\n                temp = temp.next;\\n            }\\n            headA = headA.next;\\n        }\\n        return null;\\n    }\\n```\\n\\n**Approach II - Using Hashing**\\n*Time - O(m+n),  Space - O(m)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        HashSet<ListNode> st=new HashSet<>();\\n        while(headA != null)\\n        {\\n            st.add(headA);\\n            headA = headA.next;\\n        }\\n        \\n        while(headB != null)\\n        {\\n            if(st.contains(headB)) \\n                return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n```\\n\\n**Approach III - (Using difference of length between lists)**\\n*Time - O((m+n)+(l1-l2)+min(m,n),  space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int l1 = length(headA);\\n        int l2 = length(headB);\\n        int d = 0;\\n        ListNode ptr1;\\n        ListNode ptr2;\\n    \\n        if (l1>l2)\\n        {\\n            d = l1-l2;\\n            ptr1 = headA;\\n            ptr2 = headB;\\n        }\\n        else\\n        {\\n            d = l2-l1;\\n            ptr1 = headB;\\n            ptr2 = headA;\\n        }\\n    \\n        while(d>0)\\n        {\\n            if (ptr1==null)\\n            {\\n                return null;\\n            }\\n            ptr1 = ptr1.next;\\n            d--;\\n        }\\n        while (ptr1!=null && ptr2!=null)\\n        {\\n            if (ptr1==ptr2)\\n                return ptr1;\\n            \\n            ptr1 = ptr1.next;\\n            ptr2 = ptr2.next;\\n        }\\n        return null;\\n    }\\n    \\n    public int length(ListNode head)\\n    {\\n        int i = 0;\\n        while(head!=null)\\n        {\\n            i++;\\n            head = head.next;\\n        }\\n        return i;\\n    }\\n```\\n\\n**Approach IV - Optimised**\\n*Time - O(2max(m,n)),  space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode d1 = headA, d2 = headB;\\n        while(d1!=d2)\\n        {\\n            if(d1==null)\\n                d1 = headB;\\n            else\\n                d1 = d1.next;\\n            \\n            if(d2==null)\\n                d2 = headA;\\n            else\\n                d2 = d2.next;\\n        }\\n        return d1;\\n    }\\n```\\n*If it helps you, please do upvote\\nHave fun  :)*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        while(headA!=null)\\n        {\\n            ListNode temp = headB;\\n            while(temp!=null)\\n            {\\n                if(temp==headA)\\n                    return headA;\\n                temp = temp.next;\\n            }\\n            headA = headA.next;\\n        }\\n        return null;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        HashSet<ListNode> st=new HashSet<>();\\n        while(headA != null)\\n        {\\n            st.add(headA);\\n            headA = headA.next;\\n        }\\n        \\n        while(headB != null)\\n        {\\n            if(st.contains(headB)) \\n                return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int l1 = length(headA);\\n        int l2 = length(headB);\\n        int d = 0;\\n        ListNode ptr1;\\n        ListNode ptr2;\\n    \\n        if (l1>l2)\\n        {\\n            d = l1-l2;\\n            ptr1 = headA;\\n            ptr2 = headB;\\n        }\\n        else\\n        {\\n            d = l2-l1;\\n            ptr1 = headB;\\n            ptr2 = headA;\\n        }\\n    \\n        while(d>0)\\n        {\\n            if (ptr1==null)\\n            {\\n                return null;\\n            }\\n            ptr1 = ptr1.next;\\n            d--;\\n        }\\n        while (ptr1!=null && ptr2!=null)\\n        {\\n            if (ptr1==ptr2)\\n                return ptr1;\\n            \\n            ptr1 = ptr1.next;\\n            ptr2 = ptr2.next;\\n        }\\n        return null;\\n    }\\n    \\n    public int length(ListNode head)\\n    {\\n        int i = 0;\\n        while(head!=null)\\n        {\\n            i++;\\n            head = head.next;\\n        }\\n        return i;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode d1 = headA, d2 = headB;\\n        while(d1!=d2)\\n        {\\n            if(d1==null)\\n                d1 = headB;\\n            else\\n                d1 = d1.next;\\n            \\n            if(d2==null)\\n                d2 = headA;\\n            else\\n                d2 = d2.next;\\n        }\\n        return d1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49924,
                "title": "python-ac-solution-with-clear-explanation",
                "content": "If two linked lists have intersection, we can find two observations:\\n1. They must have same nodes after the intersection point.\\n2. L1+L2 must have same tail from the intersection point as L2 + L1. For example, \\n\\nL1 = 1,2,3 \\nL2 = 6,5,2,3\\n\\nL1+L2 = 1,2,3,6,5,`2,3`\\nL2+L1 = 6,5,2,3,1,`2,3`\\n\\n* To implement L1+L2 as well as L2+L1, we can simply jump to another list's head \\nafter traveling through certain list.\\n* But, you need to notice that if the two lists have no intersection at all, \\nyou should stop after you've already checked L1+L2, so we need a flag `jumpToNext` to ensure we only traverse L1 + L2 once.\\n\\n\\n```python\\n    def getIntersectionNode(self, headA, headB):\\n        ptA, ptB, jumpToNext = headA, headB, False\\n        while ptA and ptB:\\n            if ptA == ptB:\\n                return ptA\\n            ptA, ptB = ptA.next, ptB.next\\n            if not ptA and not jumpToNext:\\n                ptA, jumpToNext = headB, True\\n            if not ptB:\\n                ptB = headA\\n        return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def getIntersectionNode(self, headA, headB):\\n        ptA, ptB, jumpToNext = headA, headB, False\\n        while ptA and ptB:\\n            if ptA == ptB:\\n                return ptA\\n            ptA, ptB = ptA.next, ptB.next\\n            if not ptA and not jumpToNext:\\n                ptA, jumpToNext = headB, True\\n            if not ptB:\\n                ptB = headA\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116531,
                "title": "easy-c-solution",
                "content": "The idea here is to traverse both the linked list and find there lengths...\\nWe now know that if the two linked list are equal after some point, there tails are equal and hence after that point, their lengths will also be equal...\\nSo, we traverse the longer linked list, till its length becomes equal to smaller linked list, and then we traverse both the linked list together  and stop when there nodes are equal...\\n\\n**Pls upvote this thread if you found the solution helpful.**\\n\\n![image](https://assets.leetcode.com/users/images/6c6af264-9ff9-444c-b62e-f586d126dfb0_1654486352.7816951.png)\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a=headA, *b=headB;\\n        int count1=0, count2=0;\\n\\t\\t\\n\\t\\t//counting lengths of both the linked list\\n        for(ListNode *curr=headA;curr!=NULL; curr=curr->next) count1++;\\n        for(ListNode *curr=headB;curr!=NULL; curr=curr->next) count2++;\\n        \\n\\t\\t//If linked list 1 is longer, we traverse it, till it becomes equal to length of second...\\n        while(count1>count2) {\\n            count1--;\\n            a=a->next;\\n        }\\n        \\n\\t\\t//If second one is longer, we traverse it, till it becomes equal to length of first...\\n        while(count2>count1) {\\n            count2--;\\n            b=b->next;\\n        }\\n        \\n\\t\\t//Since length of both is now equal, we traverse them together, and break if the nodes become equal...\\n        while(a!=b) {\\n            a=a->next;\\n            b=b->next;\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a=headA, *b=headB;\\n        int count1=0, count2=0;\\n\\t\\t\\n\\t\\t//counting lengths of both the linked list\\n        for(ListNode *curr=headA;curr!=NULL; curr=curr->next) count1++;\\n        for(ListNode *curr=headB;curr!=NULL; curr=curr->next) count2++;\\n        \\n\\t\\t//If linked list 1 is longer, we traverse it, till it becomes equal to length of second...\\n        while(count1>count2) {\\n            count1--;\\n            a=a->next;\\n        }\\n        \\n\\t\\t//If second one is longer, we traverse it, till it becomes equal to length of first...\\n        while(count2>count1) {\\n            count2--;\\n            b=b->next;\\n        }\\n        \\n\\t\\t//Since length of both is now equal, we traverse them together, and break if the nodes become equal...\\n        while(a!=b) {\\n            a=a->next;\\n            b=b->next;\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49902,
                "title": "java-beats-99-56",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode p1 = headA, p2 = headB;\\n        int len1 = 0, len2 = 0;\\n        while (p1 != null) {\\n            p1 = p1.next;\\n            len1++;\\n        }\\n        while (p2 != null) {\\n            p2 = p2.next;\\n            len2++;\\n        }\\n        p1 = headA;\\n        p2 = headB;\\n        if (len1 > len2) {\\n            for (int i = 0;i < len1 - len2; i++) {\\n                p1 = p1.next;\\n            }\\n        } else {\\n            for (int i = 0;i < len2 - len1; i++) {\\n                p2 = p2.next;\\n            }\\n        }\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode p1 = headA, p2 = headB;\\n        int len1 = 0, len2 = 0;\\n        while (p1 != null) {\\n            p1 = p1.next;\\n            len1++;\\n        }\\n        while (p2 != null) {\\n            p2 = p2.next;\\n            len2++;\\n        }\\n        p1 = headA;\\n        p2 = headB;\\n        if (len1 > len2) {\\n            for (int i = 0;i < len1 - len2; i++) {\\n                p1 = p1.next;\\n            }\\n        } else {\\n            for (int i = 0;i < len2 - len1; i++) {\\n                p2 = p2.next;\\n            }\\n        }\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093051,
                "title": "intersection-of-two-linked-lists-c-o-1-space-short-concise",
                "content": "## Solution - I\\nIf the length of linked lists had been the same, finding the intersection node would be as easy as iterating over both linked list simultaneously and returning if same node is found. \\n\\nIn the given question, however, we need to first align the lists. The head of list with greater length need to be iterated forward `diff`(difference of lengths) number of times and the final answer won\\'t be affected by this since length of list after intersection must be same(meaning intersection surely wouldn\\'t exist in the first `diff` nodes) . This way, we can parallelly compare nodes of both list and return if two nodes match.\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tint n1 = 0, n2 = 0;\\n\\tListNode* a = headA, *b = headB;\\n\\twhile(a)\\n\\t\\tn1++, a = a -> next;\\n\\twhile(b)\\n\\t\\tn2++, b = b -> next;\\n\\ta = headA, b = headB;\\n\\twhile(a && n1 > n2)\\n\\t\\ta = a -> next, n1--;\\n\\twhile(b && n2 > n1)\\n\\t\\tb = b -> next, n2--;\\n\\twhile(a && b)\\n\\t\\tif(a == b)\\n\\t\\t\\treturn a;\\n\\t\\telse a = a -> next, b = b -> next;\\n\\treturn NULL;\\n}\\n```\\n\\n---------------\\n## Solution - II\\nInfact, we don\\'t need to find `diff` and iterate the greater length list. Instead, if we reach the end of a list, just restart from the head of other list. This can help up counter the difference of lengths. Finally, the lists will either converge on intersected node or both will reach end at same time and we will return `NULL` at last. \\n\\n* For eg. Lists having intersected node (**Example 1** from description) -\\n\\t```\\n\\tA : 4 -> 1 -> 8 -> 4 -> 5 |  5 -> 6 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t  ^end(restart from B)\\n\\tB : 5 -> 6 -> 1 -> 8 -> 4 -> 5 |  4 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t\\t   ^end(restart from A)\\n\\treturn since we found the same node\\n\\t```\\n\\t*NOTE : In the above example, we compared 1(from **A**) and 1(from **B**) but didnt return it since their memory addresses didn\\'t match. We are comparing a == b, and not a->val == b->val.*\\n\\t\\n* Lists having no intersected node (**Example 3** from description)-\\n\\t```\\n\\tA : 2 -> 6 -> 4 |  1 -> 2 |   <- both reach NULL at same time, hence no intersection.\\n\\t\\t\\t\\t\\t^end      ^end\\n\\tB : 1 -> 2 |  2 -> 6 -> 4 |   <- both reach NULL at same time, no intersection\\n\\t\\t\\t   ^end           ^end\\n\\t```\\nThe implementation for the same is given below :\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        \\n    ListNode* a = headA, *b = headB;\\n    while(a != b)\\n        a = a ? a -> next : headB, b = b ? b -> next : headA;\\n    return a;\\n}\\n```\\n**Time Complexity** : **`O(N)`**, where `N` is the sum of length of both the linked lists. Since `N1+N2` == `N2+N1`, the pointers would restart atmost 1 time each. The worst case would occur when both lengths are unequal and they don\\'t have any intersection.\\n**Space Complexity** : **`O(1)`**, since only constant space is used.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tint n1 = 0, n2 = 0;\\n\\tListNode* a = headA, *b = headB;\\n\\twhile(a)\\n\\t\\tn1++, a = a -> next;\\n\\twhile(b)\\n\\t\\tn2++, b = b -> next;\\n\\ta = headA, b = headB;\\n\\twhile(a && n1 > n2)\\n\\t\\ta = a -> next, n1--;\\n\\twhile(b && n2 > n1)\\n\\t\\tb = b -> next, n2--;\\n\\twhile(a && b)\\n\\t\\tif(a == b)\\n\\t\\t\\treturn a;\\n\\t\\telse a = a -> next, b = b -> next;\\n\\treturn NULL;\\n}\\n```\n```\\n\\tA : 4 -> 1 -> 8 -> 4 -> 5 |  5 -> 6 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t  ^end(restart from B)\\n\\tB : 5 -> 6 -> 1 -> 8 -> 4 -> 5 |  4 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t\\t   ^end(restart from A)\\n\\treturn since we found the same node\\n\\t```\n```\\n\\tA : 2 -> 6 -> 4 |  1 -> 2 |   <- both reach NULL at same time, hence no intersection.\\n\\t\\t\\t\\t\\t^end      ^end\\n\\tB : 1 -> 2 |  2 -> 6 -> 4 |   <- both reach NULL at same time, no intersection\\n\\t\\t\\t   ^end           ^end\\n\\t```\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        \\n    ListNode* a = headA, *b = headB;\\n    while(a != b)\\n        a = a ? a -> next : headB, b = b ? b -> next : headA;\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918847,
                "title": "easiest-faang-method-ever",
                "content": "## ***Please go through the entire solution video and solution carefully. It is very easy to understand for beginners too :)***\\n#### **Please do Upvote if it helps\\uD83D\\uDE4F**\\n# \\uD83D\\uDCCCIntuition :-\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=u4FWXfgS8jw&list=PLgUwDviBIf0p4ozDR_kJJkONnb1wdx2Ma&index=34\\n\\n**Thanks to Striver and TUF \\u2764\\uFE0F**\\n\\n#### **Please do Upvote if it helps\\uD83D\\uDE4F**\\n\\n# \\uD83D\\uDCCCApproach :-\\n### 1) Bruteforce - O(n^2)\\n### 2) Approach-2 [Using Hashing we store address of each node and find common addresses b/w 2 linked lists]\\n### 3) Optimal Approach - 1 [TC:O(2n) SC:O(1), Longer code length]\\n##### \\uD83D\\uDD38 Find Lengths of both linked list.\\n##### \\uD83D\\uDD38 Move linked list with longer size to make the distance to intersection same.\\n##### \\uD83D\\uDD38 Loop till intersection.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n        int count1=0,count2=0;\\n        while(a){\\n            a=a->next;\\n            count1++;\\n        }\\n        while(b){\\n            b=b->next;\\n            count2++;\\n        }\\n        ListNode *t1=headA;\\n        ListNode *t2=headB;\\n        int diff=abs(count1-count2);\\n        if(count1>count2){\\n            while(diff!=0){\\n                t1=t1->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            while(diff!=0){\\n                t2=t2->next;\\n                diff--;\\n            }\\n        }\\n\\n        while(t1!=t2){\\n            t1=t1->next;\\n            t2=t2->next;\\n        }\\n        return t1;\\n    }\\n};\\n```\\n### 3) Optimal Approach - 2 [TC:O(2n) SC:O(1), Short crisp code]\\n##### \\uD83D\\uDD38Loop through both linked lists.\\n##### \\uD83D\\uDD38 As soon as any pointer reaches NULL, make it loop through the second linked list. Move each pointer by one node at a time. This covers the difference in size b/w 2 linked list.\\n##### \\uD83D\\uDD38 Loop till both pointers become equal.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n\\n        while(a!=b)    {\\n            a=a==NULL?headB:a->next;\\n            b=b==NULL?headA:b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n## **Please do Upvote if it helps\\uD83D\\uDE4F**\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n        int count1=0,count2=0;\\n        while(a){\\n            a=a->next;\\n            count1++;\\n        }\\n        while(b){\\n            b=b->next;\\n            count2++;\\n        }\\n        ListNode *t1=headA;\\n        ListNode *t2=headB;\\n        int diff=abs(count1-count2);\\n        if(count1>count2){\\n            while(diff!=0){\\n                t1=t1->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            while(diff!=0){\\n                t2=t2->next;\\n                diff--;\\n            }\\n        }\\n\\n        while(t1!=t2){\\n            t1=t1->next;\\n            t2=t2->next;\\n        }\\n        return t1;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n\\n        while(a!=b)    {\\n            a=a==NULL?headB:a->next;\\n            b=b==NULL?headA:b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403600,
                "title": "python-clean-solution",
                "content": "[**Python Data Structures and algorithms**](https://github.com/tamudashe/Python-Data-Structures-and-Algorithms.git)\\n\\n* Time comlexity: O(m + n)\\n*  Space complecity : O(1)\\n\\n```\\ndef getIntersectionNode(headA, headB):\\n        a_pointer, b_pointer = headA, headB\\n        while a_pointer != b_pointer:\\n            a_pointer = a_pointer.next if a_pointer else headB\\n            b_pointer = b_pointer.next if b_pointer else headA\\n        return a_pointer\\n```",
                "solutionTags": [],
                "code": "```\\ndef getIntersectionNode(headA, headB):\\n        a_pointer, b_pointer = headA, headB\\n        while a_pointer != b_pointer:\\n            a_pointer = a_pointer.next if a_pointer else headB\\n            b_pointer = b_pointer.next if b_pointer else headA\\n        return a_pointer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417354,
                "title": "c-java-python-javascript-hash-table-of-linked-list",
                "content": "# Intuition:\\nThe problem is to find the intersection node of two linked lists. A brute-force approach would be to traverse both the linked lists and compare each node of the first linked list with every node of the second linked list. But this approach would take O(n^2) time complexity. A better approach would be to use a hash table (unordered_set) to store the nodes of the first linked list, and then traverse the second linked list, checking if any of its nodes are already present in the hash table. If yes, then it is the intersection node.\\n\\n# Approach:\\n\\n1. Create an unordered_set of ListNode* type to store the nodes of the first linked list.\\n2. Traverse the first linked list (headA), and insert each node into the unordered_set.\\n3. Traverse the second linked list (headB), and for each node, check if it is present in the unordered_set. If yes, return the node.\\n4. If the end of the second linked list is reached, and no intersection node is found, return NULL.\\n# Complexity:\\n- Time complexity: O(m+n), where m and n are the lengths of the two linked lists. We traverse each linked list once, and the unordered_set lookup operation takes O(1) time.\\n- Space complexity: O(m), where m is the length of the first linked list. We store the nodes of the first linked list in an unordered_set.\\n\\n---\\n\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode *> st;\\n        while(headA != NULL) {\\n        st.insert(headA);\\n        headA = headA->next;\\n        }\\n        while(headB != NULL) {\\n            if(st.find(headB) != st.end()) return headB;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n---\\n# JavaScript\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    let set = new Set();\\n    while(headA) {\\n        set.add(headA);\\n        headA = headA.next;\\n    }\\n    while(headB) {\\n        if(set.has(headB)) return headB;\\n        headB = headB.next;\\n    }\\n    return null;\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n        while(headA != null) {\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n        while(headB != null) {\\n            if(set.contains(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        st = set()\\n        while headA:\\n            st.add(headA)\\n            headA = headA.next\\n        while headB:\\n            if headB in st:\\n                return headB\\n            headB = headB.next\\n        return None\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode *> st;\\n        while(headA != NULL) {\\n        st.insert(headA);\\n        headA = headA->next;\\n        }\\n        while(headB != NULL) {\\n            if(st.find(headB) != st.end()) return headB;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    let set = new Set();\\n    while(headA) {\\n        set.add(headA);\\n        headA = headA.next;\\n    }\\n    while(headB) {\\n        if(set.has(headB)) return headB;\\n        headB = headB.next;\\n    }\\n    return null;\\n};\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n        while(headA != null) {\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n        while(headB != null) {\\n            if(set.contains(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n}\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        st = set()\\n        while headA:\\n            st.add(headA)\\n            headA = headA.next\\n        while headB:\\n            if headB in st:\\n                return headB\\n            headB = headB.next\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093186,
                "title": "python-magic-solution-o-n-time-o-1-solution",
                "content": "```\\nclass Solution:\\n    def changeSign(self, head: ListNode):\\n        while ( head ):\\n            head.val *= -1\\n            head = head.next\\n    \\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        self.changeSign(headA)\\n        \\n        while ( headB ):\\n            if headB.val < 0:break\\n            headB = headB.next\\n        \\n        self.changeSign(headA)\\n        return headB",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def changeSign(self, head: ListNode):\\n        while ( head ):\\n            head.val *= -1\\n            head = head.next\\n    \\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        self.changeSign(headA)\\n        \\n        while ( headB ):\\n            if headB.val < 0:break\\n            headB = headB.next\\n        \\n        self.changeSign(headA)\\n        return headB",
                "codeTag": "Java"
            },
            {
                "id": 49938,
                "title": "python-solution-o-n-time-and-o-1-space",
                "content": "This problem could be considered as the derivation of linked list cycle. \\nLet say there are two linked lists named l1 and l2. And h1 and t1 are the head and last nodes of l1 respectively, and h2 is the head node of l2.\\n\\n1. Concat h1 and t1\\n2. Check whether there exists a cycle of linked list l2.\\n3. Find that intersection if 2 is a truth.\\n\\nBefore doing the above steps, there are two linked lists in the picture:\\n![enter image description here][1]\\n\\nAfter step 1:\\n![enter image description here][2]\\n\\nThen let's try to make the linked lists easier to understood.\\n![enter image description here][3]\\nNode 8 is what we want.  We can use then solve it by finding the start node of the cycle like the problem \"linked list cycle II\"\\n\\nHere is my code:\\n\\n\\tdef getIntersectionNode(self, headA, headB):\\n\\t\\t\"\"\"\\n\\t\\t:type head1, head1: ListNode\\n\\t\\t:rtype: ListNode\\n\\t\\t\"\"\" \\n\\t\\tif not headA or not headB: return None\\n\\t\\t\\n\\t\\tp = headA\\n\\t\\twhile p.next:\\n\\t\\t\\tp = p.next\\n\\t\\tmark = p\\n\\t\\t#make a cycled list\\n\\t\\tmark.next = headA\\n\\t\\t\\n\\t\\trst = None\\n\\t\\tp1 = headB\\n\\t\\tp2 = headB\\n\\t\\twhile p1 and p2:\\n\\t\\t\\tp1 = p1.next\\n\\t\\t\\tp2 = p2.next\\n\\t\\t\\tif p2: p2 = p2.next\\n\\t\\t\\tif p1 == p2: break\\n\\n\\t\\tif p1 and p2 and p1 == p2:\\n\\t\\t\\tp1 = headB\\n\\t\\t\\twhile p1 != p2:\\n\\t\\t\\t\\tp1 = p1.next\\n\\t\\t\\t\\tp2 = p2.next\\n\\t\\t\\trst = p1\\n\\n\\t\\t#unmake the cycle\\n\\t\\tmark.next = None\\n\\n\\t\\treturn rst\\n\\n\\n  [1]: http://b52.imgup.net/original15aa.jpg\\n  [2]: http://h04.imgup.net/concatedfe73.jpg\\n  [3]: http://g12.imgup.net/understood69a3.jpg",
                "solutionTags": [],
                "code": "This problem could be considered as the derivation of linked list cycle. \\nLet say there are two linked lists named l1 and l2. And h1 and t1 are the head and last nodes of l1 respectively, and h2 is the head node of l2.\\n\\n1. Concat h1 and t1\\n2. Check whether there exists a cycle of linked list l2.\\n3. Find that intersection if 2 is a truth.\\n\\nBefore doing the above steps, there are two linked lists in the picture:\\n![enter image description here][1]\\n\\nAfter step 1:\\n![enter image description here][2]\\n\\nThen let's try to make the linked lists easier to understood.\\n![enter image description here][3]\\nNode 8 is what we want.  We can use then solve it by finding the start node of the cycle like the problem \"linked list cycle II\"\\n\\nHere is my code:\\n\\n\\tdef getIntersectionNode(self, headA, headB):\\n\\t\\t\"\"\"\\n\\t\\t:type head1, head1: ListNode\\n\\t\\t:rtype: ListNode\\n\\t\\t\"\"\" \\n\\t\\tif not headA or not headB: return None\\n\\t\\t\\n\\t\\tp = headA\\n\\t\\twhile p.next:\\n\\t\\t\\tp = p.next\\n\\t\\tmark = p\\n\\t\\t#make a cycled list\\n\\t\\tmark.next = headA\\n\\t\\t\\n\\t\\trst = None\\n\\t\\tp1 = headB\\n\\t\\tp2 = headB\\n\\t\\twhile p1 and p2:\\n\\t\\t\\tp1 = p1.next\\n\\t\\t\\tp2 = p2.next\\n\\t\\t\\tif p2: p2 = p2.next\\n\\t\\t\\tif p1 == p2: break\\n\\n\\t\\tif p1 and p2 and p1 == p2:\\n\\t\\t\\tp1 = headB\\n\\t\\t\\twhile p1 != p2:\\n\\t\\t\\t\\tp1 = p1.next\\n\\t\\t\\t\\tp2 = p2.next\\n\\t\\t\\trst = p1\\n\\n\\t\\t#unmake the cycle\\n\\t\\tmark.next = None\\n\\n\\t\\treturn rst\\n\\n\\n  [1]: http://b52.imgup.net/original15aa.jpg\\n  [2]: http://h04.imgup.net/concatedfe73.jpg\\n  [3]: http://g12.imgup.net/understood69a3.jpg",
                "codeTag": "Python3"
            },
            {
                "id": 49925,
                "title": "java-o-n-time-o-1-space-solution-by-using-assume-there-are-no-cycles",
                "content": "As a reminder:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3\\n                       \\u2197            \\n    B:    b1 \\u2192 b2 \\u2192 b3\\n\\nBased on this I construct a structure that has a cycle in it:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3 \\\\\\n                       \\u2197              |\\n    B:    b1 \\u2192 b2 \\u2192 b3                /\\n            \\u2196------------------------\\n\\nThen starting from `a1` I try to find a cycle (`fast` iterator would wrap around to itself [`slow`]).\\nIf that's found the take some steps until the starting point is found.  \\n(A good explanation of this can be found [here](http://learningarsenal.info/index.php/2015/08/24/detecting-start-of-a-loop-in-singly-linked-list/))\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\tif (headA == null || headB == null) return null;\\n\\t\\t// find last node of list A (c3)\\n\\t\\tListNode endA = headA;\\n\\t\\twhile (endA.next != null) {\\n\\t\\t\\tendA = endA.next;\\n\\t\\t}\\n\\t\\t// join c3 to b1 making a c1...c3-b1...b3-c1 loop (if b3 indeed points to c1)\\n\\t\\tendA.next = headB;\\n\\n\\t\\tListNode start = null; // if there's no cycle this will stay null\\n\\t\\t// Floyd's cycle finder\\n\\t\\tListNode slow = headA, fast = headA;\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow == fast) { // found a cycle\\n\\t\\t\\t\\t// reset to beginning to find cycle start point (c1)\\n\\t\\t\\t\\tstart = headA;\\n\\t\\t\\t\\twhile (slow != start) {\\n\\t\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\t\\tstart = start.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// unjoin c3-b1\\n\\t\\tendA.next = null;\\n\\t\\treturn start;\\n    }\\n\\nIf there's no cycle it simply concats `B` after `A` and traverese to the end via the `fast` pointer.",
                "solutionTags": [
                    "Java"
                ],
                "code": "As a reminder:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3\\n                       \\u2197            \\n    B:    b1 \\u2192 b2 \\u2192 b3\\n\\nBased on this I construct a structure that has a cycle in it:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3 \\\\\\n                       \\u2197              |\\n    B:    b1 \\u2192 b2 \\u2192 b3                /\\n            \\u2196------------------------\\n\\nThen starting from `a1` I try to find a cycle (`fast` iterator would wrap around to itself [`slow`]).\\nIf that's found the take some steps until the starting point is found.  \\n(A good explanation of this can be found [here](http://learningarsenal.info/index.php/2015/08/24/detecting-start-of-a-loop-in-singly-linked-list/))\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\tif (headA == null || headB == null) return null;\\n\\t\\t// find last node of list A (c3)\\n\\t\\tListNode endA = headA;\\n\\t\\twhile (endA.next != null) {\\n\\t\\t\\tendA = endA.next;\\n\\t\\t}\\n\\t\\t// join c3 to b1 making a c1...c3-b1...b3-c1 loop (if b3 indeed points to c1)\\n\\t\\tendA.next = headB;\\n\\n\\t\\tListNode start = null; // if there's no cycle this will stay null\\n\\t\\t// Floyd's cycle finder\\n\\t\\tListNode slow = headA, fast = headA;\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow == fast) { // found a cycle\\n\\t\\t\\t\\t// reset to beginning to find cycle start point (c1)\\n\\t\\t\\t\\tstart = headA;\\n\\t\\t\\t\\twhile (slow != start) {\\n\\t\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\t\\tstart = start.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// unjoin c3-b1\\n\\t\\tendA.next = null;\\n\\t\\treturn start;\\n    }\\n\\nIf there's no cycle it simply concats `B` after `A` and traverese to the end via the `fast` pointer.",
                "codeTag": "Unknown"
            },
            {
                "id": 50020,
                "title": "stupid-and-short-c-solution-without-any-list-cycles-o-n-time-o-1-memory",
                "content": "Just  store addition information in 'next' pointers.\\nIt's work because memory alignment\\n\\n    \\x01ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        for (ListNode *cur = headA; cur;) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            cur = cur->next;\\n            *ptr |= 1;\\n        }\\n    \\n        ListNode *result = nullptr;\\n        for (ListNode *cur = headB; cur; cur = cur->next) {\\n            unsigned long ptr = (unsigned long)cur->next;\\n            if (ptr & 1) {\\n                result = cur;\\n                break;\\n            }\\n        }\\n        \\n        for (ListNode *cur = headA; cur; cur = cur->next) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            *ptr &= (~0ULL << 1);\\n        }\\n    \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Just  store addition information in 'next' pointers.\\nIt's work because memory alignment\\n\\n    \\x01ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        for (ListNode *cur = headA; cur;) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            cur = cur->next;\\n            *ptr |= 1;\\n        }\\n    \\n        ListNode *result = nullptr;\\n        for (ListNode *cur = headB; cur; cur = cur->next) {\\n            unsigned long ptr = (unsigned long)cur->next;\\n            if (ptr & 1) {\\n                result = cur;\\n                break;\\n            }\\n        }\\n        \\n        for (ListNode *cur = headA; cur; cur = cur->next) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            *ptr &= (~0ULL << 1);\\n        }\\n    \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093063,
                "title": "c-flipping-vs-tortoise-hare-solutions-compared-100-time-90-space",
                "content": "My first approach for this problem was relatively straightforward: we pass the first list completely flipping the values (guaranteed to be `> 0`: again - reading each single line of the specs is the key to win!) to be negative.\\n\\nWe then run through `headB` and stop at the first negative value; finally, to leave the first list as it was before, we flip all of its elements again and we are done :)\\n\\nTo do so we need only one extra variable: `originalHeadA` that will store, as its name implies, the initial value of `headA`.\\n\\nWe will then trivially do the flipping with a loop that will run as long as `headA != NULL`.\\n\\nIn the second loop, structured with a similar logic (it will run as long as `headB != NULL`), we do nothing but advancing the pointer, provided its value is not negative, in which case we `break` out of the loop. Notice that if we reach the end of the line without a match, that is still good for us, since we `headB` will be `NULL`, which is precisely what we are supposed to return in case of no matches.\\n\\nOne last loop specular to the first one, just after we reset `headA` to its original value and we can then finally return `headB` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA;\\n        // flipping headA\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        // parsing headB\\n        while (headB) {\\n            if (headB->val < 0) {\\n                break;\\n            }\\n            headB = headB->next;\\n        }\\n        // flipping headA back to the original values\\n        headA = originalHeadA;\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\nThe second approach I wanted to try was a [tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection)-like one; I am fully aware that the traditional one has 2 pointers proceeding at different speeds, typically to find cycles, but I guess it is not too much of a stretch to call my solution a derivative of it.\\n\\nTo do so, we declare both `originalHeadA` and `originalHeadB` to store the initial values and then proceed with a single loop that goes on as long as `headA` and `headB` are not both `NULL` in which we will:\\n* first of all, check if there is a match, in which case we return one of the pointers;\\n* check if we need to reset `headA` to its initial value or just advance it;\\n* check if we need to reset `headB` to its initial value or just advance it.\\n\\nIf out of the loop, we still return `headB` as above, fully knowing it is `NULL`.\\n\\nThe code, which takes a very long time, about 10-12X the previous solution (as you might guess: think of 2 lists with lengths that are coprime of each other, so you will have to run the loop the product of their lengths time):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\nCan we do better?\\n\\nWell, turn out that a smarter way to reset the pointers is to swap the values, so that if you have one which is significantly longer than the other, you will not be bound by that.\\n\\nI know, it is not super-intuitive, but if you try to run it with a few `cout`s or just on pen and paper, it should make more sense.\\n\\nYou might see for example how running it on 2 lists `[1,2,3,4,5]` and `[7,6,5]` converging at `5` is more expensive with the previous version of the code, since it keeps repeating the loop longer restarting the longer lists.\\n\\nThe updated code, which runs now at a speed comparable with the first solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadB;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadA;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA;\\n        // flipping headA\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        // parsing headB\\n        while (headB) {\\n            if (headB->val < 0) {\\n                break;\\n            }\\n            headB = headB->next;\\n        }\\n        // flipping headA back to the original values\\n        headA = originalHeadA;\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadB;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadA;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532898,
                "title": "c-tricky-solution",
                "content": "**C :**\\n\\n```\\nvoid changeSign(struct ListNode *head)\\n{\\n    while (head)\\n    {\\n        head -> val *= -1;\\n        head = head -> next;\\n    }\\n}\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign(headA);\\n    \\n    while(headB)\\n    {\\n        if(headB -> val < 0) break;\\n        headB = headB -> next;\\n    }\\n    \\n    changeSign(headA);\\n    return headB;\\n    \\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid changeSign(struct ListNode *head)\\n{\\n    while (head)\\n    {\\n        head -> val *= -1;\\n        head = head -> next;\\n    }\\n}\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign(headA);\\n    \\n    while(headB)\\n    {\\n        if(headB -> val < 0) break;\\n        headB = headB -> next;\\n    }\\n    \\n    changeSign(headA);\\n    return headB;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093183,
                "title": "c-magic-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    void changeSign(ListNode *head){\\n        while ( head )\\n        {\\n            head->val *= -1;\\n            head = head->next;\\n        }\\n    }\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        changeSign( headA );\\n        \\n        while ( headB )\\n        {\\n            if ( headB->val < 0 ) break;\\n            headB = headB->next;\\n        }\\n        \\n        changeSign( headA );\\n        return headB;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    void changeSign(ListNode *head){\\n        while ( head )\\n        {\\n            head->val *= -1;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49817,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\\n        if headA == nil || headB == nil {\\n            return nil\\n        }\\n        \\n        var a: ListNode? = headA\\n        var b: ListNode? = headB\\n        \\n        while a !== b {\\n            a = a == nil ? headB : a?.next\\n            b = b == nil ? headA : b?.next\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\\n        if headA == nil || headB == nil {\\n            return nil\\n        }\\n        \\n        var a: ListNode? = headA\\n        var b: ListNode? = headB\\n        \\n        while a !== b {\\n            a = a == nil ? headB : a?.next\\n            b = b == nil ? headA : b?.next\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49907,
                "title": "clean-java-code-easy-to-understand-explanation-o-m-n-time-o-1-space",
                "content": "If we add list A to the end of B, and add B to the end of A, then if they have intersection, the intersection would  located at the end of the combined list, and plus! they have the same index. Awesome!\\nTo return the right ListNode, we cannot actually combine them, just \"next\" the end to another list. The first equal element is what we want to find.\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA==null || headB==null)retur**n** null;\\n        \\n        ListNode a=headA;\\n        ListNode b=headB;\\n        while(a!=b){\\n            a=a==null?headB:a.next;\\n            b=b==null?headA:b.next;\\n            \\n        }return b;\\n   \\n    }",
                "solutionTags": [],
                "code": "If we add list A to the end of B, and add B to the end of A, then if they have intersection, the intersection would  located at the end of the combined list, and plus! they have the same index. Awesome!\\nTo return the right ListNode, we cannot actually combine them, just \"next\" the end to another list. The first equal element is what we want to find.\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA==null || headB==null)retur**n** null;\\n        \\n        ListNode a=headA;\\n        ListNode b=headB;\\n        while(a!=b){\\n            a=a==null?headB:a.next;\\n            b=b==null?headA:b.next;\\n            \\n        }return b;\\n   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607859,
                "title": "c-four-approaches-brute-force-to-optimized-with-explanation",
                "content": "**Approach 1:**  (Brute force) \\nTraverse entire LL-1 for each node in LL-2 and keep checking for the intersection point.\\n\\nTime Complexity : O(n*m)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n```  \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *temp;\\n        while(headA)\\n        {\\n            temp = headB;\\n            while(temp)\\n            {\\n                if(headA==temp) return headA;\\n                temp=temp->next;\\n            }\\n            headA=headA->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Approach 2:** \\nUsing hash table to store the address of each node of LL-1. \\nThen traverse LL-2, whenever we find the node that already exists in the hashtable, that \\nwill be the intersection point.\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n\\n**CODE:**\\n          \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map <ListNode*, int> mp;\\n        while(headA)\\n        {\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB)\\n        {\\n            if(mp[headB]>0) return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**Approach 3:**  *(One of the Best Approach)*\\n                Traverse LL1 and LL2 and find the length of both the LLs. \\n                find the diffrence b/w their lengths and then move the longer LL by that difference.\\n                This will make them both to cover the extra distance between them. \\n                Now move both pointers together(at the start of LL1 & one at x distance from start of LL2)\\n                Keep checking if they meet at any point. \\n                Even if they wont intersect, their value will become same when they reach null.\\n                So, if they\\'re not intersecting, null will be returned.\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n                \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int length1=0, length2=0;\\n        ListNode *h1 = headA, *h2 = headB;\\n        while(headA){\\n            length1++;\\n            headA=headA->next;  //length of LL-1\\n        }\\n        while(headB){\\n            length2++;\\n            headB=headB->next; //length of LL-2\\n        }\\n        \\n        int difference = abs(length1 - length2); //difference\\n       \\n        if(length1 > length2) {\\n            while(difference--) // moving the longerLL by the difference\\n                h1= h1->next;\\n        }\\n        else {\\n            while(difference--)\\n                h2 = h2->next;\\n        }\\n        \\n        while(h1 && h2)\\n        {\\n            if(h1==h2)\\n                return h1;  // return when address become same\\n            h1= h1->next;\\n            h2= h2->next;\\n        }\\n        return nullptr; //NULL is returned when intersection isn\\'t present.\\n        \\n    }\\n};\\n```\\n                \\n\\n**Approach 4**: (Best Approach --> Preferred one bcz of shorter code)\\n                Traverse LL-1 and LL-2 together, the one that reaches the end first, \\n                put it on the head of the other LL. (for example, LL-1 reaches null, then make ptr\\n                to point at the head of LL-2) Keep doing this until the address doessn\\'t become same.\\n                i.e, until we doesnt find the intersection point. We\\'re doing this to cover up\\n                the difference b/w LL-1 and LL-2.\\n                So, what if intersection point isnt there?? Will this method work?\\n                Yes, It will. Because if the intersection point isnt there, they both will store\\n                same address of NULL and that will be returned.\\n\\t\\t\\t\\t\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL) return NULL;\\n        ListNode *h1 = headA, *h2 = headB;\\n       \\n        while(h1 != h2) \\n        {\\n            if(h1==nullptr) h1= headB;\\n            else h1=h1->next;\\n            if(h2==nullptr) h2= headA;\\n            else h2= h2->next;\\n        }\\n        return h1;         \\n    }\\n};\\n```\\n\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```  \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *temp;\\n        while(headA)\\n        {\\n            temp = headB;\\n            while(temp)\\n            {\\n                if(headA==temp) return headA;\\n                temp=temp->next;\\n            }\\n            headA=headA->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map <ListNode*, int> mp;\\n        while(headA)\\n        {\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB)\\n        {\\n            if(mp[headB]>0) return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int length1=0, length2=0;\\n        ListNode *h1 = headA, *h2 = headB;\\n        while(headA){\\n            length1++;\\n            headA=headA->next;  //length of LL-1\\n        }\\n        while(headB){\\n            length2++;\\n            headB=headB->next; //length of LL-2\\n        }\\n        \\n        int difference = abs(length1 - length2); //difference\\n       \\n        if(length1 > length2) {\\n            while(difference--) // moving the longerLL by the difference\\n                h1= h1->next;\\n        }\\n        else {\\n            while(difference--)\\n                h2 = h2->next;\\n        }\\n        \\n        while(h1 && h2)\\n        {\\n            if(h1==h2)\\n                return h1;  // return when address become same\\n            h1= h1->next;\\n            h2= h2->next;\\n        }\\n        return nullptr; //NULL is returned when intersection isn\\'t present.\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL) return NULL;\\n        ListNode *h1 = headA, *h2 = headB;\\n       \\n        while(h1 != h2) \\n        {\\n            if(h1==nullptr) h1= headB;\\n            else h1=h1->next;\\n            if(h2==nullptr) h2= headA;\\n            else h2= h2->next;\\n        }\\n        return h1;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49920,
                "title": "ac-solution-code",
                "content": "**Procedure:**\\n1. When pointer X in shorter list reaches the end, pointer Y in the longer list will have len(longer) - len(shorter) left. Put pointer X to the head of the longer list, then when Y reaches its end, X already traveled len(longer)-len(shorter). Then put Y to the head of shorter list. \\n\\n2. Now X and Y have the same distance to the end:  \\n   1). If has intersection, intersection is the first node where X = Y\\n   2). If no intersection, termination case is X = Y = null, where they reach end together (as X, Y have the same distance to end)\\n\\n**Runtime complexity = O(m + n)** \\n\\nm = len(longer), n = len(shorter):\\n\\n    step 1: uses m time\\n    step 2: uses n time\\n.\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\tif (headA == null || headB == null) \\n    \\t\\treturn null;\\n    \\tListNode curA = headA, curB = headB;\\n    \\twhile (curA != curB) {\\n    \\t\\tcurA = (curA == null) ? headB : curA.next;\\n    \\t\\tcurB = (curB == null) ? headA : curB.next;\\t\\t\\t\\n    \\t}\\n    \\treturn curA;\\n    }",
                "solutionTags": [],
                "code": "**Procedure:**\\n1. When pointer X in shorter list reaches the end, pointer Y in the longer list will have len(longer) - len(shorter) left. Put pointer X to the head of the longer list, then when Y reaches its end, X already traveled len(longer)-len(shorter). Then put Y to the head of shorter list. \\n\\n2. Now X and Y have the same distance to the end:  \\n   1). If has intersection, intersection is the first node where X = Y\\n   2). If no intersection, termination case is X = Y = null, where they reach end together (as X, Y have the same distance to end)\\n\\n**Runtime complexity = O(m + n)** \\n\\nm = len(longer), n = len(shorter):\\n\\n    step 1: uses m time\\n    step 2: uses n time\\n.\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\tif (headA == null || headB == null) \\n    \\t\\treturn null;\\n    \\tListNode curA = headA, curB = headB;\\n    \\twhile (curA != curB) {\\n    \\t\\tcurA = (curA == null) ? headB : curA.next;\\n    \\t\\tcurB = (curB == null) ? headA : curB.next;\\t\\t\\t\\n    \\t}\\n    \\treturn curA;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49903,
                "title": "java-o-1-space-solution",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = 0, lenB = 0;\\n        ListNode currA = headA, currB = headB;\\n        while(currA != null) {\\n            lenA++;\\n            currA = currA.next;\\n        }\\n        while(currB != null) {\\n            lenB++;\\n            currB = currB.next;\\n        }\\n        currA = headA;\\n        currB = headB;\\n        if(lenA > lenB) {\\n            for(int i=0; i<lenA-lenB; i++)\\n                currA = currA.next;\\n        } else {\\n            for(int i=0; i<lenB-lenA; i++)\\n                currB = currB.next;\\n        }\\n        while(currA != currB) {\\n            currA = currA.next;\\n            currB = currB.next;\\n        }\\n        return currA;\\n    }\\n\\n**First get the two length for each list, then put them at the same starting line by moving the longer one forward. Then move them at the same time and check the first match.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = 0, lenB = 0;\\n        ListNode currA = headA, currB = headB;\\n        while(currA != null) {\\n            lenA++;\\n            currA = currA.next;\\n        }\\n        while(currB != null) {\\n            lenB++;\\n            currB = currB.next;\\n        }\\n        currA = headA;\\n        currB = headB;\\n        if(lenA > lenB) {\\n            for(int i=0; i<lenA-lenB; i++)\\n                currA = currA.next;\\n        } else {\\n            for(int i=0; i<lenB-lenA; i++)\\n                currB = currB.next;\\n        }\\n        while(currA != currB) {\\n            currA = currA.next;\\n            currB = currB.next;\\n        }\\n        return currA;\\n    }\\n\\n**First get the two length for each list, then put them at the same starting line by moving the longer one forward. Then move them at the same time and check the first match.**",
                "codeTag": "Unknown"
            },
            {
                "id": 324105,
                "title": "heavily-commented-javascript-o-n-in-o-1-space-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    // General idea: Switch tracks at the end, so you even out un-even linked lists\\n    // they will sync up at the intersection that way. Now you can straight up do a comparison\\n    // For example: \\n    // A will follow 4 - 1 - 8 - 4 - 5 - 5 - 0 - 1 - 8\\n    // B will follow 5 - 0 - 1 - 8 - 4 - 5 - 4 - 1 - 8\\n    \\n    // Now we need to account for the case where they don\\'t intersect, or our loop\\n    // would run forever. If after switching tracks, they both reach null at the same time\\n    // that\\'s when we know to stop\\n    \\n    // Basic leetcode input checks;\\n    if (!headA || !headB) {\\n        return null;\\n    }\\n    \\n    // current nodes\\n    let curA = headA;\\n    let curB = headB;\\n    \\n    // our end check. this works because we switch track to sync up\\n    while (curA !== curB) {\\n        \\n        if (curA.next) {\\n            // regular follow the path\\n            curA = curA.next;\\n        } else {\\n        \\n            if (!curB.next) {\\n                // if curB also reaches null next, we\\'ve ended up at the end without\\n                // any match found. break out of the loop and return null now.\\n                curA = null;\\n                curB = null;\\n                break;\\n            }\\n            // switch tracks to even out uneven length\\n            curA = headB;\\n        }\\n        \\n        if (curB.next) {\\n            // regular follow the path\\n            curB = curB.next \\n        } else {\\n            // switch tracks to even out uneven length\\n            curB = headA;\\n        }\\n    }\\n    \\n    return curB;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    // General idea: Switch tracks at the end, so you even out un-even linked lists\\n    // they will sync up at the intersection that way. Now you can straight up do a comparison\\n    // For example: \\n    // A will follow 4 - 1 - 8 - 4 - 5 - 5 - 0 - 1 - 8\\n    // B will follow 5 - 0 - 1 - 8 - 4 - 5 - 4 - 1 - 8\\n    \\n    // Now we need to account for the case where they don\\'t intersect, or our loop\\n    // would run forever. If after switching tracks, they both reach null at the same time\\n    // that\\'s when we know to stop\\n    \\n    // Basic leetcode input checks;\\n    if (!headA || !headB) {\\n        return null;\\n    }\\n    \\n    // current nodes\\n    let curA = headA;\\n    let curB = headB;\\n    \\n    // our end check. this works because we switch track to sync up\\n    while (curA !== curB) {\\n        \\n        if (curA.next) {\\n            // regular follow the path\\n            curA = curA.next;\\n        } else {\\n        \\n            if (!curB.next) {\\n                // if curB also reaches null next, we\\'ve ended up at the end without\\n                // any match found. break out of the loop and return null now.\\n                curA = null;\\n                curB = null;\\n                break;\\n            }\\n            // switch tracks to even out uneven length\\n            curA = headB;\\n        }\\n        \\n        if (curB.next) {\\n            // regular follow the path\\n            curB = curB.next \\n        } else {\\n            // switch tracks to even out uneven length\\n            curB = headA;\\n        }\\n    }\\n    \\n    return curB;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116312,
                "title": "c-easiest-way-o-1-space",
                "content": "The idea is to iterate through both the lists A + B and B + A simultaneously as shown below.\\nIf we look at the picture carefully, we notice that the last few red nodes will be the intersecting nodes, so we are guaranteed a solution this way.\\nIf the nodes are never intersecting, the iterations of both A+B and B+A end at the same time since they have the same length.\\n![image](https://assets.leetcode.com/users/images/8bd5413a-b2d6-446c-9c68-7222064bf44d_1654480549.0124373.png)\\n>  picture from @goAheadShaun\\'s [post](https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/2116221/Visual-Explanation-or-One-Pass-JAVA)\\n\\nHere\\'s the code :)\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // Initializing the two pointers\\n        ListNode *ptr1 = headA;\\n        ListNode *ptr2 = headB;\\n        \\n        while(ptr1 != ptr2){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n            \\n            // break the loop if they reach the end together or collide\\n            if(ptr1 == ptr2) break;\\n            \\n            // if the pointer reaches the end of A, go to B and vice versa for ptr2\\n            if(ptr1 == NULL) ptr1 = headB;\\n            if(ptr2 == NULL) ptr2 = headA;\\n \\n        }\\n        // return the collided pointer\\n        return ptr1;\\n    }\\n};\\n```\\nThis is my first time posting a solution so please upvote, thanks!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // Initializing the two pointers\\n        ListNode *ptr1 = headA;\\n        ListNode *ptr2 = headB;\\n        \\n        while(ptr1 != ptr2){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n            \\n            // break the loop if they reach the end together or collide\\n            if(ptr1 == ptr2) break;\\n            \\n            // if the pointer reaches the end of A, go to B and vice versa for ptr2\\n            if(ptr1 == NULL) ptr1 = headB;\\n            if(ptr2 == NULL) ptr2 = headA;\\n \\n        }\\n        // return the collided pointer\\n        return ptr1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092899,
                "title": "c-simple-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        \\n        while (a || b) {\\n            if (a == b) return a;\\n            \\n            if (a) a = a->next;\\n            else a = headB;\\n            \\n            if (b) b = b->next;\\n            else b = headA;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        \\n        while (a || b) {\\n            if (a == b) return a;\\n            \\n            if (a) a = a->next;\\n            else a = headB;\\n            \\n            if (b) b = b->next;\\n            else b = headA;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929431,
                "title": "3-solutions-easy-to-understand-faster-than-96-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        return self.withConstantSpaceAndLinearTime(headA, headB)\\n      \\n    def getLength(self, head):\\n        length = 0\\n        while head:\\n            head = head.next\\n            length += 1\\n        return length\\n    \\n    # Faster than 96.35% (Yay!!)\\n    def withConstantSpaceAndLinearTime(self, headA, headB):\\n        lenA = self.getLength(headA)\\n        lenB = self.getLength(headB)\\n        if lenB > lenA:\\n            headA, headB = headB, headA\\n            lenA, lenB = lenB, lenA\\n        \\n        \\n        diff = lenA - lenB\\n        while diff:\\n            headA = headA.next\\n            diff -= 1\\n        \\n        # print(headA.val, headB.val)\\n        \\n        while headA and headB and headA != headB:\\n            headA = headA.next\\n            headB = headB.next\\n        return headA\\n        \\n    # Faster than 81.92% (At that time ;)\\n    def usingSets(self, headA, headB):\\n        visited = set()\\n        while headA:\\n            visited.add(headA)\\n            headA = headA.next\\n        \\n        while headB:\\n            if headB in visited: return headB\\n            headB = headB.next\\n        return None\\n    \\n    # Gives us TLE\\n    def bruteForce(self, headA, headB):\\n        while headA:\\n            temp = headB\\n            while temp:\\n                if temp == headA: return headA\\n                temp = temp.next\\n            headA = headA.next\\n        return None\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        return self.withConstantSpaceAndLinearTime(headA, headB)\\n      \\n    def getLength(self, head):\\n        length = 0\\n        while head:\\n            head = head.next\\n            length += 1\\n        return length\\n    \\n    # Faster than 96.35% (Yay!!)\\n    def withConstantSpaceAndLinearTime(self, headA, headB):\\n        lenA = self.getLength(headA)\\n        lenB = self.getLength(headB)\\n        if lenB > lenA:\\n            headA, headB = headB, headA\\n            lenA, lenB = lenB, lenA\\n        \\n        \\n        diff = lenA - lenB\\n        while diff:\\n            headA = headA.next\\n            diff -= 1\\n        \\n        # print(headA.val, headB.val)\\n        \\n        while headA and headB and headA != headB:\\n            headA = headA.next\\n            headB = headB.next\\n        return headA\\n        \\n    # Faster than 81.92% (At that time ;)\\n    def usingSets(self, headA, headB):\\n        visited = set()\\n        while headA:\\n            visited.add(headA)\\n            headA = headA.next\\n        \\n        while headB:\\n            if headB in visited: return headB\\n            headB = headB.next\\n        return None\\n    \\n    # Gives us TLE\\n    def bruteForce(self, headA, headB):\\n        while headA:\\n            temp = headB\\n            while temp:\\n                if temp == headA: return headA\\n                temp = temp.next\\n            headA = headA.next\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49905,
                "title": "share-my-accepted-simple-and-short-c-code-with-the-help-of-the-topest-voted-one",
                "content": "    class Solution {\\n    public:\\n    \\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n    \\t\\tListNode *p1 = headA, *p2 = headB;\\n    \\t\\tif(p1 == NULL || p2 == NULL)\\n    \\t\\t\\treturn NULL;\\n    \\t\\twhile(p1 != p2)\\n    \\t\\t{\\n    \\t\\t\\tp1 = p1->next;\\n    \\t\\t\\tp2 = p2->next;\\n    \\t\\t\\tif(p1 == NULL && p2 != NULL)\\n    \\t\\t\\t\\tp1 = headB;\\n    \\t\\t\\tif(p2 == NULL && p1 != NULL)\\n    \\t\\t\\t\\tp2 = headA;\\n    \\t\\t}\\n    \\t\\treturn p1;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n    \\t\\tListNode *p1 = headA, *p2 = headB;\\n    \\t\\tif(p1 == NULL || p2 == NULL)\\n    \\t\\t\\treturn NULL;\\n    \\t\\twhile(p1 != p2)\\n    \\t\\t{\\n    \\t\\t\\tp1 = p1->next;\\n    \\t\\t\\tp2 = p2->next;\\n    \\t\\t\\tif(p1 == NULL && p2 != NULL)\\n    \\t\\t\\t\\tp1 = headB;\\n    \\t\\t\\tif(p2 == NULL && p1 != NULL)\\n    \\t\\t\\t\\tp2 = headA;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 49954,
                "title": "my-52ms-c-solve",
                "content": "    class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pA = headA;\\n        ListNode *pB = headB;\\n        int lenA = 0;\\n        int lenB = 0;\\n        while (pA) {++lenA;  pA = pA->next; }\\n        while (pB) {++lenB;  pB = pB->next; }\\n        for (int diff = abs(lenA - lenB); diff > 0; --diff) {\\n            if (lenA > lenB) {\\n                headA = headA->next;\\n            }\\n            else {\\n                headB = headB->next;\\n            }\\n        }\\n        while (headA && headB) {\\n            if (headA == headB) {\\n                return headA;\\n            }\\n            headA = headA ->next;\\n            headB = headB ->next;\\n        }\\n        return NULL;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pA = headA;\\n        ListNode *pB = headB;\\n        int lenA = 0;\\n        int lenB = 0;\\n        while (pA) {++lenA;  pA = pA->next; }",
                "codeTag": "Java"
            },
            {
                "id": 49917,
                "title": "o-n-time-o-1-space-solution-differ-from-the-official-one",
                "content": "    // get the len of a linked list\\n    int getLen(ListNode *head) {\\n        int len = 0;\\n        while(head) { len++; head = head->next; } \\n        return len;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA || !headB) return NULL;\\n        ListNode *p1 = headA, *p2 = headB;\\n        int lenA = getLen(headA), lenB = getLen(headB);\\n        \\n        if (lenA <= lenB) {\\n            for (int i = 0; i < lenB - lenA; ++i)\\n                p2 = p2->next;\\n        }\\n        else {\\n            for (int i=0; i < lenA - lenB; ++i)\\n                p1 = p1->next;\\n        }\\n        \\n        while (p1 && p2 && p1 != p2) p1 = p1->next, p2 = p2->next;\\n        if (!p1 || !p2) return NULL;\\n        return p1;\\n    }",
                "solutionTags": [],
                "code": "    // get the len of a linked list\\n    int getLen(ListNode *head) {\\n        int len = 0;\\n        while(head) { len++; head = head->next; } \\n        return len;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA || !headB) return NULL;\\n        ListNode *p1 = headA, *p2 = headB;\\n        int lenA = getLen(headA), lenB = getLen(headB);\\n        \\n        if (lenA <= lenB) {\\n            for (int i = 0; i < lenB - lenA; ++i)\\n                p2 = p2->next;\\n        }\\n        else {\\n            for (int i=0; i < lenA - lenB; ++i)\\n                p1 = p1->next;\\n        }\\n        \\n        while (p1 && p2 && p1 != p2) p1 = p1->next, p2 = p2->next;\\n        if (!p1 || !p2) return NULL;\\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2561582,
                "title": "python-91-66-faster-simplest-solution-with-explanation-beg-to-adv-linked-list",
                "content": "***Found helpful , Do upvote !!***\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        l1, l2 = headA, headB# First we are taking two pointers\\n        while l1!=l2:  # if heads are equal this implies that we found our intersection node and then we`ll return it.\\n            if l1: # if list1 is there then go ahead.\\n                l1=l1.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l1 = headB # if we reach to the end of the list1 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l1=l1.next if l1 else headB \\n            if l2:  # if list2 is there then go ahead.\\n                l2=l2.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l2 = headA # if we reach to the end of the list2 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l2=l2.next if l2 else headA\\n        return l1 # returning the pointer, we could return l2 also as we found our intersection else null.\\n```\\n**Approch of this solution is:**\\nFirstly we`ll traverse through both the list provided to find the intersection.\\nIf we didnt find the intersection. Then we move the pointers to the other list head.\\n\\n**WHY:-** by moving the pointor to the next list head, we`ll be able to eradiacte the lenght diff of both the lists,\\n\\n**In 2nd round of iteration:**\\nNow once we reach to the end of the list one, will start traversing through the next list.\\nIn doing that we will be able to eradicate the lenght diff between both lists.\\nIn this iteration l1 will go to head of list 2 and l2 will reach to the head of list 1 and then both the pointer will be in sync.\\n![image](https://assets.leetcode.com/users/images/4573ba45-8ed6-4fe1-ab89-f2ecbc99cd9f_1662887938.631127.png)\\n\\nNow we keep traversing till the time we get to the itersecting element & if there wont be any willreturn null.\\n#####  Why it didnt go infinitely:\\nBcz, both list hit null eventually and while loop will be true in that case and return null as we didnt find intersection in our traversal..\\n**Watch this video for better understanding :-** https://www.youtube.com/watch?v=D0X0BONOQhI&ab_channel=NeetCode\\n\\n***Found helpful , Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/bba69cb9-e8bf-4906-bc0c-1963853b2ab8_1662888449.4709215.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        l1, l2 = headA, headB# First we are taking two pointers\\n        while l1!=l2:  # if heads are equal this implies that we found our intersection node and then we`ll return it.\\n            if l1: # if list1 is there then go ahead.\\n                l1=l1.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l1 = headB # if we reach to the end of the list1 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l1=l1.next if l1 else headB \\n            if l2:  # if list2 is there then go ahead.\\n                l2=l2.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l2 = headA # if we reach to the end of the list2 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l2=l2.next if l2 else headA\\n        return l1 # returning the pointer, we could return l2 also as we found our intersection else null.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715399,
                "title": "python-3-both-o-n-m-and-o-1-memory-approach",
                "content": "### Approach 1- O(N+M) Time| O(N) Space\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\thashmap={}\\n        while headA:\\n            hashmap[headA]=1\\n            headA=headA.next\\n        while headB and headB not in hashmap:\\n            headB=headB.next\\n        return headB\\n```\\n### Approach 2- O(N+M) Time| O(1) Space\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\t  \\n        n,m=0,0\\n        tempA,tempB=headA,headB\\n        while tempA:\\n            n+=1\\n            tempA=tempA.next\\n        while tempB:\\n            m+=1\\n            tempB=tempB.next\\n        while m>n:\\n            headB=headB.next\\n            m-=1\\n        while n>m:\\n            headA=headA.next\\n            n-=1\\n        while headB!=headA:\\n            headB=headB.next\\n            headA=headA.next\\n        return headA\\n```\\nPS- Damn thats a lot of while loops XD\\nDo give a upvote if you feel this happens with you at times too",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\thashmap={}\\n        while headA:\\n            hashmap[headA]=1\\n            headA=headA.next\\n        while headB and headB not in hashmap:\\n            headB=headB.next\\n        return headB\\n```\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\t  \\n        n,m=0,0\\n        tempA,tempB=headA,headB\\n        while tempA:\\n            n+=1\\n            tempA=tempA.next\\n        while tempB:\\n            m+=1\\n            tempB=tempB.next\\n        while m>n:\\n            headB=headB.next\\n            m-=1\\n        while n>m:\\n            headA=headA.next\\n            n-=1\\n        while headB!=headA:\\n            headB=headB.next\\n            headA=headA.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523250,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null)  return null;\\n        ListNode A = headA, B = headB;\\n        while(A != B){\\n            A = (A == null) ? headB : A.next;\\n            B = (B == null) ? headA : B.next;\\n        }\\n        return A;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)    return null\\n    let A = headA, B = headB\\n    while(A != B){\\n        A = (A)? A.next : headB\\n        B = (B)? B.next : headA\\n    }\\n    return A\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:\\n            return null\\n        A, B = headA, headB\\n        while A != B:\\n            A = A.next if A else headB\\n            B = B.next if B else headA\\n        return A\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null)  return null;\\n        ListNode A = headA, B = headB;\\n        while(A != B){\\n            A = (A == null) ? headB : A.next;\\n            B = (B == null) ? headA : B.next;\\n        }\\n        return A;\\n    }\\n}\\n```\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)    return null\\n    let A = headA, B = headB\\n    while(A != B){\\n        A = (A)? A.next : headB\\n        B = (B)? B.next : headA\\n    }\\n    return A\\n};\\n```\n```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:\\n            return null\\n        A, B = headA, headB\\n        while A != B:\\n            A = A.next if A else headB\\n            B = B.next if B else headA\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408282,
                "title": "python-easy-illustrated-and-commented-solution-87",
                "content": "## Once either of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        curr1, curr2 = headA,headB\\n        \\n        while curr1 or curr2: # once any of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n            if curr1: curr1 = curr1.next\\n            else: headB = headB.next\\n            if curr2: curr2 = curr2.next\\n            else: headA = headA.next\\n        \\n        while headA is not headB: # find the intersection point when it becomes equal\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        return headA\\n```\\n\\norange solid arrow => final position of curr1 (pointer of headB)\\norange doted arrow => headB\\nsimilary for blue arrow\\ngreen arrow shows shifed poistions of head A and head B\\n![image](https://assets.leetcode.com/users/images/aa7b1fbf-3037-4b44-ab1a-957633c7aae3_1629176286.9457114.png)\\nPlease like if you find it helpful\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        curr1, curr2 = headA,headB\\n        \\n        while curr1 or curr2: # once any of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n            if curr1: curr1 = curr1.next\\n            else: headB = headB.next\\n            if curr2: curr2 = curr2.next\\n            else: headA = headA.next\\n        \\n        while headA is not headB: # find the intersection point when it becomes equal\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105629,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the *intersection of the Two Linked List*. It means that we have to find the **first common node** of the two given lists.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    1. Find the lengths of the two given lists.\\n    2. Make the list equal by removing some elements.\\n    3. Step 2 is done by updating the head pointer.\\n    4. Traverse the list and check for the common node.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFollow the code below to understand the solution.\\n\\n             **If this solution helped you, give it an up-vote to help others** \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n        \\n        int sizeA = 0;      //stores size of listA.\\n        int sizeB = 0;      //stores size of listA.\\n\\n        //declare temp pointer initially. (saves space)\\n        ListNode temp;\\n\\n        //traverse listA and store its size in sizeA variable.\\n        for(temp = headA; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeA++;            \\n        }\\n        \\n        //traverse listB and store its size in sizeB variable.\\n        for(temp = headB; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeB++;         \\n        }\\n\\n        //Now make the two lists equal by removing nodes of\\n        //the greater list.\\n\\n        //if size of listA is greater than size of listB.\\n        while(sizeA > sizeB)\\n        {\\n            //go to next node of the listA.\\n            headA = headA.next;\\n            sizeA--;\\n        }\\n\\n        //similarly, do it if sizeB > sizeA\\n        while(sizeB > sizeA)\\n        {\\n            headB = headB.next;\\n            sizeB--;\\n        }\\n\\n        //check the nodes untill the node becomes equal.\\n        while(headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        //finally, return either of the two nodes.\\n        //if there is no intersection, then headA and headB\\n        //will point to null.\\n        return headA;       //return headB;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n        \\n        int sizeA = 0;      //stores size of listA.\\n        int sizeB = 0;      //stores size of listA.\\n\\n        //declare temp pointer initially. (saves space)\\n        ListNode temp;\\n\\n        //traverse listA and store its size in sizeA variable.\\n        for(temp = headA; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeA++;            \\n        }\\n        \\n        //traverse listB and store its size in sizeB variable.\\n        for(temp = headB; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeB++;         \\n        }\\n\\n        //Now make the two lists equal by removing nodes of\\n        //the greater list.\\n\\n        //if size of listA is greater than size of listB.\\n        while(sizeA > sizeB)\\n        {\\n            //go to next node of the listA.\\n            headA = headA.next;\\n            sizeA--;\\n        }\\n\\n        //similarly, do it if sizeB > sizeA\\n        while(sizeB > sizeA)\\n        {\\n            headB = headB.next;\\n            sizeB--;\\n        }\\n\\n        //check the nodes untill the node becomes equal.\\n        while(headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        //finally, return either of the two nodes.\\n        //if there is no intersection, then headA and headB\\n        //will point to null.\\n        return headA;       //return headB;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155040,
                "title": "c-3-solutions",
                "content": "**Brute Force**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* pa = headA;\\n        while (pa) {\\n            for (ListNode* pb = headB; pb; pb = pb -> next) {\\n                if (pa == pb) {\\n                    return pa;\\n                }\\n            }\\n            pa = pa -> next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**Hash Table**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*> nodes;\\n        while (headA) {\\n            nodes.insert(headA);\\n            headA = headA -> next;\\n        }\\n        while (headB && nodes.find(headB) == nodes.end()) {\\n            headB = headB -> next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\n**Two Pointers**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pa = headA, *pb = headB;\\n        while (pa != pb) {\\n            pa = pa ? pa -> next : headB;\\n            pb = pb ? pb -> next : headA;\\n        }\\n        return pa;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* pa = headA;\\n        while (pa) {\\n            for (ListNode* pb = headB; pb; pb = pb -> next) {\\n                if (pa == pb) {\\n                    return pa;\\n                }\\n            }\\n            pa = pa -> next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*> nodes;\\n        while (headA) {\\n            nodes.insert(headA);\\n            headA = headA -> next;\\n        }\\n        while (headB && nodes.find(headB) == nodes.end()) {\\n            headB = headB -> next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pa = headA, *pb = headB;\\n        while (pa != pb) {\\n            pa = pa ? pa -> next : headB;\\n            pb = pb ? pb -> next : headA;\\n        }\\n        return pa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49952,
                "title": "clean-9-lines-c-solution-32ms-and-o-1-space",
                "content": "    #define NEXT(x) (x=x->next)\\n    typedef struct ListNode ln;\\n    \\n    ln* getIntersectionNode(ln *headA, ln *headB)\\n    {\\n      /* if(!headA || !headB) return NULL; */\\n      \\n      /* first get the lengths of the two lists */\\n      int lenA = 0, lenB =0;\\n      for(ln* pA = headA; pA; NEXT(pA)) lenA++;\\n      for(ln* pB = headB; pB; NEXT(pB)) lenB++;\\n    \\n      /* move the longer one forward to match two lists at the start-line */\\n      for(int i = 0; i<(lenA-lenB); i++) NEXT(headA);\\n      for(int i = 0; i<(lenB-lenA); i++) NEXT(headB);\\n    \\n      /* move simultaneously and check the first meeting point */\\n      while(headA!=headB)\\n      {\\n        NEXT(headA);\\n        NEXT(headB);\\n      }\\n    \\n      return headA; /* NULL or the intersection */\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "    #define NEXT(x) (x=x->next)\\n    typedef struct ListNode ln;\\n    \\n    ln* getIntersectionNode(ln *headA, ln *headB)\\n    {\\n      /* if(!headA || !headB) return NULL; */\\n      \\n      /* first get the lengths of the two lists */\\n      int lenA = 0, lenB =0;\\n      for(ln* pA = headA; pA; NEXT(pA)) lenA++;\\n      for(ln* pB = headB; pB; NEXT(pB)) lenB++;\\n    \\n      /* move the longer one forward to match two lists at the start-line */\\n      for(int i = 0; i<(lenA-lenB); i++) NEXT(headA);\\n      for(int i = 0; i<(lenB-lenA); i++) NEXT(headB);\\n    \\n      /* move simultaneously and check the first meeting point */\\n      while(headA!=headB)\\n      {\\n        NEXT(headA);\\n        NEXT(headB);\\n      }\\n    \\n      return headA; /* NULL or the intersection */\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2509113,
                "title": "javascript-code-simple-tc-o-n-m-sc-1-very-easy-explanation-with-images",
                "content": "**// Hi Devs if you like my post and it helps you please do vote so that it reaches more Devs**\\n\\n// in this approach we are taking two pointers and traverse both lists ,\\n// if either of pointer reaches end it start traversing another list  \\n// if  both pointer points at same node we got intersection;\\n// if both pointers points at Null means we dont get intersection \\n\\n\\n// PLEASE REFER IMAGE \\n![image](https://assets.leetcode.com/users/images/a06df456-9052-4d89-9060-e8bf52e8d14b_1661946650.5888896.png)\\n![image](https://assets.leetcode.com/users/images/511d08b0-65c4-45eb-bb4f-d5145765bfce_1661947414.5147152.png)\\n\\n\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    let p = headA;\\n    let q = headB;\\n    \\n    while(p!=q && ( p.next || q.next)){\\n        if(p.next == null) p = headB;\\n        else   p=p.next;\\n        if(q.next == null) q= headA;\\n        else q=q.next;\\n      \\n        \\n    }\\n    // console.log(q.val)\\n    if(p==q) return p;\\n   \\n};****\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    let p = headA;\\n    let q = headB;\\n    \\n    while(p!=q && ( p.next || q.next)){\\n        if(p.next == null) p = headB;\\n        else   p=p.next;\\n        if(q.next == null) q= headA;\\n        else q=q.next;\\n      \\n        \\n    }\\n    // console.log(q.val)\\n    if(p==q) return p;\\n   \\n};****\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297063,
                "title": "python-5-line-solution-with-comments-and-visualization",
                "content": "**Approach:**\\n\\n* Take two dummy nodes for each list. Point each to the head of the lists.\\n* Iterate over them. If anyone becomes null, point them to the head of the opposite lists and continue iterating until they collide.\\n\\n**Time Complexity:** O(max(n,m))\\n**Space Complexity:** O(1)\\n\\n**Visualization** -\\n![image](https://assets.leetcode.com/users/images/c082a238-c1d2-4a31-bf04-39ef5ef4ec17_1658093780.5060673.gif)\\n\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        dummyA, dummyB = headA, headB # Take dummy nodes\\n\\n        while dummyA != dummyB:\\n            dummyA = headB if dummyA is None else dummyA.next \\n            dummyB = headA if dummyB is None else dummyB.next\\n        # Return any dummy pointer. i.e. If any intersection node is present it\\'ll get returned else it will return None because at the end of iteration both dummy pointers will point to NULL.\\n        return dummyA \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        dummyA, dummyB = headA, headB # Take dummy nodes\\n\\n        while dummyA != dummyB:\\n            dummyA = headB if dummyA is None else dummyA.next \\n            dummyB = headA if dummyB is None else dummyB.next\\n        # Return any dummy pointer. i.e. If any intersection node is present it\\'ll get returned else it will return None because at the end of iteration both dummy pointers will point to NULL.\\n        return dummyA \\n```",
                "codeTag": "Java"
            },
            {
                "id": 638775,
                "title": "java-3-approaches-two-loops-hashset-and-two-pointers",
                "content": "Approach 1: Naive (using two loops)\\n``` \\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b;\\n        while(a!=null){\\n            b = headB;\\n            while(b!=null){\\n              if(a == b) return a;\\n              b = b.next;\\n            }\\n            a = a.next;\\n        }\\n        return null;\\n    }\\n}\\n```\\nApproach 2:  Using HashSet \\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b=headB;\\n       Set<ListNode> seen  = new HashSet<>();\\n       while(a!=null){\\n           seen.add(a);\\n           a=a.next;\\n       }\\n    \\n       while(b!=null){\\n           if(!seen.add(b)) return b;\\n           b=b.next;\\n       }\\n       return null;\\n    }\\n}\\n```\\n\\nApproach 3: Using Two pointers\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a=headA, b=headB;\\n        while(a!=b){\\n            if(a==null) a=headB;\\n            else  a=a.next;\\n            if(b==null) b=headA;\\n            else b=b.next;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b;\\n        while(a!=null){\\n            b = headB;\\n            while(b!=null){\\n              if(a == b) return a;\\n              b = b.next;\\n            }\\n            a = a.next;\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b=headB;\\n       Set<ListNode> seen  = new HashSet<>();\\n       while(a!=null){\\n           seen.add(a);\\n           a=a.next;\\n       }\\n    \\n       while(b!=null){\\n           if(!seen.add(b)) return b;\\n           b=b.next;\\n       }\\n       return null;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a=headA, b=headB;\\n        while(a!=b){\\n            if(a==null) a=headB;\\n            else  a=a.next;\\n            if(b==null) b=headA;\\n            else b=b.next;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49967,
                "title": "sharing-my-fast-and-easy-to-understand-accepted-java-solution",
                "content": "```\\npublic class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            \\n            if (headA == null || headB == null)\\n                return null;\\n            \\n            int countA = 0;\\n            ListNode pa = headA;\\n            while (pa != null){\\n                pa = pa.next;\\n                countA++;\\n            }\\n            \\n            int countB = 0;\\n            ListNode pb = headB;\\n            while (pb != null){\\n                pb = pb.next;\\n                countB++;\\n            }\\n            \\n            pa = headA;\\n            pb = headB;\\n            \\n            if (countA > countB){\\n                for (int i=0; i<countA-countB; i++){\\n                    pa = pa.next;\\n                }    \\n            } else if (countB > countA){\\n                for (int i=0; i<countB-countA; i++){\\n                    pb = pb.next;\\n                }    \\n            }\\n            \\n            while (pa != pb && pa != null){\\n                pa = pa.next;\\n                pb = pb.next;\\n            }\\n            \\n            return pa;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            \\n            if (headA == null || headB == null)\\n                return null;\\n            \\n            int countA = 0;\\n            ListNode pa = headA;\\n            while (pa != null){\\n                pa = pa.next;\\n                countA++;\\n            }\\n            \\n            int countB = 0;\\n            ListNode pb = headB;\\n            while (pb != null){\\n                pb = pb.next;\\n                countB++;\\n            }\\n            \\n            pa = headA;\\n            pb = headB;\\n            \\n            if (countA > countB){\\n                for (int i=0; i<countA-countB; i++){\\n                    pa = pa.next;\\n                }    \\n            } else if (countB > countA){\\n                for (int i=0; i<countB-countA; i++){\\n                    pb = pb.next;\\n                }    \\n            }\\n            \\n            while (pa != pb && pa != null){\\n                pa = pa.next;\\n                pb = pb.next;\\n            }\\n            \\n            return pa;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208755,
                "title": "160-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Traverse both linked lists to find their lengths, and the difference in lengths diff.\\n2. Move the pointer of the longer linked list diff steps ahead, so that both linked lists have the same number of nodes remaining to traverse.\\n3. Traverse both linked lists in parallel until the pointers meet at the intersection node (or null if there is no intersection).\\n\\nThis solution has a time complexity of O(m + n), where m and n are the lengths of the two linked lists, and a space complexity of O(1), since we are only using a constant amount of additional memory.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        # Find lengths of linked lists\\n        lenA, lenB = 0, 0\\n        nodeA, nodeB = headA, headB\\n        while nodeA:\\n            lenA += 1\\n            nodeA = nodeA.next\\n        while nodeB:\\n            lenB += 1\\n            nodeB = nodeB.next\\n        \\n        # Calculate difference in lengths\\n        diff = abs(lenA - lenB)\\n        if lenA > lenB:\\n            # Move pointer of A ahead\\n            while diff > 0:\\n                headA = headA.next\\n                diff -= 1\\n        else:\\n            # Move pointer of B ahead\\n            while diff > 0:\\n                headB = headB.next\\n                diff -= 1\\n        \\n        # Traverse both linked lists in parallel\\n        while headA and headB:\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        # No intersection found\\n        return None\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        # Find lengths of linked lists\\n        lenA, lenB = 0, 0\\n        nodeA, nodeB = headA, headB\\n        while nodeA:\\n            lenA += 1\\n            nodeA = nodeA.next\\n        while nodeB:\\n            lenB += 1\\n            nodeB = nodeB.next\\n        \\n        # Calculate difference in lengths\\n        diff = abs(lenA - lenB)\\n        if lenA > lenB:\\n            # Move pointer of A ahead\\n            while diff > 0:\\n                headA = headA.next\\n                diff -= 1\\n        else:\\n            # Move pointer of B ahead\\n            while diff > 0:\\n                headB = headB.next\\n                diff -= 1\\n        \\n        # Traverse both linked lists in parallel\\n        while headA and headB:\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        # No intersection found\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116478,
                "title": "c-easy-solution-w-multiple-approaches",
                "content": "**Please upvote If you like the post :)**\\n\\nSo, basically we are given the heads of two singly linked-lists `headA` and `headB`, return the `node` at which the two lists `intersect`. If the two linked lists have no intersection at all, return `null`.\\n             \\n\\n**Intuitive/Brute Force Approach :**\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tListNode *temp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\ttemp = headB;\\n\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t}\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m*n)`\\n**Space Complexity :**` O(1)`\\n\\n****\\n**HashMap Approach :** **(Somewhat linear)**\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tunordered_map<ListNode*, int> mp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\tmp[headA]++;\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\twhile(headB != NULL){\\n\\t\\t\\tif(mp[headB] > 0){\\n\\t\\t\\t\\treturn headB;\\n\\t\\t\\t}\\n\\t\\t\\theadB = headB -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m+n)`\\n**Space Complexity :**` O(m)`\\n\\n****\\n**Two Pointers Approach :** **(Space Optimized)**\\n\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *a, ListNode *b) {\\n\\t\\tListNode *ptr1 = headA;\\n\\t\\tListNode *ptr2 = headB;\\n\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ptr1;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m+n)`\\n**Space Complexity :**` O(1)`\\n\\n****\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tListNode *temp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\ttemp = headB;\\n\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t}\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tunordered_map<ListNode*, int> mp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\tmp[headA]++;\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\twhile(headB != NULL){\\n\\t\\t\\tif(mp[headB] > 0){\\n\\t\\t\\t\\treturn headB;\\n\\t\\t\\t}\\n\\t\\t\\theadB = headB -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *a, ListNode *b) {\\n\\t\\tListNode *ptr1 = headA;\\n\\t\\tListNode *ptr2 = headB;\\n\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ptr1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855370,
                "title": "c-2-approaches-solution",
                "content": "**upvote if it helps**\\n\\t\\n**approch 1**\\n\\n\\n         ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n\\t\\n**approch 2**\\n\\t\\n\\tListNode*la = headA;// pointing the refrence pointer ;\\n        ListNode*lb = headB;\\n        \\n        // base case if one the list is empty\\n        if(!la || !lb) return NULL;\\n        int n = 0 , m = 0;\\n        while(la != NULL){  // counting the lenght of List 1;\\n            la = la->next;\\n            n++;\\n        }\\n        while(lb != NULL){ // counting the lenght of List 2;\\n            lb = lb->next;\\n            m++;\\n        }\\n        int t = abs(n-m);\\n        la = headA; lb = headB;\\n        if(m>n){ \\n            while(t) lb = lb->next; t--;\\n        }\\n        else { \\n            while(t) la = la->next; t--;\\n        }\\n        while(la!=lb){\\n            la = la->next;\\n            lb = lb->next;\\n        }\\n        return la;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "**upvote if it helps**\\n\\t\\n**approch 1**\\n\\n\\n         ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n\\t\\n**approch 2**\\n\\t\\n\\tListNode*la = headA;// pointing the refrence pointer ;\\n        ListNode*lb = headB;\\n        \\n        // base case if one the list is empty\\n        if(!la || !lb) return NULL;\\n        int n = 0 , m = 0;\\n        while(la != NULL){  // counting the lenght of List 1;\\n            la = la->next;\\n            n++;\\n        }\\n        while(lb != NULL){ // counting the lenght of List 2;\\n            lb = lb->next;\\n            m++;\\n        }\\n        int t = abs(n-m);\\n        la = headA; lb = headB;\\n        if(m>n){ \\n            while(t) lb = lb->next; t--;\\n        }\\n        else { \\n            while(t) la = la->next; t--;\\n        }\\n        while(la!=lb){\\n            la = la->next;\\n            lb = lb->next;\\n        }\\n        return la;",
                "codeTag": "Unknown"
            },
            {
                "id": 1393971,
                "title": "best-6-lines-solutions-specially-for-beginners-detailed-explanation-of-approach",
                "content": "first I find the length of noth the linked lists.\\nthen find the absolute difference of length of linked list.\\nthen traverse the linked list which has more number of nodes upto when the absolute difference between the length of linked list become zero.\\nthen run a while loop upto the noth nofes are equal\\n\\n\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n             ListNode *t1=headA,*t2=headB;\\n         \\n        int l1=0,l2=0;\\n        \\n        while(t1) t1=t1->next, l1++;\\n         while(t2) t2=t2->next,l2++;\\n        int k=abs(l1-l2);\\n        \\n            if(l1>l2) while(k--) headA=headA->next;\\n           else while(k--) headB=headB->next;\\n              while(headA!=headB) headA=headA->next, headB=headB->next;\\n        \\n        return headA;\\n      }\\n\\t//guys plz plz plz upvote my solution if you really like and understand it!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "first I find the length of noth the linked lists.\\nthen find the absolute difference of length of linked list.\\nthen traverse the linked list which has more number of nodes upto when the absolute difference between the length of linked list become zero.\\nthen run a while loop upto the noth nofes are equal\\n\\n\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n             ListNode *t1=headA,*t2=headB;\\n         \\n        int l1=0,l2=0;\\n        \\n        while(t1) t1=t1->next, l1++;\\n         while(t2) t2=t2->next,l2++;\\n        int k=abs(l1-l2);\\n        \\n            if(l1>l2) while(k--) headA=headA->next;\\n           else while(k--) headB=headB->next;\\n              while(headA!=headB) headA=headA->next, headB=headB->next;\\n        \\n        return headA;\\n      }\\n\\t//guys plz plz plz upvote my solution if you really like and understand it!!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1092883,
                "title": "python-concatenate-lists",
                "content": "# Idea\\nLet\\'s say that the lists can be represented as A+**B** and C+**B** where B is the part of the list that is identical. Then, if we append both lists to the end of the other one we\\'ll have two lists: A+B+C+**B** and C+B+A+**B**. Which means if we iterate over both lists and check for equality of corresponding nodes, we\\'ll spot the repetition when we move into section B for the second time. If there\\'s no intersection we won\\'t spot the equality.\\n## Complexity\\nTime: O(N)\\nMemory: O(1)\\n## Code\\n```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\tif not headA or not headB: return None\\n\\ta = headA\\n\\tb = headB\\n\\tswaps = 0\\n\\n\\twhile swaps < 3:\\n\\t\\tif a == b: return a\\n\\t\\ta = a.next\\n\\t\\tb = b.next\\n\\t\\tif not a:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\ta = headB\\n\\t\\tif not b:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\tb = headA\\n\\n\\treturn None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\tif not headA or not headB: return None\\n\\ta = headA\\n\\tb = headB\\n\\tswaps = 0\\n\\n\\twhile swaps < 3:\\n\\t\\tif a == b: return a\\n\\t\\ta = a.next\\n\\t\\tb = b.next\\n\\t\\tif not a:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\ta = headB\\n\\t\\tif not b:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\tb = headA\\n\\n\\treturn None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1056033,
                "title": "c-super-simple-easy-clear-solution-faster-than-98-15-o-n-time-o-1-memory",
                "content": "\\tvoid changeSign(struct ListNode *head){\\n\\t\\twhile ( head )\\n\\t\\t{\\n\\t\\t\\thead->val *= -1;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t}\\n\\tstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\twhile ( headB )\\n\\t\\t{\\n\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tchangeSign( headA );\\n\\t\\treturn headB;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tvoid changeSign(struct ListNode *head){\\n\\t\\twhile ( head )\\n\\t\\t{\\n\\t\\t\\thead->val *= -1;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t}\\n\\tstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\twhile ( headB )\\n\\t\\t{\\n\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tchangeSign( headA );\\n\\t\\treturn headB;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 940739,
                "title": "simple-python-two-pointer-approach",
                "content": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        \\n        hA = headA\\n        hB = headB\\n        \\n        while hA!=hB:\\n            hA = headB if not hA else hA.next\\n            hB = headA if not hB else hB.next\\n        \\n        return hA\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        \\n        hA = headA\\n        hB = headB\\n        \\n        while hA!=hB:\\n            hA = headB if not hA else hA.next\\n            hB = headA if not hB else hB.next\\n        \\n        return hA\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 709523,
                "title": "elegant-cpp-solution-using-stack",
                "content": "I was stuck in this question for quite awhile and then it hit me. So, i tried to solve this question using a stack.\\nPush the nodes (not values) of each linked list into a separate stack. After the intersection point, the nodes will be the same.\\nWhile the stacks are not empty and the top of each stack is the same, pop from each stack.\\nWhen the tops are not equal, the previously popped element (the last equal node) was the intersection point.\\n\\nHere is the code for it:\\n``` \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        stack<ListNode*> A, B;\\n        ListNode *ptr1=headA, *ptr2=headB, *lastRead=NULL;\\n        while(ptr1) {\\n            A.push(ptr1);\\n            ptr1=ptr1->next;\\n        }\\n        while(ptr2) {\\n            B.push(ptr2);\\n            ptr2=ptr2->next;\\n        }\\n        while(!A.empty() && !B.empty() && (A.top()==B.top())) {\\n            lastRead=A.top();\\n            A.pop();\\n            B.pop();\\n\\n        }\\n        return lastRead;\\n    }\\n};\\n```\\nHope this helped :)",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        stack<ListNode*> A, B;\\n        ListNode *ptr1=headA, *ptr2=headB, *lastRead=NULL;\\n        while(ptr1) {\\n            A.push(ptr1);\\n            ptr1=ptr1->next;\\n        }\\n        while(ptr2) {\\n            B.push(ptr2);\\n            ptr2=ptr2->next;\\n        }\\n        while(!A.empty() && !B.empty() && (A.top()==B.top())) {\\n            lastRead=A.top();\\n            A.pop();\\n            B.pop();\\n\\n        }\\n        return lastRead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691897,
                "title": "python-simple-solution-using-pointers-explained",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        \\n        ## LOGIC ##\\n        # 1) Find the length of both lists;\\n        # 2) In the biggest list, advance its head N times where N is the length difference between the two lists.\\n        # 3) Now both lists have the same length, just iterate them and check for node equality.\\n        \\n\\t\\t## TIME COMPLEXITY : O(M+N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        la= lb = 0\\n        a , b = headA, headB\\n        \\n        while(headA):\\n            la += 1\\n            headA = headA.next\\n        while(headB):\\n            lb += 1\\n            headB = headB.next\\n                \\n        if( la > lb ):\\n            diff = la - lb\\n            while(diff):\\n                a = a.next\\n                diff -= 1\\n        elif( lb > la ):\\n            diff = lb - la\\n            while(diff):\\n                b = b.next\\n                diff -= 1\\n        \\n        while(a and b):\\n            if(a == b): return a\\n            a = a.next\\n            b = b.next\\n        return None      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        \\n        ## LOGIC ##\\n        # 1) Find the length of both lists;\\n        # 2) In the biggest list, advance its head N times where N is the length difference between the two lists.\\n        # 3) Now both lists have the same length, just iterate them and check for node equality.\\n        \\n\\t\\t## TIME COMPLEXITY : O(M+N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        la= lb = 0\\n        a , b = headA, headB\\n        \\n        while(headA):\\n            la += 1\\n            headA = headA.next\\n        while(headB):\\n            lb += 1\\n            headB = headB.next\\n                \\n        if( la > lb ):\\n            diff = la - lb\\n            while(diff):\\n                a = a.next\\n                diff -= 1\\n        elif( lb > la ):\\n            diff = lb - la\\n            while(diff):\\n                b = b.next\\n                diff -= 1\\n        \\n        while(a and b):\\n            if(a == b): return a\\n            a = a.next\\n            b = b.next\\n        return None      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 386184,
                "title": "easy-100-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50037,
                "title": "my-accepted-java-solution-with-o-n-time-and-o-1-space",
                "content": "    public class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            if(headA == null || headB == null)\\n                return null;\\n                \\n            ListNode currA = headA, currB = headB;\\n            ListNode lastElementA = null, lastElementB = null;\\n            \\n            while(currA != currB) {\\n                if(lastElementA != null && lastElementB != null && lastElementA != lastElementB)\\n                    return null;\\n                if(currA.next == null) {\\n                    lastElementA = currA;\\n                    currA = headB;\\n                } else\\n                    currA = currA.next;\\n                    \\n                if(currB.next == null) {\\n                    lastElementB = currB;\\n                    currB = headA;\\n                } else\\n                    currB = currB.next;\\n            }\\n            \\n            return currA;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            if(headA == null || headB == null)\\n                return null;\\n                \\n            ListNode currA = headA, currB = headB;\\n            ListNode lastElementA = null, lastElementB = null;\\n            \\n            while(currA != currB) {\\n                if(lastElementA != null && lastElementB != null && lastElementA != lastElementB)\\n                    return null;\\n                if(currA.next == null) {\\n                    lastElementA = currA;\\n                    currA = headB;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2118449,
                "title": "js-two-pointers-o-m-n-no-extra-space-explained-with-drawing",
                "content": "The idea behind this apporoach is that if one list intersects with another, this intersection will be the end of the lists, meaning its tails is a candidate for intersaction. But how would you align two pointers so that they both reach the end at the same time? You could find last nodes for each list first and then go backward but there is a faster way for the case where two lists intersects.\\n\\nLook at how rearranging the terms does not change the sum:\\n```\\n4 + 6 = 10\\n6 + 4 = 10\\n```\\n\\nSame with lists but we need to go through each node and flip pointers at the end of the lists. There won\\'t be a second flip (endless loop) because it will end either on \\'same node found\\' or on `null === null`.\\n```\\npointer1 goes: list1 null list2 null\\npointer2 goes: list2 null list1 null\\n```\\n\\nTwo examples (without and with intersection):\\n![image](https://assets.leetcode.com/users/images/8c216e8e-c53c-402f-a173-500e1b0215da_1654520230.127595.jpeg)\\n*notice how pointers aligned at the end\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n  let pointerA = headA;\\n  let pointerB = headB;\\n  \\n  while (pointerA !== pointerB) {\\n    pointerA = pointerA ? pointerA.next : headB;\\n    pointerB = pointerB ? pointerB.next : headA;\\n  }\\n  \\n  return pointerA;\\n};\\n```\\n\\nYou could experiment on paper with different lists. It\\'ll help visualise how simple this idea is.",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n4 + 6 = 10\\n6 + 4 = 10\\n```\n```\\npointer1 goes: list1 null list2 null\\npointer2 goes: list2 null list1 null\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n  let pointerA = headA;\\n  let pointerB = headB;\\n  \\n  while (pointerA !== pointerB) {\\n    pointerA = pointerA ? pointerA.next : headB;\\n    pointerB = pointerB ? pointerB.next : headA;\\n  }\\n  \\n  return pointerA;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1097119,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA,\\n                 b = headB;\\n        \\n        while (a != b)\\n        {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        \\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA,\\n                 b = headB;\\n        \\n        while (a != b)\\n        {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 465978,
                "title": "is-this-question-correct",
                "content": "how can you tell if it should return 8 or 1, if test cases are below.. \\n```\\n8\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n2\\n3\\n```\\nor \\n```\\n1\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n1\\n2\\n```",
                "solutionTags": [],
                "code": "```\\n8\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n2\\n3\\n```\n```\\n1\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n1\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224592,
                "title": "concise-7-line-c-solution",
                "content": "```c\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (!headA || !headB) return NULL;\\n    struct ListNode *ptr1 = headA, *ptr2 = headB;\\n    while (ptr1 != ptr2) {\\n        ptr1 = ptr1 ? ptr1->next : headB;\\n        ptr2 = ptr2 ? ptr2->next : headA;\\n    }\\n    return ptr1;\\n}\\n```\\nHappy coding~",
                "solutionTags": [],
                "code": "```c\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (!headA || !headB) return NULL;\\n    struct ListNode *ptr1 = headA, *ptr2 = headB;\\n    while (ptr1 != ptr2) {\\n        ptr1 = ptr1 ? ptr1->next : headB;\\n        ptr2 = ptr2 ? ptr2->next : headA;\\n    }\\n    return ptr1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49972,
                "title": "clean-java-solution-o-m-n-time-o-1-space",
                "content": "    public class Solution {\\n      \\n      public ListNode getIntersectionNode(ListNode l1, ListNode l2) {\\n        if (l1 == null || l2 == null) return null;\\n        \\n        // step 1. count the two lists\\n        int n1 = count(l1), n2 = count(l2);\\n        \\n        // step 2. move the longer one |n1 - n2| steps\\n        int n = Math.abs(n1 - n2);\\n        \\n        while (n-- > 0) {\\n          if (n1 > n2)\\n            l1 = l1.next;\\n          else\\n            l2 = l2.next;\\n        }\\n        \\n        // step 3. move together and find the meeting point\\n        while (l1 != l2) {\\n          l1 = l1.next;\\n          l2 = l2.next;\\n        }\\n        \\n        return l1;\\n      }\\n      \\n      int count(ListNode l) {\\n        int n = 0;\\n        while (l != null) {\\n          n++;\\n          l = l.next;\\n        }\\n        return n;\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      \\n      public ListNode getIntersectionNode(ListNode l1, ListNode l2) {\\n        if (l1 == null || l2 == null) return null;\\n        \\n        // step 1. count the two lists\\n        int n1 = count(l1), n2 = count(l2);\\n        \\n        // step 2. move the longer one |n1 - n2| steps\\n        int n = Math.abs(n1 - n2);\\n        \\n        while (n-- > 0) {\\n          if (n1 > n2)\\n            l1 = l1.next;\\n          else\\n            l2 = l2.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810022,
                "title": "most-optimum-sc-o-1-c-easily-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Compare on the basis of length\\n- The one which is longer, traverse it until the length become equal in both\\n- After that we\\'ll traverse each listnode one by one, if both heads (headA and headB) collides return that listnode.\\n- Else return null, no intersection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The base case if definitely if any of the head is NULL,\\n-  Return NULL, i.e no intersection.\\n- For comparing we can implement a separate function.\\n- Then implement as intution says.\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        if(head==NULL)return 0;\\n        int count=0;\\n        while(head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL)return NULL;\\n        int lenA = length(headA),lenB = length(headB);\\n\\n        if(lenA > lenB){\\n            while(lenA > lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        if(lenB > lenA){\\n            while(lenB > lenA){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n\\n        while(headA && headB){\\n            if(headA == headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        if(head==NULL)return 0;\\n        int count=0;\\n        while(head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL)return NULL;\\n        int lenA = length(headA),lenB = length(headB);\\n\\n        if(lenA > lenB){\\n            while(lenA > lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        if(lenB > lenA){\\n            while(lenB > lenA){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n\\n        while(headA && headB){\\n            if(headA == headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723547,
                "title": "simplest-and-best-approach-using-hashset-please-upvote-it-s-my-first-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        // ListNode temp1=headA;\\n        // ListNode temp2=headB;\\n        // while(temp1!=temp2){\\n        //     if(temp1==null){\\n        //         temp1=headB;\\n        //     }else{\\n        //         temp1=temp1.next;\\n        //     }\\n        //     if(temp2==null){\\n        //         temp2=headA;\\n        //     }else{\\n        //         temp2=temp2.next;\\n        //     }\\n        // }\\n        // return temp1;\\n        Set<ListNode> hs=new HashSet<>();\\n        while(headA!=null ){\\n            hs.add(headA);\\n                headA=headA.next;\\n            }\\n         while(headB!=null){\\n             if(hs.contains(headB))\\n             return headB;\\n             headB=headB.next;\\n         }   \\n\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        // ListNode temp1=headA;\\n        // ListNode temp2=headB;\\n        // while(temp1!=temp2){\\n        //     if(temp1==null){\\n        //         temp1=headB;\\n        //     }else{\\n        //         temp1=temp1.next;\\n        //     }\\n        //     if(temp2==null){\\n        //         temp2=headA;\\n        //     }else{\\n        //         temp2=temp2.next;\\n        //     }\\n        // }\\n        // return temp1;\\n        Set<ListNode> hs=new HashSet<>();\\n        while(headA!=null ){\\n            hs.add(headA);\\n                headA=headA.next;\\n            }\\n         while(headB!=null){\\n             if(hs.contains(headB))\\n             return headB;\\n             headB=headB.next;\\n         }   \\n\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553604,
                "title": "3-different-approches-using-c-optimal-and-short",
                "content": "# Approach 1 - Using hashmap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n--> We will create a unordered_map and send all the nodes of listA and mark them as true.\\n--> Now, we will traverse the nodes of listB and check whether the address of node in listB is present in map or not.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // using hashmap;\\n        unordered_map<ListNode*, bool> map;\\n        ListNode* curr = headA;\\n        while(curr != NULL){\\n            map[curr] = true;\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while(curr){\\n            if(map[curr] == true){\\n                return curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n# Approach - 2 by finding the length of the lists.\\n--> We will find the length of both the lists by traversing them. Lets say we got length of listA as n and listB as m.\\n--> Now, whoever have the longest nodes, we will traverse until abs(n-m) distance, because after traversing them we will find both start at equal distance from the intersection node. \\n--> Now, we will traverse both the nodes while both of them or not equal. We will basically return one of the node which we are traversing, because if we found equal that will be the node which we have to return, else if no itersection found, then obviously at NULL they are going to be equal, so directly what we return will be a NULL.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2*max(n,m))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int Acount = 0, Bcount = 0;\\n        ListNode* A= headA;\\n        ListNode *B = headB;\\n        while(A || B){\\n            if(A){\\n                Acount++;\\n                A = A->next;\\n            }\\n            if(B){\\n                Bcount++;\\n                B = B->next;\\n            }\\n        }\\n        ListNode *p1 = (Acount > Bcount)? headA : headB;\\n        ListNode *p2 = (p1 == headA)?headB : headA;\\n\\n        int diff = abs(Acount - Bcount);\\n        for(int i = 0; i<diff; i++){\\n            p1 = p1->next;\\n        }\\n        while(p1 != p2){\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n        return p1;\\n\\n    }\\n};\\n```\\n# Approach - 3: Optimal and short\\n--> So, the approach is interesting, we will traverse the temporary node p1 for listA and p2 for listB. So, once any of the p1 or p2 reaches the NULL, we will start traversing the node from another list.\\nExample -\\n![image.png](https://assets.leetcode.com/users/images/4d5b9a30-0979-440f-8405-ffda80da39e5_1684766210.5942867.png)\\n\\nSo, ListA conatains 4 -> 1 -> 8 -> 4 -> 5, ListB contains 5 -> 6 -> 1 -> 8 -> 4 -> 5\\n\\nSo, p1 traverses through ListA and p2 through ListB. Now, as p1 reaches Null p2 will be at Node value 4. So we will point the p1 to headB. Then when p2 reaches NUll, p1 will be at Node value 6 and we will point p2 to Head of ListA. Now, they are at same distance from the intersection point. As we traverse now, we will get the point where they are equal. So we will return p1 node(can do p2 as well as they both will be equal).\\n\\n# Time Complexity:\\n$$O(n+m)$$\\n\\n# Space Complexity:\\n$$O(1)$$ \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *p1 = headA, *p2 = headB;\\n        while(p1 != p2){\\n            p1 = p1 ? p1->next : headB;\\n            p2 = p2 ? p2->next : headA;\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // using hashmap;\\n        unordered_map<ListNode*, bool> map;\\n        ListNode* curr = headA;\\n        while(curr != NULL){\\n            map[curr] = true;\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while(curr){\\n            if(map[curr] == true){\\n                return curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int Acount = 0, Bcount = 0;\\n        ListNode* A= headA;\\n        ListNode *B = headB;\\n        while(A || B){\\n            if(A){\\n                Acount++;\\n                A = A->next;\\n            }\\n            if(B){\\n                Bcount++;\\n                B = B->next;\\n            }\\n        }\\n        ListNode *p1 = (Acount > Bcount)? headA : headB;\\n        ListNode *p2 = (p1 == headA)?headB : headA;\\n\\n        int diff = abs(Acount - Bcount);\\n        for(int i = 0; i<diff; i++){\\n            p1 = p1->next;\\n        }\\n        while(p1 != p2){\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n        return p1;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *p1 = headA, *p2 = headB;\\n        while(p1 != p2){\\n            p1 = p1 ? p1->next : headB;\\n            p2 = p2 ? p2->next : headA;\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422844,
                "title": "c-solution-o-n-m",
                "content": "# Code\\n```\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }\\n\\n    return A;\\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }\\n\\n    return A;\\n    \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343069,
                "title": "c-easy-solution-using-unordered-map",
                "content": "# Intuition\\nWe will use maps to solve this one.\\n\\n# Approach\\n- Create an unordered_map of ListNode* and let\\'s just take int for the value.\\n- then transfer all the nodes of first LL in the map.\\n- then traverse the seconf LL and check if a node from second LL is present in the map.\\n- if there is one node present, then return that one.\\n- else there is no intersection in the linked list, so return NULL.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mp;\\n\\n        ListNode* temp = headA;\\n\\n        //LL A nodes stored inside the map\\n        while(temp){\\n            mp[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        //LL B traversal\\n        temp = headB;\\n        while(temp){\\n            if(mp.find(temp) != mp.end())\\n                return temp;\\n\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mp;\\n\\n        ListNode* temp = headA;\\n\\n        //LL A nodes stored inside the map\\n        while(temp){\\n            mp[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        //LL B traversal\\n        temp = headB;\\n        while(temp){\\n            if(mp.find(temp) != mp.end())\\n                return temp;\\n\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050410,
                "title": "java-3-approaches-explained",
                "content": "**FIRST APPROACH**\\n\\n        // BRUTE FORCE APPROACH\\n        \\n        // We will take any of the linked list, and will compare each and every node of the other list with that - in order to determine if the nodes are equal - if they are equal for the first time - then it is our intersection point - if we reach to the null - there is no intersection\\n        \\n        ListNode tempA = headA;\\n        \\n        while(tempA != null)\\n        {\\n            ListNode tempB = headB;\\n            \\n            while(tempB != null)\\n            {\\n                if(tempA == tempB)\\n                {\\n                    return tempA;\\n                }\\n                tempB = tempB.next;\\n            }\\n            tempA = tempA.next;\\n        }\\n        \\n        return null;\\n\\n**SECOND APPROACH**\\n\\n        // OPTIMISED SOLUTION\\n        \\n        // We will calculate the lengths of the linked list 1 and 2, and then take out their difference - we can then move difference steps ahead from the smaller linked list - to get to our intersection point\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        int sizeA = 0, sizeB = 0;\\n        \\n        while(tempA != null)\\n        {\\n            sizeA++;\\n            tempA = tempA.next;\\n        }\\n        \\n        while(tempB != null)\\n        {\\n            sizeB++;\\n            tempB = tempB.next;\\n        }\\n        \\n        // System.out.println(\"size a : \" + sizeA + \" size b: \" + sizeB);\\n        \\n        if(sizeA <= sizeB)\\n        {\\n            // list A is small\\n            int difference = sizeB - sizeA;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headB = headB.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n        else\\n        {\\n            // list B is small\\n            int difference = sizeA - sizeB;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headA = headA.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n\\t\\t\\n**THIRD APPROACH**\\n\\n        // OPTIMISED - BETTER SOLUTION \\n        \\n        // Here, the algorithm is - we will have a tempA pointing at the head of the list 1, and tempB at list 2. We will keep on traversing them one step at a time, and when either of the temp reaches null we will assign it to the head of the other list\\n        \\n        // so if tempA reaches null, we will re assign it as headB\\n        // else if tempB reaches null, assign it as headA\\n        \\n        // By this, we will come to a point were both of the tempa and tempB will be synchronised and will reach the interesection point at the same time - by pointing to the same node\\n        \\n        // As an edge case, even if there is no interesction both the temp\\'s will be pointing at null together\\n        \\n        // The intution behind this algo is that, when one list is small and other is big, the big will still be in its list, and the small would be done wd its list. So, we can observe that now the big is difference of the size (length of the lists) away from null. So, we will begin the traversal of the temp nodes from different heads so that they can be in sync. - as our previous approach.\\n        \\n        if(headA == null || headB == null)\\n        {\\n            return null;    // no intersection is possible\\n        }\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        while(tempA != tempB)\\n        {\\n            if(tempA == null)\\n            {\\n                tempA = headB;\\n            }\\n            else\\n            {\\n                tempA = tempA.next;\\n            }\\n            \\n            if(tempB == null)\\n            {\\n                tempB = headA;\\n            }\\n            else\\n            {\\n                tempB = tempB.next;\\n            }\\n        }\\n        \\n        return tempA;\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "**FIRST APPROACH**\\n\\n        // BRUTE FORCE APPROACH\\n        \\n        // We will take any of the linked list, and will compare each and every node of the other list with that - in order to determine if the nodes are equal - if they are equal for the first time - then it is our intersection point - if we reach to the null - there is no intersection\\n        \\n        ListNode tempA = headA;\\n        \\n        while(tempA != null)\\n        {\\n            ListNode tempB = headB;\\n            \\n            while(tempB != null)\\n            {\\n                if(tempA == tempB)\\n                {\\n                    return tempA;\\n                }\\n                tempB = tempB.next;\\n            }\\n            tempA = tempA.next;\\n        }\\n        \\n        return null;\\n\\n**SECOND APPROACH**\\n\\n        // OPTIMISED SOLUTION\\n        \\n        // We will calculate the lengths of the linked list 1 and 2, and then take out their difference - we can then move difference steps ahead from the smaller linked list - to get to our intersection point\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        int sizeA = 0, sizeB = 0;\\n        \\n        while(tempA != null)\\n        {\\n            sizeA++;\\n            tempA = tempA.next;\\n        }\\n        \\n        while(tempB != null)\\n        {\\n            sizeB++;\\n            tempB = tempB.next;\\n        }\\n        \\n        // System.out.println(\"size a : \" + sizeA + \" size b: \" + sizeB);\\n        \\n        if(sizeA <= sizeB)\\n        {\\n            // list A is small\\n            int difference = sizeB - sizeA;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headB = headB.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n        else\\n        {\\n            // list B is small\\n            int difference = sizeA - sizeB;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headA = headA.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n\\t\\t\\n**THIRD APPROACH**\\n\\n        // OPTIMISED - BETTER SOLUTION \\n        \\n        // Here, the algorithm is - we will have a tempA pointing at the head of the list 1, and tempB at list 2. We will keep on traversing them one step at a time, and when either of the temp reaches null we will assign it to the head of the other list\\n        \\n        // so if tempA reaches null, we will re assign it as headB\\n        // else if tempB reaches null, assign it as headA\\n        \\n        // By this, we will come to a point were both of the tempa and tempB will be synchronised and will reach the interesection point at the same time - by pointing to the same node\\n        \\n        // As an edge case, even if there is no interesction both the temp\\'s will be pointing at null together\\n        \\n        // The intution behind this algo is that, when one list is small and other is big, the big will still be in its list, and the small would be done wd its list. So, we can observe that now the big is difference of the size (length of the lists) away from null. So, we will begin the traversal of the temp nodes from different heads so that they can be in sync. - as our previous approach.\\n        \\n        if(headA == null || headB == null)\\n        {\\n            return null;    // no intersection is possible\\n        }\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        while(tempA != tempB)\\n        {\\n            if(tempA == null)\\n            {\\n                tempA = headB;\\n            }\\n            else\\n            {\\n                tempA = tempA.next;\\n            }\\n            \\n            if(tempB == null)\\n            {\\n                tempB = headA;\\n            }\\n            else\\n            {\\n                tempB = tempB.next;\\n            }\\n        }\\n        \\n        return tempA;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1484415,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: HashMap**\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        seen = set()\\n        while headA != None:\\n            seen.add(headA)\\n            headA = headA.next\\n            \\n        while headB != None:\\n            if headB in seen:\\n                return headB\\n            headB = headB.next\\n        return None\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3*10^4` is length of listA, `N <= 3*10^4` is length of listB.\\n- Space: `O(M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Loop listA + listB**\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        pA = headA\\n        pB = headB\\n        while pA != pB:\\n            pA = pA.next if pA else headB\\n            pB = pB.next if pB else headA\\n        return pA\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3*10^4` is length of listA, `N <= 3*10^4` is length of listB.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        seen = set()\\n        while headA != None:\\n            seen.add(headA)\\n            headA = headA.next\\n            \\n        while headB != None:\\n            if headB in seen:\\n                return headB\\n            headB = headB.next\\n        return None\\n```\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        pA = headA\\n        pB = headB\\n        while pA != pB:\\n            pA = pA.next if pA else headB\\n            pB = pB.next if pB else headA\\n        return pA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360094,
                "title": "4-approaches-c",
                "content": "# Method 1(Simply use two loops) \\n\\n* Use 2 nested for loops. \\n* The outer loop will be for each node of the 1st list and inner loop will be for 2nd list. \\n* In the inner loop, check if any of nodes of the 2nd list is same as the current node of the first linked list.\\n* **So for each node for 1st loop we traverse all nodes of second list to find if any of them are equal**\\n* The time complexity of this method will be O(M * N) where m and n are the numbers of nodes in two lists.\\n\\n# Method 2 Hashing O(N) time and O(N) space\\n**Remember to insert the address of the nodes not value**\\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*>s;\\n        while(headA){\\n            s.insert(headA);\\n            headA=headA->next;\\n        }\\n        while(headB){\\n            if(s.find(headB)!=s.end())\\n                return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n```\\n\\n# Method 3(Using difference of node counts) O(N) time and O(1) space\\n\\n* Get count of the nodes in the first list, let count be c1.\\n* Get count of the nodes in the second list, let count be c2.\\n* Get the difference of counts d = abs(c1 \\u2013 c2)\\n* Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes\\n* Then we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes)\\n\\n```\\nListNode* getIntersectionNode(ListNode headA, ListNode headB) {\\n    int lenA = count(headA), lenB = count(headB);         // implement this on your own !\\n\\t\\n    // move headA and headB to the same start point\\n    while (lenA > lenB) {\\n        headA = headA.next;\\n        lenA--;\\n    }\\n    while (lenA < lenB) {\\n        headB = headB.next;\\n        lenB--;\\n    }\\n \\n    while (headA != headB) {\\n        headA = headA.next;\\n        headB = headB.next;\\n    }\\n    return headA;\\n}\\n```\\n\\n# Method 4 (Most Optimal) O(N) time and O(1) space\\n```\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n    if(headA == NULL || headB == NULL) return NULL;\\n    \\n    ListNode* a = headA;\\n    ListNode* b = headB;\\n    \\n  \\n    while( a != b){\\n    \\n        a = a == NULL ? headB : a->next;\\n        b = b == NULL ? headA : b->next;    \\n    }\\n    \\n    return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*>s;\\n        while(headA){\\n            s.insert(headA);\\n            headA=headA->next;\\n        }\\n        while(headB){\\n            if(s.find(headB)!=s.end())\\n                return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n```\n```\\nListNode* getIntersectionNode(ListNode headA, ListNode headB) {\\n    int lenA = count(headA), lenB = count(headB);         // implement this on your own !\\n\\t\\n    // move headA and headB to the same start point\\n    while (lenA > lenB) {\\n        headA = headA.next;\\n        lenA--;\\n    }\\n    while (lenA < lenB) {\\n        headB = headB.next;\\n        lenB--;\\n    }\\n \\n    while (headA != headB) {\\n        headA = headA.next;\\n        headB = headB.next;\\n    }\\n    return headA;\\n}\\n```\n```\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n    if(headA == NULL || headB == NULL) return NULL;\\n    \\n    ListNode* a = headA;\\n    ListNode* b = headB;\\n    \\n  \\n    while( a != b){\\n    \\n        a = a == NULL ? headB : a->next;\\n        b = b == NULL ? headA : b->next;    \\n    }\\n    \\n    return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349261,
                "title": "js-3-o-n-solutions-with-comments",
                "content": "**Solution 1:**\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    const set = new Set();    // This set will store all the nodes that are encountered while traversing the first LL\\n    let curr = headA;\\n    while(curr) {\\n        set.add(curr);\\n        curr = curr.next;\\n    }\\n    curr = headB;\\n    while(curr && !set.has(curr)) {    // the loop will break when we find the intersection node or if there is no intersection\\n        curr = curr.next;\\n    }\\n    return curr;\\n};\\n```\\nTime Complexity = O(m + n)\\nSpace Complexity = O(m)\\n\\n----\\n\\n**Solution 2:**\\n\\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let lenA = 0,\\n        lenB = 0,\\n        currA = headA,\\n        currB = headB;\\n    \\n    // find length of List A and List B\\n    while(currA) {\\n        ++lenA;\\n        currA = currA.next;\\n    }\\n    while(currB) {\\n        ++lenB;\\n        currB = currB.next;\\n    }\\n    \\n    // move the longer list steps equal to the difference between their lengths\\n    currA = headA;\\n    while(lenA > lenB) {\\n        currA = currA.next;\\n        --lenA;\\n    }\\n    currB = headB;\\n    while(lenA < lenB) {\\n        currB = currB.next;\\n        --lenB;\\n    }\\n    \\n    // move both pointer one step at a time until they meet at the intersection or both are equal to null\\n    // since from the start of this loop, both will have to move same distance until they reach the end\\n    while(currA !== currB) {\\n        currA = currA.next;\\n        currB = currB.next;   \\n    }\\n    return currA;\\n};\\n```\\n\\nTime Complexity = O(m + n) ~ O(n)\\nSpace Complexity = O(1)\\n\\nThis solution will traverse (m + n + max(m, n)) steps.\\n\\n----\\n\\n**Solution 3:**\\n\\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let currA = headA,\\n        currB = headB;\\n    \\n    // start both pointer from the start of the linked lists\\n    // when the smaller list pointer reaches end, we start it from the beginning of the longer list\\n    // and when the longer list reaches end, we start it from the beginning of the smaller list\\n    // so basically both the pointers traverse at-max (m + n) steps until they either meet at the intersection\\n    // or at the end (null)\\n    while(currA !== currB) {\\n        if(!currA) {\\n            currA = headB;\\n        } else {\\n            currA = currA.next;\\n        }\\n        if(!currB) {\\n            currB = headA;\\n        } else {\\n            currB = currB.next;\\n        }\\n    }\\n    return currA;\\n}\\n```\\n\\nTime Complexity = O(m + n) ~ O(n)\\nSpace Complexity = O(1)\\n\\nThis solution will traverse (m + n) steps.",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    const set = new Set();    // This set will store all the nodes that are encountered while traversing the first LL\\n    let curr = headA;\\n    while(curr) {\\n        set.add(curr);\\n        curr = curr.next;\\n    }\\n    curr = headB;\\n    while(curr && !set.has(curr)) {    // the loop will break when we find the intersection node or if there is no intersection\\n        curr = curr.next;\\n    }\\n    return curr;\\n};\\n```\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let lenA = 0,\\n        lenB = 0,\\n        currA = headA,\\n        currB = headB;\\n    \\n    // find length of List A and List B\\n    while(currA) {\\n        ++lenA;\\n        currA = currA.next;\\n    }\\n    while(currB) {\\n        ++lenB;\\n        currB = currB.next;\\n    }\\n    \\n    // move the longer list steps equal to the difference between their lengths\\n    currA = headA;\\n    while(lenA > lenB) {\\n        currA = currA.next;\\n        --lenA;\\n    }\\n    currB = headB;\\n    while(lenA < lenB) {\\n        currB = currB.next;\\n        --lenB;\\n    }\\n    \\n    // move both pointer one step at a time until they meet at the intersection or both are equal to null\\n    // since from the start of this loop, both will have to move same distance until they reach the end\\n    while(currA !== currB) {\\n        currA = currA.next;\\n        currB = currB.next;   \\n    }\\n    return currA;\\n};\\n```\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let currA = headA,\\n        currB = headB;\\n    \\n    // start both pointer from the start of the linked lists\\n    // when the smaller list pointer reaches end, we start it from the beginning of the longer list\\n    // and when the longer list reaches end, we start it from the beginning of the smaller list\\n    // so basically both the pointers traverse at-max (m + n) steps until they either meet at the intersection\\n    // or at the end (null)\\n    while(currA !== currB) {\\n        if(!currA) {\\n            currA = headB;\\n        } else {\\n            currA = currA.next;\\n        }\\n        if(!currB) {\\n            currB = headA;\\n        } else {\\n            currB = currB.next;\\n        }\\n    }\\n    return currA;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093180,
                "title": "c-magic-solution-o-n-time-o-1-space",
                "content": "```\\nvoid changeSign(struct ListNode *head){\\n    while ( head )\\n    {\\n        head->val *= -1;\\n        head = head->next;\\n    }\\n}\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign( headA );\\n        \\n    while ( headB )\\n    {\\n        if ( headB->val < 0 ) break;\\n        headB = headB->next;\\n    }\\n        \\n    changeSign( headA );\\n    return headB;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid changeSign(struct ListNode *head){\\n    while ( head )\\n    {\\n        head->val *= -1;\\n        head = head->next;\\n    }\\n}\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign( headA );\\n        \\n    while ( headB )\\n    {\\n        if ( headB->val < 0 ) break;\\n        headB = headB->next;\\n    }\\n        \\n    changeSign( headA );\\n    return headB;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1092926,
                "title": "intersection-of-two-linked-lists-c-simple-with-idea",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       ListNode *pA = headA, *pB = headB;\\n        while (pA != pB) {\\n            pA = pA ? pA->next : headB;\\n            pB = pB ? pB->next : headA;\\n        }\\n        return pA;\\n    } \\n};\\n```\\n\\nUsing Two pointers :\\nInitialize two pointers ptr1 and ptr2  at the head1 and  head2.\\nTraverse through the lists,one node at a time.\\nWhen ptr1 reaches the end of a list, then redirect it to the head2.\\nsimilarly when ptr2 reaches the end of a list, redirect it the head1.\\nOnce both of them go through reassigning,hey will be equidistant from\\n the collision point\\nIf at any node ptr1 meets ptr2, then it is the intersection node.\\nAfter second iteration if there is no intersection node it returns NULL.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       ListNode *pA = headA, *pB = headB;\\n        while (pA != pB) {\\n            pA = pA ? pA->next : headB;\\n            pB = pB ? pB->next : headA;\\n        }\\n        return pA;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802204,
                "title": "javascript-solution-160",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nlet getIntersectionNode = function(headA, headB) {\\n    if(headA===null || headB===null) {\\n        return null;\\n    }\\n    let r1=headA;\\n    let r2=headB;\\n    while(r1!==r2){\\n        r1=r1.next;\\n        r2=r2.next;\\n        if(r1===r2){\\n           return r1;\\n        }\\n        if (r1===null){\\n          r1=headB;  \\n        }\\n        if(r2===null){\\n            r2=headA;\\n        }\\n    }\\n    return r1;\\n};\\n```\\n\\n**Runtime: 96 ms, faster than 90.42% of JavaScript online submissions for Intersection of Two Linked Lists.**\\n\\n**Memory Usage: 43.7 MB, less than 58.14% of JavaScript online submissions for Intersection of Two Linked Lists.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nlet getIntersectionNode = function(headA, headB) {\\n    if(headA===null || headB===null) {\\n        return null;\\n    }\\n    let r1=headA;\\n    let r2=headB;\\n    while(r1!==r2){\\n        r1=r1.next;\\n        r2=r2.next;\\n        if(r1===r2){\\n           return r1;\\n        }\\n        if (r1===null){\\n          r1=headB;  \\n        }\\n        if(r2===null){\\n            r2=headA;\\n        }\\n    }\\n    return r1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515384,
                "title": "beats-100-fast-concise-and-readable-javascript-solution",
                "content": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)return null\\n    let a = headA, b = headB\\n    while(a !== b){\\n        a = a.next\\n        b = b.next\\n        if(!a && !b)return a\\n        if(!a)a = headB\\n        if(!b)b = headA\\n    }\\n    return a\\n};\\n```\\n![image](https://assets.leetcode.com/users/trevorhulsman123/image_1582248204.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)return null\\n    let a = headA, b = headB\\n    while(a !== b){\\n        a = a.next\\n        b = b.next\\n        if(!a && !b)return a\\n        if(!a)a = headB\\n        if(!b)b = headA\\n    }\\n    return a\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49844,
                "title": "u3010fixed-u3011python-accepted-solution-before-now-causes-memory-limit-exceeded",
                "content": "I have resolved this problem several months ago. But now when I submit the same code, it always get MLE. I also tried other solutions posted in the discuss, still got MLE. @StefanPochmann \\n\\n`Update:` Many thanks to @skyeyvapor, it's accepted when add `gc.collect()` manually. I already updated the codes below.\\n\\n\\nThis is my solution.\\n```\\nimport gc\\n\\nclass Solution(object):\\n    def cout(self, head):\\n        cnt = 0\\n        while head:\\n            cnt += 1\\n            head = head.next\\n\\n        # manually clean the memory\\n        gc.collect()\\n        return cnt\\n\\n    def getIntersectionNode(self, headA, headB):\\n        l1, l2, cnt1, cnt2 = headA, headB, self.cout(headA), self.cout(headB)\\n        if cnt2 > cnt1:\\n            l1, l2 = l2, l1\\n\\n        for _ in range(abs(cnt1 - cnt2)):\\n            l1 = l1.next\\n\\n        while l1:\\n            if l1 is l2:\\n                return l1\\n\\n            l1, l2 = l1.next, l2.next\\n```\\n\\nAnd this is another solution I tried.\\n\\n```\\nimport gc\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        a, b = headA, headB\\n        while a is not b:\\n            a = headB if a is None else a.next\\n            b = headA if b is None else b.next\\n        \\n        # clean the memory\\n        gc.collect()\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nimport gc\\n\\nclass Solution(object):\\n    def cout(self, head):\\n        cnt = 0\\n        while head:\\n            cnt += 1\\n            head = head.next\\n\\n        # manually clean the memory\\n        gc.collect()\\n        return cnt\\n\\n    def getIntersectionNode(self, headA, headB):\\n        l1, l2, cnt1, cnt2 = headA, headB, self.cout(headA), self.cout(headB)\\n        if cnt2 > cnt1:\\n            l1, l2 = l2, l1\\n\\n        for _ in range(abs(cnt1 - cnt2)):\\n            l1 = l1.next\\n\\n        while l1:\\n            if l1 is l2:\\n                return l1\\n\\n            l1, l2 = l1.next, l2.next\\n```\n```\\nimport gc\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        a, b = headA, headB\\n        while a is not b:\\n            a = headB if a is None else a.next\\n            b = headA if b is None else b.next\\n        \\n        # clean the memory\\n        gc.collect()\\n        return a\\n```",
                "codeTag": "C++"
            },
            {
                "id": 49891,
                "title": "javascript-5-lines-with-inline-comment",
                "content": "    var getIntersectionNode = function(ah, bh) {\\n        var a=ah, b=bh\\n        while(a!=b){\\n            a = a? a.next : bh // move a to head of b if at end\\n            b = b? b.next : ah // move b to head of a if at end      \\n        }\\n        \\n        return a; // a === b either happen at the connecting point or when they are both null\\n    };",
                "solutionTags": [],
                "code": "    var getIntersectionNode = function(ah, bh) {\\n        var a=ah, b=bh\\n        while(a!=b){\\n            a = a? a.next : bh // move a to head of b if at end\\n            b = b? b.next : ah // move b to head of a if at end      \\n        }\\n        \\n        return a; // a === b either happen at the connecting point or when they are both null\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 49939,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *hA = headA, *hB = headB;\\n        while (hA && hB) {\\n            if (hA == hB)\\n                return hA;\\n            hA = hA->next;\\n            hB = hB->next;\\n            if (!hA && !hB)\\n                return NULL;\\n            if (!hA) \\n                hA = headB;\\n            if (!hB)\\n                hB = headA;\\n        }\\n        return NULL;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *hA = headA, *hB = headB;\\n        while (hA && hB) {\\n            if (hA == hB)\\n                return hA;\\n            hA = hA->next;\\n            hB = hB->next;\\n            if (!hA && !hB)\\n                return NULL;\\n            if (!hA) \\n                hA = headB;\\n            if (!hB)\\n                hB = headA;\\n        }\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 50010,
                "title": "my-concise-python-solution-run-in-o-n-time-and-o-1-memory",
                "content": "    class Solution:\\n    # @param two ListNodes\\n    # @return the intersected ListNode\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:return None\\n        a,b=headA,headB\\n        ans = None\\n        while a or b:  \\n            if not a:   a=headB\\n            if not b:   b=headA\\n            if a==b and not ans: ans=a\\n            a , b = a.next,b.next\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param two ListNodes\\n    # @return the intersected ListNode\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:return None\\n        a,b=headA,headB\\n        ans = None\\n        while a or b:  \\n            if not a:   a=headB\\n            if not b:   b=headA\\n            if a==b and not ans: ans=a\\n            a , b = a.next,b.next\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3292274,
                "title": "best-6-lines-of-code-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        while (head2 != null){\\n            ListNode temp = head1;\\n            while (temp != null){\\n                if (temp == head2) return head2;\\n                temp = temp.next;\\n            }\\n            head2 = head2.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        while (head2 != null){\\n            ListNode temp = head1;\\n            while (temp != null){\\n                if (temp == head2) return head2;\\n                temp = temp.next;\\n            }\\n            head2 = head2.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964570,
                "title": "c-java-solution-with-all-the-ways-striver-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intuition is to traverse the linkedlist and return the node where the two list join and if there is no joining of the list we simply return NULL\\n\\n# Brute force \\nWe will point to a node in list 1 and check it with all the node of the list2 and if we get the same node then return that node or else return NULL;\\n\\n**Time complexity:** **O(n*m)**\\nn =length of the list 1.\\nm=length of the list2.\\n**Space complexity:**  **O(1)**\\n\\n# Hashing \\nStore all the node of the list1 and list2 in hash table and when the two node have same key then return that node.\\n\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(n+m)**\\n\\n# Optimal 1\\n \\n1. Find the length of the first list and then the length of second list.\\n2. Move the head of the longer length linkedlist till the difference of the length of two list.\\n3. After that move both the head simultaneously and return the value where they collide.\\n\\n**Code**\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int n1=0,n2=0;\\n        ListNode temp=headA;\\n        while(temp!=null){\\n            n1++;   //count the length of the list 1\\n            temp=temp.next;\\n        }\\n        temp=headB;\\n        while(temp!=null){\\n            n2++;   //count the length of the list2\\n            temp=temp.next;\\n        }\\n        ListNode larger=headA;\\n        ListNode smaller=headB;\\n        if(n1<n2){      //if A is not the larger list then swap\\n            ListNode p=larger;\\n            larger=smaller;     \\n            smaller=p;\\n        }\\n        int diff=Math.abs(n1-n2);\\n        for(int i=0;i<diff;i++){\\n            larger=larger.next;\\n        }\\n         if(larger==smaller){\\n                return larger;\\n            }\\n        while(larger!=null&&smaller!=null){\\n            larger=larger.next;\\n            smaller=smaller.next;\\n            if(larger==smaller){\\n                return larger;\\n            }\\n\\n        }\\n        return null;\\n    }\\n}\\n```\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(1)**\\n\\nThis the optimal code However the line of code is a little bit larger.\\n# Optimal 2\\n1. Traverse the list1 and list 2 \\n2. The moment one of the list reaches the null then assign it to the head of other list.\\n3. Again traverse both the list and if the second list reaches the list then assign it to the head1.\\n4. Traverse the list till it collide and return the collide node .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* a=headA;\\n        ListNode* b=headB;\\n        if(headA==NULL||headB==NULL)\\n        return NULL;\\n\\n        while(a!=b){\\n            if(a==NULL)\\n            a=headB;\\n            else\\n            a=a->next;\\n            if(b==NULL)\\n            b=headA;\\n            else \\n            b=b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(1)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int n1=0,n2=0;\\n        ListNode temp=headA;\\n        while(temp!=null){\\n            n1++;   //count the length of the list 1\\n            temp=temp.next;\\n        }\\n        temp=headB;\\n        while(temp!=null){\\n            n2++;   //count the length of the list2\\n            temp=temp.next;\\n        }\\n        ListNode larger=headA;\\n        ListNode smaller=headB;\\n        if(n1<n2){      //if A is not the larger list then swap\\n            ListNode p=larger;\\n            larger=smaller;     \\n            smaller=p;\\n        }\\n        int diff=Math.abs(n1-n2);\\n        for(int i=0;i<diff;i++){\\n            larger=larger.next;\\n        }\\n         if(larger==smaller){\\n                return larger;\\n            }\\n        while(larger!=null&&smaller!=null){\\n            larger=larger.next;\\n            smaller=smaller.next;\\n            if(larger==smaller){\\n                return larger;\\n            }\\n\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* a=headA;\\n        ListNode* b=headB;\\n        if(headA==NULL||headB==NULL)\\n        return NULL;\\n\\n        while(a!=b){\\n            if(a==NULL)\\n            a=headB;\\n            else\\n            a=a->next;\\n            if(b==NULL)\\n            b=headA;\\n            else \\n            b=b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726063,
                "title": "python3-easy-o-1-space-with-explanation",
                "content": "**Explanation**\\n\\nIf we connect the tail of the intersection part to one head, we could implement this problem using the idea from question Linked List Cycle II. To explain, the solution is now to solve for the entry node of the cycle if there is an intersection.\\n\\nNote that we need to split the cycle to the original structure before returning the intersection node as required.\\n\\n**Python3 implementation:**\\n```Python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # create a circle\\n        tail = headA\\n        while tail.next:\\n            tail = tail.next\\n        tail.next = headB\\n        # find the intersection node\\n        slow = fast = headA\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow is fast:\\n                break\\n        \\n        if not fast or not fast.next:\\n            tail.next = None\\n            return None\\n        \\n        slow = headA\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next\\n        # recover to original structure\\n        tail.next = None\\n        return slow\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```Python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # create a circle\\n        tail = headA\\n        while tail.next:\\n            tail = tail.next\\n        tail.next = headB\\n        # find the intersection node\\n        slow = fast = headA\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow is fast:\\n                break\\n        \\n        if not fast or not fast.next:\\n            tail.next = None\\n            return None\\n        \\n        slow = headA\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next\\n        # recover to original structure\\n        tail.next = None\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035448,
                "title": "java-shortest-cleanest-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode xA = headA , xB = headB;\\n      while(xA != xB) {\\n        xA = xA == null ? headB : xA.next;\\n        xB = xB == null ? headA : xB.next;\\n      }\\n      return xA;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode xA = headA , xB = headB;\\n      while(xA != xB) {\\n        xA = xA == null ? headB : xA.next;\\n        xB = xB == null ? headA : xB.next;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1759814,
                "title": "python-link-the-two-lists-o-n-m-time-and-o-1-space",
                "content": "We need two pointers: `p1` starts from `headA` and `p2` starts from `headB`.\\nThe key point is how we make sure the two pointers come to the intersection node at the same time.\\nSince the difference of the distance to the intersection is the difference of the length of the two list. We can \"link\" the two list together:\\n* Let `p1` starts from `headA` passing through the first linked list, then the second (starting from `headB`).\\n* Let `p2` starts from `headB` passing through the second linked list, then the first (starting from `headA`).\\n\\nThus, the number of steps they need to take to arrive the intersection node is equal.\\nAlso, if there is no intersection, it will end up with `p1 == p1 == null`.\\n\\n```Python\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        p1 = headA\\n        p2 = headB\\n        while p1 != p2:\\n            if p1:\\n                p1 = p1.next\\n            else:\\n                p1 = headB\\n            if p2:\\n                p2 = p2.next\\n            else:\\n                p2 = headA\\n            \\n        return p1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        p1 = headA\\n        p2 = headB\\n        while p1 != p2:\\n            if p1:\\n                p1 = p1.next\\n            else:\\n                p1 = headB\\n            if p2:\\n                p2 = p2.next\\n            else:\\n                p2 = headA\\n            \\n        return p1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698318,
                "title": "mathematical-explanation-of-o-n-time-o-1-space-solution",
                "content": "![](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)\\n\\nAssume there exists an intersection. The intersection is `None` if `A` and `B` don\\'t actually intersect. Notice that the following equation is true:\\n\\n```\\na + b + 2*c == m + n\\n\\na = number of edges from headA to the intersection node\\nb = number of edges from headB to the intersection node\\nc = number of edges from the intersection node to the tail\\nm = number of edges from headA to the tail\\nn = number of edges from headB to the tail\\n```\\n\\nTo find the intersection node, we want to solve for `a` or `b`. If we have `a`, then we can travel a distance of `a` away from `headA` and arrive at the intersection node. Alternatively, if we have `b` then we can travel a distance of `b` away from `headB` and arrive at the intersection node.\\n\\nNow, notice the following:\\n\\n```\\na + (n - m) == b\\n\\n(assuming n > m)\\n```\\n\\nIf `m > n`, then instead:\\n\\n```\\nb + (m - n) == a\\n```\\n\\nIt\\'s easy to prove. For example, for the `n > m` case:\\n\\n```\\na + (n - m) == b\\n(m - c) + (n - m) == (n - c)\\nm - m + n - c == n - c\\nn - c == n - c\\n```\\n\\nSo we just need to find the value of `n - m` and then give the iterator at `headB` a head start of `n - m`. Conversely, if `m > n`, then we give the iterator at `headA` a head start of `m - n`. Then iterate both at the same speed, and eventually they will arrive at the intersection point at the same time.\\n\\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # Calculate m\\n        m, a = 0, headA\\n        while a:\\n            m += 1\\n            a = a.next\\n        # Calculate n\\n        n, b = 0, headB\\n        while b:\\n            n += 1\\n            b = b.next\\n\\n        # Restart a, b at headA, headB\\n        # Give either a or b a \"head start\"\\n        a, b = headA, headB\\n        if m > n:\\n            # Give \\'a\\' a head start of (m - n)\\n            for _ in range(m - n):\\n                a = a.next\\n        else:\\n            # Give \\'b\\' a head start of (n - m)\\n            for _ in range(n - m):\\n                b = b.next\\n        # Iterate a and b until the intersect.\\n        while a and b and a != b:\\n            a = a.next\\n            b = b.next\\n        return a\\n```\\n\\nActually, we can make the code smaller like so:\\n\\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        a, b = headA, headB\\n        while a != b:\\n            if not a:\\n                a = headB\\n            elif not b:\\n                b = headA\\n            else:\\n                a = a.next\\n                b = b.next\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\na + b + 2*c == m + n\\n\\na = number of edges from headA to the intersection node\\nb = number of edges from headB to the intersection node\\nc = number of edges from the intersection node to the tail\\nm = number of edges from headA to the tail\\nn = number of edges from headB to the tail\\n```\n```\\na + (n - m) == b\\n\\n(assuming n > m)\\n```\n```\\nb + (m - n) == a\\n```\n```\\na + (n - m) == b\\n(m - c) + (n - m) == (n - c)\\nm - m + n - c == n - c\\nn - c == n - c\\n```\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # Calculate m\\n        m, a = 0, headA\\n        while a:\\n            m += 1\\n            a = a.next\\n        # Calculate n\\n        n, b = 0, headB\\n        while b:\\n            n += 1\\n            b = b.next\\n\\n        # Restart a, b at headA, headB\\n        # Give either a or b a \"head start\"\\n        a, b = headA, headB\\n        if m > n:\\n            # Give \\'a\\' a head start of (m - n)\\n            for _ in range(m - n):\\n                a = a.next\\n        else:\\n            # Give \\'b\\' a head start of (n - m)\\n            for _ in range(n - m):\\n                b = b.next\\n        # Iterate a and b until the intersect.\\n        while a and b and a != b:\\n            a = a.next\\n            b = b.next\\n        return a\\n```\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        a, b = headA, headB\\n        while a != b:\\n            if not a:\\n                a = headB\\n            elif not b:\\n                b = headA\\n            else:\\n                a = a.next\\n                b = b.next\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180817,
                "title": "my-simple-and-understandable-solution-using-c",
                "content": "First we will traverse through first linked list and store the nodes in a stack. Then we\\'ll traverse through second linked list and store the nodes in another stack. Then we will traverse through the stacks until the topmost elements of both stacks are not equal. This way we will find out at which point both linked list differs. Also we have to store the previous node so that we will be able to return the intersection point of boh linked list. \\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* first=headA;\\n        stack<ListNode*> a;\\n        stack<ListNode*> b;\\n        while(first!=NULL){\\n            a.push(first);\\n            first=first->next;\\n        }\\n        first=headB;\\n        while(first!=NULL){\\n            b.push(first);\\n            first=first->next;\\n        }\\n        while(a.top()==b.top()){\\n            first=a.top();\\n            a.pop();\\n            b.pop();\\n            if(a.empty() || b.empty())\\n                break;\\n        }\\n        return first;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "First we will traverse through first linked list and store the nodes in a stack. Then we\\'ll traverse through second linked list and store the nodes in another stack. Then we will traverse through the stacks until the topmost elements of both stacks are not equal. This way we will find out at which point both linked list differs. Also we have to store the previous node so that we will be able to return the intersection point of boh linked list. \\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* first=headA;\\n        stack<ListNode*> a;\\n        stack<ListNode*> b;\\n        while(first!=NULL){\\n            a.push(first);\\n            first=first->next;\\n        }\\n        first=headB;\\n        while(first!=NULL){\\n            b.push(first);\\n            first=first->next;\\n        }\\n        while(a.top()==b.top()){\\n            first=a.top();\\n            a.pop();\\n            b.pop();\\n            if(a.empty() || b.empty())\\n                break;\\n        }\\n        return first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093943,
                "title": "c-mark-nodes-as-visited-with-negative-value-o-n-m-time-o-1-space-with-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        // The key to make it O(1) space is **Each value on each linked list is in the range [1, 10^9].**\\n        // So just make each value negative to mark it as visited in the first list O(n) time\\n        // then iterate the second list until find a negative value, which is the answer O(m) time\\n        // and do another pass to put the positive value back to the first list O(m) time\\n        \\n        ListNode curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val *= -1;\\n            curr = curr.next;\\n        }\\n        \\n        curr = headB;\\n        ListNode ans = null;\\n        while (curr != null)\\n        {\\n            if (curr.val < 1)\\n            {\\n                ans = curr;\\n                break;\\n            }  \\n            curr = curr.next;\\n        }\\n        \\n        curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val = Math.Abs(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        // The key to make it O(1) space is **Each value on each linked list is in the range [1, 10^9].**\\n        // So just make each value negative to mark it as visited in the first list O(n) time\\n        // then iterate the second list until find a negative value, which is the answer O(m) time\\n        // and do another pass to put the positive value back to the first list O(m) time\\n        \\n        ListNode curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val *= -1;\\n            curr = curr.next;\\n        }\\n        \\n        curr = headB;\\n        ListNode ans = null;\\n        while (curr != null)\\n        {\\n            if (curr.val < 1)\\n            {\\n                ans = curr;\\n                break;\\n            }  \\n            curr = curr.next;\\n        }\\n        \\n        curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val = Math.Abs(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056028,
                "title": "c-super-simple-easy-clear-solution-o-n-time-o-1-memory",
                "content": "\\tclass Solution {\\n\\tprivate:\\n\\t\\tvoid changeSign(ListNode *head){\\n\\t\\t\\twhile ( head )\\n\\t\\t\\t{\\n\\t\\t\\t\\thead->val *= -1;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\t\\theadB = headB->next;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tchangeSign( headA );\\n\\t\\t\\treturn headB;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tvoid changeSign(ListNode *head){\\n\\t\\t\\twhile ( head )\\n\\t\\t\\t{\\n\\t\\t\\t\\thead->val *= -1;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 922285,
                "title": "very-simple-o-n-o-1-solution-with-changing-value-of-first-list-to-negative-kotlin",
                "content": "Since we know that all values are > 0 we can \\n1. go through the first list and change all thems to negative value\\n2. traverse second list until first negative element found, keep it as intersection node\\n3. revert value changes in the first list\\n4. return the kept intersection node\\n\\n```\\nclass Solution {\\n    fun getIntersectionNode(headA:ListNode?, headB:ListNode?):ListNode? {\\n        var curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        val intersectionNode = findIntersection(headB)\\n        \\n        curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        return intersectionNode\\n    }\\n    \\n    private fun findIntersection(headB:ListNode?) : ListNode? {\\n        var curr = headB\\n        while (curr != null) {\\n            if (curr.`val` < 0) return curr\\n            curr = curr.next\\n        }\\n        return null\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getIntersectionNode(headA:ListNode?, headB:ListNode?):ListNode? {\\n        var curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        val intersectionNode = findIntersection(headB)\\n        \\n        curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        return intersectionNode\\n    }\\n    \\n    private fun findIntersection(headB:ListNode?) : ListNode? {\\n        var curr = headB\\n        while (curr != null) {\\n            if (curr.`val` < 0) return curr\\n            curr = curr.next\\n        }\\n        return null\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908635,
                "title": "golang-solution-with-map",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    if headA == nil || headB == nil {\\n        return nil\\n    }\\n    hasVisited := make(map[*ListNode]bool)\\n    \\n    for n := headA; n != nil; n = n.Next{\\n        hasVisited[n] = true\\n    }\\n    \\n    for n := headB; n != nil; n = n.Next{\\n        if _, ok := hasVisited[n]; ok {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    if headA == nil || headB == nil {\\n        return nil\\n    }\\n    hasVisited := make(map[*ListNode]bool)\\n    \\n    for n := headA; n != nil; n = n.Next{\\n        hasVisited[n] = true\\n    }\\n    \\n    for n := headB; n != nil; n = n.Next{\\n        if _, ok := hasVisited[n]; ok {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615363,
                "title": "java-2-loops",
                "content": "Orig: https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null)  return null;\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null)  return null;\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396690,
                "title": "python-easy-to-understand-6-methods",
                "content": "```\\n# -*- coding: utf-8 -*-\\n# @Time    : 2019/10/2 7:30\\n# @Author  : LI Dongdong\\n# @FileName: lc 160.py\\n\\n############\\u9898\\u76EE\\u5206\\u6790##########################\\n\"\"\"\\n1.\\u8981\\u6C42\\uFF1A\\u627E\\u51FA\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF1B\\u65E0intersection\\u65F6\\u8FD4\\u56DEnull\\uFF1B\\n\\u94FE\\u8868\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u5047\\u8BBE\\u94FE\\u8868\\u65E0\\u73AF; O(n) time and use only O(1) memory\\n2.\\u7406\\u89E3\\uFF1A\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF0C\\u5373\\u5730\\u5740\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u5373nodeA == nodeB\\uFF0C\\u6B64\\u65F6nodeA.val=nodeB.val,nodeA.next=nodeB.next\\n(\\u6CE8\\u610F\\uFF1Aval\\u76F8\\u540C\\uFF0Cnext\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\u7684\\u5730\\u5740\\u4E0D\\u4E00\\u5B9A\\u76F8\\u540C\\uFF0C\\u6545\\u4E0D\\u4E00\\u5B9A\\u76F8\\u7B49)\\n\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784->\\u4E0D\\u6784\\u5EFA\\u65B0\\u7684\\u94FE\\u8868\\uFF1BO(1) memory->iterative method;\\n3.\\u7C7B\\u578B\\uFF1A\\u94FE\\u8868\\u9898\\uFF1B\\u4E24\\u5355\\u94FE\\u8868\\uFF1B\\u627E\\u4EA4\\u70B9\\n4.\\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A\\u94FE\\u8868\\u4E3ANone\\uFF1B\\u4E3A\\u8282\\u70B9\\n\"\"\"\\n\\n########################   brute force   ##########################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7684time complex \\u662FO(mn), leetcode\\u8D85\\u65F6\\uFF0C\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1Afor each node a in list A, traverse the entire list B and check if any node\\nin list B coincides with a\\n\\u65B9\\u6CD5\\uFF1A\\u5185\\u5916\\u4E24\\u4E2Awhile\\u5FAA\\u73AF\\uFF08for\\u5FAA\\u73AF\\u9700\\u8981\\u8BA1\\u7B97list\\u957F\\u5EA6\\uFF09\\uFF0C\\u4E0D\\u65AD\\u8FED\\u4EE3\\uFF0C\\u9047\\u5230\\u76F8\\u540C\\u5730\\u5740\\u7684\\u5219\\u8FD4\\u56DEnode\\uFF0C\\n\\u5168\\u4E0D\\u76F8\\u540C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(mn)\\nspace complex: O(1)\\n\\'\\'\\'\\n\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        while headA:\\n            currB = headB\\n            while currB:\\n                if headA == currB:\\n                    return headA\\n                else:\\n                    currB = currB.next\\n            headA = headA.next\\n        return None\\n\\n###########################  Hash Table  ##############################\\n\\'\\'\\'\\n\\u65B0\\u65B9\\u6CD5\\n\\u601D\\u8DEF\\uFF1A\\u628AA\\u7684\\u5404\\u4E2A\\u8282\\u70B9/\\u8282\\u70B9\\u7684\\u5730\\u5740\\u5B58\\u5165\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\u7136\\u540Etraverse\\u5404\\u4E2AB\\u8282\\u70B9\\uFF0C\\u770B\\u770B\\u6709\\u6CA1\\u6709\\u76F8\\u540C\\u7684\\n\\u65B9\\u6CD5\\uFF1AA\\u4E2D\\u6BCF\\u4E00\\u4E2Anode\\u90FD\\u4E0D\\u4E00\\u6837\\uFF0C\\u6545\\u53EF\\u4EE5\\u7528list/hash table(dic/set)\\u5B9E\\u73B0\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\n\\u4F46\\u662F\\u7531\\u4E8Ehash table\\u7684time complexity\\u4E3AO(1), \\u800Clist\\u4E3AO(n), \\u6545\\u4F7F\\u7528hash table\\u5B9E\\u73B0\\uFF0C\\u7136\\u540Etraverse B\\u4E2Dnode\\n\\u7528 X in hash table \\u6765\\u5B9E\\u73B0\\u5224\\u65AD\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u6DFB\\u52A0\\u65F6O(m)\\uFF0C\\u8FED\\u4EE3\\u65F6O(n)\\uFF0C\\u67E5\\u8BE2\\u65F6O(1),\\u6545\\u603B\\u8BA1\\u4E3AO(m+n+1) \\n\\u800C\\u7528list\\u7684\\u67E5\\u8BE2time complex \\u65F6O(n),\\u603B\\u8BA1\\u4E3AO(m+2n)\\n->\\u7591\\u95EE\\uFF1Flist\\u8D85\\u65F6\\uFF0C\\u4F46\\u662F\\u4ED6\\u4E0Etwo pointer method 1 \\u76F8\\u6BD4\\u770B\\u8D77\\u6765\\u5DEE\\u522B\\u4E0D\\u5927\\n->\\u53EF\\u80FD\\u56E0\\u4E3Atpm 1\\u7684\\u6700\\u5927\\u662FO(2m+2n)\\uFF0C\\u4F46\\u662F\\u5E73\\u65F6\\u8FDC\\u672A\\u5230\\uFF0C\\u800C\\u7528list\\uFF0C\\u4E00\\u5B9A\\u662FO(m+2n)\\nspace complex: max(O(m),O(n))\\n\\'\\'\\'\\nclass Solution:\\n    class Solution:\\n        def getIntersectionNode(self, headA, headB):\\n            if headA == None or headB == None:\\n                return None\\n            hash_table = {}\\n            # or hash_table = set()\\n            while headA:\\n                hash_table[headA] = 1\\n                #hash_table.add(headA)\\n                headA = headA.next\\n            while headB:\\n                if headB in hash_table:\\n                    return headB\\n                else:\\n                    headB = headB.next\\n            return None\\n\\'\\'\\'\\n\\u5982\\u4E0B\\u4EE3\\u7801\\u6709\\u9519\\u8BEF\\uFF0C\\u56E0\\u4E3Acontinue\\uFF0C\\u6545headB = headB.next \\u6CA1\\u6709\\u8FD0\\u884C\\n                else:\\n                    continue\\n                headB = headB.next\\n\\'\\'\\'\\n######################## reduce gap method ##########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u5206\\u522B\\u4ECE\\u4E24\\u6BB5\\u76F8\\u540C\\u957F\\u5EA6\\u7684\\u8D77\\u59CB\\u70B9\\u5F00\\u59CB\\u5F80\\u540Eiterative\\n\\u65B9\\u6CD5\\uFF1A\\u6C42\\u957F\\u5EA6\\u5DEE\\u5F02->\\u79FB\\u52A8\\u8F83\\u957F\\u6BB5\\u7684pointer\\u5230\\u4E0E\\u8F83\\u77ED\\u6BB5\\u76F8\\u540C\\u7684\\u957F\\u5EA6\\u5904-\\u300B\\u4E24\\u6761\\u94FE\\u8868\\u4E00\\u8D77\\u8DD1\\uFF0C\\n\\u6700\\u591A\\u8DD1\\u516C\\u5171\\u957F\\u5EA6\\uFF0C\\u627E\\u4EA4\\u70B9\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + O(m-n) + min(O(m),O(n)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n\\n        lengthA=0\\n        while currA:\\n            lengthA+=1\\n            currA=currA.next\\n        lengthB=0\\n        while currB:\\n            lengthB+=1\\n            currB=currB.next\\n\\n        if lengthA > lengthB:\\n            gap = lengthA - lengthB\\n            while gap:\\n                headA=headA.next\\n                gap-=1\\n            while lengthB:\\n                lengthB -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA == lengthB:\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA < lengthB:\\n            gap = lengthB - lengthA\\n            while gap:\\n                headB=headB.next\\n                gap-=1\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n####################### Two pointer method 1 ###########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u540C\\u65F6\\u8FED\\u4EE3A\\u548CB\\uFF0CA\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AB\\u8FD0\\u884C\\uFF0CB\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AA\\u8FD0\\u884C\\uFF0C\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5982\\u76F8\\u9047\\u5219\\u4E3A\\u4EA4\\u70B9\\uFF0C\\u5982\\u4E0D\\u76F8\\u9047\\u5219\\u8FD4\\u56DENone\\n\\u65B9\\u6CD5\\uFF1A\\u8BBE\\u8BA1\\u5FAA\\u73AF\\uFF0C\\u5224\\u65AD\\u6761\\u4EF6\\u4E3AA\\u957F+B\\u957F\\u7684\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0CA\\u5FAA\\u73AF\\u5B8C\\u540E\\u4E3ANone\\u65F6\\uFF0C\\u7528\\u8D4B\\u503C\\u62FC\\u63A5\\u8FDE\\u63A5B\\uFF0CB\\u540C\\u7406\\uFF0C\\u5F53headA=headB\\u65F6\\u8DF3\\u51FA\\u8FD4\\u56DEhead\\uFF0C\\u5F53\\u5FAA\\u73AF\\u5B8C\\u6210\\u4E4B\\u540E\\u90FD\\u65E0\\uFF0C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)+O(m)+O(n) = 0(2m+2n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u8D4B\\u503C\\u62FC\\u63A5\\u548Cnext\\u62FC\\u63A5\\u7684\\u533A\\u522B\\n\\u8D4B\\u503C\\u62FC\\u63A5\\u4EE5\\u540E\\uFF0C\\u672A\\u6539\\u53D8\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u800C\\u5982\\u679C\\u662F\\u7528.next=\\u8FDB\\u884C\\u62FC\\u63A5\\uFF0C\\u5219\\u6539\\u53D8\\u4E86\\u539F\\u6709\\u7ED3\\u6784\\u3002\\n\\u540C\\u65F6\\u7531\\u4E8E\\u662FA\\u62FCB\\uFF0CB\\u62FCA\\uFF0C\\u90A3\\u4E48\\u8D4B\\u503C\\u62FC\\u63A5\\u7ED3\\u679C\\u662F\\u4E24\\u4E2A\\u5206\\u6BB5AB,BA,\\u800Cnext\\u62FC\\u63A5\\u662F\\u73AF A-B-A\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            currB = currB.next\\n\\n        sum_length = lengthA + lengthB\\n        tempA=headA\\n        tempB=headB\\n        while sum_length:\\n            if not headA:\\n                headA = tempB\\n            if not headB:\\n                headB = tempA\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n            sum_length -= 1\\n        return None\\n\\n#######################  Two pointer method 2 ###########################\\n\\'\\'\\'\\nTwo pointer method 1 \\u7684\\u4F18\\u5316\\u7248\\n\\u601D\\u8DEF\\uFF1A\\u4E0ETwo pointer method 1\\u76F8\\u540C\\n\\u65B9\\u6CD5\\uFF1Awhile\\u5224\\u65AD\\u6761\\u4EF6\\u6539\\u4E3AheadA!=headB\\uFF0C\\u5F53\\u6709\\u4EA4\\u53C9\\u70B9\\u4E14\\u8FD0\\u884C\\u5230\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9(headA)\\uFF1B\\n\\u5F53\\u6CA1\\u6709\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0C\\u9012\\u5F52\\u5B8C\\u4E24\\u4E2A\\u5206\\u6BB5\\uFF0C\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6307\\u5411\\u7684\\u5206\\u6BB5\\u7684\\u672B\\u5C3E\\uFF08curA = None,curB= None)\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9\\uFF08headA=None\\uFF09\\nwhile\\u5224\\u65AD\\u6761\\u4EF6\\u4E0D\\u80FD\\u7528headA==None or headB==None,\\u56E0\\u4E3Atraverse\\u5230\\u62FC\\u63A5\\u70B9\\u65F6\\uFF0CheadA or headB\\u4E5F\\u4F1A\\u4E3ANone;\\n\\u7528and\\u65F6\\uFF0C\\u82E5\\u6709\\u4EA4\\u53C9\\u70B9\\uFF0C\\u8FD8\\u8981\\u6DFB\\u52A0\\u5176\\u4ED6\\u6761\\u4EF6\\u8FDB\\u884C\\u8FD4\\u56DE\\u4EA4\\u5DEE\\u70B9\\u3002\\u6545\\u7528 while curA != curB:\\u662F\\u6700\\u597D\\u7684\\u3002\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)=O(m+n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u65B0\\u578B\\u4E66\\u5199\\u65B9\\u5F0F\\uFF1A\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            \\u4E0E\\n            curA = curA.next if curA else headB\\n            \\u76F8\\u540C\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        curA = headA\\n        curB = headB\\n        while curA != curB:\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            curB = curB.next if curB else headA\\n        return curA\\n\\n######################Two pointer method 3#######################################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7531\\u4E8E\\u7528next\\u8FDE\\u63A5\\u4E86A\\u548CB\\uFF0C\\u6539\\u53D8\\u4E86\\u539F\\u94FE\\u8868\\u7684\\u7ED3\\u6784\\uFF0C\\u6545\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1AA\\u5C3E\\u8FDEB\\u5934\\uFF0CB\\u5C3E\\u8054A\\u5934\\uFF0CA,B\\u4E24\\u5934\\u540C\\u65F6iterative\\uFF0C\\u76F8\\u9047\\u7684\\u65F6\\u5019\\u5373\\u4EA4\\u70B9\\uFF0C\\u4E0D\\u76F8\\u9047\\u5219\\u6CA1\\u6709\\u4EA4\\u70B9\\n\\u65B9\\u6CD5\\uFF1AA pointer\\u79FB\\u52A8\\u5230\\u672B\\u5C3E\\uFF0C\\u540E\\u8FDE\\u63A5B\\u5934\\uFF1BB\\u540C\\u6837\\u505A->\\u540C\\u65F6\\u4ECEA,B\\u5934\\u5F00\\u59CB\\u79FB\\u52A8\\uFF0C\\u6700\\u591A\\u79FB\\u52A8m+n\\u6B21\\uFF0C\\u76F8\\u7B49\\u5219\\u8FD4\\u56DEnode\\uFF0C\\u5168\\u90E8\\u4E0D\\u80FD\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + max(O(n),O(m)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA = headA\\n        currB = headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            prevA = currA\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            prevB = currB\\n            currB = currB.next\\n\\n        prevA.next = headB\\n        prevB.next = headA\\n\\n        sum_length = lengthA + lengthB\\n        while sum_length:\\n            sum_length -= 1\\n            if headA == headB:\\n                return headA\\n            else:\\n                headA = headA.next\\n                headB = headB.next\\n        return None\\n\\n######################\\u6784\\u9020\\u4EA4\\u53C9\\u94FE\\u8868######################################\\nA1 = ListNode(4)\\nA2 = ListNode(1)\\n\\nB1 = ListNode(5)\\nB2 = ListNode(0)\\nB3 = ListNode(1)\\n\\nC1 = ListNode(8)\\nC2= ListNode(4)\\nC3= ListNode(5)\\n\\n\\n\\nA1.next = A2\\nA2.next=C1\\nC1.next=C2\\nC2.next=C3\\n\\nB1.next=B2\\nB2.next=B3\\nB3.next=C1\\n\\n\\nrl = Solution()\\nrl.getIntersectionNode(A1,B1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# -*- coding: utf-8 -*-\\n# @Time    : 2019/10/2 7:30\\n# @Author  : LI Dongdong\\n# @FileName: lc 160.py\\n\\n############\\u9898\\u76EE\\u5206\\u6790##########################\\n\"\"\"\\n1.\\u8981\\u6C42\\uFF1A\\u627E\\u51FA\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF1B\\u65E0intersection\\u65F6\\u8FD4\\u56DEnull\\uFF1B\\n\\u94FE\\u8868\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u5047\\u8BBE\\u94FE\\u8868\\u65E0\\u73AF; O(n) time and use only O(1) memory\\n2.\\u7406\\u89E3\\uFF1A\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF0C\\u5373\\u5730\\u5740\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u5373nodeA == nodeB\\uFF0C\\u6B64\\u65F6nodeA.val=nodeB.val,nodeA.next=nodeB.next\\n(\\u6CE8\\u610F\\uFF1Aval\\u76F8\\u540C\\uFF0Cnext\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\u7684\\u5730\\u5740\\u4E0D\\u4E00\\u5B9A\\u76F8\\u540C\\uFF0C\\u6545\\u4E0D\\u4E00\\u5B9A\\u76F8\\u7B49)\\n\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784->\\u4E0D\\u6784\\u5EFA\\u65B0\\u7684\\u94FE\\u8868\\uFF1BO(1) memory->iterative method;\\n3.\\u7C7B\\u578B\\uFF1A\\u94FE\\u8868\\u9898\\uFF1B\\u4E24\\u5355\\u94FE\\u8868\\uFF1B\\u627E\\u4EA4\\u70B9\\n4.\\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A\\u94FE\\u8868\\u4E3ANone\\uFF1B\\u4E3A\\u8282\\u70B9\\n\"\"\"\\n\\n########################   brute force   ##########################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7684time complex \\u662FO(mn), leetcode\\u8D85\\u65F6\\uFF0C\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1Afor each node a in list A, traverse the entire list B and check if any node\\nin list B coincides with a\\n\\u65B9\\u6CD5\\uFF1A\\u5185\\u5916\\u4E24\\u4E2Awhile\\u5FAA\\u73AF\\uFF08for\\u5FAA\\u73AF\\u9700\\u8981\\u8BA1\\u7B97list\\u957F\\u5EA6\\uFF09\\uFF0C\\u4E0D\\u65AD\\u8FED\\u4EE3\\uFF0C\\u9047\\u5230\\u76F8\\u540C\\u5730\\u5740\\u7684\\u5219\\u8FD4\\u56DEnode\\uFF0C\\n\\u5168\\u4E0D\\u76F8\\u540C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(mn)\\nspace complex: O(1)\\n\\'\\'\\'\\n\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        while headA:\\n            currB = headB\\n            while currB:\\n                if headA == currB:\\n                    return headA\\n                else:\\n                    currB = currB.next\\n            headA = headA.next\\n        return None\\n\\n###########################  Hash Table  ##############################\\n\\'\\'\\'\\n\\u65B0\\u65B9\\u6CD5\\n\\u601D\\u8DEF\\uFF1A\\u628AA\\u7684\\u5404\\u4E2A\\u8282\\u70B9/\\u8282\\u70B9\\u7684\\u5730\\u5740\\u5B58\\u5165\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\u7136\\u540Etraverse\\u5404\\u4E2AB\\u8282\\u70B9\\uFF0C\\u770B\\u770B\\u6709\\u6CA1\\u6709\\u76F8\\u540C\\u7684\\n\\u65B9\\u6CD5\\uFF1AA\\u4E2D\\u6BCF\\u4E00\\u4E2Anode\\u90FD\\u4E0D\\u4E00\\u6837\\uFF0C\\u6545\\u53EF\\u4EE5\\u7528list/hash table(dic/set)\\u5B9E\\u73B0\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\n\\u4F46\\u662F\\u7531\\u4E8Ehash table\\u7684time complexity\\u4E3AO(1), \\u800Clist\\u4E3AO(n), \\u6545\\u4F7F\\u7528hash table\\u5B9E\\u73B0\\uFF0C\\u7136\\u540Etraverse B\\u4E2Dnode\\n\\u7528 X in hash table \\u6765\\u5B9E\\u73B0\\u5224\\u65AD\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u6DFB\\u52A0\\u65F6O(m)\\uFF0C\\u8FED\\u4EE3\\u65F6O(n)\\uFF0C\\u67E5\\u8BE2\\u65F6O(1),\\u6545\\u603B\\u8BA1\\u4E3AO(m+n+1) \\n\\u800C\\u7528list\\u7684\\u67E5\\u8BE2time complex \\u65F6O(n),\\u603B\\u8BA1\\u4E3AO(m+2n)\\n->\\u7591\\u95EE\\uFF1Flist\\u8D85\\u65F6\\uFF0C\\u4F46\\u662F\\u4ED6\\u4E0Etwo pointer method 1 \\u76F8\\u6BD4\\u770B\\u8D77\\u6765\\u5DEE\\u522B\\u4E0D\\u5927\\n->\\u53EF\\u80FD\\u56E0\\u4E3Atpm 1\\u7684\\u6700\\u5927\\u662FO(2m+2n)\\uFF0C\\u4F46\\u662F\\u5E73\\u65F6\\u8FDC\\u672A\\u5230\\uFF0C\\u800C\\u7528list\\uFF0C\\u4E00\\u5B9A\\u662FO(m+2n)\\nspace complex: max(O(m),O(n))\\n\\'\\'\\'\\nclass Solution:\\n    class Solution:\\n        def getIntersectionNode(self, headA, headB):\\n            if headA == None or headB == None:\\n                return None\\n            hash_table = {}\\n            # or hash_table = set()\\n            while headA:\\n                hash_table[headA] = 1\\n                #hash_table.add(headA)\\n                headA = headA.next\\n            while headB:\\n                if headB in hash_table:\\n                    return headB\\n                else:\\n                    headB = headB.next\\n            return None\\n\\'\\'\\'\\n\\u5982\\u4E0B\\u4EE3\\u7801\\u6709\\u9519\\u8BEF\\uFF0C\\u56E0\\u4E3Acontinue\\uFF0C\\u6545headB = headB.next \\u6CA1\\u6709\\u8FD0\\u884C\\n                else:\\n                    continue\\n                headB = headB.next\\n\\'\\'\\'\\n######################## reduce gap method ##########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u5206\\u522B\\u4ECE\\u4E24\\u6BB5\\u76F8\\u540C\\u957F\\u5EA6\\u7684\\u8D77\\u59CB\\u70B9\\u5F00\\u59CB\\u5F80\\u540Eiterative\\n\\u65B9\\u6CD5\\uFF1A\\u6C42\\u957F\\u5EA6\\u5DEE\\u5F02->\\u79FB\\u52A8\\u8F83\\u957F\\u6BB5\\u7684pointer\\u5230\\u4E0E\\u8F83\\u77ED\\u6BB5\\u76F8\\u540C\\u7684\\u957F\\u5EA6\\u5904-\\u300B\\u4E24\\u6761\\u94FE\\u8868\\u4E00\\u8D77\\u8DD1\\uFF0C\\n\\u6700\\u591A\\u8DD1\\u516C\\u5171\\u957F\\u5EA6\\uFF0C\\u627E\\u4EA4\\u70B9\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + O(m-n) + min(O(m),O(n)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n\\n        lengthA=0\\n        while currA:\\n            lengthA+=1\\n            currA=currA.next\\n        lengthB=0\\n        while currB:\\n            lengthB+=1\\n            currB=currB.next\\n\\n        if lengthA > lengthB:\\n            gap = lengthA - lengthB\\n            while gap:\\n                headA=headA.next\\n                gap-=1\\n            while lengthB:\\n                lengthB -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA == lengthB:\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA < lengthB:\\n            gap = lengthB - lengthA\\n            while gap:\\n                headB=headB.next\\n                gap-=1\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n####################### Two pointer method 1 ###########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u540C\\u65F6\\u8FED\\u4EE3A\\u548CB\\uFF0CA\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AB\\u8FD0\\u884C\\uFF0CB\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AA\\u8FD0\\u884C\\uFF0C\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5982\\u76F8\\u9047\\u5219\\u4E3A\\u4EA4\\u70B9\\uFF0C\\u5982\\u4E0D\\u76F8\\u9047\\u5219\\u8FD4\\u56DENone\\n\\u65B9\\u6CD5\\uFF1A\\u8BBE\\u8BA1\\u5FAA\\u73AF\\uFF0C\\u5224\\u65AD\\u6761\\u4EF6\\u4E3AA\\u957F+B\\u957F\\u7684\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0CA\\u5FAA\\u73AF\\u5B8C\\u540E\\u4E3ANone\\u65F6\\uFF0C\\u7528\\u8D4B\\u503C\\u62FC\\u63A5\\u8FDE\\u63A5B\\uFF0CB\\u540C\\u7406\\uFF0C\\u5F53headA=headB\\u65F6\\u8DF3\\u51FA\\u8FD4\\u56DEhead\\uFF0C\\u5F53\\u5FAA\\u73AF\\u5B8C\\u6210\\u4E4B\\u540E\\u90FD\\u65E0\\uFF0C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)+O(m)+O(n) = 0(2m+2n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u8D4B\\u503C\\u62FC\\u63A5\\u548Cnext\\u62FC\\u63A5\\u7684\\u533A\\u522B\\n\\u8D4B\\u503C\\u62FC\\u63A5\\u4EE5\\u540E\\uFF0C\\u672A\\u6539\\u53D8\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u800C\\u5982\\u679C\\u662F\\u7528.next=\\u8FDB\\u884C\\u62FC\\u63A5\\uFF0C\\u5219\\u6539\\u53D8\\u4E86\\u539F\\u6709\\u7ED3\\u6784\\u3002\\n\\u540C\\u65F6\\u7531\\u4E8E\\u662FA\\u62FCB\\uFF0CB\\u62FCA\\uFF0C\\u90A3\\u4E48\\u8D4B\\u503C\\u62FC\\u63A5\\u7ED3\\u679C\\u662F\\u4E24\\u4E2A\\u5206\\u6BB5AB,BA,\\u800Cnext\\u62FC\\u63A5\\u662F\\u73AF A-B-A\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            currB = currB.next\\n\\n        sum_length = lengthA + lengthB\\n        tempA=headA\\n        tempB=headB\\n        while sum_length:\\n            if not headA:\\n                headA = tempB\\n            if not headB:\\n                headB = tempA\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n            sum_length -= 1\\n        return None\\n\\n#######################  Two pointer method 2 ###########################\\n\\'\\'\\'\\nTwo pointer method 1 \\u7684\\u4F18\\u5316\\u7248\\n\\u601D\\u8DEF\\uFF1A\\u4E0ETwo pointer method 1\\u76F8\\u540C\\n\\u65B9\\u6CD5\\uFF1Awhile\\u5224\\u65AD\\u6761\\u4EF6\\u6539\\u4E3AheadA!=headB\\uFF0C\\u5F53\\u6709\\u4EA4\\u53C9\\u70B9\\u4E14\\u8FD0\\u884C\\u5230\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9(headA)\\uFF1B\\n\\u5F53\\u6CA1\\u6709\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0C\\u9012\\u5F52\\u5B8C\\u4E24\\u4E2A\\u5206\\u6BB5\\uFF0C\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6307\\u5411\\u7684\\u5206\\u6BB5\\u7684\\u672B\\u5C3E\\uFF08curA = None,curB= None)\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9\\uFF08headA=None\\uFF09\\nwhile\\u5224\\u65AD\\u6761\\u4EF6\\u4E0D\\u80FD\\u7528headA==None or headB==None,\\u56E0\\u4E3Atraverse\\u5230\\u62FC\\u63A5\\u70B9\\u65F6\\uFF0CheadA or headB\\u4E5F\\u4F1A\\u4E3ANone;\\n\\u7528and\\u65F6\\uFF0C\\u82E5\\u6709\\u4EA4\\u53C9\\u70B9\\uFF0C\\u8FD8\\u8981\\u6DFB\\u52A0\\u5176\\u4ED6\\u6761\\u4EF6\\u8FDB\\u884C\\u8FD4\\u56DE\\u4EA4\\u5DEE\\u70B9\\u3002\\u6545\\u7528 while curA != curB:\\u662F\\u6700\\u597D\\u7684\\u3002\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)=O(m+n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u65B0\\u578B\\u4E66\\u5199\\u65B9\\u5F0F\\uFF1A\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            \\u4E0E\\n            curA = curA.next if curA else headB\\n            \\u76F8\\u540C\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        curA = headA\\n        curB = headB\\n        while curA != curB:\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            curB = curB.next if curB else headA\\n        return curA\\n\\n######################Two pointer method 3#######################################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7531\\u4E8E\\u7528next\\u8FDE\\u63A5\\u4E86A\\u548CB\\uFF0C\\u6539\\u53D8\\u4E86\\u539F\\u94FE\\u8868\\u7684\\u7ED3\\u6784\\uFF0C\\u6545\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1AA\\u5C3E\\u8FDEB\\u5934\\uFF0CB\\u5C3E\\u8054A\\u5934\\uFF0CA,B\\u4E24\\u5934\\u540C\\u65F6iterative\\uFF0C\\u76F8\\u9047\\u7684\\u65F6\\u5019\\u5373\\u4EA4\\u70B9\\uFF0C\\u4E0D\\u76F8\\u9047\\u5219\\u6CA1\\u6709\\u4EA4\\u70B9\\n\\u65B9\\u6CD5\\uFF1AA pointer\\u79FB\\u52A8\\u5230\\u672B\\u5C3E\\uFF0C\\u540E\\u8FDE\\u63A5B\\u5934\\uFF1BB\\u540C\\u6837\\u505A->\\u540C\\u65F6\\u4ECEA,B\\u5934\\u5F00\\u59CB\\u79FB\\u52A8\\uFF0C\\u6700\\u591A\\u79FB\\u52A8m+n\\u6B21\\uFF0C\\u76F8\\u7B49\\u5219\\u8FD4\\u56DEnode\\uFF0C\\u5168\\u90E8\\u4E0D\\u80FD\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + max(O(n),O(m)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA = headA\\n        currB = headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            prevA = currA\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            prevB = currB\\n            currB = currB.next\\n\\n        prevA.next = headB\\n        prevB.next = headA\\n\\n        sum_length = lengthA + lengthB\\n        while sum_length:\\n            sum_length -= 1\\n            if headA == headB:\\n                return headA\\n            else:\\n                headA = headA.next\\n                headB = headB.next\\n        return None\\n\\n######################\\u6784\\u9020\\u4EA4\\u53C9\\u94FE\\u8868######################################\\nA1 = ListNode(4)\\nA2 = ListNode(1)\\n\\nB1 = ListNode(5)\\nB2 = ListNode(0)\\nB3 = ListNode(1)\\n\\nC1 = ListNode(8)\\nC2= ListNode(4)\\nC3= ListNode(5)\\n\\n\\n\\nA1.next = A2\\nA2.next=C1\\nC1.next=C2\\nC2.next=C3\\n\\nB1.next=B2\\nB2.next=B3\\nB3.next=C1\\n\\n\\nrl = Solution()\\nrl.getIntersectionNode(A1,B1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342805,
                "title": "hashtable-solution-o-m-n",
                "content": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        hash_table_A = {}\\n        while headA != None:\\n            hash_table_A[headA] = headA.next\\n            headA = headA.next\\n        while headB != None:\\n            if headB in hash_table_A:\\n                return headB\\n            headB = headB.next\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        hash_table_A = {}\\n        while headA != None:\\n            hash_table_A[headA] = headA.next\\n            headA = headA.next\\n        while headB != None:\\n            if headB in hash_table_A:\\n                return headB\\n            headB = headB.next\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268844,
                "title": "example-1-why-is-it-intersection-at-8",
                "content": "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nOutput: Reference of the node with value = 8\\nInput Explanation: The intersected node\\'s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\\n\\nDon\\'t listA and listB intersect at node=1? I even fail the test case for it. Here is my code for reference:\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null) {\\n            return null;\\n        }\\n        \\n        // Calculate length of each list\\n        ListNode temp = headA;\\n        int lengthA = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthA++;\\n            //temp = temp.next;\\n        }\\n        \\n        temp = headB;\\n        int lengthB = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthB++;\\n            //temp = temp.next;\\n        }\\n        \\n        // Determine which list is longer\\n        ListNode longer = lengthA > lengthB ? headA : headB;\\n        ListNode shorter = lengthA < lengthB ? headA : headB;\\n        \\n        // Move the longer pointer so its aligned with the shorter\\n        int diff = Math.abs(lengthA - lengthB);\\n        for(int i = 0; i < diff; i++) {\\n            longer = longer.next;\\n        }\\n        \\n        // Find intersection point\\n        while(longer != null && shorter != null) {\\n            if(longer.val == shorter.val) {\\n                return longer;\\n            }\\n            longer = longer.next;\\n            shorter = shorter.next;\\n        }\\n        \\n        return null;\\n    } \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null) {\\n            return null;\\n        }\\n        \\n        // Calculate length of each list\\n        ListNode temp = headA;\\n        int lengthA = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthA++;\\n            //temp = temp.next;\\n        }\\n        \\n        temp = headB;\\n        int lengthB = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthB++;\\n            //temp = temp.next;\\n        }\\n        \\n        // Determine which list is longer\\n        ListNode longer = lengthA > lengthB ? headA : headB;\\n        ListNode shorter = lengthA < lengthB ? headA : headB;\\n        \\n        // Move the longer pointer so its aligned with the shorter\\n        int diff = Math.abs(lengthA - lengthB);\\n        for(int i = 0; i < diff; i++) {\\n            longer = longer.next;\\n        }\\n        \\n        // Find intersection point\\n        while(longer != null && shorter != null) {\\n            if(longer.val == shorter.val) {\\n                return longer;\\n            }\\n            longer = longer.next;\\n            shorter = shorter.next;\\n        }\\n        \\n        return null;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020914,
                "title": "two-pointer-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n# Two Pointer Approach\\nHere\\'s a step-by-step explanation of your getIntersectionNode function:\\n\\nNull Check: You begin by checking if either of the input linked lists (headA or headB) is empty. If either of them is empty (i.e., NULL), there can be no intersection, so you immediately return NULL.\\n\\nInitialization: You initialize two pointers, temp1 and temp2, which initially point to the heads of the two linked lists, headA and headB, respectively.\\n\\nIntersection Detection Loop: You enter a loop that continues until temp1 and temp2 point to the same node (i.e., they intersect). Within the loop:\\n\\nYou check if temp1 has reached the end of headA (i.e., temp1 == NULL). If it has, you reset temp1 to the head of headB. This step is essential because if temp1 reaches the end of headA and continues into headB, it ensures that temp1 and temp2 travel the same distance when searching for the intersection point.\\n\\nSimilarly, you check if temp2 has reached the end of headB (i.e., temp2 == NULL). If it has, you reset temp2 to the head of headA. Again, this step maintains the balance in the distances traveled by temp1 and temp2.\\n\\nIn each iteration of the loop, both temp1 and temp2 move one step forward in their respective linked lists. This step is crucial because it allows the pointers to eventually meet at the intersection point if one exists.\\n\\nReturn Intersection Point: Once the loop exits, it means that temp1 and temp2 have met at the intersection point if there is one. You return either temp1 or temp2 (they are now pointing to the same intersection node) as the result.\\n\\nThis approach works because it effectively balances the traversal lengths of headA and headB, ensuring that both pointers start from the other linked list when they reach the end of their respective lists. When they eventually meet, it\\'s guaranteed to be at the intersection point, or NULL if there is no intersection.\\n\\nThe time complexity of this approach is O(m + n), where m and n are the lengths of headA and headB respectively, as both pointers traverse their respective lists once.\\n\\nThe space complexity is O(1) because you are using only a constant amount of additional memory for the two pointers and some temporary variables.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(M+N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n        {\\n            return NULL;\\n        }\\n        ListNode *temp1=headA;\\n        ListNode *temp2=headB;\\n\\n        while(temp1!=temp2)\\n        {\\n            if(temp1==NULL)\\n            {\\n                temp1=headB;\\n            }else\\n            temp1=temp1->next;\\n            if(temp2==NULL)\\n            {\\n                temp2=headA;\\n            }else\\n            temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n        {\\n            return NULL;\\n        }\\n        ListNode *temp1=headA;\\n        ListNode *temp2=headB;\\n\\n        while(temp1!=temp2)\\n        {\\n            if(temp1==NULL)\\n            {\\n                temp1=headB;\\n            }else\\n            temp1=temp1->next;\\n            if(temp2==NULL)\\n            {\\n                temp2=headA;\\n            }else\\n            temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985657,
                "title": "python-94-40-faster-o-1-space-2-approaches",
                "content": "```\\n#Time Complexity: O(n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        s=set()\\n        while headA:\\n            s.add(headA)\\n            headA=headA.next\\n        while headB:\\n            if headB in s:\\n                return headB\\n            headB=headB.next\\n        return None\\n\\n#Time Complexity: O(n)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        c1=c2=0\\n        temp1,temp2=headA,headB\\n        while temp1 or temp2:\\n            if temp1:\\n                c1+=1\\n                temp1=temp1.next\\n            if temp2:\\n                c2+=1\\n                temp2=temp2.next\\n        c=c1-c2\\n        if c<0:\\n            while c!=0:\\n                headB=headB.next\\n                c+=1\\n        else:\\n            while c!=0:\\n                headA=headA.next\\n                c-=1\\n        while headA:\\n            if headA==headB:\\n                return headA\\n            headA=headA.next\\n            headB=headB.next\\n        return headA\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n#Time Complexity: O(n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        s=set()\\n        while headA:\\n            s.add(headA)\\n            headA=headA.next\\n        while headB:\\n            if headB in s:\\n                return headB\\n            headB=headB.next\\n        return None\\n\\n#Time Complexity: O(n)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        c1=c2=0\\n        temp1,temp2=headA,headB\\n        while temp1 or temp2:\\n            if temp1:\\n                c1+=1\\n                temp1=temp1.next\\n            if temp2:\\n                c2+=1\\n                temp2=temp2.next\\n        c=c1-c2\\n        if c<0:\\n            while c!=0:\\n                headB=headB.next\\n                c+=1\\n        else:\\n            while c!=0:\\n                headA=headA.next\\n                c-=1\\n        while headA:\\n            if headA==headB:\\n                return headA\\n            headA=headA.next\\n            headB=headB.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799162,
                "title": "simple-python-solution",
                "content": "\\nWe basically want to increase both A and B till they come out equal. The difference in the lengths can be managed in the same line using simple if-else.\\nJust keep on moving A and B till they become equal\\n# Code\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA and headB:\\n            A, B = headA, headB\\n            while A != B:\\n                A = A.next if A else headB\\n                B = B.next if B else headA\\n            return B\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA and headB:\\n            A, B = headA, headB\\n            while A != B:\\n                A = A.next if A else headB\\n                B = B.next if B else headA\\n            return B\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151072,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr2 != NULL) {\\n            ListNode* temp = curr1;\\n            while (temp != NULL) {\\n                if (temp == curr2)\\n                    return curr2;\\n                temp = temp->next;\\n            }\\n            curr2 = curr2->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n# Approach 2\\nHashing\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(m)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set <ListNode* > nodes;\\n        ListNode* curr = headA;\\n        while (curr != NULL) {\\n            nodes.insert(curr);\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while (curr != NULL) {\\n            if (nodes.find(curr) != nodes.end())\\n                return curr;\\n            curr = curr->next;    \\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n\\n# Approach 3\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr1 != curr2) {\\n            curr1 = curr1->next;\\n            curr2 = curr2->next;\\n            if (curr1 == curr2)\\n                return curr1;\\n            if (curr1 == NULL)\\n                curr1 = headB;\\n            if (curr2 == NULL)\\n                curr2 = headA;\\n        }\\n        return curr1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr2 != NULL) {\\n            ListNode* temp = curr1;\\n            while (temp != NULL) {\\n                if (temp == curr2)\\n                    return curr2;\\n                temp = temp->next;\\n            }\\n            curr2 = curr2->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set <ListNode* > nodes;\\n        ListNode* curr = headA;\\n        while (curr != NULL) {\\n            nodes.insert(curr);\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while (curr != NULL) {\\n            if (nodes.find(curr) != nodes.end())\\n                return curr;\\n            curr = curr->next;    \\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr1 != curr2) {\\n            curr1 = curr1->next;\\n            curr2 = curr2->next;\\n            if (curr1 == curr2)\\n                return curr1;\\n            if (curr1 == NULL)\\n                curr1 = headB;\\n            if (curr2 == NULL)\\n                curr2 = headA;\\n        }\\n        return curr1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136735,
                "title": "most-optimal-java-sol-1ms-98-6-beats",
                "content": "# Intuition\\n1) put dumm 1 & dummy 2 node on both heads then move them one by one.\\n2) when one reaches end or null put that dummy node at head of other list i.e. dummy1==null then dummy1 = head2.\\n3) after dummy 1 when dummy2 will reach null put it at head1.\\n4) and now at this point the length of both lists from both dummy to end will be equal.\\n5) if they refer to same address while iterating return it.\\n6) otherwise if they reach null together there is no intersection.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2m) m length of greater list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    if(headA==null || headB==null)  return null;\\n    ListNode a = headA;\\n    ListNode b = headB;\\n    while(a!=b){\\n        a = a==null ? headB : a.next;\\n        b = b==null ? headA : b.next;\\n    }\\n    return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    if(headA==null || headB==null)  return null;\\n    ListNode a = headA;\\n    ListNode b = headB;\\n    while(a!=b){\\n        a = a==null ? headB : a.next;\\n        b = b==null ? headA : b.next;\\n    }\\n    return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721631,
                "title": "very-easy-and-detailed-explanation-in-python",
                "content": "**Explanation**\\nHere we are traversing the pointers two times in the Linked List.\\nEighter of the two who will first encounter the None, are going to switch the head and continue the second traversal,\\n\\nThe idea is if you switch head, the possible difference between length would be countered. On the second traversal, they either hit or miss. \\nIf they meet, pa or pb would be the node we are looking for, if they didn\\'t meet, they will hit the end at the same iteration, pa == pb == None.\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA is None or headB is None:\\n            return None\\n\\n        pa = headA \\n        pb = headB\\n\\n        while pa is not pb:\\n            if pa is None:\\n                pa = headB \\n            else:\\n                pa=pa.next\\n            if pb is None:\\n                pb = headA \\n            else:\\n                pb=pb.next\\n\\n        return pa\\n\\n\\n```\\n![image](https://assets.leetcode.com/users/images/225dd7bc-f7c4-487e-9019-316ae9cde3fd_1666176062.6584425.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA is None or headB is None:\\n            return None\\n\\n        pa = headA \\n        pb = headB\\n\\n        while pa is not pb:\\n            if pa is None:\\n                pa = headB \\n            else:\\n                pa=pa.next\\n            if pb is None:\\n                pb = headA \\n            else:\\n                pb=pb.next\\n\\n        return pa\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278151,
                "title": "simple-python-solution-beats-96-with-comments",
                "content": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n\\n        seen = set()    #Create a set for seen nodes\\n        while headA or headB:   \\n            if headA:\\n                if headA in seen:   # If B has passed the node previously, then this is the intersect\\n                    return headA\\n                else:\\n                    seen.add(headA) # record the node if not previously seen\\n                headA = headA.next\\n                \\n            if headB:\\n                if headB in seen:\\n                    return headB\\n                else:\\n                    seen.add(headB)\\n                headB = headB.next\\n        return  # if no intersect, return None\\n\\n#If you find this solution helpful, please upvote :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n\\n        seen = set()    #Create a set for seen nodes\\n        while headA or headB:   \\n            if headA:\\n                if headA in seen:   # If B has passed the node previously, then this is the intersect\\n                    return headA\\n                else:\\n                    seen.add(headA) # record the node if not previously seen\\n                headA = headA.next\\n                \\n            if headB:\\n                if headB in seen:\\n                    return headB\\n                else:\\n                    seen.add(headB)\\n                headB = headB.next\\n        return  # if no intersect, return None\\n\\n#If you find this solution helpful, please upvote :)",
                "codeTag": "Java"
            },
            {
                "id": 2146325,
                "title": "java-intersection-of-linkedlist-with-intuition-99-faster",
                "content": "### **Intuition:**\\nSuppose list-B is shorter than list-A.\\n1) Take two pointers( \\'a\\' & \\'b\\'). Point each of them to the head of the lists. (say \\'a\\' for list-A & \\'b\\' for list-B)\\n 2) Traverse both list simultaneously. After sometime, pointer \\'b\\' on shorter list-B will reach null earlier than \\'a\\' (because list-B is smaller in length). \\n In that case, the distance of other pointer \\'a\\' (currently on list-A) to the pointer \\'b\\' (which is currently null) is the difference in length of linked-lists. (This is simple math operation, difference of lengths)\\n3) Now, we point pointer \\'b\\' to list-A\\'s head (on list-A NOT on list-B)  &  move both \\'a\\' & \\'b\\' simultaneously till \\'a\\' reaches null. (Remember both the pointers \\'a\\' & \\'b\\' are currently on same list).\\n4) When \\'a\\' reaches null, pointer \\'b\\' (on list-A) will cover a distance equal to difference of length of linked-list. This is simple maths, because previously (when \\'b\\' was null), \\'a\\' pointer was at distance equal to difference in length of linked-list.\\n5) In next iteration we place \\'a\\' on list-B\\'s head (which is shorter list).\\n     Due to this, the distance of both pointer \\'a\\' & \\'b\\' (on list-B & list-A respectively) till the end becomes equal (in short both the pointer are at equal distance from their end\\n     of linked-list). This is because \\'b\\' has already travelled the difference in lengths (of linked-list) on list-A.\\n6) Then we move both the pointers together until intersection found. \\n7) Here we guaranteed that intersection will bound to occur, as both \\'a\\' & \\'b\\' are equal distances from the ends of both the lists.\\n\\n*Please DO Upvote if you found this Helpful!* \\n\\n\\n### **Code :**\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n\\n        while (a != b){\\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n\\n        while (a != b){\\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118504,
                "title": "c-linked-list-simple-approach-with-explanation-daily-leetcoding-challenge-june-day-6",
                "content": "```\\nclass Solution {\\npublic:\\n    //define two listnodes tempA for listA and tempB for listB \\n    //and iterate over the respective list until we reach at their end \\n    //when we reach at the end, we start traversing in the opposite list\\n    //until tempA and tempB are reach at the same node \\n    //if they reach we get the intersection node otherwise if there is no intersect node\\n    //we reach at NULL and return\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *tempA = headA, *tempB = headB;\\n        \\n        if(tempA==NULL || tempB==NULL) return NULL;\\n        \\n        while(tempA!=tempB)\\n        {\\n            tempA==NULL ? tempA=headB : tempA=tempA->next;\\n            tempB==NULL ? tempB=headA : tempB=tempB->next;\\n        }\\n        \\n        return tempA;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //define two listnodes tempA for listA and tempB for listB \\n    //and iterate over the respective list until we reach at their end \\n    //when we reach at the end, we start traversing in the opposite list\\n    //until tempA and tempB are reach at the same node \\n    //if they reach we get the intersection node otherwise if there is no intersect node\\n    //we reach at NULL and return\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *tempA = headA, *tempB = headB;\\n        \\n        if(tempA==NULL || tempB==NULL) return NULL;\\n        \\n        while(tempA!=tempB)\\n        {\\n            tempA==NULL ? tempA=headB : tempA=tempA->next;\\n            tempB==NULL ? tempB=headA : tempB=tempB->next;\\n        }\\n        \\n        return tempA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118189,
                "title": "c-optimal-solution-explained-super-smooth",
                "content": "**Please do upvote if you like the solution:)**\\n\\n**Algorithm:**\\nstep-1: make 2 pointers d1 & d2 which will be pointing to L1 and L2 repectively.\\nstep-2: keep iterating both the pointers (until both becomes NULL) by one step and assign to one- other linked-list if any of the pointer reaches NULL.\\nsep-3: If there is a intersection point then definitely d1 == d2 at some point then we will return either d1 or d2.\\n\\n\\n**Code:**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {        //optimal oneih\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* d1 = headA;\\n        ListNode* d2 = headB;\\n        \\n        while(d1 || d2 || d1!=d2){\\n            if(d1==d2)\\n                return d1;          //return if both are equal; if not intersect: NULL-NULL\\n            \\n            if(d1==NULL){            //asssign to another LL, if any of them reaches NULL\\n                d1 = headB;\\n                continue;\\n            }\\n                \\n            if(d2==NULL){\\n                d2 = headA;\\n                continue;\\n            }\\n                \\n            d1 = d1->next;\\n            d2 = d2->next;\\n        }\\n        return d1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {        //optimal oneih\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* d1 = headA;\\n        ListNode* d2 = headB;\\n        \\n        while(d1 || d2 || d1!=d2){\\n            if(d1==d2)\\n                return d1;          //return if both are equal; if not intersect: NULL-NULL\\n            \\n            if(d1==NULL){            //asssign to another LL, if any of them reaches NULL\\n                d1 = headB;\\n                continue;\\n            }\\n                \\n            if(d2==NULL){\\n                d2 = headA;\\n                continue;\\n            }\\n                \\n            d1 = d1->next;\\n            d2 = d2->next;\\n        }\\n        return d1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117054,
                "title": "cpp-solution-3-approaches-from-o-n-space-to-o-1-easy",
                "content": "__Thanks for checking out my solution\\nDo Upvote this post, if you found this helpful :))__\\n\\n____\\n__Approach 1 : Simplest but fails on the follow up constraints__\\n__Use a unordered set (Uses O(1) time for operations)\\nTraverse the first list and Store all the nodes of the first list in it\\nTraverse the second list and check for each node in the set__\\n>__If found, return the node__\\n\\n__Return Null, if during the traversal, nothing was returned__\\n\\n```\\nclass Solution\\n{ // 58 ms, faster than 30.98% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        unordered_set<ListNode *> s; // The idea is pretty straight forward\\n        while (headA)                // Traverse the list\\n        {\\n            s.insert(headA); // Add the nodes to the set\\n            headA = headA->next;\\n        }\\n        while (headB) // Traverse the list 2\\n        {\\n            if (s.find(headB) != s.end()) // if any node is already in the set, return the node\\n                return headB;\\n            headB = headB->next;\\n        }\\n        return NULL; // If the control has not been returned, till now, return NULL\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(n)__\\n\\n__Since this method uses extra space, it violates the follow up condition. Lets think for a more optimised approach.__\\n\\n____\\n\\n__Approach 2 : Space Optimisation__\\n__Thinking about Space optimisation is what brings us to this solution__\\n\\n__Step 1 : Get the lengths of the two Lists, assuming that the first list is longer than the second one.\\nStep 2 : If our assumption is wrong about the lists, swap them.\\nStep 3 : Get the difference in the lengths\\nStep 4 : Advance the first List by this difference in length__\\n>Now it is obvious that if there exists an intersection point, the length (till the end) from this assumed point will be same for both the lists\\n>We only need to bring both the lists to a point from where the number of nodes becomes same for both of them, and hence we advance the longer list(if thats the case), by the difference in their lengths\\n>>If the lists are of same size, the difference will be 0, and hence no list will be advanced\\n\\n__Step 5 : Now until a common node is found, keep advancing both the lists.\\nStep 6 : Return the address stored in the Pointer to the first List__\\n> If at some point a common node was found, the loop will break, with pointer pointing at the __Intersection Point__\\n> Otherwise the pointer will be pointing at the end of the list, i.e. __NULL__\\n\\n__Below is the Coding implementation of the above approach__\\n```\\nclass Solution\\n{ // Runtime: 48 ms, faster than 86.40% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *t1 = headA, *t2 = headB;\\n        int c1 = 0, c2 = 0;\\n        while (t1) // Get the Length of the First List\\n        {\\n            ++c1;\\n            t1 = t1->next;\\n        }\\n        while (t2) // Get the length of the second list\\n        {\\n            ++c2;\\n            t2 = t2->next;\\n        }\\n        if (c1 < c2) // If Second List is longer than the first one, swap them, prevents if else block\\n        {\\n            swap(headA, headB);\\n            swap(c1, c2);\\n        }\\n        c1 -= c2;    // Get the Difference in length\\n        while (c1--) // Advance the first List\\n            headA = headA->next;\\n        while (headA != headB) // Now we know that list have same length, Traverse till nothing common is found\\n        {\\n            headA = headA->next; // Advance List 1\\n            headB = headB->next; // Advance List 2\\n        }\\n        return headA; // if during traversal nothing is returned, no intersection exists\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(1)__\\n\\n____\\n\\n__Approach 3 : Improved version of the Approach 2\\nHere we will take advantage of the fact that__\\n>__If the two lists have same lengths, they will either reach the intersection point (if it exists), or the end of the list, at the same time.\\n>Otherwise, one of the list will reach its end before the other, which presents us to use a Two-Pointer Approach__\\n>>___Here we assign the pointer to the shorter list, the head pointer of the longer one (A kind of two pointer Approach).\\n>>This assignment will help us advance the pointer(earlier pointing to the shorter list) to the longer list by the difference in the lengths of the two lists\\n>>Meanwhile the actual pointer to the longer list will reach the end, and is assigned the head pointer of the shorter list\\n>>These two assignments brings both the lists to a point from where they equal nodes to traverse till the end___\\n>>>Now when the two pointers advance, they will either reach the intersection point(if it exists), or the end of the list.\\n>>>In both the cases, the control will be returned, either with the __Intersection Node__ or the __NULL pointer__.\\n\\n__Below is the coding implementation of the improved upon idea of the Second Approach__\\n\\n```\\nclass Solution\\n{ // Runtime: 45 ms, faster than 92.53% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ListNode *t1 = headA, *t2 = headB;   //traversal node 1 and traversal node 2\\n        while (t1 != t2) // Traverse till nodes are not common\\n        {\\n            t1 = t1->next; // Advance the list 1\\n            t2 = t2->next; // Advance the list 2\\n            if (t1 == t2)  // If same, return the node\\n                return t1;\\n            if (!t1)        // If t1 == NULL, list A < List B,\\n                t1 = headB; // Assign the other List\\n            if (!t2)        // If t1 == NULL, list A > List B\\n                t2 = headA; // Assign the other List\\n            /*\\n            This List assignment, will ensure that lists of different sizes, reach a point from where\\n            Both the lists have equal nodes to traverse till the end.\\n            Now t1 == t2 statement will break the loop when both the nodes point NULL\\n            Or when both the nodes point to the intersection point\\n            */\\n        }\\n        return t1; // if t1 == t2, initially, return t1\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(1)__",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution\\n{ // 58 ms, faster than 30.98% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        unordered_set<ListNode *> s; // The idea is pretty straight forward\\n        while (headA)                // Traverse the list\\n        {\\n            s.insert(headA); // Add the nodes to the set\\n            headA = headA->next;\\n        }\\n        while (headB) // Traverse the list 2\\n        {\\n            if (s.find(headB) != s.end()) // if any node is already in the set, return the node\\n                return headB;\\n            headB = headB->next;\\n        }\\n        return NULL; // If the control has not been returned, till now, return NULL\\n    }\\n};\\n```\n```\\nclass Solution\\n{ // Runtime: 48 ms, faster than 86.40% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *t1 = headA, *t2 = headB;\\n        int c1 = 0, c2 = 0;\\n        while (t1) // Get the Length of the First List\\n        {\\n            ++c1;\\n            t1 = t1->next;\\n        }\\n        while (t2) // Get the length of the second list\\n        {\\n            ++c2;\\n            t2 = t2->next;\\n        }\\n        if (c1 < c2) // If Second List is longer than the first one, swap them, prevents if else block\\n        {\\n            swap(headA, headB);\\n            swap(c1, c2);\\n        }\\n        c1 -= c2;    // Get the Difference in length\\n        while (c1--) // Advance the first List\\n            headA = headA->next;\\n        while (headA != headB) // Now we know that list have same length, Traverse till nothing common is found\\n        {\\n            headA = headA->next; // Advance List 1\\n            headB = headB->next; // Advance List 2\\n        }\\n        return headA; // if during traversal nothing is returned, no intersection exists\\n    }\\n};\\n```\n```\\nclass Solution\\n{ // Runtime: 45 ms, faster than 92.53% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ListNode *t1 = headA, *t2 = headB;   //traversal node 1 and traversal node 2\\n        while (t1 != t2) // Traverse till nodes are not common\\n        {\\n            t1 = t1->next; // Advance the list 1\\n            t2 = t2->next; // Advance the list 2\\n            if (t1 == t2)  // If same, return the node\\n                return t1;\\n            if (!t1)        // If t1 == NULL, list A < List B,\\n                t1 = headB; // Assign the other List\\n            if (!t2)        // If t1 == NULL, list A > List B\\n                t2 = headA; // Assign the other List\\n            /*\\n            This List assignment, will ensure that lists of different sizes, reach a point from where\\n            Both the lists have equal nodes to traverse till the end.\\n            Now t1 == t2 statement will break the loop when both the nodes point NULL\\n            Or when both the nodes point to the intersection point\\n            */\\n        }\\n        return t1; // if t1 == t2, initially, return t1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768768,
                "title": "java-solution-4-approaches-brute-hashing-optimal-best",
                "content": "1. Brute\\n\\nHere we pick a list and keep traversing it checking if the node matches. If not we move to the next node and reinitialise the list which is check to its head again.\\n\\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode temp = headB;\\n        \\n         while (headA != null){\\n           while (headB != null){\\n             if (headA != headB) headB = headB.next;\\n             else return headB;\\n             }\\n\\t\\t\\theadB = temp;\\n            headA = headA.next;\\n         }\\n        \\n       return null;\\n\\t}\\n}\\n```\\n\\n2. Hashing\\n\\n We make a HashMap of any list and keep the nodes as key. If we take values as key that will break the code as similar values do exist in the test cases but we only want the intersecting node. After that we loop on the other list and check if the interesecting node is present in the map.\\n \\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\n        Map<ListNode, Integer> map = new HashMap<>();\\n        \\n     while (headA != null){\\n            map.put(headA, map.getOrDefault(headA, 0) + 1);\\n            headA = headA.next;\\n        }\\n        \\n        while (headB != null){\\n            if (map.containsKey(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n\\t}\\n}\\n```\\n\\n3. Optimal (lengthy)\\n\\nIn this approach we first calucalate the length of both the list. Then we traverse again the bigger list upto the difference of the lengths. After that we traverse both the list together as they are on same length and therefore we can check for the intersecting node.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\t\\n\\t\\tint c1 = 0, c2 = 0;\\n        ListNode d1 = headA, d2 = headB;\\n        \\n        while (d1 != null){\\n            c1++;\\n            d1 = d1.next;\\n        }\\n        \\n        while (d2 != null){\\n            c2++;\\n            d2 = d2.next;\\n        }\\n        \\n        if (c1 > c2){\\n            int diff = c1 - c2;\\n            while (diff > 0){ \\n                headA = headA.next;\\n                diff--;\\n            }\\n        } else {\\n            int diff = c2 - c1;\\n            while (diff > 0) {\\n                headB = headB.next;\\n                diff--;\\n            }\\n        }\\n        \\n        while (headA != null && headB != null){\\n            if (headA == headB) return headB;\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n```\\n\\n4. Best Solution\\n\\nThis is a similar approach to the first but instead of calculating the length we keep on traversing both the lists using dummy nodes. When any of the dummy reaches the null point then we shift it to the start of the other list. What this does is it reduces the length difference apparently which helps us to get the intersecting node.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode dA = headA;\\n        ListNode dB = headB;\\n        \\n        while (dA != dB){\\n            dA = dA == null ? headB : dA.next;\\n            dB = dB == null ? headA : dB.next;\\n        }\\n        \\n        return dB;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode temp = headB;\\n        \\n         while (headA != null){\\n           while (headB != null){\\n             if (headA != headB) headB = headB.next;\\n             else return headB;\\n             }\\n\\t\\t\\theadB = temp;\\n            headA = headA.next;\\n         }\\n        \\n       return null;\\n\\t}\\n}\\n```\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\n        Map<ListNode, Integer> map = new HashMap<>();\\n        \\n     while (headA != null){\\n            map.put(headA, map.getOrDefault(headA, 0) + 1);\\n            headA = headA.next;\\n        }\\n        \\n        while (headB != null){\\n            if (map.containsKey(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n\\t}\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\t\\n\\t\\tint c1 = 0, c2 = 0;\\n        ListNode d1 = headA, d2 = headB;\\n        \\n        while (d1 != null){\\n            c1++;\\n            d1 = d1.next;\\n        }\\n        \\n        while (d2 != null){\\n            c2++;\\n            d2 = d2.next;\\n        }\\n        \\n        if (c1 > c2){\\n            int diff = c1 - c2;\\n            while (diff > 0){ \\n                headA = headA.next;\\n                diff--;\\n            }\\n        } else {\\n            int diff = c2 - c1;\\n            while (diff > 0) {\\n                headB = headB.next;\\n                diff--;\\n            }\\n        }\\n        \\n        while (headA != null && headB != null){\\n            if (headA == headB) return headB;\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode dA = headA;\\n        ListNode dB = headB;\\n        \\n        while (dA != dB){\\n            dA = dA == null ? headB : dA.next;\\n            dB = dB == null ? headA : dB.next;\\n        }\\n        \\n        return dB;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662425,
                "title": "c-solution-using-two-pointers",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA;\\n        ListNode *b = headB;\\n        \\n        while(a!=b){\\n            a= (a==NULL) ? headB : a->next;\\n            b= (b==NULL) ? headA : b->next;\\n        }\\n        // there is no intersection and diff length \\n        //then also after second iteration both will point to NULL.\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA;\\n        ListNode *b = headB;\\n        \\n        while(a!=b){\\n            a= (a==NULL) ? headB : a->next;\\n            b= (b==NULL) ? headA : b->next;\\n        }\\n        // there is no intersection and diff length \\n        //then also after second iteration both will point to NULL.\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514699,
                "title": "easy-to-code-in-c-linked-list",
                "content": "class Solution {\\npublic:\\n\\nint len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        \\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        \\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        \\n        return NULL;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nint len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1189812,
                "title": "simple-java-solution-faster-than-98-08",
                "content": "**Simple JAVA Solution faster than 98.08% **\\n```\\npublic ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        ListNode cur1=head1;\\n        ListNode cur2=head2;\\n        while(cur1!=null&&cur2!=null){\\n            if(cur1==cur2){\\n                return cur1;\\n            }\\n            cur1=cur1.next;\\n            cur2=cur2.next;\\n            if(cur1 == null) { \\n                cur1 = head2;\\n            } else if(cur2 == null) { \\n                cur2 = head1;\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        ListNode cur1=head1;\\n        ListNode cur2=head2;\\n        while(cur1!=null&&cur2!=null){\\n            if(cur1==cur2){\\n                return cur1;\\n            }\\n            cur1=cur1.next;\\n            cur2=cur2.next;\\n            if(cur1 == null) { \\n                cur1 = head2;\\n            } else if(cur2 == null) { \\n                cur2 = head1;\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093170,
                "title": "intersection-of-two-linked-lists-python-o-n-time-o-1-add-l-space",
                "content": "1. We compute the lengths of the two lists.\\n2. Without loss of generality we render A at least as long as B.\\n3. We advance the head pointer of A by (len_a - len_b), namely, until both pointers have the same distance to the intersection.\\n4. We advance the two head pointers in tandem until the intersection, possibly None.\\n\\n```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        def get_length(head: ListNode) -> int:\\n            length = 0\\n            while(head):\\n                head, length = head.next, length + 1\\n            return length\\n        \\n        len_a, len_b = get_length(headA), get_length(headB)\\n        if len_a < len_b:\\n            headA, headB, len_a, len_b = headB, headA, len_b, len_a\\n        for _ in range(len_a - len_b):\\n            headA = headA.next\\n        while headA is not headB:\\n            headA, headB = headA.next, headB.next\\n        return headA\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        def get_length(head: ListNode) -> int:\\n            length = 0\\n            while(head):\\n                head, length = head.next, length + 1\\n            return length\\n        \\n        len_a, len_b = get_length(headA), get_length(headB)\\n        if len_a < len_b:\\n            headA, headB, len_a, len_b = headB, headA, len_b, len_a\\n        for _ in range(len_a - len_b):\\n            headA = headA.next\\n        while headA is not headB:\\n            headA, headB = headA.next, headB.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092872,
                "title": "python-c-illustration-explanation-o-n-o-1-solution",
                "content": "# Explanation:\\nEverything is simple. If there is intersection, it will be on same distance from the end in both linked lists, so we just need to iterate part where potentially can have intersection. This part is last `n` elements, where `n == min(len(list1), len(list2))`.\\nI get length of both lists, and skip the first elements of longer one, until both lists pointers will not be on same distance to their ends. \\nHere is good illustration where we should search for intersection:\\n![image](https://assets.leetcode.com/users/images/33bedbe5-8127-488d-8a46-61b9a9ba6873_1614846291.9376721.png)\\n![image](https://assets.leetcode.com/users/images/4453e84f-6a75-4b27-a06e-9367b7e90ea0_1614846296.1134787.png)\\n![image](https://assets.leetcode.com/users/images/dfbed1d1-5d00-4b1b-993c-fa3d43b1cd82_1614846492.9817722.png)\\n\\n\\n\\n## Python code:\\n```\\nclass Solution:\\n  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n    def listLen(head: ListNode) -> int:\\n      l = 0\\n      while head:\\n        l += 1\\n        head = head.next\\n      return l\\n\\n    lA = listLen(headA)\\n    lB = listLen(headB)\\n\\n    if lA > lB:\\n      for _ in range(lA - lB):\\n        headA = headA.next\\n    else:\\n      for _ in range(lB - lA):\\n        headB = headB.next\\n    \\n    while headA and headB:\\n      if headA is headB:\\n        return headA\\n      headA = headA.next\\n      headB = headB.next\\n      \\n    return None\\n```\\n\\n## C++ code:\\n```\\nclass Solution {\\n  public:\\n    int listLen(ListNode *head) {\\n      int l = 0;\\n      while (head) {\\n        ++l;\\n        head = head->next;\\n      }\\n      return l;\\n    }\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n      int lA = listLen(headA);\\n      int lB = listLen(headB);\\n\\n      if (lA > lB) {\\n        for (int i = lA - lB; i > 0; --i) {\\n          headA = headA->next;\\n        }\\n      } else {\\n        for (int i = lB - lA; i > 0; --i) {\\n          headB = headB->next;\\n        }\\n      }\\n      \\n      while (headA && headB) {\\n        if (headA == headB) {\\n          return headA;\\n        }\\n        headA = headA->next;\\n        headB = headB->next;\\n      }\\n      \\n      return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n    def listLen(head: ListNode) -> int:\\n      l = 0\\n      while head:\\n        l += 1\\n        head = head.next\\n      return l\\n\\n    lA = listLen(headA)\\n    lB = listLen(headB)\\n\\n    if lA > lB:\\n      for _ in range(lA - lB):\\n        headA = headA.next\\n    else:\\n      for _ in range(lB - lA):\\n        headB = headB.next\\n    \\n    while headA and headB:\\n      if headA is headB:\\n        return headA\\n      headA = headA.next\\n      headB = headB.next\\n      \\n    return None\\n```\n```\\nclass Solution {\\n  public:\\n    int listLen(ListNode *head) {\\n      int l = 0;\\n      while (head) {\\n        ++l;\\n        head = head->next;\\n      }\\n      return l;\\n    }\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n      int lA = listLen(headA);\\n      int lB = listLen(headB);\\n\\n      if (lA > lB) {\\n        for (int i = lA - lB; i > 0; --i) {\\n          headA = headA->next;\\n        }\\n      } else {\\n        for (int i = lB - lA; i > 0; --i) {\\n          headB = headB->next;\\n        }\\n      }\\n      \\n      while (headA && headB) {\\n        if (headA == headB) {\\n          return headA;\\n        }\\n        headA = headA->next;\\n        headB = headB->next;\\n      }\\n      \\n      return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056026,
                "title": "python-super-simple-easy-clear-solution-o-n-time-o-1-memory",
                "content": "\\tclass Solution:\\n\\t\\tdef changeSign(self, head: ListNode):\\n\\t\\t\\twhile ( head ):\\n\\t\\t\\t\\thead.val *= -1\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\n\\t\\tdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB ):\\n\\t\\t\\t\\tif headB.val < 0:break\\n\\t\\t\\t\\theadB = headB.next\\n\\t\\t\\t\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\treturn headB",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef changeSign(self, head: ListNode):\\n\\t\\t\\twhile ( head ):\\n\\t\\t\\t\\thead.val *= -1\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\n\\t\\tdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB ):\\n\\t\\t\\t\\tif headB.val < 0:break\\n\\t\\t\\t\\theadB = headB.next\\n\\t\\t\\t\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\treturn headB",
                "codeTag": "Java"
            },
            {
                "id": 809226,
                "title": "python-brute-force-hashtable-two-pointer-solutions",
                "content": "Refer to https://leetcode.com/problems/intersection-of-two-linked-lists/solution/ for explanations. Here I will just provide the code samples.\\n\\n*Node Definition*\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n```\\n**Brute Force**\\n```\\nclass Solution:\\n    \"\"\"\\n    Brute Force\\n    Time: O(MN)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n\\n        while ptrA:\\n            ptrB = headB\\n            while ptrB:\\n                if ptrA is ptrB:\\n                    return ptrA\\n                ptrB = ptrB.next\\n\\n            ptrA = ptrA.next\\n\\n        return\\n```\\n\\n**Hash Table Based**\\n```\\nclass Solution:\\n    \"\"\"\\n    Hash Table\\n    Time: O(M + N)\\n    Space: O(M) or O(N)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        address = dict()\\n\\n        while headA:\\n            address[id(headA)] = headA\\n            headA = headA.next\\n\\n        while headB:\\n            if id(headB) in address:\\n                return address[id(headB)]\\n            headB = headB.next\\n\\n        return\\n```\\n\\n**Two Pointers**\\n```\\nclass Solution:\\n    \"\"\"\\n    Two Pointers\\n    Time: O(M + N)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n        ptrB = headB\\n\\n        while ptrA is not ptrB:\\n            ptrA = headB if ptrA is None else ptrA.next\\n            ptrB = headA if ptrB is None else ptrB.next\\n\\n        return ptrA\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Brute Force\\n    Time: O(MN)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n\\n        while ptrA:\\n            ptrB = headB\\n            while ptrB:\\n                if ptrA is ptrB:\\n                    return ptrA\\n                ptrB = ptrB.next\\n\\n            ptrA = ptrA.next\\n\\n        return\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Hash Table\\n    Time: O(M + N)\\n    Space: O(M) or O(N)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        address = dict()\\n\\n        while headA:\\n            address[id(headA)] = headA\\n            headA = headA.next\\n\\n        while headB:\\n            if id(headB) in address:\\n                return address[id(headB)]\\n            headB = headB.next\\n\\n        return\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Two Pointers\\n    Time: O(M + N)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n        ptrB = headB\\n\\n        while ptrA is not ptrB:\\n            ptrA = headB if ptrA is None else ptrA.next\\n            ptrB = headA if ptrB is None else ptrB.next\\n\\n        return ptrA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732969,
                "title": "easiest-java-o-1-space-solution-6-lines",
                "content": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        while(a != b){ \\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA; \\n        }\\n        \\n       return a; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        while(a != b){ \\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA; \\n        }\\n        \\n       return a; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683981,
                "title": "c-solution-with-map",
                "content": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tmap<ListNode*, int> mA;\\n\\tListNode* pA = headA;\\n\\twhile (pA) {\\n\\t\\tmA[pA]++;\\n\\t\\tpA = pA->next;\\n\\t}\\n\\tListNode* pB = headB;\\n\\twhile (pB) {\\n\\t\\tif (mA.find(pB) != mA.end())\\n\\t\\t\\treturn pB;\\n\\t\\tpB= pB->next;\\n\\t}\\n\\treturn nullptr;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tmap<ListNode*, int> mA;\\n\\tListNode* pA = headA;\\n\\twhile (pA) {\\n\\t\\tmA[pA]++;\\n\\t\\tpA = pA->next;\\n\\t}\\n\\tListNode* pB = headB;\\n\\twhile (pB) {\\n\\t\\tif (mA.find(pB) != mA.end())\\n\\t\\t\\treturn pB;\\n\\t\\tpB= pB->next;\\n\\t}\\n\\treturn nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467993,
                "title": "python-3-five-lines-beats-99",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, A: ListNode, B: ListNode) -> ListNode:\\n        S = set()\\n        while A != None: A, _ = A.next, S.add(A) \\n        while B != None:\\n            if B in S: return B\\n            B = B.next\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, A: ListNode, B: ListNode) -> ListNode:\\n        S = set()\\n        while A != None: A, _ = A.next, S.add(A) \\n        while B != None:\\n            if B in S: return B\\n            B = B.next\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 211922,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute Force Approach**\\n\\n**Algorithm:**\\n1. For each node in list `A`, traverse over list `B` and check whether or not the node is present in list `B`.\\n1. The one thing we need to be careful of is that we are comparing objects of type `ListNode`. We don\\'t want to compare the values within the nodes; since doing this would cause our code to break when two different nodes have the same value.\\n\\n**Time Complexity:** `O(N * M)`, considering `N` be the length of list `A` and `M` be the length of list `B`.\\n- For each of the `N` nodes in list `A`, we are traversing over each of the nodes in list `B`. \\n- In the worst case, we won\\'t find a match, and so will need to do this until reaching the end of list `B`, giving a worst-case time complexity of `O(N * M)`.\\n\\n**Space Complexity:** `O(1)`.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            // For each node in list A, traverse over list B\\n            for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n                if (currentA == currentB) {\\n                    return currentA;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Hash Table**\\n\\n**Algorithm:**\\n1. Traverse list `A` and store the address/reference of each node in a hash table. \\n1. Then for each node in list `B`, check whether or not that node exists in the hash table. If it does, return it as it must be the intersection node. If we get to the end of list `B` without finding an intersection node, return null.\\n\\n**Time complexity:** `O(N + M)`\\n- Firstly, we need to build up the hash table. It costs `O(1)` to insert an item into a hash table, and we need to do this for each of the `N` nodes in list `A`. This gives a cost of `O(N)` for building the hash table.\\n- Secondly, we need to traverse list `B`, and for each node, we need to check whether or not it is in the hash table. In the worst case, there will not be a match, requiring us to check all `M` nodes in list B. As it is also `O(1)` to check whether or not an item is in a hash table, this checking has a total cost of `O(M)`.\\n- Finally, combining the two parts, we get `O(N) + O(M) = O(N + M)`\\n\\n**Space complexity:** `O(N)`.\\n- As we are storing each of the nodes from list `A` into a hash table, the hash table will require `O(N)` space. \\n- Note that we could have instead stored the nodes of list `B` into the hash table, this would have been a space complexity of `O(M)`. Unless we know which list is longer though, it doesn\\'t make any real difference.\\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n\\n        // Store the list A nodes in the set\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            set.add(currentA);\\n        }\\n\\n        // Check if any of the list B element is in the Set \\n        for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n            if (set.contains(currentB)) {\\n                return currentB;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n**Solution 3: Using Two Pointers**\\n\\n**Intuition:**\\n- In the first iteration, we will reset the pointer of one linked-list to the `head` of another linked-list after it reaches the `tail` node. \\n- In the second iteration, we will move two pointers until they points to the same node. So if two linked-list intersects, the meeting point in second iteration must be the intersection point. \\n- If the two linked lists have no intersection, then the meeting pointer in second iteration must be the `tail` node of both lists, which is `null`\\n\\n**Algorithm:**\\n1. Set pointer `currentA` to point at `headA`.\\n1. pointer `currentB` to point at `headB`.\\n1. While `currentA` and `currentB` are not pointing at the same node:\\n\\t- If `currentA` is pointing to a `null`, set `currentA` to point to `headB`.\\n\\t- Else, set `currentA` to point at `currentA.next`.\\n\\t- If `currentB` is pointing to a `null`, set `currentB` to point to `headA`.\\n\\t- Else, set `currentB` to point at `currentB.next`.\\n1. return the value pointed to by `currentA` (or by `currentB`; they are the same now)\\n\\n**Time Complexity:** `O(N + M)`, where `N` and `M` are the lengths of linked-lists\\n- In the worst case, each list is traversed twice giving `2 * N + 2 * M`, which is equivalent to `O(N + M)`. This is because the pointers firstly go down each list so that they can be \"lined up\" and then in the second iteration, the intersection node is searched for.\\n- An interesting observation is that when the lists are of the same length, this algorithm only traverses each list once. This is because the pointers are already \"lined up\" from the start, so the additional pass is unnecessary.\\n\\n**Space Complexity:** `O(1)`, since we are not allocating any additional data structures, \\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA = headA;\\n        ListNode currentB = headB;\\n\\n        while (currentA != currentB) {\\n            currentA = currentA == null ? headB : currentA.next;\\n            currentB = currentB == null ? headA : currentB.next;\\n        }\\n        return currentA;\\n    }\\n}\\n```\\n\\n**Solution 4: Using Difference of List Lengths**\\n\\n**Algorithm:**\\n1. Find length of both lists, let it be `N` and `M`.\\n1. Find the difference of List Lengths `diff = abs(N \\u2013 M)`\\n1. Now traverse the longer list from the `first` node till `diff` nodes so that from here onwards both the lists have equal no of nodes.\\n1. Then we can traverse both the lists in parallel till we come across a common node\\n\\n**Time Complexity:** `O(N + M)`, where `N` and `M` are the lengths of linked-lists\\n**Space Complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA;\\n        ListNode currentB;\\n        int N = 0;\\n        int M = 0;\\n\\n        // Calculate N; the length of list A.\\n        for (currentA = headA; currentA != null; currentA = currentA.next) {\\n            N += 1;\\n        }\\n        // Calculate M; the length of list B.\\n        for (currentB = headB; currentB != null; currentB = currentB.next) {\\n            M += 1;\\n        }\\n        currentA = headA;\\n        currentB = headB;\\n        int diff = Math.abs(N - M);\\n\\n        // Set the start pointer for the longer list.\\n        if (N > M) {\\n            while (diff-- > 0) {\\n                currentA = currentA.next;\\n            }\\n        }\\n        if (M > N) {\\n            while (diff-- > 0) {\\n                currentB = currentB.next;\\n            }\\n        }\\n\\n        // Move both pointers through the list together.\\n        while (currentA != null) {\\n            if (currentA == currentB) {\\n                return currentA;\\n            }\\n            currentA = currentA.next;\\n            currentB = currentB.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            // For each node in list A, traverse over list B\\n            for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n                if (currentA == currentB) {\\n                    return currentA;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n\\n        // Store the list A nodes in the set\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            set.add(currentA);\\n        }\\n\\n        // Check if any of the list B element is in the Set \\n        for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n            if (set.contains(currentB)) {\\n                return currentB;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA = headA;\\n        ListNode currentB = headB;\\n\\n        while (currentA != currentB) {\\n            currentA = currentA == null ? headB : currentA.next;\\n            currentB = currentB == null ? headA : currentB.next;\\n        }\\n        return currentA;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA;\\n        ListNode currentB;\\n        int N = 0;\\n        int M = 0;\\n\\n        // Calculate N; the length of list A.\\n        for (currentA = headA; currentA != null; currentA = currentA.next) {\\n            N += 1;\\n        }\\n        // Calculate M; the length of list B.\\n        for (currentB = headB; currentB != null; currentB = currentB.next) {\\n            M += 1;\\n        }\\n        currentA = headA;\\n        currentB = headB;\\n        int diff = Math.abs(N - M);\\n\\n        // Set the start pointer for the longer list.\\n        if (N > M) {\\n            while (diff-- > 0) {\\n                currentA = currentA.next;\\n            }\\n        }\\n        if (M > N) {\\n            while (diff-- > 0) {\\n                currentB = currentB.next;\\n            }\\n        }\\n\\n        // Move both pointers through the list together.\\n        while (currentA != null) {\\n            if (currentA == currentB) {\\n                return currentA;\\n            }\\n            currentA = currentA.next;\\n            currentB = currentB.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49918,
                "title": "c-another-solution-using-the-code-of-finding-the-loop-beginning",
                "content": "    class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (headA==NULL || headB==NULL) return NULL;\\n        if (headA==headB) return headA;\\n        ListNode *tailA=headA;\\n        while (tailA->next!=NULL){\\n            tailA=tailA->next;\\n        }\\n        tailA->next = headB;\\n        ListNode *slow=headA,*fast=headA;\\n        while (fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow==fast){\\n                fast = headA;\\n                while (fast!=slow){\\n                    fast = fast->next;\\n                    slow = slow->next;\\n                }\\n                tailA->next = NULL;\\n                return fast;\\n            }\\n        }\\n        tailA->next = NULL;\\n        return NULL;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (headA==NULL || headB==NULL) return NULL;\\n        if (headA==headB) return headA;\\n        ListNode *tailA=headA;\\n        while (tailA->next!=NULL){\\n            tailA=tailA->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49975,
                "title": "52ms-in-c-with-time-o-n-space-o-1",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* cur_node_1 = headA;\\n        ListNode* cur_node_2 = headB;\\n        //cal diff of length\\n        while(cur_node_1 != nullptr && cur_node_2 != nullptr){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        //make two start point with same length\\n        //will exchange point to the other list\\n        if(cur_node_1 != nullptr) {\\n            cur_node_2 = headA;\\n            while(cur_node_1 != nullptr){\\n                cur_node_1 = cur_node_1->next;\\n                cur_node_2 = cur_node_2->next;\\n            }\\n            cur_node_1 = headB;\\n        }\\n        else if(cur_node_2 != nullptr){\\n            cur_node_1 = headB;\\n            while(cur_node_2 != nullptr){\\n                cur_node_2 = cur_node_2->next;\\n                cur_node_1 = cur_node_1->next;\\n            }\\n            cur_node_2 = headA;\\n        }\\n        else{\\n            cur_node_1 = headB;\\n            cur_node_2 = headA;\\n        }\\n        //because len is same, they will meet each other if has joinpoint\\n        while(cur_node_1 != cur_node_2){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        return cur_node_1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* cur_node_1 = headA;\\n        ListNode* cur_node_2 = headB;\\n        //cal diff of length\\n        while(cur_node_1 != nullptr && cur_node_2 != nullptr){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        //make two start point with same length\\n        //will exchange point to the other list\\n        if(cur_node_1 != nullptr) {\\n            cur_node_2 = headA;\\n            while(cur_node_1 != nullptr){\\n                cur_node_1 = cur_node_1->next;\\n                cur_node_2 = cur_node_2->next;\\n            }\\n            cur_node_1 = headB;\\n        }\\n        else if(cur_node_2 != nullptr){\\n            cur_node_1 = headB;\\n            while(cur_node_2 != nullptr){\\n                cur_node_2 = cur_node_2->next;\\n                cur_node_1 = cur_node_1->next;\\n            }\\n            cur_node_2 = headA;\\n        }\\n        else{\\n            cur_node_1 = headB;\\n            cur_node_2 = headA;\\n        }\\n        //because len is same, they will meet each other if has joinpoint\\n        while(cur_node_1 != cur_node_2){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        return cur_node_1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49962,
                "title": "my-simple-c-solution",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tif (headA == NULL || headB == NULL) {\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t\\tListNode* s1 = headA, *s2 = headB;\\n\\t\\tint dis = getdis(s1, s2);\\n\\t\\tdis>=0? moveHead(dis, headA) : moveHead(-dis, headB);\\n\\t\\twhile (headA != headB) {\\n\\t\\t\\theadA = headA->next;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\treturn headA;\\n\\t}\\n\\n\\tint getdis(ListNode* s1, ListNode* s2) {\\n\\t\\tint i = 0;\\n\\t\\twhile (s1&&s2) {\\n\\t\\t\\ts1 = s1->next;\\n\\t\\t\\ts2 = s2->next;\\n\\t\\t}\\n\\t\\tif (s1){\\n\\t\\t\\twhile (s1){ s1 = s1->next; i++; }\\n\\t\\t}\\n\\t\\telse\\n\\t\\twhile (s2){ s2 = s2->next; i--; };\\n\\t\\treturn i;\\n\\t}\\n\\n\\tvoid moveHead(int i, ListNode*& n) {\\n\\t\\twhile (i > 0 && n) {\\n\\t\\t\\tn = n->next;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tif (headA == NULL || headB == NULL) {\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t\\tListNode* s1 = headA, *s2 = headB;\\n\\t\\tint dis = getdis(s1, s2);\\n\\t\\tdis>=0? moveHead(dis, headA) : moveHead(-dis, headB);\\n\\t\\twhile (headA != headB) {\\n\\t\\t\\theadA = headA->next;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\treturn headA;\\n\\t}\\n\\n\\tint getdis(ListNode* s1, ListNode* s2) {\\n\\t\\tint i = 0;\\n\\t\\twhile (s1&&s2) {\\n\\t\\t\\ts1 = s1->next;\\n\\t\\t\\ts2 = s2->next;\\n\\t\\t}\\n\\t\\tif (s1){\\n\\t\\t\\twhile (s1){ s1 = s1->next; i++; }\\n\\t\\t}\\n\\t\\telse\\n\\t\\twhile (s2){ s2 = s2->next; i--; };\\n\\t\\treturn i;\\n\\t}\\n\\n\\tvoid moveHead(int i, ListNode*& n) {\\n\\t\\twhile (i > 0 && n) {\\n\\t\\t\\tn = n->next;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 49997,
                "title": "my-simple-c-solution-with-explanations-and-comments-o-n-time-o-1-space",
                "content": "explanation: the Idea is simple. check which list is longer, for instance A is longer than B with steps nodes. Then the longer one walk the the steps. Now they have the same length. then Both of the lists walk at the same pace until they meet:\\n\\n       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *curA = headA, *curB = headB;\\n        int size_diff =  0;\\n        bool flag = false; // false for A shorter, true for B shorter\\n        while (curA && curB) {\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        flag = curA; // if curA not null,  B shorter, otherwise, A shorter\\n        ListNode *start = curA ? curA : curB;\\n        while(start) {\\n            size_diff++;\\n            start = start->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        if (flag) \\n        while (size_diff--) curA = curA->next; // A longer, A walk size_diff steps\\n        else while (size_diff--) curB = curB->next; // B longer, B walk size_diff \\n        while (curA && curB)  // now they walk together\\n        {\\n            if (curA == curB) return curA;\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return nullptr;\\n    }",
                "solutionTags": [],
                "code": "explanation: the Idea is simple. check which list is longer, for instance A is longer than B with steps nodes. Then the longer one walk the the steps. Now they have the same length. then Both of the lists walk at the same pace until they meet:\\n\\n       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *curA = headA, *curB = headB;\\n        int size_diff =  0;\\n        bool flag = false; // false for A shorter, true for B shorter\\n        while (curA && curB) {\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        flag = curA; // if curA not null,  B shorter, otherwise, A shorter\\n        ListNode *start = curA ? curA : curB;\\n        while(start) {\\n            size_diff++;\\n            start = start->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        if (flag) \\n        while (size_diff--) curA = curA->next; // A longer, A walk size_diff steps\\n        else while (size_diff--) curB = curB->next; // B longer, B walk size_diff \\n        while (curA && curB)  // now they walk together\\n        {\\n            if (curA == curB) return curA;\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return nullptr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 50012,
                "title": "my-java-solution",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null) {\\n            return null;\\n        }\\n    \\tint length1 = 0, length2 = 0, diff = 0;\\n    \\tListNode list1 = headA, list2 = headB;\\n    \\twhile (list1 != null) {\\n    \\t\\tlength1++;\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list2 != null) {\\n    \\t\\tlength2++;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n\\t\\tlist1 = headA;\\n\\t\\tlist2 = headB;\\n    \\tdiff = length1 - length2;\\n    \\tif (length2 > length1) {\\n    \\t\\tlist1 = headB;\\n    \\t\\tlist2 = headA;\\n    \\t\\tdiff = length2 - length1;\\n    \\t}\\n    \\tfor (int i = 0; i < diff; i++) {\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list1 != null && list2 != null) {\\n    \\t\\tif (list1.val == list2.val) {\\n    \\t\\t\\treturn list1;\\n    \\t\\t}\\n    \\t\\tlist1 = list1.next;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n    \\treturn null;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null) {\\n            return null;\\n        }\\n    \\tint length1 = 0, length2 = 0, diff = 0;\\n    \\tListNode list1 = headA, list2 = headB;\\n    \\twhile (list1 != null) {\\n    \\t\\tlength1++;\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list2 != null) {\\n    \\t\\tlength2++;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n\\t\\tlist1 = headA;\\n\\t\\tlist2 = headB;\\n    \\tdiff = length1 - length2;\\n    \\tif (length2 > length1) {\\n    \\t\\tlist1 = headB;\\n    \\t\\tlist2 = headA;\\n    \\t\\tdiff = length2 - length1;\\n    \\t}\\n    \\tfor (int i = 0; i < diff; i++) {\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list1 != null && list2 != null) {\\n    \\t\\tif (list1.val == list2.val) {\\n    \\t\\t\\treturn list1;\\n    \\t\\t}\\n    \\t\\tlist1 = list1.next;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n    \\treturn null;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49893,
                "title": "simple-thought-with-o-n-time-and-o-1-space-complexity-for-intersection-of-two-linked-lists",
                "content": "My thought is very simple.\\n\\n**case 1**: If A and B has the same length, we just need to move two pointers(*pa*, *pb*) of two lists together to check whether *pa* == *pb*.\\n\\n**case 2**: If their length are not equal we can know their length difference (*lenDiff*) and move the pointer of longer list *lenDiff* steps forward, then follow case 1.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n            return NULL;\\n        int lenA = 0;\\n        ListNode *pa = headA;\\n        while(pa) {\\n            lenA++;\\n            pa = pa->next;\\n        }\\n        int lenB = 0;\\n        ListNode *pb = headB;\\n        while(pb) {\\n            lenB++;\\n            pb = pb->next;\\n        }\\n        int lenDiff = lenA - lenB;\\n        pa = headA;\\n        pb = headB;\\n        if(lenDiff > 0) {\\n            while(lenDiff != 0) {\\n                pa = pa->next;\\n                lenDiff--;\\n            }\\n        }\\n        else if(lenDiff < 0) {\\n            while(lenDiff != 0) {\\n                pb = pb->next;\\n                lenDiff++;\\n            }\\n        }\\n        while(pa && pb) {\\n            if(pa == pb)\\n                return pa;\\n            pa = pa->next;\\n            pb = pb->next;\\n        }\\n        return NULL;\\n    }",
                "solutionTags": [],
                "code": "My thought is very simple.\\n\\n**case 1**: If A and B has the same length, we just need to move two pointers(*pa*, *pb*) of two lists together to check whether *pa* == *pb*.\\n\\n**case 2**: If their length are not equal we can know their length difference (*lenDiff*) and move the pointer of longer list *lenDiff* steps forward, then follow case 1.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n            return NULL;\\n        int lenA = 0;\\n        ListNode *pa = headA;\\n        while(pa) {\\n            lenA++;\\n            pa = pa->next;\\n        }\\n        int lenB = 0;\\n        ListNode *pb = headB;\\n        while(pb) {\\n            lenB++;\\n            pb = pb->next;\\n        }\\n        int lenDiff = lenA - lenB;\\n        pa = headA;\\n        pb = headB;\\n        if(lenDiff > 0) {\\n            while(lenDiff != 0) {\\n                pa = pa->next;\\n                lenDiff--;\\n            }\\n        }\\n        else if(lenDiff < 0) {\\n            while(lenDiff != 0) {\\n                pb = pb->next;\\n                lenDiff++;\\n            }\\n        }\\n        while(pa && pb) {\\n            if(pa == pb)\\n                return pa;\\n            pa = pa->next;\\n            pb = pb->next;\\n        }\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3880523,
                "title": "intersection-of-two-linked-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3200014,
                "title": "finding-the-intersection-of-two-linked-lists-using-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to use two pointers to traverse each linked list, first to count their lengths, then move the pointer of the longer list to the same distance from the end as the shorter list. Finally, move both pointers forward until they intersect.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the linked lists headA and headB using two pointers currA and currB, respectively, to count their lengths lenA and lenB, respectively.\\n\\n2. Reset the pointers currA and currB to the heads of the linked lists.\\n\\n\\n3. If lenA > lenB, move the pointer currA to the same distance from the end as the shorter list by advancing currA lenA - lenB steps. Otherwise, move the pointer currB to the same distance from the end as the shorter list by advancing currB lenB - lenA steps.\\n\\n4. Move both pointers currA and currB forward until they intersect at the same node or they reach the end of their respective linked lists.\\n\\n5. If an intersection is found, return the intersected node, otherwise, return null.\\n\\n- Explanation : The algorithm uses two pointers to traverse two linked lists, count their lengths, move the pointer of the longer list to the same distance from the end as the shorter list, and then move both pointers forward until they intersect at the same node. The algorithm\\'s approach and complexity have been explained in detail in the previous response.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $ O(m + n)$ because we traverse both linked lists once to count their lengths, and then traverse both lists once to find the intersection node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is $O(1)$ because we only use a constant amount of extra space to store the pointers currA and currB.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n                # Get the lengths of the two linked lists\\n            lenA, lenB = 0, 0\\n            currA, currB = headA, headB\\n            while currA is not None:\\n                    lenA += 1\\n                    currA = currA.next\\n            while currB is not None:\\n                    lenB += 1\\n                    currB = currB.next\\n        \\n        # Reset the pointers to the heads of the two linked lists\\n            currA, currB = headA, headB\\n        \\n        # Move the pointer of the longer list to the same distance from the end as the shorter list\\n            if lenA > lenB:\\n                for i in range(lenA - lenB):\\n                    currA = currA.next\\n            elif lenB > lenA:\\n                for i in range(lenB - lenA):\\n                    currB = currB.next\\n        \\n        # Move both pointers forward until they intersect\\n            while currA is not None and currB is not None:\\n                if currA == currB:\\n                    return currA\\n                currA = currA.next\\n                currB = currB.next\\n        \\n        # No intersection found\\n            return None\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n                # Get the lengths of the two linked lists\\n            lenA, lenB = 0, 0\\n            currA, currB = headA, headB\\n            while currA is not None:\\n                    lenA += 1\\n                    currA = currA.next\\n            while currB is not None:\\n                    lenB += 1\\n                    currB = currB.next\\n        \\n        # Reset the pointers to the heads of the two linked lists\\n            currA, currB = headA, headB\\n        \\n        # Move the pointer of the longer list to the same distance from the end as the shorter list\\n            if lenA > lenB:\\n                for i in range(lenA - lenB):\\n                    currA = currA.next\\n            elif lenB > lenA:\\n                for i in range(lenB - lenA):\\n                    currB = currB.next\\n        \\n        # Move both pointers forward until they intersect\\n            while currA is not None and currB is not None:\\n                if currA == currB:\\n                    return currA\\n                currA = currA.next\\n                currB = currB.next\\n        \\n        # No intersection found\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027758,
                "title": "java-set-easy-solution",
                "content": "# Code\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        HashSet<ListNode> set = new HashSet<>();\\n\\n        while(headA != null){\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n\\n        while(headB != null){\\n            if(set.contains(headB)){\\n                return headB;\\n            }else{\\n                headB = headB.next;\\n            }\\n        }\\n\\n        return null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        HashSet<ListNode> set = new HashSet<>();\\n\\n        while(headA != null){\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n\\n        while(headB != null){\\n            if(set.contains(headB)){\\n                return headB;\\n            }else{\\n                headB = headB.next;\\n            }\\n        }\\n\\n        return null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016868,
                "title": "go-that-s-how-you-do-it-in-the-real-world-no-fancy-stuff",
                "content": "\"Simplicity is the ultimate sophistication\"\\n\\n```\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    seen := make(map[*ListNode]bool)\\n    for n := headA; n != nil; n = n.Next {\\n        seen[n] = true\\n    }\\n\\n    for n := headB; n != nil; n = n.Next {\\n        if seen[n] {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    seen := make(map[*ListNode]bool)\\n    for n := headA; n != nil; n = n.Next {\\n        seen[n] = true\\n    }\\n\\n    for n := headB; n != nil; n = n.Next {\\n        if seen[n] {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874342,
                "title": "c-simple-solution",
                "content": "# Approach\\n1. First we have to determine the length of list A and list B\\n2. Then we must match the lists so that the endings of list A and list B match\\n3. Then you just need to iterate both lists and compare the nodes, if there is a match, then there are intersections of the lists. If there is no match, then return null\\n\\n# Complexity\\n- Time complexity: O(N + M) = O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) \\n    {\\n        var lengthA = GetListNodeLength(headA);\\n        var lengthB = GetListNodeLength(headB);\\n\\n        while (lengthA > lengthB)\\n        {\\n            headA = headA.next;\\n            lengthA--;\\n        }\\n\\n        while (lengthB > lengthA)\\n        {\\n            headB = headB.next;\\n            lengthB--;\\n        }\\n        \\n        while (headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        return headA;\\n    }\\n    \\n    private static int GetListNodeLength(ListNode node)\\n    {\\n        var length = 0;\\n\\n        while (node != null)\\n        {\\n            node = node.next;\\n            length++;\\n        }\\n\\n        return length;\\n    }\\n}\\n```\\n![Screenshot 2022-12-03 233255.png](https://assets.leetcode.com/users/images/16f90ede-d6bf-471d-aa39-f6ec21dee0fa_1670100031.2386193.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) \\n    {\\n        var lengthA = GetListNodeLength(headA);\\n        var lengthB = GetListNodeLength(headB);\\n\\n        while (lengthA > lengthB)\\n        {\\n            headA = headA.next;\\n            lengthA--;\\n        }\\n\\n        while (lengthB > lengthA)\\n        {\\n            headB = headB.next;\\n            lengthB--;\\n        }\\n        \\n        while (headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        return headA;\\n    }\\n    \\n    private static int GetListNodeLength(ListNode node)\\n    {\\n        var length = 0;\\n\\n        while (node != null)\\n        {\\n            node = node.next;\\n            length++;\\n        }\\n\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541315,
                "title": "intersection-of-two-linked-list",
                "content": "# **If it Help Please UpVote :)\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode temp1=headA;\\n        ListNode temp2=headB;\\n        while(temp1!=temp2){\\n            if(temp1==null){\\n                temp1=headB;\\n            }\\n            else{\\n                temp1=temp1.next;\\n            }\\n            if(temp2==null){\\n                temp2=headA;\\n            }else{\\n                temp2=temp2.next;\\n            }\\n          \\n        }\\n          return temp1;\\n\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode temp1=headA;\\n        ListNode temp2=headB;\\n        while(temp1!=temp2){\\n            if(temp1==null){\\n                temp1=headB;\\n            }\\n            else{\\n                temp1=temp1.next;\\n            }\\n            if(temp2==null){\\n                temp2=headA;\\n            }else{\\n                temp2=temp2.next;\\n            }\\n          \\n        }\\n          return temp1;\\n\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276038,
                "title": "c-easiest-code-cleanest-code-and-easiest-to-understand",
                "content": "Have seen a lot of solutions on this problem.However,none of them seemed suitable for beginners to follow plus the number of solutions in the discuss section is overwhelming.So thought of creating a clear,concise and clean code for beginners to follow.\\nDo upvote.\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n  \\n        ListNode* temp1=headA;\\n        ListNode* temp2=headB;\\n        int len1=0;\\n        int len2=0;\\n        while(headA!=NULL){\\n            headA=headA->next;\\n            len1++;\\n            \\n        }\\n         while(headB!=NULL){\\n            headB=headB->next;\\n            len2++;\\n            \\n        }\\n        int delta;\\n        if(len1>len2){\\n            delta=len1-len2;\\n        }\\n        else if(len1<len2){\\n            delta=len2-len1;\\n        }\\n        else{\\n            delta=0;\\n        }\\n        if(len1>len2){\\n \\n            while(delta--){\\n                temp1=temp1->next;\\n            }\\n        }\\n        else if(len1<len2){\\n            while(delta--){\\n                temp2=temp2->next;\\n            }\\n        }\\n        //now we can move both pointers\\n        while(temp1!=temp2){\\n             temp1=temp1->next;\\n             temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n  \\n        ListNode* temp1=headA;\\n        ListNode* temp2=headB;\\n        int len1=0;\\n        int len2=0;\\n        while(headA!=NULL){\\n            headA=headA->next;\\n            len1++;\\n            \\n        }\\n         while(headB!=NULL){\\n            headB=headB->next;\\n            len2++;\\n            \\n        }\\n        int delta;\\n        if(len1>len2){\\n            delta=len1-len2;\\n        }\\n        else if(len1<len2){\\n            delta=len2-len1;\\n        }\\n        else{\\n            delta=0;\\n        }\\n        if(len1>len2){\\n \\n            while(delta--){\\n                temp1=temp1->next;\\n            }\\n        }\\n        else if(len1<len2){\\n            while(delta--){\\n                temp2=temp2->next;\\n            }\\n        }\\n        //now we can move both pointers\\n        while(temp1!=temp2){\\n             temp1=temp1->next;\\n             temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201626,
                "title": "99-fast-awesome-3-approaches-explained-in-detail-begineer-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/902af032-f096-4ab7-a2bc-e58387ba6882_1656262920.0406907.png)\\n\\n```\\n**# BRUTE FORCE:**\\nWE WILL FIRST TRAVERSE THE FIRST LIST \\nAND IN OUR MAP FOR EVERY ADDRESS OF A NODE WE WILL STORE A VALUE WHICH WILL REPRESENT HOW MANY TIMES A NODE WITH A SPECIFIC ADDRESSS HAVE BEEN ENCOUNTERED BY US.\\nNOW FOR THE FIRST LIST FOR EVERY ADDRESS OF A NODE WE WILL HAVE A VALUE OF 1.\\nNOW WE WILL TRAVERSE FOR THE SECOND LIST, NOW WHEN FOR A ADDRESS IF THE COUNT IS ALREADY 1 WHICH MEANS THAT WE HAVE ALREADY ENCOUNTERED THAT PARTICULAR NODE.\\nTHIS ULTIMATELY EXPLAINS THAT WE HAVE TO VISIT THIS NODE AGAIN SO THIS MEANS THAT THIS IS THE INTERSECTION NODE \\n# **BRUTE FORCE CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //BRUTE FORCE\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        unordered_map<ListNode* , int>mp;\\n        ListNode *temp = NULL;\\n        while(headA!=NULL){ //O(M) FOR THE WORST CASE\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB!=NULL){ //O(N) FOR THE WORST CASE\\n            if(mp[headB]==1){\\n                temp = headB;\\n                break;\\n            }\\n            headB=headB->next;\\n        }\\n        return temp;\\n    }\\n    // TC:- O(M)+O(N);\\n    // SC:- In my solution it is equal to the lenght of LIST1, it can further be optimized to \\n    // O(min(M,N)) for this first we will have to find the list1 and list2 length then out of both \\n    // which is minimum that size can be used to create a map\\n\\t\\n# \\t**OPTIMIZED:**\\n\\tUSING THE DIFFERENCE BETWEEN THE LENGTH\\'S\\n        Step 1-> Find the length of both Linked-Lists and take their difference \\'d\\'\\n        Step 2-> Move the larger node forward by \\'d\\' steps\\n        Step 3-> Now the starting point of both linkedlists are equidistant from intersection ,so move \\n        both pointers together untill the intersection is found.\\n# **OPTIMIZED CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        ListNode* temp = NULL;\\n        int as = 0 , bs = 0;\\nwhile(a!=NULL){\\n            as++;\\n            a=a->next;\\n        }\\n        while(b!=NULL){\\n            bs++;\\n            b=b->next;\\n        }\\n        a=headA;\\n        b=headB;\\n        int diff = 0;\\n        if(as<bs){\\n            diff = bs-as;\\n            while(diff!=0){\\n                b=b->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            diff = as-bs;\\n            while(diff!=0){\\n                a=a->next;\\n                diff--;\\n            }\\n        }\\n        while(a!=b and a!=NULL and b!=NULL){\\n            a=a->next;\\n            b=b->next;\\n        }\\n        if(a!=NULL){\\n            return a;\\n        }\\n        return temp;\\n    }\\n\\n# **OPTIMAL:**\\nVisualization of this solution:\\nCase 1 (Have Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b            \\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 2 (Have Intersection & Different Len):\\n\\n            a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\nA:          a1 \\u2192 a2\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:          a1 \\u2192 a2\\n                   \\u2198      a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198           a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197      b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198                a = null, then a = b1\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197           b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197                b = null, then b = a1 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       a\\n            b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197\\nB:     b1 \\u2192 b2 \\u2192 b3\\n            a\\n                 b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198 b\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 a\\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 3 (Have No Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nCase 4 (Have No Intersection & Different Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null, then b = a1\\n       b                   a = null, then a = b1\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b                   \\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       a\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            a\\n                      b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 a\\n                           b = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      a = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nNotice that if list A and list B have the same length, this solution will terminate in no more than 1 traversal; if both lists have different lengths, this solution will terminate in no more than 2 traversals -- in the second traversal, swapping a and b synchronizes a and b before the end of the second traversal. By synchronizing a and b I mean both have the same remaining steps in the second traversal so that it\\'s guaranteed for them to reach the first intersection node, or reach null at the same time (technically speaking, in the same iteration) -- see Case 2 (Have Intersection & Different Len) and Case 4 (Have No Intersection & Different Len).\\n\\nFURTHER EXPLAINTATION IF ANY DOUBT IS STILL THERE:\\nLet assume the length of List A is a + c and length of List B is b + c (c is the length of the intersected or common part).\\nLength of A + Length of B == Length of A + Length of B == a + c + b + c.\\nLet make ptr1 and ptr2 as start pointers of list A and list B respectively.\\nThe idea is to traverse both pointers by same distance (a + b + c).\\nFirst traverse both the pointers until they reach to the end of their respective lists and then to offset the length difference between the two lists we switch\\nboth the pointers i.e. we points ptr1 to head B after a + c iterations and points ptr2 to head A after b + c iterations.\\nIn the second traversal, we traversed ptr1 by \\'b\\' steps and ptr2 by \\'a\\' steps.\\nAfter a + b + c iterations, both pointers will meet to the first intersection node.\\nNote: If there is no intersection and length of both lists are same then both the pointers will points to NULL simultaneously in the first traversal.\\nIf there is no intersection and length of both lists are different then both the pointers will points to NULL simultaneously in the second traversal.\\n\\n# **CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        /* USING TWO POINTER*/\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        while(a!=b){\\n            if(a==NULL){\\n                a=headB;\\n            }\\n            else{\\n                a = a -> next;\\n            }\\n            if(b==NULL){\\n                b=headA;\\n            }\\n            else{\\n                b = b -> next;\\n            }\\n        }\\n        return a;\\n    }\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/902af032-f096-4ab7-a2bc-e58387ba6882_1656262920.0406907.png)\\n\\n```\\n**# BRUTE FORCE:**\\nWE WILL FIRST TRAVERSE THE FIRST LIST \\nAND IN OUR MAP FOR EVERY ADDRESS OF A NODE WE WILL STORE A VALUE WHICH WILL REPRESENT HOW MANY TIMES A NODE WITH A SPECIFIC ADDRESSS HAVE BEEN ENCOUNTERED BY US.\\nNOW FOR THE FIRST LIST FOR EVERY ADDRESS OF A NODE WE WILL HAVE A VALUE OF 1.\\nNOW WE WILL TRAVERSE FOR THE SECOND LIST, NOW WHEN FOR A ADDRESS IF THE COUNT IS ALREADY 1 WHICH MEANS THAT WE HAVE ALREADY ENCOUNTERED THAT PARTICULAR NODE.\\nTHIS ULTIMATELY EXPLAINS THAT WE HAVE TO VISIT THIS NODE AGAIN SO THIS MEANS THAT THIS IS THE INTERSECTION NODE \\n# **BRUTE FORCE CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //BRUTE FORCE\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        unordered_map<ListNode* , int>mp;\\n        ListNode *temp = NULL;\\n        while(headA!=NULL){ //O(M) FOR THE WORST CASE\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB!=NULL){ //O(N) FOR THE WORST CASE\\n            if(mp[headB]==1){\\n                temp = headB;\\n                break;\\n            }\\n            headB=headB->next;\\n        }\\n        return temp;\\n    }\\n    // TC:- O(M)+O(N);\\n    // SC:- In my solution it is equal to the lenght of LIST1, it can further be optimized to \\n    // O(min(M,N)) for this first we will have to find the list1 and list2 length then out of both \\n    // which is minimum that size can be used to create a map\\n\\t\\n# \\t**OPTIMIZED:**\\n\\tUSING THE DIFFERENCE BETWEEN THE LENGTH\\'S\\n        Step 1-> Find the length of both Linked-Lists and take their difference \\'d\\'\\n        Step 2-> Move the larger node forward by \\'d\\' steps\\n        Step 3-> Now the starting point of both linkedlists are equidistant from intersection ,so move \\n        both pointers together untill the intersection is found.\\n# **OPTIMIZED CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        ListNode* temp = NULL;\\n        int as = 0 , bs = 0;\\nwhile(a!=NULL){\\n            as++;\\n            a=a->next;\\n        }\\n        while(b!=NULL){\\n            bs++;\\n            b=b->next;\\n        }\\n        a=headA;\\n        b=headB;\\n        int diff = 0;\\n        if(as<bs){\\n            diff = bs-as;\\n            while(diff!=0){\\n                b=b->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            diff = as-bs;\\n            while(diff!=0){\\n                a=a->next;\\n                diff--;\\n            }\\n        }\\n        while(a!=b and a!=NULL and b!=NULL){\\n            a=a->next;\\n            b=b->next;\\n        }\\n        if(a!=NULL){\\n            return a;\\n        }\\n        return temp;\\n    }\\n\\n# **OPTIMAL:**\\nVisualization of this solution:\\nCase 1 (Have Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b            \\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 2 (Have Intersection & Different Len):\\n\\n            a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\nA:          a1 \\u2192 a2\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:          a1 \\u2192 a2\\n                   \\u2198      a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198           a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197      b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198                a = null, then a = b1\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197           b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197                b = null, then b = a1 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       a\\n            b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197\\nB:     b1 \\u2192 b2 \\u2192 b3\\n            a\\n                 b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198 b\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 a\\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 3 (Have No Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nCase 4 (Have No Intersection & Different Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null, then b = a1\\n       b                   a = null, then a = b1\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b                   \\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       a\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            a\\n                      b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 a\\n                           b = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      a = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nNotice that if list A and list B have the same length, this solution will terminate in no more than 1 traversal; if both lists have different lengths, this solution will terminate in no more than 2 traversals -- in the second traversal, swapping a and b synchronizes a and b before the end of the second traversal. By synchronizing a and b I mean both have the same remaining steps in the second traversal so that it\\'s guaranteed for them to reach the first intersection node, or reach null at the same time (technically speaking, in the same iteration) -- see Case 2 (Have Intersection & Different Len) and Case 4 (Have No Intersection & Different Len).\\n\\nFURTHER EXPLAINTATION IF ANY DOUBT IS STILL THERE:\\nLet assume the length of List A is a + c and length of List B is b + c (c is the length of the intersected or common part).\\nLength of A + Length of B == Length of A + Length of B == a + c + b + c.\\nLet make ptr1 and ptr2 as start pointers of list A and list B respectively.\\nThe idea is to traverse both pointers by same distance (a + b + c).\\nFirst traverse both the pointers until they reach to the end of their respective lists and then to offset the length difference between the two lists we switch\\nboth the pointers i.e. we points ptr1 to head B after a + c iterations and points ptr2 to head A after b + c iterations.\\nIn the second traversal, we traversed ptr1 by \\'b\\' steps and ptr2 by \\'a\\' steps.\\nAfter a + b + c iterations, both pointers will meet to the first intersection node.\\nNote: If there is no intersection and length of both lists are same then both the pointers will points to NULL simultaneously in the first traversal.\\nIf there is no intersection and length of both lists are different then both the pointers will points to NULL simultaneously in the second traversal.\\n\\n# **CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        /* USING TWO POINTER*/\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        while(a!=b){\\n            if(a==NULL){\\n                a=headB;\\n            }\\n            else{\\n                a = a -> next;\\n            }\\n            if(b==NULL){\\n                b=headA;\\n            }\\n            else{\\n                b = b -> next;\\n            }\\n        }\\n        return a;\\n    }\\n\\t\\n\\t\\n",
                "codeTag": "C++"
            },
            {
                "id": 2117634,
                "title": "c-efficient-solution-easy-to-understand",
                "content": "**\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n        ListNode* p1;\\n        ListNode* p2;\\n        p1 = headA;\\n        p2 = headB;\\n        while(p1 != p2)\\n        {\\n            \\n            if(p1 ==NULL)\\n            {\\n                p1 = headB;\\n            }\\n            else\\n            {\\n                p1 = p1 ->next;\\n            }\\n            if(p2 == NULL)\\n            {\\n                p2 = headA;\\n            }\\n            else\\n            {\\n                p2 = p2 ->next;\\n            }\\n            \\n        }\\n        return p1;\\n    }\\n# };****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n        ListNode* p1;\\n        ListNode* p2;\\n        p1 = headA;\\n        p2 = headB;\\n        while(p1 != p2)\\n        {\\n            \\n            if(p1 ==NULL)\\n            {\\n                p1 = headB;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2117209,
                "title": "c-2-approach-easy-to-understand-daily-leetcoding-challenge-june-day-6",
                "content": "**Please Upvote If It helps**\\n\\n**Approach 1 : (Better Using Count)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        int cnt1 = 0 , cnt2 = 0;   // for counting the length of both lists\\n        \\n        // counting the length of Linked List 1\\n        while(dummy1 != NULL)\\n        {\\n            cnt1++;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        // counting the length of Linked List 1\\n        while(dummy2 != NULL)\\n        {\\n            cnt2++;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        // aggain point our dummy1 and dummy2 to headA and headB\\n        dummy1 = headA;\\n        dummy2 = headB;\\n        \\n        // here we are finding the max & min length diff and according to that we are moving are dummy node to make both dummies equal\\n        int diff;\\n        if(cnt1 > cnt2)\\n        {\\n            diff = cnt1-cnt2;\\n            while(diff--)                                  // while diff not get 0 move our dummy\\n                dummy1 = dummy1->next;\\n        }\\n        else\\n        {\\n            diff = cnt2-cnt1;\\n            while(diff--)\\n                dummy2 = dummy2->next;\\n        }\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n\\n        }\\n        return dummy1;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 : (Optimal Uisng Pointers)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            // logic behind this assign is to fill the differences \\n            else\\n            {\\n                dummy1 = headB;          // if dummy1 reached to null then assign it to head OF L2\\n            }\\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n            else\\n            {\\n                dummy2 = headA;          // if dummy2 reached to null then assign it to head OF L1\\n            }\\n        }\\n        return dummy1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        int cnt1 = 0 , cnt2 = 0;   // for counting the length of both lists\\n        \\n        // counting the length of Linked List 1\\n        while(dummy1 != NULL)\\n        {\\n            cnt1++;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        // counting the length of Linked List 1\\n        while(dummy2 != NULL)\\n        {\\n            cnt2++;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        // aggain point our dummy1 and dummy2 to headA and headB\\n        dummy1 = headA;\\n        dummy2 = headB;\\n        \\n        // here we are finding the max & min length diff and according to that we are moving are dummy node to make both dummies equal\\n        int diff;\\n        if(cnt1 > cnt2)\\n        {\\n            diff = cnt1-cnt2;\\n            while(diff--)                                  // while diff not get 0 move our dummy\\n                dummy1 = dummy1->next;\\n        }\\n        else\\n        {\\n            diff = cnt2-cnt1;\\n            while(diff--)\\n                dummy2 = dummy2->next;\\n        }\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n\\n        }\\n        return dummy1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            // logic behind this assign is to fill the differences \\n            else\\n            {\\n                dummy1 = headB;          // if dummy1 reached to null then assign it to head OF L2\\n            }\\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n            else\\n            {\\n                dummy2 = headA;          // if dummy2 reached to null then assign it to head OF L1\\n            }\\n        }\\n        return dummy1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117005,
                "title": "python-two-pass-comments",
                "content": "```\\n def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        aLen = self.getLength(headA)\\n        bLen = self.getLength(headB)\\n        # print(f\\'|aLen| => {aLen}, |bLen| => {bLen}\\')\\n        \\n        a_ptr, b_ptr = headA, headB\\n        \\n        # move the pointers to the appropriate spots\\n        if aLen < bLen:\\n            # move b to start at the same end distance as a\\n            for i in range(bLen - aLen):\\n                b_ptr = b_ptr.next\\n            \\n        else:\\n            # move a to start at the same end distance as b\\n            for i in range(aLen - bLen):\\n                a_ptr = a_ptr.next\\n                \\n        # check to see if there is an intersection\\n        while a_ptr and b_ptr:\\n            if a_ptr == b_ptr:\\n                return a_ptr\\n            a_ptr = a_ptr.next\\n            b_ptr = b_ptr.next\\n        \\n        return None \\n        \\n    def getLength(self, node: ListNode) -> int:\\n        _len = 0\\n        cur = node\\n        while cur:\\n            cur = cur.next\\n            _len += 1\\n        return _len\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        aLen = self.getLength(headA)\\n        bLen = self.getLength(headB)\\n        # print(f\\'|aLen| => {aLen}, |bLen| => {bLen}\\')\\n        \\n        a_ptr, b_ptr = headA, headB\\n        \\n        # move the pointers to the appropriate spots\\n        if aLen < bLen:\\n            # move b to start at the same end distance as a\\n            for i in range(bLen - aLen):\\n                b_ptr = b_ptr.next\\n            \\n        else:\\n            # move a to start at the same end distance as b\\n            for i in range(aLen - bLen):\\n                a_ptr = a_ptr.next\\n                \\n        # check to see if there is an intersection\\n        while a_ptr and b_ptr:\\n            if a_ptr == b_ptr:\\n                return a_ptr\\n            a_ptr = a_ptr.next\\n            b_ptr = b_ptr.next\\n        \\n        return None \\n        \\n    def getLength(self, node: ListNode) -> int:\\n        _len = 0\\n        cur = node\\n        while cur:\\n            cur = cur.next\\n            _len += 1\\n        return _len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116795,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    const map = new WeakMap();\\n\\n    while (headA || headB) {\\n        if (headA) {\\n            if (map.has(headA)) {\\n                return headA;\\n            }\\n\\n            map.set(headA, true);\\n            headA = headA.next;\\n        }\\n        \\n        if (headB) {\\n            if (map.has(headB)) {\\n                return headB;\\n            }\\n\\n            map.set(headB, true);\\n            headB = headB.next;\\n        }\\n    }\\n\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    const map = new WeakMap();\\n\\n    while (headA || headB) {\\n        if (headA) {\\n            if (map.has(headA)) {\\n                return headA;\\n            }\\n\\n            map.set(headA, true);\\n            headA = headA.next;\\n        }\\n        \\n        if (headB) {\\n            if (map.has(headB)) {\\n                return headB;\\n            }\\n\\n            map.set(headB, true);\\n            headB = headB.next;\\n        }\\n    }\\n\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116777,
                "title": "1-ms-faster-than-99-17-of-java-online-submissions-for-intersection-of-two-linked-lists",
                "content": "```\\n        ListNode slow = headA;\\n        ListNode fast = headB;\\n        while(slow != fast)\\n        {\\n            slow = slow.next;\\n            fast = fast.next;\\n            if(slow == fast)\\n            {\\n                return slow;\\n            }\\n            if(slow == null)\\n            {\\n                slow = headB;\\n            }\\n            if(fast == null)\\n            {\\n                fast = headA;\\n            }\\n        }\\n        return slow;\\n\\t",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n        ListNode slow = headA;\\n        ListNode fast = headB;\\n        while(slow != fast)\\n        {\\n            slow = slow.next;\\n            fast = fast.next;\\n            if(slow == fast)\\n            {\\n                return slow;\\n            }\\n            if(slow == null)\\n            {\\n                slow = headB;\\n            }\\n            if(fast == null)\\n            {\\n                fast = headA;\\n            }\\n        }\\n        return slow;\\n\\t",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566447,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565391,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565983,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567217,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566338,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567743,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566986,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566324,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567603,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566908,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566447,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565391,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565983,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567217,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566338,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567743,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566986,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566324,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567603,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566908,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567425,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1567518,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568988,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566723,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566301,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566591,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1570781,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568556,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568359,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568174,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568106,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1572102,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1712054,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1569790,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1569595,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1568989,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 2010947,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1950775,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1823033,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1728584,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1576458,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1575715,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1575609,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1574827,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1574623,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1571350,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1571351,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1576493,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1570314,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1568028,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1570063,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2071789,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2066698,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2058940,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2052012,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2049717,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2045186,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2044065,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2029688,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2027265,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2024422,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 2013873,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1989858,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1958922,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1957671,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1947312,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1947127,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1933524,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1922224,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1895867,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1895677,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1891235,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1863327,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1850854,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1850704,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1813475,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1810882,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1805167,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1794944,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1793378,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1781684,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1769742,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1766752,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1761029,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1759332,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1757655,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1756157,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1747694,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1742213,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1742210,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1725151,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1718437,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1716218,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1716215,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1693694,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1689523,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1681293,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1658140,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1625165,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1569765,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Single Number III",
        "question_content": "<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>\n\n<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,2,5]\n<strong>Output:</strong> [3,5]\n<strong>Explanation: </strong> [5, 3] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0]\n<strong>Output:</strong> [-1,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 68900,
                "title": "accepted-c-java-o-n-time-o-1-space-easy-solution-with-detail-explanations",
                "content": "Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes:\\n\\n- In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value '1') in the XOR result. Find\\nout an arbitrary set bit (for example, the rightmost set bit).\\n\\n- In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group.\\n\\n**Complexity:**\\n\\n- Time: *O* (*n*)\\n\\n- Space: *O* (1)\\n\\n**A Corner Case:**\\n\\n- When `diff == numeric_limits<int>::min()`, `-diff` is also `numeric_limits<int>::min()`. Therefore, the value of `diff` after executing `diff &= -diff` is still `numeric_limits<int>::min()`. The answer is still correct.\\n\\n\\nC++:\\n\\n    class Solution\\n    {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) \\n        {\\n            // Pass 1 : \\n            // Get the XOR of the two numbers we need to find\\n            int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            // Get its last set bit\\n            diff &= -diff;\\n\\n            // Pass 2 :\\n            vector<int> rets = {0, 0}; // this vector stores the two numbers we will return\\n            for (int num : nums)\\n            {\\n                if ((num & diff) == 0) // the bit is not set\\n                {\\n                    rets[0] ^= num;\\n                }\\n                else // the bit is set\\n                {\\n                    rets[1] ^= num;\\n                }\\n            }\\n            return rets;\\n        }\\n    };\\n\\n\\nJava:\\n\\n    public class Solution {\\n        public int[] singleNumber(int[] nums) {\\n            // Pass 1 : \\n            // Get the XOR of the two numbers we need to find\\n            int diff = 0;\\n            for (int num : nums) {\\n                diff ^= num;\\n            }\\n            // Get its last set bit\\n            diff &= -diff;\\n            \\n            // Pass 2 :\\n            int[] rets = {0, 0}; // this array stores the two numbers we will return\\n            for (int num : nums)\\n            {\\n                if ((num & diff) == 0) // the bit is not set\\n                {\\n                    rets[0] ^= num;\\n                }\\n                else // the bit is set\\n                {\\n                    rets[1] ^= num;\\n                }\\n            }\\n            return rets;\\n        }\\n    }\\n\\nThanks for reading :)\\n\\n\\n----------\\n\\n\\nAcknowledgements:\\n\\n- Thank **@jianchao.li.fighter** for introducing this problem and for your encouragement.\\n\\n- Thank **@StefanPochmann** for your valuable suggestions and comments. Your idea of `diff &= -diff` is very elegent! And yes, it does not need to XOR for both group in the second pass. XOR for one group suffices. I revise my code accordingly. \\n\\n- Thank **@Nakagawa_Kanon** for posting this question and presenting the same idea in a previous thread (prior to this thread).\\n\\n- Thank **@caijun** for providing an interesting test case.",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) \\n        {\\n            // Pass 1 : \\n            // Get the XOR of the two numbers we need to find\\n            int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            // Get its last set bit\\n            diff &= -diff;\\n\\n            // Pass 2 :\\n            vector<int> rets = {0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 68921,
                "title": "c-solution-o-n-time-and-o-1-space-easy-understaning-with-simple-explanation",
                "content": "    vector<int> singleNumber(vector<int>& nums) {\\n        int aXorb = 0;  // the result of a xor b;\\n        for (auto item : nums) aXorb ^= item;\\n        int lastBit = (aXorb & (aXorb - 1)) ^ aXorb;  // the last bit that a diffs b\\n        int intA = 0, intB = 0;\\n        for (auto item : nums) {\\n            // based on the last bit, group the items into groupA(include a) and groupB\\n            if (item & lastBit) intA = intA ^ item;\\n            else intB = intB ^ item;\\n        }\\n        return vector<int>{intA, intB};   \\n    }",
                "solutionTags": [],
                "code": "    vector<int> singleNumber(vector<int>& nums) {\\n        int aXorb = 0;  // the result of a xor b;\\n        for (auto item : nums) aXorb ^= item;\\n        int lastBit = (aXorb & (aXorb - 1)) ^ aXorb;  // the last bit that a diffs b\\n        int intA = 0, intB = 0;\\n        for (auto item : nums) {\\n            // based on the last bit, group the items into groupA(include a) and groupB\\n            if (item & lastBit) intA = intA ^ item;\\n            else intB = intB ^ item;\\n        }\\n        return vector<int>{intA, intB};   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 750536,
                "title": "simple-c-in-o-1-space-and-o-n-time-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    // xor all numbers, so the duplicates are cancelled\\n\\tint x = 0;\\n\\tfor (const int curr: nums) {\\n\\t\\tx ^= curr;    \\n\\t}\\n\\n\\t// find the bit that is set in x.\\n\\tint bit;\\n\\tfor (int i=0; i<32; ++i) {\\n\\t\\tif (x & (1<<i)) {\\n\\t\\t\\tbit = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// let the answer be first and second.\\n\\t// let first is the number that has the bit set.\\n\\t// second does not have the bit set, because x=first^second has the bit set.  \\n\\t// now xor all numbers in nums with the bit set.\\n\\t// all duplicates will be cancelled\\n\\t// only first will remain. second will not be included, as second does not have the bit set.\\n\\tint first = 0;\\n\\tfor (int a: nums) {\\n\\t\\tif (a & (1<<bit)) {\\n\\t\\t\\tfirst ^= a;\\n\\t\\t}\\n\\t}\\n\\t// now x=first^second, therefore second = a^first\\n\\tint second = first^x;\\n\\treturn {first, second};\\n    }\\n};\\n//please upvote if you like the solution and explaination\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    // xor all numbers, so the duplicates are cancelled\\n\\tint x = 0;\\n\\tfor (const int curr: nums) {\\n\\t\\tx ^= curr;    \\n\\t}\\n\\n\\t// find the bit that is set in x.\\n\\tint bit;\\n\\tfor (int i=0; i<32; ++i) {\\n\\t\\tif (x & (1<<i)) {\\n\\t\\t\\tbit = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// let the answer be first and second.\\n\\t// let first is the number that has the bit set.\\n\\t// second does not have the bit set, because x=first^second has the bit set.  \\n\\t// now xor all numbers in nums with the bit set.\\n\\t// all duplicates will be cancelled\\n\\t// only first will remain. second will not be included, as second does not have the bit set.\\n\\tint first = 0;\\n\\tfor (int a: nums) {\\n\\t\\tif (a & (1<<bit)) {\\n\\t\\t\\tfirst ^= a;\\n\\t\\t}\\n\\t}\\n\\t// now x=first^second, therefore second = a^first\\n\\tint second = first^x;\\n\\treturn {first, second};\\n    }\\n};\\n//please upvote if you like the solution and explaination\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750622,
                "title": "python-4-lines-o-n-time-o-1-space-explained",
                "content": "I think it is rather hard problem than medium. If you solved Single Number I or II problems you probably can immediately say, that this problem is about bit manipulations. So, the first step is to evaluate `XOR` of all numbers, but what is next? It is indeed very difficult question, if we are not allowed to use extra memory and we want to stay with `O(n)` iterations. So, what exactly we get, when we evaluate `XOR` of all numbers? We will have `num1 ^ num2`, where `num1` and `num2` are desired numbers. We need to use all the imformation given in statement, and so these numbers are different, and it means there will be at least one `bit`, where they differ, it means one number of `num1` and `num2` have this bit equal to `0` and other to `1` . Let us remember this bit and traverse data once again: making `XOR` of numbers, where this bit is equal to `1`. Then we get exactly one of our desired numbers. Finally, we can find other number, using `num2 = s^num1`, where `s` is `XOR` of all numbers.\\n\\n1. Evaluate `s` - `XOR` of all numbers.\\n2. `nz` is non-zero bit. `s&(s-1)` trick is used to remove last `1`: for example for number `s = 110100`, the value `s&(s-1) = 110000`, and `s & (s-1) ^ s = 110000 ^ 110100 = 000100`.\\n3. We evaluate `num1`, using only numbers, where this bit is not absent.\\n4. Finally, we evaluate `num2 = s ^ num` and return answer.\\n\\n**Complexity**: time complexity is `O(n)`, where we do `2` passes over data. Additional space complexity is `O(1)`, we use just several additional variables.\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        s = reduce(xor, nums)\\n        nz = s & (s-1) ^ s\\n        num1 = reduce(xor, filter(lambda n: n & nz, nums))\\n        return(num1, s ^ num1)\\n```\\n\\n**Update** Thanks @rkmd for pointing out nicer ways to use `reduce` function!\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums):\\n        s = reduce(xor, nums)\\n        nz = s & (s-1) ^ s\\n        num1 = reduce(xor, filter(lambda n: n & nz, nums))\\n        return(num1, s ^ num1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561852,
                "title": "c-easy-clean-solution-fastest-all-4-methods-detailed-explanation-comments",
                "content": "**NOTE:**  All of below methods are accepted by OJ. Only the last Method (i.e Method4) satisfies the **[T(n) = O(n) and S(n) = O(1)]** constraint of the problem. I have presented all possible solutions here to help you explore the different ways to solve this problem. \\n\\n##### Method1: Using hashTable [T(n) = S(n) = O(n)]\\nIdea is to simply use a hashTable to store the frequency of each num in one pass. Then iterate over the `element: x` in hashTable and include x in ans only if `freq[x] == 1`.\\n\\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tunordered_map<int, int> freq;\\n\\t// generate freq\\n\\tfor (auto &num: nums) ++freq[num];\\n\\tvector<int> ans;\\n\\t// generate ans\\n\\tfor (auto &[x, f]: freq)\\n\\t\\tif (f == 1) {\\n\\t\\t\\tans.push_back(x);\\n\\t\\t\\tif (ans.size() == 2)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\treturn ans;\\n}\\n```\\n\\n##### Method2: Using Set [T(n) = S(n) = O(n)]\\nIdea is to simply use a set (`unordered_set to get avg. O(1) insert and delete`) to store each num in it in one pass. While storing, `if num is already present in set then delete it and if not then insert it` so that at the end, in the set, we only have elements with odd frequency and since, only two elements (distinct) in the nums are having odd frequency (=1), we get these two distinct elements stored in the set at the end.\\n\\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tunordered_set<int> visited;\\n\\t// store num with odd freq into set\\n\\tfor (auto &num: nums)\\n\\t\\tif (visited.count(num))\\n\\t\\t\\tvisited.erase(num);\\n\\t\\telse visited.insert(num);\\n\\t// return ans\\n\\treturn vector<int> (visited.begin(), visited.end());\\n}\\n```\\n\\n##### Method3: Using Sorting [T(n) = O(nlgn) and S(n) = O(1), excluding S(n) for std::sort()]\\nIdea is to simply use sorting to club the elements together in the nums vector. Finally, use a while loop to iterate over the sorted nums, `if nums[i] == nums[i+1], then skip these two by moving forward using i += 2` otherwise `add nums[i] to ans and move forward using i++`.\\nCorner Case: `if nums[n - 1] != nums[n - 2] (where n:= nums.size())` then we might skip adding nums[n - 1] to the ans. So, check at the end, `if ans.size() == 1 then add nums[n - 1] to the ans`.\\n\\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tsort (nums.begin(), nums.end());\\n\\tvector<int> ans;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n - 1)\\n\\t    // skip equal elements\\n\\t\\tif (nums[i] == nums[i + 1]) i += 2;\\n\\t\\t// generate ans\\n\\t\\telse {\\n\\t\\t\\tans.push_back(nums[i++]);\\n\\t\\t\\tif (ans.size() == 2)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t// corner case\\n\\tif (ans.size() == 1) \\n\\t\\tans.push_back(nums.back());\\n\\treturn ans;\\n}\\n```\\n\\n##### Method4: Using Bit Manipulation [T(n) = O(n) and S(n) = O(1)]\\nIdea is to use property of XOR: \\n`1. xor(a, a) = 0` \\n`2. xor(a, 0) = xor(0, a) = a`\\n`3. xor(1, 1) = xor(0, 0) = 0`\\n`4. xor(1, 0) = xor(0, 1) = 1`\\n`5. xor(a, b) = c => xor(a, c) = b and xor(b, c) = a`\\n\\nLet two distinct elements be: `first and sec`. Now, `firstXorSec := xor(first, sec) = xor(nums[i], 0), 0 <= i < [n:= nums.size()]`, why? because nums has odd and even freq. elements, doing xor will cancel out elements with even freq. using the 1. property of xor. So, at the end, xor of only odd freq. elements i.e first and sec remains. \\n\\nNow, `first != sec` => there is atleast 1 set bit in `firstXorSec`. Using 4. property of xor, one of first and sec, must have a set bit (Let it be first). We find/ denote this rightmost set bit using `mask: has all bits 0 except the rightmost set bit in firstXorSec`. So, we can divide the elements in nums in two groups A and B, where:\\n`1. groupA: (num & mask) == 1 i.e bit is set`\\n`2. groupB: (num & mask) == 0 i.e bit is not set`\\n\\nClearly, both first and sec belong to different groups and since, all other elements occurs in pair, so, we can safely again use 1. property of xor to generate first. Finally, using 5. propery of xor, we have `sec = xor(firstXorSec, first)`.\\n\\n**NOTE:** \\n1. we can also do: `mask = firstXorSec & -firstXorSec` to get the rightmost set bit in firstXorSec but this method is not intuitive, hence, i avoided it. For more details on how it works, read [here](https://www.quora.com/In-programming-what-does-n-n-return).\\n2. Other similar problems based on the above properties of xor:\\n\\t[136. Single Number](https://leetcode.com/problems/single-number/)\\n\\t[137. Single Number II](https://leetcode.com/problems/single-number-ii/)\\n\\t[268. Missing Number](https://leetcode.com/problems/missing-number/)\\n\\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tint firstXorSec = 0, mask = 1, first = 0;\\n\\t// get xor of first and sec\\n\\tfor (auto &num: nums) firstXorSec ^= num;\\n\\t// get rightmost set bit in above xor\\n\\twhile (not (firstXorSec & mask)) mask <<= 1;\\n\\t// get first distinct number\\n\\tfor (auto &num: nums)\\n\\t\\tif (num & mask) first ^= num;\\n\\t// return ans\\n\\treturn {first, firstXorSec ^ first};\\n}\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tunordered_map<int, int> freq;\\n\\t// generate freq\\n\\tfor (auto &num: nums) ++freq[num];\\n\\tvector<int> ans;\\n\\t// generate ans\\n\\tfor (auto &[x, f]: freq)\\n\\t\\tif (f == 1) {\\n\\t\\t\\tans.push_back(x);\\n\\t\\t\\tif (ans.size() == 2)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\treturn ans;\\n}\\n```\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tunordered_set<int> visited;\\n\\t// store num with odd freq into set\\n\\tfor (auto &num: nums)\\n\\t\\tif (visited.count(num))\\n\\t\\t\\tvisited.erase(num);\\n\\t\\telse visited.insert(num);\\n\\t// return ans\\n\\treturn vector<int> (visited.begin(), visited.end());\\n}\\n```\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tsort (nums.begin(), nums.end());\\n\\tvector<int> ans;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n - 1)\\n\\t    // skip equal elements\\n\\t\\tif (nums[i] == nums[i + 1]) i += 2;\\n\\t\\t// generate ans\\n\\t\\telse {\\n\\t\\t\\tans.push_back(nums[i++]);\\n\\t\\t\\tif (ans.size() == 2)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t// corner case\\n\\tif (ans.size() == 1) \\n\\t\\tans.push_back(nums.back());\\n\\treturn ans;\\n}\\n```\n```\\nvector<int> singleNumber(vector<int> &nums) {\\n\\tint firstXorSec = 0, mask = 1, first = 0;\\n\\t// get xor of first and sec\\n\\tfor (auto &num: nums) firstXorSec ^= num;\\n\\t// get rightmost set bit in above xor\\n\\twhile (not (firstXorSec & mask)) mask <<= 1;\\n\\t// get first distinct number\\n\\tfor (auto &num: nums)\\n\\t\\tif (num & mask) first ^= num;\\n\\t// return ans\\n\\treturn {first, firstXorSec ^ first};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68923,
                "title": "bit-manipulation-beats-99-62",
                "content": "Find the rightmost set bit, divide numbers into two groups. Each group will end up being one unique number.\\n\\n    public int[] singleNumber(int[] nums) {\\n        int result[] = new int[2];        \\n        int xor = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n        {\\n            xor ^= nums[i];\\n        }\\n        \\n        int bit = xor & ~(xor-1);\\n        int num1 = 0;\\n        int num2 = 0;\\n        \\n        for (int num : nums)\\n        {\\n            if ((num & bit) > 0)\\n            {\\n                num1 ^= num;\\n            }\\n            else\\n            {\\n                num2 ^= num;\\n            }\\n        }\\n        \\n        result[0] = num1;\\n        result[1] = num2;\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Find the rightmost set bit, divide numbers into two groups. Each group will end up being one unique number.\\n\\n    public int[] singleNumber(int[] nums) {\\n        int result[] = new int[2];        \\n        int xor = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n        {\\n            xor ^= nums[i];\\n        }\\n        \\n        int bit = xor & ~(xor-1);\\n        int num1 = 0;\\n        int num2 = 0;\\n        \\n        for (int num : nums)\\n        {\\n            if ((num & bit) > 0)\\n            {\\n                num1 ^= num;\\n            }\\n            else\\n            {\\n                num2 ^= num;\\n            }\\n        }\\n        \\n        result[0] = num1;\\n        result[1] = num2;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1561827,
                "title": "c-python-5-simple-solutions-w-explanation-brute-force-sort-hashmap-hashset-xor-o-1",
                "content": "We are given an array `nums` in which only 2 elements occur once and rest all elements occur exactly twice. We need to find the 2 elements that occur only once.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Brute-Force)***\\n \\n Let\\'s start with the most obvious brute-force approach. We can select each number in the given array and re-iterate whole array to see if there\\'s a duplicate. If we don\\'t find a duplicate, then we will push that element into our resultant array and return at the end.\\n \\n**C++** \\n \\n```cpp\\nclass Solution {\\npublic:\\n   vector<int> singleNumber(vector<int>& nums) {\\n       vector<int> ans;\\n       for(int i = 0; i < size(nums) && size(ans) < 2; i++) \\n           for(int j = 0; j < size(nums); j++) \\n               if(i != j and nums[i] == nums[j]) break;\\n               else if(j == size(nums)-1) ans.push_back(nums[i]);\\n       return ans;\\n   }\\n};\\n```\\n\\n**Python**\\n \\n ```python\\n class Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i, n1 in enumerate(nums):\\n            for j, n2 in enumerate(nums):\\n                if i != j and n1 == n2: break\\n                elif j == len(nums)-1:\\n                    ans.append(n1)\\n        return ans\\n ```\\n \\n ***Time Complexity :*** <code><b>O(N<sup>2</sup>)</b></code>, where `N` is the number of elements in the given array. We iterate over the entire array for each element until we find two elements that occur only once. In the worst case, we iterate over entire array for `N` times for `N` elements giving the overall time complexity of  <code>O(N*N) = O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **`O(1)`**, only constant extra space is used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Sort)***\\n\\nWe can sort and then each duplicate element will be adjacent. We can iterate over array and check if an element occurs only once by comparing it with its adjacent elements\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) \\n            if((i && nums[i] == nums[i-1]) || (i+1 < size(nums) && nums[i] == nums[i+1])) continue;\\n            else ans.push_back(nums[i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        ans = []\\n        for i in range(len(nums)):\\n            if (i and nums[i] == nums[i-1]) or (i+1 < len(nums) and nums[i] == nums[i+1]):\\n                continue\\n            ans.append(nums[i])\\n        return ans\\n```\\n\\n ***Time Complexity :*** <code><b>O(NlogN)</b></code>, required for sorting\\n***Space Complexity :*** **`O(sort)`**, the space required by internal sorting algorithm used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (HashMap)***\\n\\nA more efficient way to solve this problem is to maintain a hashmap. \\n* We iterate over the array and store the number of times an element occurs in the array using the hashmap. \\n* Then, we iterate over the hashmap and push the elements into the resultant array that occurs only once.\\n\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int, int> mp;\\n        for(const int n : nums) mp[n]++;\\n        for(auto [n, freq] : mp) \\n            if(freq == 1) \\n\\t\\t\\t    ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        ans, mp = [], Counter(nums)\\n        for n, freq in mp.items():\\n            if freq == 1:\\n                ans.append(n)\\n        return ans\\n```\\n\\n ***Time Complexity :*** <code><b>O(N)</b></code>, we iterate over the array once and the hashmap once which contains `N-2` elements. Thus the overall time complexity comes out to `O(N + N - 2) \\u2248 O(2N-2) \\u2248 O(N)`\\n***Space Complexity :*** **`O(N)`**, required for maintaining the hashmap.\\n\\n---\\n\\n \\u2714\\uFE0F ***Solution - IV (HashSet)***\\n\\nThis approach is very similar to previous one. But since the elements occur only once or twice, we can optimize the previous approach slightly by using hashset instead. \\n\\n* The first time we encounter an element, we add it into hashset\\n* If we find an element that is already present in hashset, we remove it.\\n* Finally, our hashset will only contain elements occuring once.\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(const int n : nums) \\n            if(s.count(n)) s.erase(n);\\n            else s.insert(n);\\n        return vector<int>(begin(s), end(s));\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        s = set()\\n        for n in nums:\\n            if n in s: s.remove(n)\\n            else: s.add(n)\\n        return s\\n```\\n\\n\\n ***Time Complexity :*** <code><b>O(N)</b></code>\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Xor)***\\n\\nBoth the above solutions solve the question but neither do it both in optimal time and space complexity. I would suggest to first solve **[136. Single Number](https://leetcode.com/problems/single-number/)** if you haven\\'t already, before moving on to the solution.\\n\\nWe use the Xor function to solve this problem in linear time and constant space complexity. First, let\\'s note the properties of Xor -\\n\\n1. **A \\u2295 B = B \\u2295 A**\\n2. **A \\u2295 ( B \\u2295 C ) = ( A \\u2295 B ) \\u2295 C**\\n3. **A \\u2295 0 = A**\\n4. **A \\u2295 A = 0**\\n\\nThe last property is the main one that will be helpful to solve this question. If we Xor all the elements of given array, all the **duplicate elements will cancel out each other** out to 0 because they occur exactly twice and the **result - `Xor1` will be Xor  of the elements that occur only once.**\\n\\n**But how do we differentiate and find the two elements from `Xor1`?**\\n\\nFor this, we need to dig deeper into how Xor works on bit-level. The **Xor property-4** basically tells us that two same bits will cancel each other out to 0 (**1 \\u2295 1 = 0** and **0 \\u2295 0 = 0**).  So, all the set bits in the Xor always occur odd number of times in the array. \\n\\nThus, we select any arbitrary set-bit of the Xor obtained in above iteration - let\\'s choose the lowest set-bit - `i`. Then we can re-iterate over the array and Xor all elements having `i`th bit set. All the duplicates will again cancel out each other and the resultant Xor - **`Xor2`** will be one of the elements that occur only once.\\n\\nWe can then perform **`Xor1 \\u2295 Xor2`**, which will cancel out the first element occuring once and we get the 2nd element as well :)\\n\\n<details>\\n<summary><b>Dry run</b></summary>\\n\\n```cpp\\nnums = [1,2,1,3,2,5]\\nWe need to find a and b such that both of them occur once in the array.\\n\\n1. Xor1 = 1 \\u2295 2 \\u2295 1 \\u2295 3 \\u2295 2 \\u2295 5 = 6\\nTo verify, calculate a \\u2295 b = 3 \\u2295 5 = 6 which is equal to Xor1\\n\\n2. The lowest set-bit in Xor1 (110) is 2nd bit.\\n\\n3. We Xor all elements having 2nd bit set.\\n   So, Xor2 = 2 \\u2295 3 \\u2295 2 = 3\\n   So, we get one of the number occuring exactly once - 3\\n   \\n\\n4. We get the 2nd number by doing Xor1 \\u2295 Xor2 = 6 \\u2295 3 = 5\\n\\nThus, we can see that this method correctly finds the two elements occuring once.\\n```\\n\\n</details>\\n\\n</br>\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int Xor1 = 0, Xor2 = 0, i;\\n        for(const int n : nums) Xor1 ^= n;      // Xor all elements of array\\n        for(int bit = 0; bit < 32; bit++)       // finding the lowest set bit in Xor1\\n            if(Xor1 & 1 << bit) {\\n                i = bit;\\n                break;\\n            }\\n        \\n        for(const int n : nums)              // Xor-ing all elements having ith bit set\\n            if(n & 1 << i) \\n                Xor2 ^= n;\\n\\t\\t\\t\\t\\n        return {Xor1 ^ Xor2, Xor2};             // final result\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        Xor1, Xor2, i = 0, 0, 0\\n        for n in nums:\\n            Xor1 ^= n\\n        for bit in range(32):\\n            if Xor1 & 1 << bit:\\n                i = bit\\n                break\\n        for n in nums:\\n            if n & 1 << i:\\n                Xor2 ^= n\\n        return [Xor1 ^ Xor2, Xor2]\\n```\\n\\n ***Time Complexity :*** <code><b>O(N)</b></code>. We iterate over the array exactly twice.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is used.\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n   vector<int> singleNumber(vector<int>& nums) {\\n       vector<int> ans;\\n       for(int i = 0; i < size(nums) && size(ans) < 2; i++) \\n           for(int j = 0; j < size(nums); j++) \\n               if(i != j and nums[i] == nums[j]) break;\\n               else if(j == size(nums)-1) ans.push_back(nums[i]);\\n       return ans;\\n   }\\n};\\n```\n```python\\n class Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i, n1 in enumerate(nums):\\n            for j, n2 in enumerate(nums):\\n                if i != j and n1 == n2: break\\n                elif j == len(nums)-1:\\n                    ans.append(n1)\\n        return ans\\n ```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) \\n            if((i && nums[i] == nums[i-1]) || (i+1 < size(nums) && nums[i] == nums[i+1])) continue;\\n            else ans.push_back(nums[i]);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        ans = []\\n        for i in range(len(nums)):\\n            if (i and nums[i] == nums[i-1]) or (i+1 < len(nums) and nums[i] == nums[i+1]):\\n                continue\\n            ans.append(nums[i])\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int, int> mp;\\n        for(const int n : nums) mp[n]++;\\n        for(auto [n, freq] : mp) \\n            if(freq == 1) \\n\\t\\t\\t    ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        ans, mp = [], Counter(nums)\\n        for n, freq in mp.items():\\n            if freq == 1:\\n                ans.append(n)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(const int n : nums) \\n            if(s.count(n)) s.erase(n);\\n            else s.insert(n);\\n        return vector<int>(begin(s), end(s));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        s = set()\\n        for n in nums:\\n            if n in s: s.remove(n)\\n            else: s.add(n)\\n        return s\\n```\n```cpp\\nnums = [1,2,1,3,2,5]\\nWe need to find a and b such that both of them occur once in the array.\\n\\n1. Xor1 = 1 \\u2295 2 \\u2295 1 \\u2295 3 \\u2295 2 \\u2295 5 = 6\\nTo verify, calculate a \\u2295 b = 3 \\u2295 5 = 6 which is equal to Xor1\\n\\n2. The lowest set-bit in Xor1 (110) is 2nd bit.\\n\\n3. We Xor all elements having 2nd bit set.\\n   So, Xor2 = 2 \\u2295 3 \\u2295 2 = 3\\n   So, we get one of the number occuring exactly once - 3\\n   \\n\\n4. We get the 2nd number by doing Xor1 \\u2295 Xor2 = 6 \\u2295 3 = 5\\n\\nThus, we can see that this method correctly finds the two elements occuring once.\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int Xor1 = 0, Xor2 = 0, i;\\n        for(const int n : nums) Xor1 ^= n;      // Xor all elements of array\\n        for(int bit = 0; bit < 32; bit++)       // finding the lowest set bit in Xor1\\n            if(Xor1 & 1 << bit) {\\n                i = bit;\\n                break;\\n            }\\n        \\n        for(const int n : nums)              // Xor-ing all elements having ith bit set\\n            if(n & 1 << i) \\n                Xor2 ^= n;\\n\\t\\t\\t\\t\\n        return {Xor1 ^ Xor2, Xor2};             // final result\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        Xor1, Xor2, i = 0, 0, 0\\n        for n in nums:\\n            Xor1 ^= n\\n        for bit in range(32):\\n            if Xor1 & 1 << bit:\\n                i = bit\\n                break\\n        for n in nums:\\n            if n & 1 << i:\\n                Xor2 ^= n\\n        return [Xor1 ^ Xor2, Xor2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561785,
                "title": "java-simple-bit-manipulation-using-xor-two-pass-beats-100-0ms-tc-o-n-sc-o-1",
                "content": "# **Two-Pass Solution | Bit Manipulation using XOR**\\nThe idea is to use XOR to remove all numbers that appear exactly twice. Thus, in the first pass, we will XOR all nums in the input array. We will be left with XOR (`aXORb`) of two numbers that appear exactly once. (Let\\'s call these numbers `A` and `B`.)\\n\\nIn XOR, a bit is set in the result if both bits at the same locations are different.\\nNow find the rightmost set bit in `aXORb`. This will give us the rightmost bit that is different in `A` & `B`. \\n\\nWe can now go through all numbers in input array again (second pass) and XOR the numbers that have this bit set to `1`. This will give us the first number `A`.\\nTo get the second number perform `aXORb ^ A`.\\n\\n---\\n\\n**Example**\\n\\nLet us use this input: nums = `[1,2,1,3,2,5]`\\nSince we will need the binary representation of each of these numbers, I have converted them here for simplicity `[0x001, 0x010, 0x001, 0x011, 0x010, 0x101]`\\n\\nNow perform XOR each of these numbers:\\n`aXORb` = `1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5` = `0x110`\\n\\nIn this `aXORb` rightmost set bit can be found by ` aXORb & -aXORb` which will give us:\\n`rightSetBit` = `0x010`;\\n\\nIn the second pass, we try to XOR all numbers that have this bit set to `1`. There are total three such numbers: `[2, 2, 3]`. XOR of these numbers should give us `3`. This can be assigned to `A`.  To get `B` we can perform XOR of `A` and `aXORb`. In this example, `aXORb ^ A` = `0x110 ^ 0x011` = `0x101` (which is 5 in decimal).\\n\\nThus the output result is `[3,5]`.\\n\\n---\\n\\n**Time Complexity:** `O(2 * N)` = `O(N)` --> Each number in the input array is visited twice.\\n\\n**Space Complexity:** `O(1)` --> Uses constant auxiliary space.\\n\\n---\\n\\n```java\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        if (nums == null || nums.length < 2 || nums.length % 2 != 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n\\n        int aXORb = 0;\\n        for (int n : nums) {\\n            aXORb ^= n;\\n        }\\n\\n        int rightSetBit = aXORb & -aXORb;\\n        int a = 0;\\n        for (int n : nums) {\\n            if ((n & rightSetBit) != 0) {\\n                a ^= n;\\n            }\\n        }\\n\\n        return new int[] {a, aXORb ^ a};\\n    }\\n}\\n```\\n\\n---\\n\\n<ins>Other Similar questions on LeetCode:</ins>\\n- [136. Single Number](https://leetcode.com/problems/single-number/)\\n- [137. Single Number II](https://leetcode.com/problems/single-number-ii/)\\n- [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)\\n- [461. Hamming Distance](https://leetcode.com/problems/hamming-distance/)\\n- [477. Total Hamming Distance](https://leetcode.com/problems/total-hamming-distance/)\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        if (nums == null || nums.length < 2 || nums.length % 2 != 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n\\n        int aXORb = 0;\\n        for (int n : nums) {\\n            aXORb ^= n;\\n        }\\n\\n        int rightSetBit = aXORb & -aXORb;\\n        int a = 0;\\n        for (int n : nums) {\\n            if ((n & rightSetBit) != 0) {\\n                a ^= n;\\n            }\\n        }\\n\\n        return new int[] {a, aXORb ^ a};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561847,
                "title": "c-easy-intuitive-sol-bit-manipulation-o-n-time-and-o-1-space-complexity",
                "content": "Hello there, first of all thanks in advance for reading!\\n\\n**My approach:**\\n\\n1. Since, we know for a fact that there are exactly 2 numbers that appear once (let them be x and y) and others appear twice.\\n\\n2. Therefore, its better to take xor of every number so that we are left with (x^y).\\n\\n3. Now, we know that suppose ith bit (let say rightmost bit) is set in our xor, that can only mean that the ith bit was set in exactly one of the two numbers x and y.\\n\\n4. So, to seperate x and y, we know that they have different ith bit and therefore we will take two buckets.\\n\\n5. We will loop through the vector again and put the numbers whose ith bit is set in bucket 1 and others in bucket 2. (WLOG assume that x comes in bucket1 and y comes in bucket2 with the rest of the numbers)\\n\\n6. Now, note that in bucket1 we have x and other numbers that appear twice and in bucket2 we have y and other numbers that appear twice. So its better to take the xor of bucket1 (we get x from here) and xor of bucket2 (we get y from here).\\n\\n**Time Complexity:** O(N) for first loop and O(N) for second loop. Hence overall it is O(N).\\n**Space Complexity:** O(1)\\n\\nBelow is the implementation of my approach mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        int bucket1{}, bucket2{};\\n        long long int xr{};\\n        \\n\\t\\t//Calculate xor of every number so that xr will have (x^y)\\n        for(int i{}; i<n; ++i) \\n            xr = xr ^ nums[i];\\n        \\n\\t\\t// Compute rightmost set bit of xr, gives us the ith bit we need as a mask\\n        int mask = xr & (-xr);\\n        \\n\\t\\t// Fill our buckets according to our intuition mentioned in above steps\\n        for(int i{}; i<n; ++i){\\n            \\n            if(mask & nums[i])\\n                bucket1 ^= nums[i];\\n            \\n            else\\n                bucket2 ^= nums[i];\\n        }\\n        \\n\\t\\t// bucket1 and bucket2 will contain x and y\\n        res.push_back(bucket1);\\n        res.push_back(bucket2);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        int bucket1{}, bucket2{};\\n        long long int xr{};\\n        \\n\\t\\t//Calculate xor of every number so that xr will have (x^y)\\n        for(int i{}; i<n; ++i) \\n            xr = xr ^ nums[i];\\n        \\n\\t\\t// Compute rightmost set bit of xr, gives us the ith bit we need as a mask\\n        int mask = xr & (-xr);\\n        \\n\\t\\t// Fill our buckets according to our intuition mentioned in above steps\\n        for(int i{}; i<n; ++i){\\n            \\n            if(mask & nums[i])\\n                bucket1 ^= nums[i];\\n            \\n            else\\n                bucket2 ^= nums[i];\\n        }\\n        \\n\\t\\t// bucket1 and bucket2 will contain x and y\\n        res.push_back(bucket1);\\n        res.push_back(bucket2);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68931,
                "title": "easy-python-o-n-o-1-solution",
                "content": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[int]\\n            \"\"\"\\n            xor = 0\\n            a = 0\\n            b = 0\\n            for num in nums:\\n                xor ^= num\\n            mask = 1\\n            while(xor&mask == 0):\\n                mask = mask << 1\\n            for num in nums:\\n                if num&mask:\\n                    a ^= num\\n                else:\\n                    b ^= num\\n            return [a, b]",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[int]\\n            \"\"\"\\n            xor = 0\\n            a = 0\\n            b = 0\\n            for num in nums:\\n                xor ^= num\\n            mask = 1\\n            while(xor&mask == 0):\\n                mask = mask << 1\\n            for num in nums:\\n                if num&mask:\\n                    a ^= num\\n                else:\\n                    b ^= num\\n            return [a, b]",
                "codeTag": "Java"
            },
            {
                "id": 1561873,
                "title": "solutions-for-interview-simple-no-complex-bit-logic",
                "content": "***Method 1(Using hashing)***\\n\\nBy storing the frequency of all elements int the hashmap we can easily find which two elements are having `frequency ==1`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto x:nums){\\n            mp[x]++;\\n        }\\n        vector<int>ans;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Complexity:***\\n```\\nTime: O (n)\\nSpace: O (n)\\n```\\n\\n***Method 2(Using bit manipulation)***\\nWe will be needing `xor of the elements` of the complete array in two passes.\\n\\n**INTUITION**\\nAs we know the two numbers appearing once will differ at atleast `one bit `\\n```\\nEg:- Let 1st number be 1 and 2nd be 5\\n1 => 0001\\n5 => 0101\\n1 and 5 differ at 3rd bit\\n```\\nSo, we need to find the one bit at which numbers differ, so that we can divide the array into two groups\\n```\\nEg :- Let array be [1,3,3,4,4,5,6,6,7,7]\\nWe can observe that the two numbers coming once are 1 and 5, bit at which\\n1 and 5 differ are 3rd bit\\nSo, number :- 1 ,3rd bit is 0 and number 5, 3rd bit is 1\\n```\\nNow we need to divide the array into two groups with numbers at `3rd bit == 0 as 1st group` and numbers with `3rd bit==1 into second`\\n```\\nGroup 1 => [1,3,3]  //1 and 3 are having 3rd bit as 0\\nGroup 2 => [4,4,5,6,6,7,7]  //4,5,6,7 are having 3rd bit as 1\\n```\\nNow xoring into respective groups will give us the two numbers.\\n\\n**How to find the bit at which two numbers differ?**\\nWe will iterate the bits of xor of complete elements (x) `(0-32)` and will check if the `ith bit of xor is one` then it is different, we will check this by the formulae:-\\n`x&(1<<i)`\\n For those who don\\'t know about this formulae,\\n Here,\\n```\\n1 << 0 = `0000 0001`\\n1 << 1 = `0000 0010`\\n1 << 2 = `0000 0100`\\n``` \\nand` i varies from (0-32)`\\nAnd we are using and operation for checking every bit to be one\\n\\n**STEPS**\\n* Take xor the the complete array and store in` variable x`\\n* Now we need to find the bit at which the two numbers differ let it be `idx`\\n* The idx can be either `1 or 0`\\n* By dividing the set of numbers into 2 groups with first group of idx` bit==1 and second bit==0`\\n* Now xoring in respective groups will give us two numbers.\\n\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int x=0; \\n        //Xoring all elements\\n        for(int i=0;i<nums.size();i++){\\n            x^=nums[i];\\n        }\\n        //index for bit difference\\n        int idx;\\n\\t\\t\\n        //Find the bit at which two numbers differ\\n        for(int i=0;i<32;i++){\\n            if(x&(1<<i)){\\n                idx=i;break;\\n            }\\n        }\\n        //Finding the 1st number\\n        int first=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]&(1<<idx)){\\n                first^=nums[i];\\n            }\\n        }\\n\\t\\t//second number will be xor of complete and first\\n        int second=first^x;\\n        return {first,second};\\n    }\\n```\\n***Complexity:***\\n```\\nTime: O (n)\\nSpace: O (1)\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto x:nums){\\n            mp[x]++;\\n        }\\n        vector<int>ans;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime: O (n)\\nSpace: O (n)\\n```\n```\\nEg:- Let 1st number be 1 and 2nd be 5\\n1 => 0001\\n5 => 0101\\n1 and 5 differ at 3rd bit\\n```\n```\\nEg :- Let array be [1,3,3,4,4,5,6,6,7,7]\\nWe can observe that the two numbers coming once are 1 and 5, bit at which\\n1 and 5 differ are 3rd bit\\nSo, number :- 1 ,3rd bit is 0 and number 5, 3rd bit is 1\\n```\n```\\nGroup 1 => [1,3,3]  //1 and 3 are having 3rd bit as 0\\nGroup 2 => [4,4,5,6,6,7,7]  //4,5,6,7 are having 3rd bit as 1\\n```\n```\\n1 << 0 = `0000 0001`\\n1 << 1 = `0000 0010`\\n1 << 2 = `0000 0100`\\n```\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int x=0; \\n        //Xoring all elements\\n        for(int i=0;i<nums.size();i++){\\n            x^=nums[i];\\n        }\\n        //index for bit difference\\n        int idx;\\n\\t\\t\\n        //Find the bit at which two numbers differ\\n        for(int i=0;i<32;i++){\\n            if(x&(1<<i)){\\n                idx=i;break;\\n            }\\n        }\\n        //Finding the 1st number\\n        int first=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]&(1<<idx)){\\n                first^=nums[i];\\n            }\\n        }\\n\\t\\t//second number will be xor of complete and first\\n        int second=first^x;\\n        return {first,second};\\n    }\\n```\n```\\nTime: O (n)\\nSpace: O (1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342714,
                "title": "best-explanation-c",
                "content": "In exercise Finding a Number That Appears Once in Array of Duplicated Numbers we have discussed a simple method to isolate one number which appears once when all other elements appear exactly twice. The solution was to XOR all the array elements. Since K XOR K is zero for any integer K, we are sure that all duplicated numbers will zero themselves out. The only number which does not cancel itself is the one which appears once. So the result of the operation is that one number.\\n\\nHowever, this solution cannot be applied directly to finding two numbers that appear once each. Suppose that these numbers that appear once are J and K, and all other numbers appear twice. If we decide to XOR all the array\\'s elements, the overall result would actually be J XOR K. Unfortunately, there is no way to extract J and K out of their XOR. But there is one thing that we can do. Since J and K are different, we are sure that J XOR K is different than zero. This information is valuable in sense that we know pieces of information that differ. If we pick up any bit that is 1 in J XOR K, we can use it as a mask to test each element of the array. Obviously, that mask will be the discriminator between J and K - only one of them will have value 1 at that particular position.\\n\\nNow that we have the mask with exactly one bit set to 1, we can walk through the array once again. But this time we are going to maintain two XORed results. One for numbers that have bit 1 at the mask\\'s position and another for numbers that have bit 0 at that position. In this way, we are sure that all duplicates will go into the same pile. But likewise, we are sure that J and K will go into separate piles. The overall result is that the first XORed result will be equal to J and the second XORed result will be equal to K (or the other way around, but it really doesn\\'t matter).\\n\\n\\n\\'\\'\\'\\n\\n    vector<int> singleNumber(vector<int>& A) {\\n        int n=A.size();\\n        int mask=1;\\n        int Xor=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            Xor^=A[i];\\n            \\n        }\\n        \\n        while((Xor &mask)==0)\\n        {\\n            mask<<=1;\\n        }\\n        \\n        int j=0,k=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask & A[i])==0) j^=A[i];\\n            else k^=A[i];\\n            \\n        }\\n        cout<<mask;\\n        \\n        vector<int>ans;\\n        ans.push_back(j);\\n         ans.push_back(k);\\n        return ans;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "In exercise Finding a Number That Appears Once in Array of Duplicated Numbers we have discussed a simple method to isolate one number which appears once when all other elements appear exactly twice. The solution was to XOR all the array elements. Since K XOR K is zero for any integer K, we are sure that all duplicated numbers will zero themselves out. The only number which does not cancel itself is the one which appears once. So the result of the operation is that one number.\\n\\nHowever, this solution cannot be applied directly to finding two numbers that appear once each. Suppose that these numbers that appear once are J and K, and all other numbers appear twice. If we decide to XOR all the array\\'s elements, the overall result would actually be J XOR K. Unfortunately, there is no way to extract J and K out of their XOR. But there is one thing that we can do. Since J and K are different, we are sure that J XOR K is different than zero. This information is valuable in sense that we know pieces of information that differ. If we pick up any bit that is 1 in J XOR K, we can use it as a mask to test each element of the array. Obviously, that mask will be the discriminator between J and K - only one of them will have value 1 at that particular position.\\n\\nNow that we have the mask with exactly one bit set to 1, we can walk through the array once again. But this time we are going to maintain two XORed results. One for numbers that have bit 1 at the mask\\'s position and another for numbers that have bit 0 at that position. In this way, we are sure that all duplicates will go into the same pile. But likewise, we are sure that J and K will go into separate piles. The overall result is that the first XORed result will be equal to J and the second XORed result will be equal to K (or the other way around, but it really doesn\\'t matter).\\n\\n\\n\\'\\'\\'\\n\\n    vector<int> singleNumber(vector<int>& A) {\\n        int n=A.size();\\n        int mask=1;\\n        int Xor=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            Xor^=A[i];\\n            \\n        }\\n        \\n        while((Xor &mask)==0)\\n        {\\n            mask<<=1;\\n        }\\n        \\n        int j=0,k=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask & A[i])==0) j^=A[i];\\n            else k^=A[i];\\n            \\n        }\\n        cout<<mask;\\n        \\n        vector<int>ans;\\n        ans.push_back(j);\\n         ans.push_back(k);\\n        return ans;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 68945,
                "title": "share-my-c-solution",
                "content": "> 1.assume that A and B are the two elements which we want to find;\\n\\n>2.use XOR for all elements,the result is : r = A^B,we just need to distinguish A from B next step;\\n\\n>3.if we can find a bit '1' in r,then the bit in corresponding position in A and B must be different.We can use {last = r & (~(r-1))} to get the last bit 1 int r;\\n\\n>4.we use last to divide all numbers into two groups,then A and B must fall into the two distrinct groups.XOR elements in eash group,get the A and B.\\n\\n    class Solution {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) {\\n            int r = 0, n = nums.size(), i = 0, last = 0;\\n            vector<int> ret(2, 0);\\n            \\n            for (i = 0; i < n; ++i) \\n                r ^= nums[i];\\n            \\n            last = r & (~(r - 1));\\n            for (i = 0; i < n; ++i)\\n            {\\n                if ((last & nums[i]) != 0)\\n                    ret[0] ^= nums[i];\\n                else\\n                    ret[1] ^= nums[i];\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) {\\n            int r = 0, n = nums.size(), i = 0, last = 0;\\n            vector<int> ret(2, 0);\\n            \\n            for (i = 0; i < n; ++i) \\n                r ^= nums[i];\\n            \\n            last = r & (~(r - 1));\\n            for (i = 0; i < n; ++i)\\n            {\\n                if ((last & nums[i]) != 0)\\n                    ret[0] ^= nums[i];\\n                else\\n                    ret[1] ^= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69006,
                "title": "my-java-solution-adapted-from-the-commonest-solution-here",
                "content": "I read @zhiqing_xiao 's post to get an idea about the solution. His solution is really smart and elegant, but it took me a while to get understand how \"diff &= -diff\" works. I changed it a little bit to make it better understood, but it is totally based on his solution.\\n\\nInstead of using the right-most \"1\" of diff, I used the left-most \"1\" to divide groups. This should also do the trick.\\n\\n    public class Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int diff = 0;\\n        for(int num: nums){\\n            diff^=num;\\n        }\\n        diff = Integer.highestOneBit(diff);\\n        \\n        int[] result = new int[2];\\n        Arrays.fill(result,0);\\n        for(int num: nums){\\n            if((diff & num) == 0){\\n                result[0] ^= num;\\n            }\\n            else{\\n                result[1] ^= num;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int diff = 0;\\n        for(int num: nums){\\n            diff^=num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69007,
                "title": "c-o-n-time-o-1-space-7-line-solution-with-detail-explanation",
                "content": "    int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n        int i, *ret = calloc(*returnSize = 2, sizeof(int));\\n        for(i = 0; i < numsSize; ret[0] ^= nums[i++]);\\n        for(i = 0; i < numsSize; i++)\\n            if(nums[i] & ret[0] & -ret[0])\\n                ret[1] ^= nums[i];\\n        ret[0] ^= ret[1];\\n        return ret;\\n    }\\n\\nHowever I posted this question some days ago at https://leetcode.com/discuss/48119/single-number-iii .\\n\\n 1. x = xor of each element in the list ==> x = a xor b\\n 2. a != b => there are at least one 1-bit in x\\n 3. take an arbitrary 1-bit (which means a and b is different on this bit), the elements in the array can be classified into two groups according to this bit: one of them contains a, the other contains b. \\n 4. a = xor of each element in the list which the corresponding bit = 0 \\n 5. b = a xor x",
                "solutionTags": [],
                "code": "    int* singleNumber(int* nums, int numsSize, int* returnSize) {\\n        int i, *ret = calloc(*returnSize = 2, sizeof(int));\\n        for(i = 0; i < numsSize; ret[0] ^= nums[i++]);\\n        for(i = 0; i < numsSize; i++)\\n            if(nums[i] & ret[0] & -ret[0])\\n                ret[1] ^= nums[i];\\n        ret[0] ^= ret[1];\\n        return ret;\\n    }\\n\\nHowever I posted this question some days ago at https://leetcode.com/discuss/48119/single-number-iii .\\n\\n 1. x = xor of each element in the list ==> x = a xor b\\n 2. a != b => there are at least one 1-bit in x\\n 3. take an arbitrary 1-bit (which means a and b is different on this bit), the elements in the array can be classified into two groups according to this bit: one of them contains a, the other contains b. \\n 4. a = xor of each element in the list which the corresponding bit = 0 \\n 5. b = a xor x",
                "codeTag": "Java"
            },
            {
                "id": 1456099,
                "title": "accepted-c-o-n-time-easy-solution-with-detailed-explaination",
                "content": "**STEPS**\\n1. First we run ^(xor) to get the a^b (According to ex 1, 1^1 = 0 and 2^2 = 0 and the final xor = 3^5)\\n2. Search the position to do partitioning in binary representation of a^b\\n3. Partition the array by this position and get a and b correspondingly\\n\\n**e.g. [1, 2, 1, 3, 2, 5]**\\n\\n**1 = 001\\n2 = 010\\n1 = 001\\n3 = 011\\n2 = 010\\n5 = 101**\\n\\nAfter 1st step, we found out that a^b = 3^5 = 6 which is 110\\nLet\\'s use the righmost setbit to partition our array\\n\\nNow we create a mask and then find the rightmost setbit so the mask will be, mask = 010 \\n\\n**If mask & nums[i] == 0**\\n1 = 001 \\n1 = 001 \\n5 = 101 \\u2705\\n1^1^5 => **5**\\n\\n**else**\\n2 = 010\\n2 = 010              \\n3 = 011 \\u2705\\n2^2^3 => **3**\\n\\n**ans = [3, 5]**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xoR = 0,n = nums.size();\\n        for(int i = 0;i<n;i++) {\\n            xoR ^= nums[i];\\n        }\\n        \\n        int mask = 1;\\n        while(1) {\\n            if((mask & xoR) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int a = 0, b = 0;\\n        for(int i = 0;i<n;i++) {\\n            if(nums[i] & mask) a ^= nums[i];\\n            else b ^= nums[i];\\n        }\\n        return {a, b}; \\n    }\\n};\\n```\\n**Upvote if this helps you :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xoR = 0,n = nums.size();\\n        for(int i = 0;i<n;i++) {\\n            xoR ^= nums[i];\\n        }\\n        \\n        int mask = 1;\\n        while(1) {\\n            if((mask & xoR) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int a = 0, b = 0;\\n        for(int i = 0;i<n;i++) {\\n            if(nums[i] & mask) a ^= nums[i];\\n            else b ^= nums[i];\\n        }\\n        return {a, b}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69013,
                "title": "16ms-c-solution",
                "content": "Assume that the two single numbers are x and y. \\n\\n1. XOR all the numbers and all the duplicates will be neutralized, so the result will be x^y.\\n2. Get the number which contains a single one bit, i.e., the lowest one bit of x^y.\\n3. XOR all the numbers which has the lowest one bit of x^y. Assume that the lowest one bit of x^y comes from x. Then y won't be included in the xor operations. Since those duplicates which also have the lowest one bit of x^y are neutralized, the result will be x.\\n\\nCode:\\n\\n    class Solution \\n    {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) \\n        {\\n            vector<int> res;\\n            \\n            // Assume that the two single numbers are x and y. \\n            // XOR all the numbers and all the duplicates will \\n            // be neutralized, so the result will be x^y.\\n            int xXorY = 0;\\n            for (auto& i : nums)\\n            {\\n                xXorY ^= i;\\n            }\\n            \\n            // Get the number which contains a single one bit, \\n            // i.e., the lowest one bit of x^y.\\n            int lowestOneBit = xXorY & (~(xXorY - 1));\\n            \\n            // XOR all the numbers which has the lowest one bit \\n            // of x^y. Assume that the lowest one bit of x^y \\n            // comes from x. Then y won't be included in the \\n            // xor operations. Since those duplicates which also  \\n            // have the lowest one bit of x^y are neutralized, \\n            // the result will be x.\\n            int x = 0;\\n            for (auto& i : nums)\\n            {\\n                if (i & lowestOneBit)\\n                {\\n                    x ^= i;\\n                }\\n            }\\n            \\n            // y = (x^y)^x.\\n            int y = xXorY ^ x;\\n            \\n            res.push_back(x);\\n            res.push_back(y);\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) \\n        {\\n            vector<int> res;\\n            \\n            // Assume that the two single numbers are x and y. \\n            // XOR all the numbers and all the duplicates will \\n            // be neutralized, so the result will be x^y.\\n            int xXorY = 0;\\n            for (auto& i : nums)\\n            {\\n                xXorY ^= i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 68924,
                "title": "3-lines-ruby-4-lines-c",
                "content": "Based on [Nakagawa_Kanon's solution/explanation](https://leetcode.com/discuss/52369/c-o-n-time-o-1-space-7-line-solution-with-detail-explanation).\\n\\n**Ruby**\\n\\n    def single_number(nums)\\n      a = nums.reduce(:^)\\n      b = nums.select { |n| n & a & -a > 0 }.reduce(:^)\\n      [a ^ b, b]\\n    end\\n\\nOr:\\n    \\n    def single_number(nums)\\n      a = b = nums.reduce(:^)\\n      nums.each { |n| b ^= n if n & a & -a > 0 }\\n      [a ^ b, b]\\n    end\\n\\n**C++**\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for (int n : nums)                 a ^= n;\\n        for (int n : nums) if (n & a & -a) b ^= n;\\n        return {a ^ b, b};\\n    }",
                "solutionTags": [
                    "C++",
                    "Ruby"
                ],
                "code": "Based on [Nakagawa_Kanon's solution/explanation](https://leetcode.com/discuss/52369/c-o-n-time-o-1-space-7-line-solution-with-detail-explanation).\\n\\n**Ruby**\\n\\n    def single_number(nums)\\n      a = nums.reduce(:^)\\n      b = nums.select { |n| n & a & -a > 0 }.reduce(:^)\\n      [a ^ b, b]\\n    end\\n\\nOr:\\n    \\n    def single_number(nums)\\n      a = b = nums.reduce(:^)\\n      nums.each { |n| b ^= n if n & a & -a > 0 }\\n      [a ^ b, b]\\n    end\\n\\n**C++**\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for (int n : nums)                 a ^= n;\\n        for (int n : nums) if (n & a & -a) b ^= n;\\n        return {a ^ b, b};\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1561823,
                "title": "python-o-1-space-easy-clean-code-with-explaination-sr",
                "content": "**PLEASE DO UPVOTE IF YOU GET THIS**\\n```\\nimport math\\nclass Solution:\\n    \\'\\'\\'\\n        say nums = [1,2,1,3,2,5]\\n        x = XOR(nums) -> 6\\n        Binary form of 6 is 110\\n\\n        find the first set bit position and divide the array into 2 based on that bit position\\n        why?\\n            Becoz 6 is the result obtained after 3^5 -> if we can throw these numbers into different parts \\n            then our smaller arrays looks like -> [find the number that will appear exactly once and \\n            remaining elements appear twice]\\n\\n        Based on 2nd bit position if we partition the array it looks like\\n\\n        Array1 -> [1,1,5]\\n        Array2 -> [2,3,2]\\n\\n        Apply XOR for each part -> TADA!!!! We got what we want\\n\\n    \\'\\'\\'\\n        \\n    def checkBit(self, n, i):\\n        return (n & (1<<i))!=0\\n    \\n    def getSetBitPos(self, n):\\n        for i in range(32):\\n            if self.checkBit(n, i):\\n                return i\\n    \\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x,n = 0,len(nums)\\n        if n==2:\\n            return nums\\n        \\n        for i in range(n):\\n            x^=nums[i]\\n        \\n        pos = self.getSetBitPos(x)\\n        x1,x2 = 0,0\\n        for i in range(n):\\n            if self.checkBit(nums[i],pos):\\n                x1^=nums[i]\\n            else:\\n                x2^=nums[i]\\n        \\n        return [x1, x2]\\n```\\n**PLEASE DO UPVOTE IF YOU GET THIS**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    \\'\\'\\'\\n        say nums = [1,2,1,3,2,5]\\n        x = XOR(nums) -> 6\\n        Binary form of 6 is 110\\n\\n        find the first set bit position and divide the array into 2 based on that bit position\\n        why?\\n            Becoz 6 is the result obtained after 3^5 -> if we can throw these numbers into different parts \\n            then our smaller arrays looks like -> [find the number that will appear exactly once and \\n            remaining elements appear twice]\\n\\n        Based on 2nd bit position if we partition the array it looks like\\n\\n        Array1 -> [1,1,5]\\n        Array2 -> [2,3,2]\\n\\n        Apply XOR for each part -> TADA!!!! We got what we want\\n\\n    \\'\\'\\'\\n        \\n    def checkBit(self, n, i):\\n        return (n & (1<<i))!=0\\n    \\n    def getSetBitPos(self, n):\\n        for i in range(32):\\n            if self.checkBit(n, i):\\n                return i\\n    \\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x,n = 0,len(nums)\\n        if n==2:\\n            return nums\\n        \\n        for i in range(n):\\n            x^=nums[i]\\n        \\n        pos = self.getSetBitPos(x)\\n        x1,x2 = 0,0\\n        for i in range(n):\\n            if self.checkBit(nums[i],pos):\\n                x1^=nums[i]\\n            else:\\n                x2^=nums[i]\\n        \\n        return [x1, x2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750604,
                "title": "c-two-solutions-with-explanation",
                "content": "Both have O(n) time complexity\\n\\n### O(1) Space Solution - Bit Manipulation\\nHow to handle this  with O(1) space? Lets see\\n>Before going let us see XOR property.\\n>If both bits are same the give x^y = 0 \\n>If both bit are different we get x^y = 1 \\n>Here x and y are the individual bits and not the number\\n\\nFIrst lets take XOR of the entire array - what will be the output?\\nIt will be the XOR of the two unique numbers.\\nSuppose the array is - 1,1,2,2,3,5 \\nXOR will be 3^5 = 6 ``(011 ^ 101 = 110)``\\n\\nNow what to do with this number? As we can see the set bits are the ones which are different in both the numbers.\\nLets choose one bit from this result.\\nSo if consider all numbers in array we can classify the numbers in two category \\n1. Group with the bit **set** at the chosen position\\n2. Group with the bit **unset** at the chosen position\\n\\nAnd if we perform XOR of both the group the repeating numbers will cancel each other out. So we will get those individual numbers in the seperate groups.\\n\\nSo for above example if we choose the first set bit from the right i.e. the  bit in the middle\\n1 - 001\\n2 - 010\\n3 - 011\\n5 - 101\\n``Array  = [1,1,2,2,3,5]``\\nGroup A (middle bit set) = 2,2,3 -> XOR = 3\\nGroup B (middle bit unset) = 1,1,5 -> XOR = 5\\n\\nIf you still have doubt: Ofcourse they both will end up in different group as the bit we chose is from their XOR and so for one of them it is set and for the other it is unset.\\n\\n> #### For those who are not accustomed to bit manipulation\\n> if x = 1:   0000001\\n> x<<1  will be  - 0000010\\n> again x<<1 will be 0000100\\n> You get the idea, its also the powers of two as they are binary numbers.\\n> To check if a current bit is set you perform & operation\\n> So our xor was 6 : 110 \\n> to find set bit let x = 001 initially\\n> 6^x = (110 ^ 001) = 0 so perfrom x<<1 => x = 010\\n> Now 6^x = (111 ^ 010) = 1 - This is the rightmost set bit\\n\\nCODE: \\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xr = 0,num1=0,num2=0;  // Xor of entire array, the two numbers\\n        for(int x: nums) xr^=x;   // XOR of two num\\n        int setBit = 1;   // Let us begin with the first num\\n        for(int i = 1;i<=31;i++){\\n            if(xr & setBit) break;    //This is the rightmost set bit   \\n            setBit<<=1;\\n        }\\n\\t\\t\\n        for(int x: nums){\\n            if((x&setBit) == setBit) num1 ^= x;   // this is group A\\n            else num2 ^= x;   // This is group B\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```\\n### O(n) Space Solution - Map\\n\\nWe use a map to store count and in second pass we insert the elements with count 1 as one in answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;\\n        cout<<xr;\\n        for(auto p:m) if(p.second == 1) ans.push_back(p.first);\\n        return ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xr = 0,num1=0,num2=0;  // Xor of entire array, the two numbers\\n        for(int x: nums) xr^=x;   // XOR of two num\\n        int setBit = 1;   // Let us begin with the first num\\n        for(int i = 1;i<=31;i++){\\n            if(xr & setBit) break;    //This is the rightmost set bit   \\n            setBit<<=1;\\n        }\\n\\t\\t\\n        for(int x: nums){\\n            if((x&setBit) == setBit) num1 ^= x;   // this is group A\\n            else num2 ^= x;   // This is group B\\n        }\\n        return {num1,num2};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int>ans;\\n        unordered_map<int,int>m;\\n        for(int x:nums) m[x]++;\\n        cout<<xr;\\n        for(auto p:m) if(p.second == 1) ans.push_back(p.first);\\n        return ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 68922,
                "title": "a-summary-of-java-solutions",
                "content": "        A summary of solutions, the first two are learned and modified from previous answer with detailed explanation. \\n    The third one is wrote for fun since I wrote the similar method for single number II for fun as well. \\n        \\n            public class Solution {\\n                public int[] singleNumber(int[] nums) {\\n                    // go through the array and XOR every element, for example, result = 6 (3^5)\\n                    int result = nums[0];\\n                    for(int i = 1; i < nums.length; i++){\\n                        result ^= nums[i];\\n                    }\\n                    // notice that 6^5 = 3, 6^3 = 5\\n                    // now how to find 3 and 5 from 6\\n                    int[] r = new int[2];\\n                    // find the lowest bit of the result\\n                    // let's say 6 (0110), -6 = 1010  0110 & 1010 = 0010\\n                    int lowbit = result & -result;\\n                    // since this bit from the result is 1, we can be sure that \\n                    // a & lowbit and b & lowbit have different result\\n                    for(int n : nums){\\n                        if((n & lowbit) == 0) r[0] ^= n;\\n                        else r[1] ^=n;\\n                    }\\n                    return r;\\n                }\\n            }\\n            \\n            public class Solution {\\n                public int[] singleNumber(int[] nums) {\\n                    HashSet<Integer> h = new HashSet<>();\\n                    for(int n : nums){\\n                        if(h.contains(n)) h.remove(n);\\n                        else h.add(n);\\n                    }\\n                    Object[] t =h.toArray();\\n                    int[] result = new int[2];\\n                    result[0] = (int)t[0];\\n                    result[1] = (int)t[1];\\n                    return result;\\n                }\\n            }\\n            \\n            public class Solution {\\n                public int[] singleNumber(int[] nums) {\\n                    Arrays.sort(nums);\\n                    int len = nums.length;\\n                    int[] result = new int[2];\\n                    for(int i = 0; i < len; ){\\n                        if(i != len - 1 && nums[i] == nums[i+1]) i += 2;\\n                        else{\\n                            if(result[0] == 0) result[0] = nums[i];\\n                            else result[1] = nums[i];\\n                            i++;\\n                        }\\n                    }\\n                    return result;\\n                }\\n            }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n                public int[] singleNumber(int[] nums) {\\n                    // go through the array and XOR every element, for example, result = 6 (3^5)\\n                    int result = nums[0];\\n                    for(int i = 1; i < nums.length; i++){\\n                        result ^= nums[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 68992,
                "title": "20-ms-c-solution",
                "content": "class Solution {\\n\\npublic:\\n    \\nvector<int> singleNumber(vector<int>& nums) {\\n\\n        int xXor = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            xXor = xXor ^ nums[i];\\n        }\\n        \\n        int marker = 1; \\n        while ((marker & xXor) != marker) {\\n            marker = marker << 1;\\n        }\\n        \\n        int resultX = 0;\\n        for (int i = 0; i<nums.size(); i++) {\\n            if (nums[i] & marker) {\\n                resultX = resultX^nums[i];\\n            }\\n        }\\n        \\n        int resultY = resultX^xXor;\\n        \\n        return vector<int>{resultX, resultY};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n    \\nvector<int> singleNumber(vector<int>& nums) {\\n\\n        int xXor = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            xXor = xXor ^ nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1562094,
                "title": "python-easy-3-lines-bit-manipulation-o-n-time-o-1-space",
                "content": "Given an integer array `nums`, we have to find the two elements, `a` and `b` that appear only once in the array.\\n\\n#### Intuition\\n\\nTo understand this solution there are a couple of important bitwise xor properties that you must keep in mind. *Skip to the bottom if know these already.*\\n\\n1. `a \\u2295 b = b \\u2295 a` and `a \\u2295 (b \\u2295 c) = (a \\u2295 b) \\u2295 c`\\nxor is commutative and associative.\\n\\n2. `a \\u2295 b = c` => `a \\u2295 c = b` => `b \\u2295 c = a`\\nxor is the inverse of itself.\\n\\n3. `x \\u2295 x = 0`\\nTherefore, we can say that if a number `x` appeares an even number of times \\u2295 operation will cancel it out.\\nFormally, `x \\u2295 x \\u2295 x \\u2295 x .... n times = 0`, where n is even.\\n\\n4. `y = x & (x-1)`\\nThis is more of a trick rather than a property to strip the lowest set bit of a number. You would\\'ve already known this If you\\'re familliar with BIT, Binary lifting or Binary exponentation.\\n\\nFinally, to solve this problem:\\n\\n1. Find the xor of the two numbers `a` and `b` that only occur once by xor-ing the entire array. **Property 3**\\n\\n*The two numbers `a` and `b` must differ by at least one bit, otherwise their xor would\\'ve been 0. Lets say `b` is the number that has the lowest set bit and `a` has the lowest unset bit.*\\n\\n2. Find `a` by xor-ing all those numbers that have the lowest unset bit. **Property 4**\\n\\n3. Once you have `a` we can find `b` by xor-ing with xor of the entire array. **Property 2**\\n\\n#### Implementation\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        zor = reduce(xor, nums)\\n        res = reduce(xor, filter(lambda i: i & (zor ^ (zor & (zor - 1))), nums))\\n        return [res,res^zor]\\n```\\n\\n**Time Complexity :** <img src=\"https://latex.codecogs.com/gif.latex?\\\\inline&space;O(n)\" title=\"O(n)\" />\\n**Space Complexity :** <img src=\"https://latex.codecogs.com/gif.latex?\\\\inline&space;O(1)\" title=\"O(1)\" />",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        zor = reduce(xor, nums)\\n        res = reduce(xor, filter(lambda i: i & (zor ^ (zor & (zor - 1))), nums))\\n        return [res,res^zor]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750629,
                "title": "java-bitwise-operation",
                "content": "```java\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        // xor will contain a ^ b as other elements have appeared twice\\n        int xor = 0;\\n        for (int num: nums) {\\n            xor = xor ^ num;\\n        }\\n        /*\\n        * get the low set bit, let\\'s say it is at ith position and if ith\\n        * bit is set in A^B (xor), what does it mean? It means ith bit is\\n        * set in either A\\'s or B\\'s binary representation but not both.\\n        *\\n        * 1. now split all numbers into two groups, Group 1 will contains\\n        * all numbers whose ith bit is set in it\\'s binary representation.\\n        * Let\\'s assume A is also one of them. if we xor all the elements in\\n        * this group, we will get A why ? Because A has appeared exactly once\\n        * and rest of the elements which have ith bit set have appeared twice.\\n        * \\n        * 2. second group will contain elements whose ith bit is not set. xoring\\n        * all the elements in this group will give B becaise B has appeared\\n        * exactly once and rest of the elements which have ith bit unset have\\n        * appeared twice.\\n        */\\n        int lowBitSet = xor & (-xor); // get the lowest bit set\\n        int a = 0; \\n        int b = 0;\\n        for (int num: nums) {\\n            if ((lowBitSet & num) == 0) {\\n                // num has ith bit unset that\\'s why & operation is returning zero\\n                a = a ^ num;\\n            } else {\\n                // num has ith bit set that\\'s why & operation is returning non zero\\n                b = b ^ num;\\n            }\\n        }\\n        return new int[]{a,b};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        // xor will contain a ^ b as other elements have appeared twice\\n        int xor = 0;\\n        for (int num: nums) {\\n            xor = xor ^ num;\\n        }\\n        /*\\n        * get the low set bit, let\\'s say it is at ith position and if ith\\n        * bit is set in A^B (xor), what does it mean? It means ith bit is\\n        * set in either A\\'s or B\\'s binary representation but not both.\\n        *\\n        * 1. now split all numbers into two groups, Group 1 will contains\\n        * all numbers whose ith bit is set in it\\'s binary representation.\\n        * Let\\'s assume A is also one of them. if we xor all the elements in\\n        * this group, we will get A why ? Because A has appeared exactly once\\n        * and rest of the elements which have ith bit set have appeared twice.\\n        * \\n        * 2. second group will contain elements whose ith bit is not set. xoring\\n        * all the elements in this group will give B becaise B has appeared\\n        * exactly once and rest of the elements which have ith bit unset have\\n        * appeared twice.\\n        */\\n        int lowBitSet = xor & (-xor); // get the lowest bit set\\n        int a = 0; \\n        int b = 0;\\n        for (int num: nums) {\\n            if ((lowBitSet & num) == 0) {\\n                // num has ith bit unset that\\'s why & operation is returning zero\\n                a = a ^ num;\\n            } else {\\n                // num has ith bit set that\\'s why & operation is returning non zero\\n                b = b ^ num;\\n            }\\n        }\\n        return new int[]{a,b};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68977,
                "title": "concise-c-solution-bit-manipulation",
                "content": "    vector<int> singleNumber(vector<int>& nums) {\\n        int x_xor_y = 0;\\n        for (int n: nums) {\\n            x_xor_y ^= n;\\n        }\\n        // find the last set bit - \\n        // The last bit that x =/= y\\n        int mask = x_xor_y & ~(x_xor_y - 1);\\n        int x = 0;\\n        int y = 0;\\n        // x: XOR of a,a,b,b,x\\n        // y: XOR of c,c,y\\n        for (int n: nums) {\\n            if (n & mask) {\\n                x ^= n;\\n            } else {\\n                y ^= n;\\n            }\\n        }\\n        return vector<int> {x, y};\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> singleNumber(vector<int>& nums) {\\n        int x_xor_y = 0;\\n        for (int n: nums) {\\n            x_xor_y ^= n;\\n        }\\n        // find the last set bit - \\n        // The last bit that x =/= y\\n        int mask = x_xor_y & ~(x_xor_y - 1);\\n        int x = 0;\\n        int y = 0;\\n        // x: XOR of a,a,b,b,x\\n        // y: XOR of c,c,y\\n        for (int n: nums) {\\n            if (n & mask) {\\n                x ^= n;\\n            } else {\\n                y ^= n;\\n            }\\n        }\\n        return vector<int> {x, y};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68993,
                "title": "share-my-c-solutions-using-bit-manipulation-and-sort-with-explanations",
                "content": "    class Solution {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) {\\n            // solution1:using sort\\n            // vector<int> res;      \\n            // sort(nums.begin(),nums.end());\\n            // if(nums.size() == 2 && nums[0] != nums[1]) return nums;\\n            // for(int i = 0; i < nums.size();) {\\n            //     if((nums[i] != nums[i + 1])) {\\n            //         res.push_back(nums[i]);\\n            //         i ++;\\n            //     }\\n            //     else  i = i + 2;\\n            // }\\n            // return res;\\n            //solution2:using bit manipulation\\n            int n = 0;  \\n            vector<int> res;\\n            for(int i = 0; i < nums.size(); i++) {\\n                n = n ^ nums[i]; \\n            }\\n           /*flag is the last \"1\" bit of n,the two elements which appear only once must be defferent in this bit\\n           so we can use flag to devide all the elements into two parts,one contains a and the other one contains b.*/\\n            int flag = n & (~(n - 1));\\n            int a = 0,b = 0;\\n            for(int i = 0; i < nums.size(); i ++) {\\n                if((flag&nums[i]) == 0) a ^= nums[i];\\n                else b ^= nums[i];\\n            }\\n            res.push_back(a);\\n            res.push_back(b);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> singleNumber(vector<int>& nums) {\\n            // solution1:using sort\\n            // vector<int> res;      \\n            // sort(nums.begin(),nums.end());\\n            // if(nums.size() == 2 && nums[0] != nums[1]) return nums;\\n            // for(int i = 0; i < nums.size();) {\\n            //     if((nums[i] != nums[i + 1])) {\\n            //         res.push_back(nums[i]);\\n            //         i ++;\\n            //     }",
                "codeTag": "Java"
            },
            {
                "id": 523982,
                "title": "simplest-explanation-with-code-in-c",
                "content": "**Explanation:**\\n\\nEx: [1, 2, 1, 3, 2, 5]\\n\\n0 0 0 1\\n0 0 1 0\\n0 0 0 1\\n0 0 1 1\\n0 0 1 0\\n0 1 0 1\\n\\nCalculating the XOR on all the elements gives you 3 ^ 5 which is bitwise :\\n\\n0 0 1 1 ^ 0 1 0 1 = 0 1 1 0\\n\\n**Reason for finding the rightmost set bit to build the mask :**\\n\\nThe rightmost set bit represents the first position where there was a difference in the bits in the numbers 3 and 5. (2nd position in this case) -> 0 1 (1) 0\\n\\nWith this information we can divide the array into 2 groups one with set bit at position 2 and another with bit unset at position 2.\\n\\nTherefore, when you loop through the array and AND each number to the mask you\\'re assigning the number to either of the groups i.e with set / unset bit at that position!\\n\\na (Group having unset bit at pos 2) = XOR(1, 1, 5) -> 5\\nb (Group having set bit at pos 2) = XOR(2, 2, 3) -> 3\\n\\nHope its clear enough! :D\\n\\n**The Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int Xor = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            Xor ^= nums[i];\\n        }\\n        \\n        // find rightmost set bit\\n        int mask = 1;\\n        while(1) {\\n            if((mask & Xor) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int a = 0, b = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if((nums[i] & mask) == 0) {\\n                a ^= nums[i];\\n            }\\n            else {\\n                b ^= nums[i];\\n            }\\n        }\\n        return { a, b };\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int Xor = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            Xor ^= nums[i];\\n        }\\n        \\n        // find rightmost set bit\\n        int mask = 1;\\n        while(1) {\\n            if((mask & Xor) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int a = 0, b = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if((nums[i] & mask) == 0) {\\n                a ^= nums[i];\\n            }\\n            else {\\n                b ^= nums[i];\\n            }\\n        }\\n        return { a, b };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501747,
                "title": "concise-javascript-solution-using-xor-o-1-space",
                "content": "Our task is to find the two \"unusual\" numbers that appear once. All other numbers appear twice - we will exploit this property to avoid using extra space.\\n\\n```\\n[1, 2, 3, 2, 1, 5]\\n```\\n\\nFirst, we XOR all the numbers together. A number XORed with itself is zero - the numbers that appear twice will disappear from the XOR sum. Therefore,\\n\\n```\\n1 ^ 2 ^ 3 ^ 2 ^ 1 ^ 5 == 3 ^ 5\\n```\\n\\nSo the bits left in the result are the **\"residue\"** of the two unusual numbers. Let\\'s look at the binary representation of this residue.\\n\\n```\\n3 ^ 5 == 0b011 ^ 0b101 == 0b110\\n```\\n\\nThe trick is: we know each of the bits present in the residue `0b110` *must* be present in *one* of the unusual numbers. We will (arbitrarily) select the most significant bit.\\n\\nWe get the position of the MSB (most significant bit) by *measuring the string length of the binary representation of the number*:\\n```\\nvar uniqBitPos = xor.toString(2).length - 1;\\n```\\n\\nFor example, `\"110\"` has length 3, and the zero-based index of the MSB is 2.\\n\\nThen, we do an XOR pass again, this time ignoring all the numbers with a bit in this unique position. This might filter out some of the normal numbers, but that doesn\\'t matter; either way the normal numbers don\\'t contribute to the XOR sum. **The number we are left with after this second pass is the first unusual number**.\\n\\nFinally, we can XOR this **first** number with the original **residue** to obtain the **second** unusual number.\\n\\n```\\nvar singleNumber = function(nums) {\\n  var xor = nums\\n    .reduce((acc, cur) => acc ^ cur, 0);\\n  var uniqBitPos = xor.toString(2).length - 1;\\n  var xor2 = nums\\n    .filter(num => (num >> uniqBitPos & 1) == 0)\\n    .reduce((acc, cur) => acc ^ cur, 0);\\n  return [xor2, xor2 ^ xor];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n[1, 2, 3, 2, 1, 5]\\n```\n```\\n1 ^ 2 ^ 3 ^ 2 ^ 1 ^ 5 == 3 ^ 5\\n```\n```\\n3 ^ 5 == 0b011 ^ 0b101 == 0b110\\n```\n```\\nvar uniqBitPos = xor.toString(2).length - 1;\\n```\n```\\nvar singleNumber = function(nums) {\\n  var xor = nums\\n    .reduce((acc, cur) => acc ^ cur, 0);\\n  var uniqBitPos = xor.toString(2).length - 1;\\n  var xor2 = nums\\n    .filter(num => (num >> uniqBitPos & 1) == 0)\\n    .reduce((acc, cur) => acc ^ cur, 0);\\n  return [xor2, xor2 ^ xor];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183716,
                "title": "single-number-series-summary",
                "content": "Below are ```Single Number``` series questions on Leetcode:\\n1. [136. Single Number -- 1 Number appears 1 time & others appear 2 times](https://leetcode.com/problems/single-number/description/)\\n```java\\npublic int singleNumber(int[] nums) {\\n        // Xor\\n        // Edge case\\n        if(nums == null || nums.length == 0)    return -1;\\n        \\n        int xor = nums[0];\\n        for(int i = 1; i < nums.length; i++)\\n            xor = xor ^ nums[i];\\n        return xor;\\n}\\n```\\n\\n2. [137. Single Number II --  1 Number appears 1 time & others appear 3 times](https://leetcode.com/problems/single-number-ii/description/)\\n```java\\npublic int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n}\\n```\\n\\n3. [260. Single Number III--  2 Numbers appear 1 time & others appear 2 times](https://leetcode.com/problems/single-number-iii/description/)\\n```java\\npublic int[] singleNumber(int[] nums) {\\n        // XOr\\n        // Edge case \\n        if(nums == null || nums.length == 0) return null;\\n        \\n        int xor = 0;\\n        for(int i : nums)\\n            xor ^= i;\\n        \\n        xor &= -xor;\\n        \\n        int[] res = {0,0};\\n        for(int i : nums) {\\n            if((i & xor) == 0)\\n                res[0] ^= i;\\n            else\\n                res[1] ^= i;\\n        }\\n        return res;\\n}\\n```\\n\\n4. [540. Single Element in a Sorted Array  -- 1 Number appears 1 time & others appear 2 times ** Sorted**](https://leetcode.com/problems/single-element-in-a-sorted-array/description/)\\n```java\\npublic int singleNonDuplicate(int[] nums) {\\n        // Binary search\\n        // Edge case\\n        if(nums == null || nums.length < 3)    return -1;\\n        if(nums[0] != nums[1]) return nums[0];\\n        if(nums[nums.length - 1] != nums[nums.length - 2]) return nums[nums.length - 1];\\n        \\n        int left = 0, right = nums.length - 1;\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == nums[mid - 1]) {\\n                if((right - mid) % 2 == 0)\\n                    right = mid - 2;\\n                else\\n                    left = mid + 1;\\n            } else if(nums[mid] == nums[mid + 1]) {\\n                if((mid - left) % 2 == 0)\\n                    left = mid + 2;\\n                else\\n                    right = mid - 1;\\n            } else {\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Single Number```\n```java\\npublic int singleNumber(int[] nums) {\\n        // Xor\\n        // Edge case\\n        if(nums == null || nums.length == 0)    return -1;\\n        \\n        int xor = nums[0];\\n        for(int i = 1; i < nums.length; i++)\\n            xor = xor ^ nums[i];\\n        return xor;\\n}\\n```\n```java\\npublic int singleNumber(int[] nums) {\\n        int ones = 0, twos = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            ones = (ones ^ nums[i]) & ~twos;\\n            twos = (twos ^ nums[i]) & ~ones;\\n        }\\n        return ones;\\n}\\n```\n```java\\npublic int[] singleNumber(int[] nums) {\\n        // XOr\\n        // Edge case \\n        if(nums == null || nums.length == 0) return null;\\n        \\n        int xor = 0;\\n        for(int i : nums)\\n            xor ^= i;\\n        \\n        xor &= -xor;\\n        \\n        int[] res = {0,0};\\n        for(int i : nums) {\\n            if((i & xor) == 0)\\n                res[0] ^= i;\\n            else\\n                res[1] ^= i;\\n        }\\n        return res;\\n}\\n```\n```java\\npublic int singleNonDuplicate(int[] nums) {\\n        // Binary search\\n        // Edge case\\n        if(nums == null || nums.length < 3)    return -1;\\n        if(nums[0] != nums[1]) return nums[0];\\n        if(nums[nums.length - 1] != nums[nums.length - 2]) return nums[nums.length - 1];\\n        \\n        int left = 0, right = nums.length - 1;\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == nums[mid - 1]) {\\n                if((right - mid) % 2 == 0)\\n                    right = mid - 2;\\n                else\\n                    left = mid + 1;\\n            } else if(nums[mid] == nums[mid + 1]) {\\n                if((mid - left) % 2 == 0)\\n                    left = mid + 2;\\n                else\\n                    right = mid - 1;\\n            } else {\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68978,
                "title": "share-two-java-solution-uff1ad",
                "content": "I use HashSet\\n\\n    public int[] singleNumber(int[] nums) {\\n        int[] ans = new int[2];\\n        if(nums == null || nums.length <=1){\\n            return ans;\\n        }\\n        \\n        HashSet<Integer> record = new HashSet<Integer>();\\n        for(int i = 0;i<nums.length;i++){\\n            if(record.contains(nums[i])){\\n                record.remove(nums[i]);\\n            }\\n            else{\\n                record.add(nums[i]);\\n            }\\n        }\\n        Object[] test = record.toArray();\\n        ans[0]=(int)test[0];\\n        ans[1]=(int)test[1];\\n        return ans;\\n    \\nII use bit\\n\\n    public int[] singleNumber(int[] nums) {\\n        int record = 0;\\n        for (int num : nums) {\\n            record ^= num;\\n        }\\n        record &= -record;\\n\\n        int[] ans = {0, 0}; \\n        for (int num : nums){\\n            if ((num & record)==0) \\n            {\\n                ans[0] ^= num;\\n            }\\n            else \\n            {\\n                ans[1] ^= num;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "I use HashSet\\n\\n    public int[] singleNumber(int[] nums) {\\n        int[] ans = new int[2];\\n        if(nums == null || nums.length <=1){\\n            return ans;\\n        }\\n        \\n        HashSet<Integer> record = new HashSet<Integer>();\\n        for(int i = 0;i<nums.length;i++){\\n            if(record.contains(nums[i])){\\n                record.remove(nums[i]);\\n            }\\n            else{\\n                record.add(nums[i]);\\n            }\\n        }\\n        Object[] test = record.toArray();\\n        ans[0]=(int)test[0];\\n        ans[1]=(int)test[1];\\n        return ans;\\n    \\nII use bit\\n\\n    public int[] singleNumber(int[] nums) {\\n        int record = 0;\\n        for (int num : nums) {\\n            record ^= num;\\n        }\\n        record &= -record;\\n\\n        int[] ans = {0, 0}; \\n        for (int num : nums){\\n            if ((num & record)==0) \\n            {\\n                ans[0] ^= num;\\n            }\\n            else \\n            {\\n                ans[1] ^= num;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 176063,
                "title": "c-o-n-time-o-1-memory-with-a-clear-explanation",
                "content": "You should already be familiar with the trick of XOR-ing all numbers in order to get the only one which exists exactly once as opposed to 2 times. Here the same thing is done, but what we get at the end is `a ^ b` (`a` and `b` are the two numbers that exist exactly once).\\n\\nLet\\'s say, for example:\\n`a ^ b = 00111011001100000011101100110000`\\nEvery `1` in there means that `a` and `b` have different bits at that position, while `0` means they have the same bit. There will surely be at least one `1` because the numbers themselves are different, and we need to pick any `1` from `a ^ b`, where we can then decide that `a` will be the number with the `0` bit at that position and `b` will be the one with the `1` bit.\\n`==>  a = ***************************0****`\\n`==>  b = ***************************1****`\\n\\nFinally we can \"partition\" the input array into two parts - numbers with a 0-bit there, in which `a` is the only number encountered once (and all others are encountered twice), and numbers with a 1-bit, in which `b` is the only number encountered once, and we XOR the numbers again.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int aXorB = 0;\\n        for (int num : nums) {\\n            aXorB ^= num;\\n        }\\n        int differingBit = 1;\\n        while ((differingBit & aXorB) == 0) {\\n            differingBit <<= 1;\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        for (int num : nums) {\\n            if ((num & differingBit) == 0) {\\n                a ^= num;\\n            } else {\\n                b ^= num;\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```\\n\\nOf course this can be made much shorter but I wanted the logic to be clearer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int aXorB = 0;\\n        for (int num : nums) {\\n            aXorB ^= num;\\n        }\\n        int differingBit = 1;\\n        while ((differingBit & aXorB) == 0) {\\n            differingBit <<= 1;\\n        }\\n        \\n        int a = 0;\\n        int b = 0;\\n        for (int num : nums) {\\n            if ((num & differingBit) == 0) {\\n                a ^= num;\\n            } else {\\n                b ^= num;\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750900,
                "title": "c-too-easy-way-using-bit-manipulation-with-explanation",
                "content": "**we will be given numbers which all will be repeating except two numbers so the best way to identify these numbers is using finding the low-bit.**\\n\\nNow what a low bit is ??\\n\\n**for ex: [1,2,1,3,2,5]**\\n**low bit is the 2\\'s complement of the sum**\\n\\nHow do we find a sum??\\n\\nSum = 0;\\nsum ^= nums[i];\\n\\nafter finding sum we find low bit of it using sum & (-sum)\\n\\nNow we divide the our results which comprises of two numbers into different categories.\\nOne with having low bit and other not.\\n\\nLet\\'s see the code:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int sum = 0;\\n        for (auto num : nums) {\\n            sum ^= num;\\n        }\\n        \\n        vector<int> res{0, 0};\\n        int lowbit = sum & (-sum);  //way to find lowbit\\n        for (auto num : nums) {\\n            if (num & lowbit)\\n                res[0] ^= num;\\n            else\\n                res[1] ^= num;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nif you find this useful, upvote it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int sum = 0;\\n        for (auto num : nums) {\\n            sum ^= num;\\n        }\\n        \\n        vector<int> res{0, 0};\\n        int lowbit = sum & (-sum);  //way to find lowbit\\n        for (auto num : nums) {\\n            if (num & lowbit)\\n                res[0] ^= num;\\n            else\\n                res[1] ^= num;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561914,
                "title": "c-simple-bit-manipulation-o-n-time-o-1-space",
                "content": "* Given that the arrray contains every element appearing twice except two numbers. We need to find those two numbers.\\n* If we xor all the numbers, then result = a^b where \\'a\\' and \\'b\\' are those numbers appearing once.\\n* We know that \\'a\\' and \\'b\\' are two distinct number, so their xor have atleast one set bit.\\n* We can group the entire numbers in the array by checking whether this particular bit is set or not.\\n\\nFor eg : concider the array : [1, 2, 1, 3, 2, 5]\\n```\\n0 0 1\\n0 1 0\\n0 0 1\\n0 1 1\\n0 1 0\\n1 0 1\\nxor = 1 1 0\\n```\\n* We can group the array by either taking any of the set bit. For the sake of convenience i am taking the right most set bit for grouping. \\n* Then 1st set = [001, 001, 101] = [1, 1, 5] and 2nd set = [010, 011, 010] = [2, 3, 2]. \\n* Now you can see that \\'a\\' and \\'b\\' are in different sets and everything else are present twice. Now xor whole set to obtain \\'a\\' and \\'b\\'. ie., 001 ^ 001 ^ 101 = 101,   010 ^ 011 ^ 010 = 011\\n------------------------------------------------------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int XOR = 0, a = 0, b = 0;\\n        for(int x : nums)\\n            XOR ^= x;\\n        int mask = 1;\\n        for(int i=0; i<32; i++){\\n            if(XOR & mask)\\n                break;\\n            mask <<= 1;\\n        }\\n        for(int x : nums){\\n            if(x & mask)\\n                a ^= x;\\n            else\\n                b ^= x;\\n        }\\n        return {a, b};\\n    }\\n};\\n```\\n* **Time Complexity = O(N)**\\n* **Space Complexity  = O(1)**\\n**IF YOU FIND IT HELPFUL, PLEASE UPVOTE**\\n",
                "solutionTags": [],
                "code": "```\\n0 0 1\\n0 1 0\\n0 0 1\\n0 1 1\\n0 1 0\\n1 0 1\\nxor = 1 1 0\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int XOR = 0, a = 0, b = 0;\\n        for(int x : nums)\\n            XOR ^= x;\\n        int mask = 1;\\n        for(int i=0; i<32; i++){\\n            if(XOR & mask)\\n                break;\\n            mask <<= 1;\\n        }\\n        for(int x : nums){\\n            if(x & mask)\\n                a ^= x;\\n            else\\n                b ^= x;\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109312,
                "title": "concise-c-solution-0-ms-100-faster-explained-with-comments",
                "content": "**Optimal Solution :**\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n        \\n        int Xor = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            Xor ^= nums[i];\\n        }\\n        //cout<<Xor<<\"\\\\n\";\\n        // 3 in binary is 011\\n        // 5 in binary is 101\\n        // 3^5 is 6 and in binary it is 110\\n        // Notice we are getting unique set bits from both numbers \\n        // Now use that unique set bit and find all the numbers with that unique set bit\\n        // find rightmost set bit\\n        int mask = 1;\\n        while(1) {\\n            if((mask & Xor) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int x = 0, y = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if((nums[i] & mask) == 0) {  // & with mask to find the unique set bit\\n                x ^= nums[i];\\n            }\\n            else {\\n                y ^= nums[i];   // automatically second number will store here or we can find \\n                                // second number using y = x^xorr\\n            }\\n        }\\n        return { x, y };\\n        \\n    }\\n```\\n\\n**Naive Solution :**\\n```\\n   vector<int> singleNumber(vector<int>& nums) {     \\n        // !!!!!!! Naive O(n) space !!!!!!!\\n        map<int,int> mp;\\n         map<int,int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        vector<int> res;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            if(it->second==1) res.push_back(it->first);\\n        }\\n        return res;\\n    } \\n            \\n```\\n\\nKindly Upvote me to motivate me so that I can serve the leetcode community better. Thanks in advance.\\n\\n# HAPPY CODING FOLKS !!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n        \\n        int Xor = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            Xor ^= nums[i];\\n        }\\n        //cout<<Xor<<\"\\\\n\";\\n        // 3 in binary is 011\\n        // 5 in binary is 101\\n        // 3^5 is 6 and in binary it is 110\\n        // Notice we are getting unique set bits from both numbers \\n        // Now use that unique set bit and find all the numbers with that unique set bit\\n        // find rightmost set bit\\n        int mask = 1;\\n        while(1) {\\n            if((mask & Xor) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        \\n        int x = 0, y = 0;\\n        for(int i=0;i<nums.size();i++) {\\n            if((nums[i] & mask) == 0) {  // & with mask to find the unique set bit\\n                x ^= nums[i];\\n            }\\n            else {\\n                y ^= nums[i];   // automatically second number will store here or we can find \\n                                // second number using y = x^xorr\\n            }\\n        }\\n        return { x, y };\\n        \\n    }\\n```\n```\\n   vector<int> singleNumber(vector<int>& nums) {     \\n        // !!!!!!! Naive O(n) space !!!!!!!\\n        map<int,int> mp;\\n         map<int,int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        vector<int> res;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            if(it->second==1) res.push_back(it->first);\\n        }\\n        return res;\\n    } \\n            \\n```",
                "codeTag": "C++"
            },
            {
                "id": 750721,
                "title": "c-o-n-time-o-1-space-with-bitwise-sorcery-explained-in-detail",
                "content": "So, this is similar to the previous version of the problem, in which we had to find the only single number that is repeated once (the rest is repeated twice).\\n\\nIf you have not solved it yet, quick recap: given an array/vector/list/other series of numbers, all duplicate numbers cancel each other when XORed (`^`) together: `2 ^ 2`, `123456 ^ 123456`, `-42 ^ -42`, etc. - they all give you zero, so the problem was solved just reducing the whole collection of data to a final cumulative XOR result.\\n\\nThis problem is similar, but at the end you will (of course) get the result of XORing the only 2 non-repeated numbers (and we are told they are different from each other in the description, so we know they cannot XOR each other to `0`).\\n\\nIn the sample case (`[1,2,1,3,2,5]`), for example, you would end up with the value of `3 ^ 5` - which is to say `6`.\\n\\nNeedless to say, we cannot stop here.\\n\\nThe next idea is to try and group all numbers into 2 different buckets, so the first number is in one and the second is in the other, so that then we can XOR them to death and leave only one number in each bucket (possibly playing the Highlander theme while brandishing a bloodied claymore - I am not putting the link here not to break the description, but feel free to hum it in your mind while closing this kata).\\n\\nBut how can we do that?\\n\\nLet\\'s look at our previous example, where we got `6` as the final grand total XORing of the series: that is `110` in binary and, given how XOR works, we know that one number HAS to have `1` as second least significant bit, and the other has not. Same for the third less significant bit, okay, but if you have played enough with bitwise operators, you will know by now that there is an easy and sweet way to get the least significant `1` of a number: `n & (-n)`.\\n\\nWhy is that, you might ask again?\\n\\nOkay, I promise you we are almost there, so bear with me: think of any number, say `6` as in our example above. In binary that is represented as `000...0110` (depending on how many bits we are using, which in turn depends on how your machine deals with integers, longs or whatever other data type your using, but I digress). Its negative counterpart is [two\\'s complement](https://en.wikipedia.org/wiki/Two%27s_complement) of that number, that is to say `111...1010`, so doing a binary `&` is going to return us just the least significant bit: `000...0010`.\\n\\nNow, if you survived this far, the final step is relatively trivial: all the numbers that do NOT have this least significant digit go in the first bucket (so, in our case: `[1, 1, 3]`) and all the others in the second bucket (so it would be filled with `[2, 2, 5]`). Or the other way around, of course, since the description specify the order of the results does not matter.\\n\\nXOR them together and you will be left with `3` in the first bucket and `5` in the other: bingo!\\n\\nExtra step: in order to spicy things up a bit, I just went with a call to `accumulate` directly initialising a 2 elements vector as a base accumulator and then using `!(b & lowerBit)` as an index to tell it which bucket should be used for each step of the loop - a tiny hack instead of just using a ternary operator or other conditionals to use either `0` or `1` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        // we start reducing the vector to a cumulative xor result and then we get the least significant bit of it\\n        int cumXor = accumulate(begin(nums), end(nums), 0, [](int a, int b){return a ^ b;}), lowerBit = cumXor & (-cumXor);\\n        // then I xor all the numbers again in the first element of res if they don\\'t have\\n        // the same least significant bit or in the second if they do\\n        return accumulate(begin(nums), end(nums), vector<int>(2), [lowerBit](vector<int> res, int b){return (res[!(b & lowerBit)] ^= b, res);});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        // we start reducing the vector to a cumulative xor result and then we get the least significant bit of it\\n        int cumXor = accumulate(begin(nums), end(nums), 0, [](int a, int b){return a ^ b;}), lowerBit = cumXor & (-cumXor);\\n        // then I xor all the numbers again in the first element of res if they don\\'t have\\n        // the same least significant bit or in the second if they do\\n        return accumulate(begin(nums), end(nums), vector<int>(2), [lowerBit](vector<int> res, int b){return (res[!(b & lowerBit)] ^= b, res);});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326622,
                "title": "all-in-one-summary-single-number-i-ii-iii",
                "content": "I\\'ve combined many solutions together from some posts in English and some others in Chinese.\\n\\nReference: [Problem I](https://leetcode.com/problems/single-number/), [Problem II](https://leetcode.com/problems/single-number-ii/), [Problem III](https://leetcode.com/problems/single-number-iii/)\\nDifficulty: `Medium`\\n\\n\\n## Single Number I\\n\\n> Given a `non-empty` array of integers, every element appears twice except for one. Find that single one.\\n\\n**Follow-up:** Your algorithm should have a `linear runtime` complexity. Could you implement it `without using extra memory`?\\n\\n**Example:**\\n\\n```java\\nInput: [2,2,1]\\nOutput: 1\\nInput: [4,1,2,1,2]\\nOutput: 4\\n```\\n\\n\\n**Methods:**\\n\\n1. Brute-force\\n  - `Option 1`: Check each item with the rest of items.\\n  ```java\\n  public int singleNumber(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; ++i) { // examing i\\n      boolean isSingle = true;\\n      for (int j = 0; j < n; ++j) {\\n        if (i == j) continue; // except itself\\n        \\n        if (nums[i] == nums[j]) { // found duplicate numbers\\n          isSingle = false;\\n        }\\n      }\\n      if (isSingle) {\\n        return nums[i];\\n      }\\n    }\\n    throw new IllegalArgumentException();\\n  }\\n  ```\\n    - **Time:** `O(N^2)`\\n    - **Space:** `O(1)`\\n  - `Option 2`:\\n    - Iterate over all the elements in `nums`.\\n    - If some number in `nums` is new to the array, append it.\\n    - If some number is already in the array, remove it.\\n    - **Time:** `O(N^2)`\\n    - **Space:** `O(N)`\\n2. Hash Table\\n   - For the `Option 2` above, we can optimize it by using a hash set since `add` and `remove` operations take only `O(1)` time.\\n   - The way to get the value in a set is to iterate it.\\n    ```java\\n    // HashSet\\n    public int singleNumber(int[] nums) {\\n      Set<Integer> set = new HashSet<>();\\n      for (int val : nums) {\\n        if (set.contains(val)) {\\n          set.remove(val);\\n        } else {\\n          set.add(val);\\n        }\\n      }      \\n      for (int val : set) {\\n        return val;\\n      }\\n      throw new IllegalArgumentException();\\n    }\\n    ```\\n     - **Time:** `O(N)`\\n     - **Space:** `O(N)`\\n3. Math\\n   - Use the following equation to solve the problem:\\n   - `2 * (a + b + c) - (a + a + b + b + c) = c`\\n  ```java\\n    public int singleNumber(int[] nums) {\\n      int sum = 0;\\n      Set<Integer> set = new HashSet<>();\\n      for (int val : nums) {\\n        sum += val;\\n        set.add(val);\\n      }\\n      int setSum = 0;\\n      for (int val : set) {\\n        setSum += val;\\n      }\\n      return 2 * setSum - sum;\\n    }\\n  ```\\n     - **Time:** `O(N)`\\n     - **Space:** `O(N)`\\n4. Bit Manipulation\\n   - If we take `XOR` of zero and some bit, it will return that bit:\\n     - `a ^ 0 = a`\\n   - If we take `XOR` of two same bits, it will return `0`:\\n     - `a ^ a = 0`\\n   - So we have: `a ^ b ^ a = (a ^ a) ^ b = b`.\\n   - The numbers that occur twice will be reduced to zero.\\n  ```java\\n  public int singleNumber(int[] nums) {\\n    int a = 0;\\n    for (int val : nums) {\\n      a ^= val;\\n    }\\n    return a;\\n  }\\n  ```\\n    - **Time:** `O(N)`\\n    - **Space:** `O(1)`\\n\\n\\n## Single Number II\\n\\n> Given a `non-empty` array of integers, every element appears three times except for one. Find that single one.\\n\\n**Follow-up:** Your algorithm should have a `linear runtime` complexity. Could you implement it `without using extra memory`?\\n\\n\\n**Example:**\\n\\n```java\\nInput: [2,2,3,2]\\nOutput: 3\\nInput: [0,1,0,1,0,1,99]\\nOutput: 99\\n```\\n\\n**Methods**\\n\\n1. Brute-force (same as Problem I)\\n2. Hash Table\\n   - Use a hash map to count the number of occurrence.\\n   - **Time:** `O(N)`\\n   - **Space:** `O(N)`\\n3. Math (same as Problem I)\\n   - $3 * (a + b + c) - (a + a + a + b + b + b + c) = c$\\n4. Bit Manipulation (Generalized)\\n   - See details below.\\n\\n```java\\n// k = 3 / 11 (m = 2), p = 1\\npublic int singleNumber(int[] nums) {\\n  int x1 = 0, x2 = 0, mask = 0;\\n  for (int val : nums) {\\n    x2 = x2 ^ (x1 & val);\\n    x1 = x1 ^ val;\\n    mask = ~(x2 & x1);\\n    x2 = x2 & mask;\\n    x1 = x1 & mask;\\n  }\\n  // p = 1, final state: x2 = 0, x1 = 1\\n  return x1;\\n}\\n```\\n\\n\\n## Generalized Method\\n\\nReference: [Detailed explanation and generalization of the bitwise operation method for single numbers\\n](https://leetcode.com/problems/single-number-ii/discuss/43295)\\n\\nGreat article!\\n\\n### Design Counting System\\n\\n#### Update A State\\n\\nThe problem can be generalized as follows:\\n\\n- Given an array of integers, every element appears `k` (`k > 1`) times except for one which appears `p` times (`p >= 1, p % k != 0`). Find that single one.\\n\\nThe idea is to design a way to count the number of 1-bit digits. If the number of 1-bit digits equals `k`, we restore the counting system to `0` and make it start over.\\n\\nTo represent this counting system, we can use `m-bit` binary form `xm, ..., x2, x1`. Here are four properties of the counter:\\n\\n- There is an initial state of the counter, say `0`.\\n- For each input, if we hit `0`, the counting bit `xi` should remain unchanged.\\n- Otherwise (hit `1`), the bit should increase by one.\\n- In order to cover `k` counts (states), we require `2^m >= k`, which means we need `m` bits that satisfy `m >= logk`.\\n\\nFor example, if we need three states (`k = 3`), we can use `m = 2` bits to represent this.\\n\\n- State 1: `x2 = 0, x1 = 0`\\n- State 2: `x2 = 0, x1 = 1`\\n- State 3: `x2 = 1, x1 = 0`\\n\\nThe key part is: how each bit changes as we are going through the array.\\n\\n```java\\n         x3   x2   x1\\nState 1:  0    0    0\\nState 2:  0    0    1\\nState 3:  0    1    0\\nState 4:  0    1    1\\nState 5:  1    0    0\\n```\\n\\nWe can observe that:\\n\\n- The `x1` column changes from 0 to 1 or from 0 to 1 successively, and if it encounter a `1`, it should change. So we can use bit-toggle operation `^= 1`.\\n  - `x1 = x1 ^ val` (val could be `1` or `0`)\\n- The `x2` column changes when `x1` changes from `0` to `1`. Thus we can express this as follows:\\n  - `x2 = x2 ^ (x1 & val)`\\n- The `x3` column then could be expressed similarly:\\n  - `x3 = x3 ^ (x2 & x1 & val)`\\n- To generalize, `xm` could be expressed as follows:\\n  - `xm = xm ^ (xm-1 & ... & x2 & x1 & val)`\\n\\n\\n#### Reset A State\\n\\nAlso, we need to design a cutting mechanism to reset the counting if it hits one for `k` times. To this end, we apply bitwise `AND` to those `x` values with some `mask` to reset the bits.\\n\\nSpecifically, we want a `mask` that will be `0` only when the count reaches `k` and be `1` for all other count cases.\\n\\nHow do we achieve that?\\n\\nFor example, check out the examples when `k = 2` and `k = 3`:\\n\\n```java\\n          x2   x1  +1  x2   x1  =>  x2   x1\\nState 1:   0    0       0    1  =>   0    1\\nState 2:   0    1       1    0  =>   0    1\\nk = 2:                  1    0  =>   0    0\\n\\n          x2   x1  +1  x2   x1  =>  x2   x1\\nState 1:   0    0       0    1  =>   0    1\\nState 2:   0    1       1    0  =>   0    1\\nState 3:   1    0       1    1  =>   1    0\\nk = 3:                  1    1  =>   0    0\\n```\\n\\nWhen the bits of `x` are the same as `k`\\'s, it should be reset.\\n\\n- If the bit of `k` is `1`, the `mask` should be `~x`.\\n- If the bit of `k` is `0`, the `mask` should be `x`.\\n\\nCombining all of them together:\\n\\n- The `mask` should be `~(ym & ... & y2 & y1)`.\\n  - If `k = 1`, `y = x`.\\n  - If `k = 0`, `y = ~x`.\\n\\nTherefore, as for the examples above:\\n\\n- `k = 2 (1 0)`: the mask is `~(x2 & ~x1)`.\\n- `k = 3 (1 1)`: the mask is `~(x2 & x1)`.\\n\\nOne more example for `k = 5 (101)`, the mask is `~(x3 & ~x2 & x1)`.\\n\\n\\n#### Combination\\n\\nTo this point, we can write out the code for this counting system for `k = 3`:\\n\\n```java\\nint x1 = 0, x2 = 0;\\nfor (int val : nums) {\\n  // update the state\\n  x2 = x2 ^ (x1 & val);\\n  x1 = x1 ^ val;\\n  // mask\\n  mask = ~(x2 & x1);\\n  x2 = x2 & mask;\\n  x1 = x1 & mask;\\n}\\n```\\n\\n\\n### Back To Problem\\n\\nIt\\'s time to generalize our results from 1-bit number case to 32-bit integers. With the help of bitwise operations, we may be able to manage all the 32 bits (counters) collectively instead of using 32 32-bit integers.\\n\\nAn intuitive Image from the post:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/7ywr3.jpg)\\n\\nThe question is how to get the result from the `x` values in those counters. By now, we notice that the counters\\' states are only contributed by the number we want. Let\\'s say the number appear $p$ times, so there should be `p` \"1\"s which have entered the counters. Since `p` could be very large, we need to do `p\\' = p % k` to know the exact numbers of `1`.\\n\\nNotice that if `p % k == 0`, this method is no longer effective for this problem.\\n\\n- For example, if `k = 2 (1 0), p = 1 (0 1)`, the final state of `1`\\'s corresponding counter\\'s state should be `x2 = 0, x1 = 1`. So we just need to return `x1` as our result.\\n\\n- For another example, if `k = 2 (1 0), p = 2 (1 0)`, the final state of `1`\\'s corresponding counter\\'s state should be `x2 = 0, x1 = 0`. However, since it is also the same case of `0`, we cannot extract the bits that are `1`.\\n\\n- For another example , if `k = 4 (1 0 0), p = 3 (0 1 1)`, the final state of `1`\\'s corresponding counter\\'s state should be `x3 = 0, x2 = 1, x1 = 1`. So, we just need to return `x2 | x1`, or `x2`, or `x1` as our results.\\n\\n\\n\\n## Single Number III\\n\\n> Given an array of numbers `nums`, in which `exactly two elements` appear only once and all the other elements appear `exactly twice`. Find the two elements that appear only `once`.\\n\\n**Note:** The order of the result is not important. So in the above example, [5, 3] is also correct.\\n\\n**Follow-up:** Your algorithm should have a `linear runtime` complexity. Could you implement it `without using extra memory`?\\n\\n\\n**Example:**\\n\\n```java\\nInput:  [1,2,1,3,2,5]\\nOutput: [3,5]\\n```\\n\\n**Methods**\\n\\n1. Brute-force (same as Problem I)\\n   - Use `stream()` to convert `List<Integer>` to `int[]`.\\n  ```java\\n  public int[] singleNumber(int[] nums) {\\n    int n = nums.length;\\n    List<Integer> result = new ArrayList<>();\\n    for (int i = 0; i < n; ++i) { // examing i\\n      boolean isSingle = true;\\n      for (int j = 0; j < n; ++j) {\\n        if (i == j) continue; // except itself\\n        \\n        if (nums[i] == nums[j]) { // found duplicate numbers\\n          isSingle = false;\\n        }\\n      }\\n      if (isSingle) {\\n        result.add(nums[i]);\\n      }\\n    }\\n    return result.stream().filter(Objects::nonNull).mapToInt(Integer::intValue).toArray();\\n    // OR: return new int[] { result.get(0), result.get(1) };\\n  }\\n  ```\\n2. Hash Table\\n   - Use a hash set.\\n  ```java\\n  public int[] singleNumber(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int val : nums) {\\n      if (set.contains(val)) {\\n        set.remove(val);\\n      } else {\\n        set.add(val);\\n      }\\n    }\\n    return set.stream().filter(Objects::nonNull).mapToInt(Integer::intValue).toArray();\\n  }\\n  ```\\n    - **Time:** `O(N)`\\n    - **Space:** `O(N)`\\n3. Math (not applicable)\\n4. Bit Manipulation ([reference](https://leetcode.com/problems/single-number-iii/discuss/68900))\\n   - This time we need one more trick. We need to put those distinct single numbers into two groups.\\n   - Let `a` and `b` be the two unique numbers.\\n   - **In the first pass**, we use `^` to get the value `a ^ b`. With this value, we extract any bit which has value `1`. The bit values of `a` and `b` in this position must be different.\\n   - **In the second pass**, we separate numbers into two groups, one group with that bit set, and another group with that bit unset.\\n     - Notice that the size of each group could be different, but we have guaranteed that `a` and `b` are not in the same group, and other same numbers are in the same group (`since they both have that bit set or unset`).\\n    - Under this condition, we can extract `a` and `b` in each group by the method proposed in the Problem I.\\n    - **Time:** `O(N)`\\n    - **Space:** `O(1)`\\n\\n**Note:** Be careful of the precedence of `&` and `>`.\\n\\n```java\\npublic int[] singleNumber(int[] nums) {\\n  // First Pass\\n  int abXor = 0;\\n  for (int val : nums) {\\n    abXor ^= val;\\n  }\\n  \\n  // Isolate one \"1\" bit in the abXor\\n  int mask = abXor & ~(abXor - 1);\\n  \\n  // Second Pass\\n  int a = 0, b = 0;\\n  for (int val : nums) {\\n    if ((val & mask) > 0) { // with that bit set\\n      a = a ^ val;\\n    } else { // with that bit unset\\n      b = b ^ val;\\n    }\\n  }\\n  return new int[] { a, b };\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nInput: [2,2,1]\\nOutput: 1\\nInput: [4,1,2,1,2]\\nOutput: 4\\n```\n```java\\n  public int singleNumber(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; ++i) { // examing i\\n      boolean isSingle = true;\\n      for (int j = 0; j < n; ++j) {\\n        if (i == j) continue; // except itself\\n        \\n        if (nums[i] == nums[j]) { // found duplicate numbers\\n          isSingle = false;\\n        }\\n      }\\n      if (isSingle) {\\n        return nums[i];\\n      }\\n    }\\n    throw new IllegalArgumentException();\\n  }\\n  ```\n```java\\n    // HashSet\\n    public int singleNumber(int[] nums) {\\n      Set<Integer> set = new HashSet<>();\\n      for (int val : nums) {\\n        if (set.contains(val)) {\\n          set.remove(val);\\n        } else {\\n          set.add(val);\\n        }\\n      }      \\n      for (int val : set) {\\n        return val;\\n      }\\n      throw new IllegalArgumentException();\\n    }\\n    ```\n```java\\n    public int singleNumber(int[] nums) {\\n      int sum = 0;\\n      Set<Integer> set = new HashSet<>();\\n      for (int val : nums) {\\n        sum += val;\\n        set.add(val);\\n      }\\n      int setSum = 0;\\n      for (int val : set) {\\n        setSum += val;\\n      }\\n      return 2 * setSum - sum;\\n    }\\n  ```\n```java\\n  public int singleNumber(int[] nums) {\\n    int a = 0;\\n    for (int val : nums) {\\n      a ^= val;\\n    }\\n    return a;\\n  }\\n  ```\n```java\\nInput: [2,2,3,2]\\nOutput: 3\\nInput: [0,1,0,1,0,1,99]\\nOutput: 99\\n```\n```java\\n// k = 3 / 11 (m = 2), p = 1\\npublic int singleNumber(int[] nums) {\\n  int x1 = 0, x2 = 0, mask = 0;\\n  for (int val : nums) {\\n    x2 = x2 ^ (x1 & val);\\n    x1 = x1 ^ val;\\n    mask = ~(x2 & x1);\\n    x2 = x2 & mask;\\n    x1 = x1 & mask;\\n  }\\n  // p = 1, final state: x2 = 0, x1 = 1\\n  return x1;\\n}\\n```\n```java\\n         x3   x2   x1\\nState 1:  0    0    0\\nState 2:  0    0    1\\nState 3:  0    1    0\\nState 4:  0    1    1\\nState 5:  1    0    0\\n```\n```java\\n          x2   x1  +1  x2   x1  =>  x2   x1\\nState 1:   0    0       0    1  =>   0    1\\nState 2:   0    1       1    0  =>   0    1\\nk = 2:                  1    0  =>   0    0\\n\\n          x2   x1  +1  x2   x1  =>  x2   x1\\nState 1:   0    0       0    1  =>   0    1\\nState 2:   0    1       1    0  =>   0    1\\nState 3:   1    0       1    1  =>   1    0\\nk = 3:                  1    1  =>   0    0\\n```\n```java\\nint x1 = 0, x2 = 0;\\nfor (int val : nums) {\\n  // update the state\\n  x2 = x2 ^ (x1 & val);\\n  x1 = x1 ^ val;\\n  // mask\\n  mask = ~(x2 & x1);\\n  x2 = x2 & mask;\\n  x1 = x1 & mask;\\n}\\n```\n```java\\nInput:  [1,2,1,3,2,5]\\nOutput: [3,5]\\n```\n```java\\n  public int[] singleNumber(int[] nums) {\\n    int n = nums.length;\\n    List<Integer> result = new ArrayList<>();\\n    for (int i = 0; i < n; ++i) { // examing i\\n      boolean isSingle = true;\\n      for (int j = 0; j < n; ++j) {\\n        if (i == j) continue; // except itself\\n        \\n        if (nums[i] == nums[j]) { // found duplicate numbers\\n          isSingle = false;\\n        }\\n      }\\n      if (isSingle) {\\n        result.add(nums[i]);\\n      }\\n    }\\n    return result.stream().filter(Objects::nonNull).mapToInt(Integer::intValue).toArray();\\n    // OR: return new int[] { result.get(0), result.get(1) };\\n  }\\n  ```\n```java\\n  public int[] singleNumber(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int val : nums) {\\n      if (set.contains(val)) {\\n        set.remove(val);\\n      } else {\\n        set.add(val);\\n      }\\n    }\\n    return set.stream().filter(Objects::nonNull).mapToInt(Integer::intValue).toArray();\\n  }\\n  ```\n```java\\npublic int[] singleNumber(int[] nums) {\\n  // First Pass\\n  int abXor = 0;\\n  for (int val : nums) {\\n    abXor ^= val;\\n  }\\n  \\n  // Isolate one \"1\" bit in the abXor\\n  int mask = abXor & ~(abXor - 1);\\n  \\n  // Second Pass\\n  int a = 0, b = 0;\\n  for (int val : nums) {\\n    if ((val & mask) > 0) { // with that bit set\\n      a = a ^ val;\\n    } else { // with that bit unset\\n      b = b ^ val;\\n    }\\n  }\\n  return new int[] { a, b };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791433,
                "title": "complete-understanding-of-bits-read-it-once-o-n",
                "content": "\\nLet\\u2019s us understand why this is solved with bits operations.\\n\\nNote:- bits are the representation of a number in its binary form (e.g 4= 1 0 0)\\n\\n Xor: \\xA0XOR\\xA0compares two input bits and generates one output bit. The logic is simple. If the bits are the same, the result is 0  ,else 1.(operator= \\u2018^\\u2019)\\nAnd:  If the bits are the same, the result is 1  ,else 0.(operator= \\u2018&\\u2019)\\n\\n  1 0 0 1  xor with 1 1 1 1 \\n\\n\\t1  0 0  1\\n    1  1  1  1 \\n     \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014-----\\n\\t0  1  1  0\\n\\n\\n==>**` REMEMBER xor of two equal numbers will give 0 (e.g 4^4) and xor of a number with 0 gives the number itself.(4^0=4)`**\\n```\\n\\n 1 0 0\\t\\t\\t\\t\\t1\\t1\\t1\\n 1 0 0 \\t\\t\\t\\t\\t0\\t0\\t0\\n   -\\u2014\\u2014\\u2014\\u2014\\t\\t     \\t\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n 0 0 0\\t\\t\\t\\t    1\\t1\\t1\\n \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\t\\t          \\t\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n```\\n\\n\\n  \\n\\nLet\\u2019s dive in the question with the given example to make it more clear:-\\n\\n[ 1, 2, 1, 3 ,2 ,5]\\n\\nlets xor the array i.e 1^2^1^3^2^5\\n\\n\\n\\n**`==>REASON`**\\nAs the question states every number will occur twice except the two  unique number.  Lets rearrange the number to understand 1^1^2^2^3^5.\\n    1^1  =0\\n    2^2=0\\nwe are remained with \\n\\n0 ^0^3^5\\n\\n**`Congrats you solved  question no 136 where every number is occuring twice, only  unique remains after xor of the array elements `**\\n\\n0 makes no use as it gives the same number so we have 3^5 i.e (011^101= 110)=6\\nIf you see carefully these are the two numbers  that are unique but how to get them ,as we have the xor of them.\\n\\nWe are almost done !\\nobserve the xor  bits of both number\\n\\n3^5=6(1 1 0)\\n\\n\\n\\tfrom right \\t\\t1 is at (index2)\\t\\t1 is at (index1)\\t\\t0 is at (index 0)\\n\\nif we travel from the rightmost(Least significant bit ) in the xor and see where the two bits differ (i.e when the first index from right   have xor  value 1 ) which is index 1 from rightmost(LSB) in this case .\\nHmm !! \\uD83E\\uDD14what can we conclude from that?\\n\\n**`\\\\\\\\Query1   Read the below explaination given at the end to know how to calculate the rightmost bit that is set , if u already know then continue.`**\\n\\nnow again look into the example array\\n\\t\\t\\t\\t\\t\\t\\n\\t\\tindex\\t\\t2\\t\\t1\\t\\t0\\n\\t\\t-------------------------------\\n\\t\\t1 \\t\\t\\t0\\t\\t0\\t\\t1\\t\\n\\t\\t2 \\t\\t\\t0\\t\\t1\\t\\t0\\n\\t\\t1 \\t\\t\\t0\\t\\t0\\t\\t1\\n\\t\\t3 \\t\\t\\t0\\t\\t1\\t\\t1\\n\\t\\t2 \\t\\t\\t0\\t\\t1\\t\\t0\\n\\t\\t5 \\t\\t\\t1\\t\\t0\\t\\t1\\n\\t\\t    \\t\\n\\t\\t\\n\\n\\nwe know that two numbers(3 and 5) differ at index 1 what if we just seperate all the integers that have same values at index 1(i.e store all the numbers with bit=1 at index 1 in one container(variable) and with bit as 0 at index 1 in another).\\n\\n\\n**`\\\\\\\\Query2  Read below at the end  to know how we check if the integer that have specific bit at a specific index.. if u already know then continue with the solution.`**\\n\\n\\nlet us do it \\n\\ncontainer 1 with bit==1 at index 1will have  integer -> 2,3,2 (these all have bit =1 at index 1)\\ncontiner  2 with bit==0 at index 1 will have integer->1 1 5(these have 0 at index 1)\\n\\nxor the elements inside each container will give  2^3^2=  0^3=3\\nand 1^1^5=0^5=5\\n\\n**container can be two variables with value=0 .**\\n\\nand yesss finally we got the two integers that we want ..\\n\\n------------------------------------------------------------------------------------------------\\n------------------------------------------------------------------------------------------------\\n------------------------------------------------------------------------------------------------\\n------------------------------------------------------------------------------------------------\\n------------------------------------------------------------------------------------------------\\n------------------------------------------------------------------------------------------------\\n# **Answer to Queries**\\n\\n**Query1-> How to find the rightmost set bit??**\\n \\nlets stick with the same example so as to not get any confusion\\n\\n3    0  0\\t1 \\t1\\n5    0  1\\t0\\t1\\n    \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n       0  1\\t1\\t0\\n\\nlets go with 0 1 1 0\\n\\nlets say we are at positon 0(int position=0) i.e  at index 0 from right we can see that the bit is not set (it is 0) so we are sure that both the values would be equal i want to leave it and move to the next bit.\\nTo go to the next bit i.e index 1 from right  how about shift the bits to right one place 0 1 1 0->0 0 1 1  without actually moving i have reached to the next bit i.e 1 by shifting the bits  and increase the postion to 1 (position++)now this bit is set (i.e 1) so i know that this is the first bit that is set and which i needed so i will stop.\\n\\nobserved a thing??\\n0 1 1 0=6 and  after shifting right we got 0 0 1 1=3\\n\\nactually shifting right means dividing a number by 2^(number of time you want to shift)\\nRight shift denoted as a>>b => a right shift by b ==> a/(2^b)\\nhere we are doing num >>1 (shift by 1). ==> num=num/2^1;\\n\\nposition value comes as 1 . \\n\\nwe have figured a way to find the rightmost set bit.\\n\\n\\n\\n\\n\\n\\n**Query2==> how to check what value of bit the integer has  at a particular index .**\\n\\n3 = 0 1 1 \\n\\nsuppose i need to check if 3 has a value set  or not at index 1 as above example .\\n\\nTo find  a bit value that is only set at the particular  index we can use left shift how?\\nIn the above way of finding the index (query 1) we found that the index 1 is the place where the two bits differ . Every power of 2 gives a particular number that has the bit as 1 at the index==power\\ne.g (2^0=1       has set bit at 0 index only)\\n\\t\\t(2^1=2     has set bit at 1 index only)\\nwhat is the number that has set bit 1 at index 1 only?\\n2 is the answer=0 1 0 but how to get it ?\\n1<<(index value)\\nlest shifting  :- a<<b =>a*2^(index value)\\nin this case we have index=1(rightmost position value that we find having bit =1 )\\n1<<1=1 *2^(1)=2\\n\\nthis is our mask (remember what is mask in bit masking ) that\\u2019s the one you were finding.\\n\\ni have the number ( mask ) if we & it with 3\\n\\t0 1 1\\n    &  0 1 0\\n      \\u2014\\u2014\\u2014\\u2014\\n\\t0  1\\t0\\t   =2 \\n\\nyes 3 has the bit as 1 at index 1  because the result >0\\n\\nlets do it with 5\\n\\t1  0  1\\n   &.  0  1  0\\n      \\u2014\\u2014\\u2014\\u2014\\u2014\\n\\t0   0  0   =0\\n\\nit dosn\\u2019t have a set bit at index 1 so the result is =0.\\n\\n\\nso like this for each integer we  can check if at that index the value is >0 or 0 .\\n\\n\\n\\n\\n\\n\\n\\n```\\n vector<int>ans;\\n        int x_or=0  ; \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x_or=x_or^nums[i]; //xor of array  \\n        }\\n        int pos=0;\\n        int temp=x_or;\\n        while((temp&1)==0)//finding the rightmost set bit\\n        {\\n            pos++;\\n            temp=temp>>1;\\n        }\\n        int mask=1<<pos;//making the mask with set bit at pos index\\n        int num1=0;\\n        int num2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]&mask)>0)//container1\\n            {\\n                num1^=nums[i];\\n            }\\n            else\\n            {\\n                num2^=nums[i];//container2\\n            }\\n        }\\n        ans.push_back(num1);\\n        ans.push_back(num2);\\n        return ans;\\n        \\n```\\n\\n```\\nTime complexity =O(N)+O(N)~= O(N) for two traversals of the array\\nSpace complexity=O(1) \\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n 1 0 0\\t\\t\\t\\t\\t1\\t1\\t1\\n 1 0 0 \\t\\t\\t\\t\\t0\\t0\\t0\\n   -\\u2014\\u2014\\u2014\\u2014\\t\\t     \\t\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n 0 0 0\\t\\t\\t\\t    1\\t1\\t1\\n \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\t\\t          \\t\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n```\n```\\n vector<int>ans;\\n        int x_or=0  ; \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x_or=x_or^nums[i]; //xor of array  \\n        }\\n        int pos=0;\\n        int temp=x_or;\\n        while((temp&1)==0)//finding the rightmost set bit\\n        {\\n            pos++;\\n            temp=temp>>1;\\n        }\\n        int mask=1<<pos;//making the mask with set bit at pos index\\n        int num1=0;\\n        int num2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]&mask)>0)//container1\\n            {\\n                num1^=nums[i];\\n            }\\n            else\\n            {\\n                num2^=nums[i];//container2\\n            }\\n        }\\n        ans.push_back(num1);\\n        ans.push_back(num2);\\n        return ans;\\n        \\n```\n```\\nTime complexity =O(N)+O(N)~= O(N) for two traversals of the array\\nSpace complexity=O(1) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561862,
                "title": "javasscript-clean-easy-to-understand-commented-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n*/\\nvar singleNumber = function(nums) {\\n    // T: O(n), S: O(1)\\n    let n = nums.length;\\n    let seen = 0;\\n    \\n    // xoring an even amount of times the same number will cancel it out,\\n    // leaving us with seen = A ^ B (A and B are our missing numbers which\\n    // will not get canceled out).\\n    for (let i = 0; i < n; i++) {\\n        seen = seen ^ nums[i];\\n    }\\n    \\n    // at this point, our \\'seen\\' variable stores the result of A^B xor operation\\n    // we need to figure out what numbers from the list are A and B\\n    // for that, we\\'ll just find the first bit set, as we know after a xor\\n    // operation the only way that a bit ends up set, is as a result of either A or B \\n    // having that same bit set, but not both of them at the same time.\\n    //\\n    // for instance, lets say A = 7, and B = 3, \\'seen\\' variable should be 4 since 7 ^ 3 = 4\\n    // 0000 0111 (=7)  (3rd LSB bit is set)\\n    // 0000 0011 (=3)  (3rd LSB bit is not set)\\n    // 0000 0100 (=4) <--- only the 3rd LSB bit is set after the xor operation, all the other bits are unset\\n    // \\n    // if we find that first bit set in our \\'seen\\' variable, then we know (at least) in that\\n    // specific position the value of that bit in A is different from the value of that same bit in B.\\n    // meaning that in one number the bit must be set, and in the other one it must not.\\n    //\\n    // we will loop until we find that different bit (that is now set), while we build a mask\\n    // that will come in handy during the final pass.\\n    let mask = 1;\\n    while (!(seen & mask)) {\\n        mask = mask << 1;\\n    }\\n\\n    let a = 0;\\n    let b = 0;\\n    // we\\'ll now do a final pass, dividing our set of numbers into 2 subsets\\n    // the first one will contain the numbers that have the first different bit set,\\n    // and the second one will contain the numbers that have it unset\\n    // this will separate our A and B values, since only one of them will be \\n    // able to match our mask\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] & mask) {\\n            a = a ^ nums[i];\\n        } else {\\n            b = b ^ nums[i];\\n        }\\n    }\\n\\t\\n    // finally, numbers that appear an even amount of times will again cancel each other out in the\\n    // exact same way they did during the first pass. however, this time we\\'ll be left with our missing\\n    // numbers A and B (that only appear once) separated.\\n    return [a, b];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n*/\\nvar singleNumber = function(nums) {\\n    // T: O(n), S: O(1)\\n    let n = nums.length;\\n    let seen = 0;\\n    \\n    // xoring an even amount of times the same number will cancel it out,\\n    // leaving us with seen = A ^ B (A and B are our missing numbers which\\n    // will not get canceled out).\\n    for (let i = 0; i < n; i++) {\\n        seen = seen ^ nums[i];\\n    }\\n    \\n    // at this point, our \\'seen\\' variable stores the result of A^B xor operation\\n    // we need to figure out what numbers from the list are A and B\\n    // for that, we\\'ll just find the first bit set, as we know after a xor\\n    // operation the only way that a bit ends up set, is as a result of either A or B \\n    // having that same bit set, but not both of them at the same time.\\n    //\\n    // for instance, lets say A = 7, and B = 3, \\'seen\\' variable should be 4 since 7 ^ 3 = 4\\n    // 0000 0111 (=7)  (3rd LSB bit is set)\\n    // 0000 0011 (=3)  (3rd LSB bit is not set)\\n    // 0000 0100 (=4) <--- only the 3rd LSB bit is set after the xor operation, all the other bits are unset\\n    // \\n    // if we find that first bit set in our \\'seen\\' variable, then we know (at least) in that\\n    // specific position the value of that bit in A is different from the value of that same bit in B.\\n    // meaning that in one number the bit must be set, and in the other one it must not.\\n    //\\n    // we will loop until we find that different bit (that is now set), while we build a mask\\n    // that will come in handy during the final pass.\\n    let mask = 1;\\n    while (!(seen & mask)) {\\n        mask = mask << 1;\\n    }\\n\\n    let a = 0;\\n    let b = 0;\\n    // we\\'ll now do a final pass, dividing our set of numbers into 2 subsets\\n    // the first one will contain the numbers that have the first different bit set,\\n    // and the second one will contain the numbers that have it unset\\n    // this will separate our A and B values, since only one of them will be \\n    // able to match our mask\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] & mask) {\\n            a = a ^ nums[i];\\n        } else {\\n            b = b ^ nums[i];\\n        }\\n    }\\n\\t\\n    // finally, numbers that appear an even amount of times will again cancel each other out in the\\n    // exact same way they did during the first pass. however, this time we\\'ll be left with our missing\\n    // numbers A and B (that only appear once) separated.\\n    return [a, b];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244592,
                "title": "c-easy-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size()==2)\\n        {\\n            //all are appeared once\\n            return nums;\\n        }\\n        \\n        //we calculate the xor of all elements as usual \\n        int xorVal=0;\\n        for(auto i:nums)\\n            xorVal=xorVal^ i;\\n        //now we have the xor of two unique values\\n        //now we have to get the one of the unique value \\n        //in xor the result is 1 if one value has set bit and other doesnot\\n        //we use this logic to get the one of the unique val \\n        //get the first position of set bit in xorVal\\n        int pos=0;\\n        int temp=xorVal;\\n        while(!(temp&1)){\\n            pos++;\\n            temp>>=1;\\n        }\\n        //we will now calculate the xor values of all elements in the array which has set bit in position pos\\n        int tempXor=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(checkSetBit(nums[i],pos)){\\n                tempXor=tempXor ^ nums[i];\\n            }\\n        }\\n        //we have got one of the value in our answer  \\n        vector<int> res;\\n        res.push_back(tempXor);\\n        res.push_back(tempXor ^ xorVal); //gives the other unique value\\n        return res;\\n    }\\n    \\n    //checks if a set bit exists in position \\'pos\\' in its binary representation\\n    bool checkSetBit(int num,int pos)\\n    {\\n        return (num&(1<<pos));\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size()==2)\\n        {\\n            //all are appeared once\\n            return nums;\\n        }\\n        \\n        //we calculate the xor of all elements as usual \\n        int xorVal=0;\\n        for(auto i:nums)\\n            xorVal=xorVal^ i;\\n        //now we have the xor of two unique values\\n        //now we have to get the one of the unique value \\n        //in xor the result is 1 if one value has set bit and other doesnot\\n        //we use this logic to get the one of the unique val \\n        //get the first position of set bit in xorVal\\n        int pos=0;\\n        int temp=xorVal;\\n        while(!(temp&1)){\\n            pos++;\\n            temp>>=1;\\n        }\\n        //we will now calculate the xor values of all elements in the array which has set bit in position pos\\n        int tempXor=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            if(checkSetBit(nums[i],pos)){\\n                tempXor=tempXor ^ nums[i];\\n            }\\n        }\\n        //we have got one of the value in our answer  \\n        vector<int> res;\\n        res.push_back(tempXor);\\n        res.push_back(tempXor ^ xorVal); //gives the other unique value\\n        return res;\\n    }\\n    \\n    //checks if a set bit exists in position \\'pos\\' in its binary representation\\n    bool checkSetBit(int num,int pos)\\n    {\\n        return (num&(1<<pos));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68998,
                "title": "how-to-use-bit-manipulation-to-solve-this-problem",
                "content": "Here's the question.\\n\\n    Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\\n    \\n    For example:\\n    \\n    Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].\\n    \\n    **Note**:\\n    The order of the result is not important. So in the above example, [5, 3] is also correct.\\n    Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\\n\\nI know how to do this with a hashtable, but it's more than constant space.\\n\\nI've read this [post][1] using bit manipulation, but found it hard to understand why. Can anyone kindly elaborate on that?\\n\\nMany Thanks!\\n\\n\\n  [1]: https://leetcode.com/discuss/52521/share-two-java-solution-%EF%BC%9Ad",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "Here's the question.\\n\\n    Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\\n    \\n    For example:\\n    \\n    Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].\\n    \\n    **Note**:\\n    The order of the result is not important. So in the above example, [5, 3] is also correct.\\n    Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\\n\\nI know how to do this with a hashtable, but it's more than constant space.\\n\\nI've read this [post][1] using bit manipulation, but found it hard to understand why. Can anyone kindly elaborate on that?\\n\\nMany Thanks!\\n\\n\\n  [1]: https://leetcode.com/discuss/52521/share-two-java-solution-%EF%BC%9Ad",
                "codeTag": "Unknown"
            },
            {
                "id": 3684319,
                "title": "bit-manipulation-xor",
                "content": "# Intuition\\nSimilar to Single Number 1 with the difference that there are two single elements. Lets think in the same direction and use some xor properties.\\n**Please solve Single number 1 before attempting this.**\\n# Properties\\n1. a ^ a = 0\\n2. a ^ 0 = a\\n3. a ^ b = b ^ a\\n4. a ^ ( b ^ c ) = ( a ^ b ) ^ c;\\n5. a ^ b != 0 for all (a,b) such that a != b\\n6. 1 ^ 1 = 0 ^ 0 = 0\\n7. 1 ^ 0 = 1\\n# Approach\\n1. Lets take xor of the whole array( my first for loop ).\\n2. The resultant would be of the form a^b, where a and b both are unique number whose frequency is one and the **xor would not be zero because numbers are distinct**\\n3. Now we know that the total xor is non zero therefore atleast one bit in it must be set. This set bit would have come from either a or from b but not both becasue 1 ^ 1 = 0 i.e if both a and b have same set bit it would get toggled.\\n4. lets assume that it came from b. Iterate through the array and take xor of all the elements where that bit is set( it wont be in a ). Every number would come in pair except b so prevxor ^ b = a;\\n5. Now that we have a, xor it with initial array xor to get b.\\n6. **NOTE :** It doesn\\'t matter which set bit we choose in point 4. The concept would remain the same.\\n\\nThis question can also be solved using maps and sets. Please give those approaches a try as well.\\n**Hint for set :** if an element is already present delete it, else insert in set.\\n**Hint for map :** Store frequency of the numbers.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int number = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            number ^= nums[i];\\n        }\\n        int setBit = 1;\\n        while( true ){\\n            if( number & ( setBit ) ){\\n                break;\\n            }\\n            setBit <<= 1;\\n        }\\n        int firstAns = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            if( nums[i]&setBit ){\\n                firstAns ^= nums[i];\\n            }\\n        }\\n        int secondAns = firstAns^number;\\n        return {firstAns,secondAns}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int number = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            number ^= nums[i];\\n        }\\n        int setBit = 1;\\n        while( true ){\\n            if( number & ( setBit ) ){\\n                break;\\n            }\\n            setBit <<= 1;\\n        }\\n        int firstAns = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            if( nums[i]&setBit ){\\n                firstAns ^= nums[i];\\n            }\\n        }\\n        int secondAns = firstAns^number;\\n        return {firstAns,secondAns}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562229,
                "title": "c-easy-solution-o-n-time-and-o-1-space-with-explanation",
                "content": "**Step-Wise Explanation:-** \\n1. First do a XOR of all the elements.\\n2. Then with the help of mask, find the right-most set bit of the xor of all the elements.\\n3. After that we keep two variables, and check the mask\\'th bit, if it is set then add in first variable, else put it in the second variable.\\n4. Return both the variables, which is the answer.\\n```\\nclass Solution {\\npublic:\\n    int most_significant_bit(long long n) {\\n        int mask = 1;\\n        while(1) {\\n            if((mask & n) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        return mask;\\n    }\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int first_xor = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            first_xor = first_xor ^ nums[i];\\n        int set_bit = most_significant_bit(first_xor);\\n        int xor_a = 0, xor_b = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] & set_bit) \\n                xor_a ^= nums[i];\\n            else \\n                xor_b ^= nums[i];\\n        }\\n        return {xor_a,xor_b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int most_significant_bit(long long n) {\\n        int mask = 1;\\n        while(1) {\\n            if((mask & n) == 0) {\\n                mask = mask << 1;\\n            }\\n            else break;\\n        }\\n        return mask;\\n    }\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int first_xor = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            first_xor = first_xor ^ nums[i];\\n        int set_bit = most_significant_bit(first_xor);\\n        int xor_a = 0, xor_b = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] & set_bit) \\n                xor_a ^= nums[i];\\n            else \\n                xor_b ^= nums[i];\\n        }\\n        return {xor_a,xor_b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407441,
                "title": "best-easiest-o-n-time-o-1-space-explained-easy",
                "content": "**Thoughts**\\nThis problem has a lot of very unintuitive approaches. This problem requires Bit Manupulation. I recommend the other two variations of this problem more, as they are more interview oriented and intituive.*You can find them in the \"Similar Problems\" section.* Having said that,\\n\\n**Aim**\\nThis problem requires for us to find the two numbers( I\\'ve taken as A and B) that don\\'t repeat twice in an array of elements that repeat twice.\\n\\n**Pre Req Knowledge**\\nAll the elements except A and B occour twice. Bitwise XOR of two identical Numbers is 0. \\n```\\n//for any p,\\np xor p  = 0; // Here xor = BITWISE XOR\\n```\\n\\n**Approach**\\nIf we xor all the elements of the array, that xor product( named xorAll in the code) will be A^B. Beacuse all the other elements occour twice so their net contribution will be zero. *This approach is Problem number 136, SIngle Number I.*\\nNow we have,\\n```\\nxorAll = A^B\\n```\\n\\n**The tricky part** - *How to extract A and B from xor product ?*\\n\\nObservation -> The xor product(```xorAll```) can\\'t be zero, because if it is zero, it means both numbers are identical, and that can\\'t be the case according to the question.\\nHence, there would be atleast one bit in ```xorAll``` which will be one. And for that bit, A and B will have different values,as A^B is 1.\\nSo we find the ```least set bit```( least set bit means the first bit from the right that is not zero) of ```xorAll```, then create a mask, which is 1 at the least bit and zero otherwise, and then we will divide all the elements of the ```nums ```array into two groups :-\\n>>The first group will have all the numbers whose ```least set bit``` is 1, and the second group, where all the numbers have their ```least set bit``` as 0.\\n>>\\n>>All the numbers that occoured in pairs, will be distributed in pairs i.e. Both occourances of that number will either be in group 1 or group 2.\\n>>\\n>>A and B can\\'t be in the same group. Because for this bit(```least set bit```), A^B is 1, which means if this bit of A is 1, it woulb be 0 for B and vice versa.\\n>>\\n>>Now we take xor product of all elements in group 1 and to get A, and xor product of all elements in group 2 to get B.\\n\\n**Implementation**\\nImplelemtation is mostly straight foreward, One thing to note is that the problem is meant to be solved in constant space, so you can\\'t hard code to make two groups as was explained in approach, so you would have to apply a single if loop like i did.\\n\\nFor the mask,\\nFor making a mask which checks the least set bit for any number, take the number(num), negate it(~num), add one(~num +1), then and(&) with itself. So, ```mask => ((~num)+1)&num;``` \\n\\n```\\nclass Solution {\\npublic:\\n   vector<int> singleNumber(vector<int>& nums) {\\n        long int xorAll = 0;\\n        int A=0, B=0; // assumed numbers\\n        \\n        //XOR all numbers\\n        for(int i: nums) xorAll = xorAll^i;\\n        //xorAll is effectively A^B;\\n        \\n        \\n        //finding the Least Set Bit(LSB) in xorAll and creating  a mask with only that bit as set(1)\\n        long int mask =(( ~xorAll)+1) & xorAll;\\n        \\n        // seperating with an if-else loop and xor after that\\n        for(int i=0; i< nums.size(); i++){\\n            if(nums[i] & mask) A = A^nums[i];\\n            else B = B^nums[i];\\n        }\\n        return {A,B};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//for any p,\\np xor p  = 0; // Here xor = BITWISE XOR\\n```\n```\\nxorAll = A^B\\n```\n```xorAll```\n```xorAll```\n```least set bit```\n```xorAll```\n```nums ```\n```least set bit```\n```least set bit```\n```least set bit```\n```mask => ((~num)+1)&num;```\n```\\nclass Solution {\\npublic:\\n   vector<int> singleNumber(vector<int>& nums) {\\n        long int xorAll = 0;\\n        int A=0, B=0; // assumed numbers\\n        \\n        //XOR all numbers\\n        for(int i: nums) xorAll = xorAll^i;\\n        //xorAll is effectively A^B;\\n        \\n        \\n        //finding the Least Set Bit(LSB) in xorAll and creating  a mask with only that bit as set(1)\\n        long int mask =(( ~xorAll)+1) & xorAll;\\n        \\n        // seperating with an if-else loop and xor after that\\n        for(int i=0; i< nums.size(); i++){\\n            if(nums[i] & mask) A = A^nums[i];\\n            else B = B^nums[i];\\n        }\\n        return {A,B};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68965,
                "title": "java-bit-manipulation-solution",
                "content": "    public class Solution {\\n        public int[] singleNumber(int[] nums) {\\n            int diff = 0;\\n            for (int num : nums) {\\n                diff ^= num; \\n            }\\n            // pick one bit as flag\\n            int bitFlag = (diff & (~ (diff - 1)));\\n            int[] res = new int[2];\\n            for (int num : nums) {\\n                if ((n & bitFlag) == 0) {\\n                    res[0] ^= num;\\n                } else {\\n                    res[1] ^= num;\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int[] singleNumber(int[] nums) {\\n            int diff = 0;\\n            for (int num : nums) {\\n                diff ^= num; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 68982,
                "title": "java-easy-to-understand-solution-with-no-confusing-x-x",
                "content": "     public int[] singleNumber(int[] nums) {\\n        int [] result = new int [2];\\n        int xorResult = 0;\\n        //find the Xor of two numbers\\n        for(int i = 0; i < nums.length; i++){\\n            xorResult ^= nums[i];\\n        }\\n        \\n        //find the last bit where it is 1\\n        //a bit of 1 means, at this bit\\n        //either num1 == 0 && num2 == 1 || num1 == 1 && num2 == 0\\n\\n        int lastBitOne = 0;\\n        for(int i = 0; i < 32 ; i++){\\n            if((xorResult & 1) == 1){\\n                lastBitOne = i;\\n                break;\\n            }\\n            xorResult >>>= 1;\\n        }\\n        \\n        //now knowing the lastBitOne\\n        //we can splite the elements into two groups\\n        //one group with that bit = 1, one group with that bit = 0\\n        //We know one result has to be in group1 and the onter has to be in group2\\n        //We just Xor elements in two group\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if((nums[i] >>> lastBitOne & 1) == 0){\\n                result[0] ^= nums[i];\\n            } else{\\n                result[1] ^= nums[i];\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "solutionTags": [],
                "code": "     public int[] singleNumber(int[] nums) {\\n        int [] result = new int [2];\\n        int xorResult = 0;\\n        //find the Xor of two numbers\\n        for(int i = 0; i < nums.length; i++){\\n            xorResult ^= nums[i];\\n        }\\n        \\n        //find the last bit where it is 1\\n        //a bit of 1 means, at this bit\\n        //either num1 == 0 && num2 == 1 || num1 == 1 && num2 == 0\\n\\n        int lastBitOne = 0;\\n        for(int i = 0; i < 32 ; i++){\\n            if((xorResult & 1) == 1){\\n                lastBitOne = i;\\n                break;\\n            }\\n            xorResult >>>= 1;\\n        }\\n        \\n        //now knowing the lastBitOne\\n        //we can splite the elements into two groups\\n        //one group with that bit = 1, one group with that bit = 0\\n        //We know one result has to be in group1 and the onter has to be in group2\\n        //We just Xor elements in two group\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if((nums[i] >>> lastBitOne & 1) == 0){\\n                result[0] ^= nums[i];\\n            } else{\\n                result[1] ^= nums[i];\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3916117,
                "title": "bitwise-solution-beats-99-84",
                "content": "# Intuition\\nThe problem statement requires us to find two elements that appear only once in an array, while all other elements appear twice. The key idea in this solution is to use the XOR operation to differentiate and separate these two unique elements. XORing all the elements in the array will cancel out the pairs of elements that appear twice, leaving us with the XOR of the two target elements. Then, we use the XOR result to isolate the rightmost set bit, which is common to only one of the target elements. Finally, we partition the elements into two groups based on this set bit, and perform XOR operations within each group to find the two target elements.\\n\\n# Approach\\n1)Calculate the XOR of all elements in the array. This will give us the XOR of the two target elements that appear only once.\\n2)Find the rightmost set bit in the XOR result by performing a bitwise AND operation with its two\\'s complement (-xor). This isolates the rightmost set bit, which is a bit that is set in only one of the two target elements.\\n3)Partition the array into two groups:\\nGroup A: Elements with the rightmost set bit as 0.\\nGroup B: Elements with the rightmost set bit as 1.\\nPerform XOR operations within each group to find the two target elements.\\n5)Return the two target elements in an array.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through the nums array twice, once for XORing all elements and once for separating elements into groups. Each iteration takes O(n) time, where n is the length of the array. The bitwise operations also take constant time. Hence, the overall time complexity is O(n).\\n\\n- Space complexity:\\nThe space used is constant as there are no extra data structures being used that depend on the input size. Therefore, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor = 0;\\n        for (int num : nums) {\\n            xor ^= num;\\n        }\\n        \\n        int mask = xor & (-xor); // Get the rightmost set bit\\n        \\n        int xor1 = 0;\\n        int xor2 = 0;\\n        \\n        for (int num : nums) {\\n            if ((num & mask) == 0) {\\n                xor1 ^= num;\\n            } else {\\n                xor2 ^= num;\\n            }\\n        }\\n        \\n        return new int[]{xor1, xor2};\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor = 0;\\n        for (int num : nums) {\\n            xor ^= num;\\n        }\\n        \\n        int mask = xor & (-xor); // Get the rightmost set bit\\n        \\n        int xor1 = 0;\\n        int xor2 = 0;\\n        \\n        for (int num : nums) {\\n            if ((num & mask) == 0) {\\n                xor1 ^= num;\\n            } else {\\n                xor2 ^= num;\\n            }\\n        }\\n        \\n        return new int[]{xor1, xor2};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683953,
                "title": "bit-manipulation-xor",
                "content": "# Intuition\\nSimilar to Single Number 1 with the difference that there are two single elements. Lets think in the same direction and use some xor properties.\\n**Please solve Single number 1 before attempting this.**\\n# Properties\\n1. a ^ a = 0\\n2. a ^ 0 = a\\n3. a ^ b = b ^ a\\n4. a ^ ( b ^ c ) = ( a ^ b ) ^ c;\\n5. a ^ b != 0 for all (a,b) such that a != b\\n6. 1 ^ 1 = 0 ^ 0 = 0\\n7. 1 ^ 0 = 1\\n# Approach\\n1. Lets take xor of the whole array( my first for loop ).\\n2. The resultant would be of the form a^b, where a and b both are unique number whose frequency is one and the **xor would not be zero because numbers are distinct**\\n3. Now we know that the total xor is non zero therefore atleast one bit in it must be set. This set bit would have come from either a or from b but not both becasue 1 ^ 1 = 0 i.e if both a and b have same set bit it would get toggled.\\n4. lets assume that it came from b. Iterate through the array and take xor of all the elements where that bit is set( it wont be in a ). Every number would come in pair except b so prevxor ^ b = a;\\n5. Now that we have a, xor it with initial array xor to get b.\\n6. **NOTE :** It doesn\\'t matter which set bit we choose in point 4. The concept would remain the same.\\n\\nThis question can also be solved using maps and sets. Please give those approaches a try as well.\\n**Hint for set :** if an element is already present delete it, else insert in set.\\n**Hint for map :** Store frequency of the numbers.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int number = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            number ^= nums[i];\\n        }\\n        int setBit = 1;\\n        while( true ){\\n            if( number & ( setBit ) ){\\n                break;\\n            }\\n            setBit <<= 1;\\n        }\\n        int firstAns = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            if( nums[i]&setBit ){\\n                firstAns ^= nums[i];\\n            }\\n        }\\n        int secondAns = firstAns^number;\\n        return {firstAns,secondAns}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int number = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            number ^= nums[i];\\n        }\\n        int setBit = 1;\\n        while( true ){\\n            if( number & ( setBit ) ){\\n                break;\\n            }\\n            setBit <<= 1;\\n        }\\n        int firstAns = 0;\\n        for( int i = 0; i < nums.size(); i++ ){\\n            if( nums[i]&setBit ){\\n                firstAns ^= nums[i];\\n            }\\n        }\\n        int secondAns = firstAns^number;\\n        return {firstAns,secondAns}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235148,
                "title": "260-time-90-93-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem in O(n) time complexity and O(1) space complexity by using bitwise operations.\\n\\n1. First, we XOR all the elements in the array to find the XOR of the two elements that appear only once. Let\\'s call this XOR result as \"x\".\\n\\n2. Next, we find the rightmost set bit in the XOR result \"x\". We can do this by taking the two\\'s complement of \"x\" and then doing a bitwise AND with \"x\". Let\\'s call the result of this operation as \"mask\".\\n\\n3. We then iterate through the array and separate the elements into two groups: one group with elements having the bit at the \"mask\" position as 1, and the other group with elements having the bit at the \"mask\" position as 0.\\n\\n4. Finally, we XOR all the elements in each group separately to get the two elements that appear only once.\\n\\n# Complexity\\n- Time complexity:\\n90.93%\\n\\n- Space complexity:\\n56.33%\\n\\n# Code\\n```\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> List[int]:\\n    # Step 1: Find XOR of the two elements that appear only once\\n    x = 0\\n    for num in nums:\\n        x ^= num\\n\\n    # Step 2: Find the rightmost set bit in the XOR result\\n    mask = x & -x\\n    \\n    # Step 3: Separate the elements into two groups\\n    group1, group2 = 0, 0\\n    for num in nums:\\n        if num & mask:\\n            group1 ^= num\\n        else:\\n            group2 ^= num\\n    \\n    # Step 4: XOR all the elements in each group separately\\n    return [group1, group2]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> List[int]:\\n    # Step 1: Find XOR of the two elements that appear only once\\n    x = 0\\n    for num in nums:\\n        x ^= num\\n\\n    # Step 2: Find the rightmost set bit in the XOR result\\n    mask = x & -x\\n    \\n    # Step 3: Separate the elements into two groups\\n    group1, group2 = 0, 0\\n    for num in nums:\\n        if num & mask:\\n            group1 ^= num\\n        else:\\n            group2 ^= num\\n    \\n    # Step 4: XOR all the elements in each group separately\\n    return [group1, group2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026453,
                "title": "bit-manipulation-xor-and-python3-o-n-time-and-o-1-space",
                "content": "The idea is based on the fact:-\\nx^x=0\\nx^0=x\\n\\nTherefore if there are (n-2) elements in array that appears twice so they are going to cancel out each other using the xor operation. And finally we will get two xored elements that are occurred only once.\\nExample:-\\n[-1, -1, 1, 2, 3, 1, 2, 5]\\ni=0 and x=0     then x=x^arr[0]=>  x = 0 ^ -1 = -1  (remember xor property x^0=x) \\ni=1 and x=-1    then x=x^arr[1]=> x = -1 ^ -1 = -1   (remember xor property x^x=0)\\ni=2 and x=0     then x=x^arr[2]=> x = 0 ^ 1 = 1\\ni=3 and x=1     then x=x^arr[3]=> x = 1 ^ 2 = 3\\ni=4 and x=3     then x=x^arr[4]=> x = 3 ^ 3 = 0 \\ni=5 and x=0     then x=x^arr[5]=> x = 0 ^ 1 = 1\\ni=6 and x=1     then x=x^arr[6]=> x = 1 ^ 2 = 3\\ni=7 and x=3     then x=x^arr[7]=> x= 3 ^ 5 = 6\\n\\nFinally we have got xor of two distinct elements 3 and 5 as 6.\\nNow how will we determine that 6 is the xor of which two elements.\\n\\nFor this we have an interesting property of xor.\\neg.\\n3 ^ 5\\n3  =     011\\n5  =     101 \\n3^5=   110\\nIn the above example one can notice that if the corresponding bit is same then output is 0 otherwise output is 1.\\n\\nSo we can use this idea to find the two elements \\'a\\' and \\'b\\' whose xor is \\'x\\'.\\nwe will first find the last set bit of the x.\\nso for 3^5 it will be 2. how?\\nsee this example\\n6 = x=110 and -x= 1\\'s complement + 1 = 2\\'s complement = 001+1= 010\\n    => x=x&-x\\n\\t      110\\n\\t\\t  010\\n\\t\\t  010\\nit means 010(2) is the last set bit in 6.\\n\\nwe will divide the array into two parts. first part will have the elements with last set bit and 2nd part will have elements with no last set bit.\\n\\neg. [ 1, 2, 3, 1, 2, 5]\\n1st part:[2,2,3]\\n2nd part: [1,1,5]\\nnow do xor of all elements of 1st and 2nd parts separately and you will get your required two numbers.\\nxor(1st  part)=3\\nxor(2nd part)=5\\nand hence two distinct elements are 3 and 5 in this example.\\n\\n                    THANKS FOR READING THE POST!!!\\n\\t\\t\\tPLEASE UPVOTE IF YOU LIKE AND QUERIES ARE ALWAYS WELCOME\\n ```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x=0\\n        for ele in nums:\\n            x^=ele\\n        set_bit=x&-x\\n        n1,n2=0,0\\n        for i in range(len(nums)):\\n            if(set_bit&nums[i]):\\n                n1^=nums[i]\\n            else:\\n                n2^=nums[i]\\n        return [n1,n2]",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "The idea is based on the fact:-\\nx^x=0\\nx^0=x\\n\\nTherefore if there are (n-2) elements in array that appears twice so they are going to cancel out each other using the xor operation. And finally we will get two xored elements that are occurred only once.\\nExample:-\\n[-1, -1, 1, 2, 3, 1, 2, 5]\\ni=0 and x=0     then x=x^arr[0]=>  x = 0 ^ -1 = -1  (remember xor property x^0=x) \\ni=1 and x=-1    then x=x^arr[1]=> x = -1 ^ -1 = -1   (remember xor property x^x=0)\\ni=2 and x=0     then x=x^arr[2]=> x = 0 ^ 1 = 1\\ni=3 and x=1     then x=x^arr[3]=> x = 1 ^ 2 = 3\\ni=4 and x=3     then x=x^arr[4]=> x = 3 ^ 3 = 0 \\ni=5 and x=0     then x=x^arr[5]=> x = 0 ^ 1 = 1\\ni=6 and x=1     then x=x^arr[6]=> x = 1 ^ 2 = 3\\ni=7 and x=3     then x=x^arr[7]=> x= 3 ^ 5 = 6\\n\\nFinally we have got xor of two distinct elements 3 and 5 as 6.\\nNow how will we determine that 6 is the xor of which two elements.\\n\\nFor this we have an interesting property of xor.\\neg.\\n3 ^ 5\\n3  =     011\\n5  =     101 \\n3^5=   110\\nIn the above example one can notice that if the corresponding bit is same then output is 0 otherwise output is 1.\\n\\nSo we can use this idea to find the two elements \\'a\\' and \\'b\\' whose xor is \\'x\\'.\\nwe will first find the last set bit of the x.\\nso for 3^5 it will be 2. how?\\nsee this example\\n6 = x=110 and -x= 1\\'s complement + 1 = 2\\'s complement = 001+1= 010\\n    => x=x&-x\\n\\t      110\\n\\t\\t  010\\n\\t\\t  010\\nit means 010(2) is the last set bit in 6.\\n\\nwe will divide the array into two parts. first part will have the elements with last set bit and 2nd part will have elements with no last set bit.\\n\\neg. [ 1, 2, 3, 1, 2, 5]\\n1st part:[2,2,3]\\n2nd part: [1,1,5]\\nnow do xor of all elements of 1st and 2nd parts separately and you will get your required two numbers.\\nxor(1st  part)=3\\nxor(2nd part)=5\\nand hence two distinct elements are 3 and 5 in this example.\\n\\n                    THANKS FOR READING THE POST!!!\\n\\t\\t\\tPLEASE UPVOTE IF YOU LIKE AND QUERIES ARE ALWAYS WELCOME\\n ```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x=0\\n        for ele in nums:\\n            x^=ele\\n        set_bit=x&-x\\n        n1,n2=0,0\\n        for i in range(len(nums)):\\n            if(set_bit&nums[i]):\\n                n1^=nums[i]\\n            else:\\n                n2^=nums[i]\\n        return [n1,n2]",
                "codeTag": "Java"
            },
            {
                "id": 68999,
                "title": "python-o-n-o-1-solution",
                "content": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            # https://leetcode.com/discuss/48119/single-number-iii\\n            xor = 0\\n            for num in nums: xor ^= num\\n            xor = xor & (xor - 1) ^ xor\\n            a = b = 0\\n            for num in nums:\\n                if xor & num:\\n                    a ^= num\\n                else:\\n                    b ^= num\\n            return [a, b]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def singleNumber(self, nums):\\n            # https://leetcode.com/discuss/48119/single-number-iii\\n            xor = 0\\n            for num in nums: xor ^= num\\n            xor = xor & (xor - 1) ^ xor\\n            a = b = 0\\n            for num in nums:\\n                if xor & num:\\n                    a ^= num\\n                else:\\n                    b ^= num\\n            return [a, b]",
                "codeTag": "Java"
            },
            {
                "id": 68981,
                "title": "accepted-easy-solution-with-java-using-hashset",
                "content": "\\npublic class Solution {\\n\\n    public int[] singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        for(int i:nums){\\n             if(set.add(i)==false)\\n             set.remove(i);\\n        }\\n       \\tint a[]= new int [set.size()];\\n\\t\\tint c=0;\\n\\t\\tfor(int b:set){\\n\\t\\t\\ta[c]=b;\\n\\t\\t\\tc++;\\n\\t\\t}\\n\\t\\treturn a;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int[] singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        for(int i:nums){\\n             if(set.add(i)==false)\\n             set.remove(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1100478,
                "title": "java-solution-1-ms-100-in-o-1-space-easy-explanation",
                "content": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n            MOST IMPORTANT PROPERTY FOR THIS QUESTION IS \\n                XOR OF 2 SAME NUMBERS IS 0\\n                FOR EXAMPLE: A = 5, B = 5\\n                A^B = 101 ^ 101 = 0\\n        \\n        */\\n        // sample test case [1,2,1,3,2,5]\\n        int n = nums.length;\\n        int xor = 0;\\n        // duplicates will be eliminated and only xor of 2 unique number (lets say A and B) will be left, i.e.: A^B\\n        // for example test case A^B = 6\\n        for(int i=0;i<n;i++){\\n            xor ^= nums[i];\\n        }\\n        // 3 in binary is 011\\n        // 5 in binary is 101\\n        // 3^5 is 6 and in binary it is 110\\n        // Notice we are getting unique set bits from both numbers \\n        // Now use that unique set bit and find all the numbers with that unique set bit\\n        int pos = 0;\\n        int temp = xor;\\n        // decrease the A^B (stored in temp) by shifting right till we find set bit\\n        // for sample test case pos will be 1\\n        while((temp&1)!=1){\\n            pos++;\\n            temp = temp>>1;\\n        }\\n        // create a mask and use & operator to find numbers with set bits at that position\\n        // for sample test case our mask will be 010\\n        int mask = 1<<pos;\\n        int a = 0;\\n        // iterate array with mask and you will get the unique number as xor of duplicate number will be 0 \\n        for(int i=0;i<n;i++){\\n            if((nums[i]&mask)>0){\\n                a = (nums[i]^a);\\n            }\\n        }\\n        // if you xor with the a you will get the second number\\n        int b = xor ^ a;\\n        int[] res = new int[2];\\n        res[0]=a;\\n        res[1]=b;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n            MOST IMPORTANT PROPERTY FOR THIS QUESTION IS \\n                XOR OF 2 SAME NUMBERS IS 0\\n                FOR EXAMPLE: A = 5, B = 5\\n                A^B = 101 ^ 101 = 0\\n        \\n        */\\n        // sample test case [1,2,1,3,2,5]\\n        int n = nums.length;\\n        int xor = 0;\\n        // duplicates will be eliminated and only xor of 2 unique number (lets say A and B) will be left, i.e.: A^B\\n        // for example test case A^B = 6\\n        for(int i=0;i<n;i++){\\n            xor ^= nums[i];\\n        }\\n        // 3 in binary is 011\\n        // 5 in binary is 101\\n        // 3^5 is 6 and in binary it is 110\\n        // Notice we are getting unique set bits from both numbers \\n        // Now use that unique set bit and find all the numbers with that unique set bit\\n        int pos = 0;\\n        int temp = xor;\\n        // decrease the A^B (stored in temp) by shifting right till we find set bit\\n        // for sample test case pos will be 1\\n        while((temp&1)!=1){\\n            pos++;\\n            temp = temp>>1;\\n        }\\n        // create a mask and use & operator to find numbers with set bits at that position\\n        // for sample test case our mask will be 010\\n        int mask = 1<<pos;\\n        int a = 0;\\n        // iterate array with mask and you will get the unique number as xor of duplicate number will be 0 \\n        for(int i=0;i<n;i++){\\n            if((nums[i]&mask)>0){\\n                a = (nums[i]^a);\\n            }\\n        }\\n        // if you xor with the a you will get the second number\\n        int b = xor ^ a;\\n        int[] res = new int[2];\\n        res[0]=a;\\n        res[1]=b;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628260,
                "title": "python-o-1-aux-space-by-xor-and-masking-90-w-comment",
                "content": "Python O(1) aux space by XOR and masking 90%\\n\\n---\\n\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        xor = lambda x,y : x^y\\n        \\n        xor_result = reduce( xor, nums)\\n        \\n        # mask is the right-most 1 of xor result\\n        # use mask to separate nums into two groups, one group contains single_num_a, the other contains single_num_b\\n        mask = xor_result & -xor_result\\n        \\n        single_num_a, single_num_b = 0, 0\\n        \\n        for number in nums:\\n            # separate and collect these two single numbers by masking\\n            \\n            if mask&number:\\n                single_num_a ^= number\\n            else:\\n                single_num_b ^= number\\n                \\n        return [single_num_a, single_num_b]\\n\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #136 Single Number](https://leetcode.com/problems/single-number/)\\n\\n[Leetcode #137 Single Number II](https://leetcode.com/problems/single-number-ii/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        xor = lambda x,y : x^y\\n        \\n        xor_result = reduce( xor, nums)\\n        \\n        # mask is the right-most 1 of xor result\\n        # use mask to separate nums into two groups, one group contains single_num_a, the other contains single_num_b\\n        mask = xor_result & -xor_result\\n        \\n        single_num_a, single_num_b = 0, 0\\n        \\n        for number in nums:\\n            # separate and collect these two single numbers by masking\\n            \\n            if mask&number:\\n                single_num_a ^= number\\n            else:\\n                single_num_b ^= number\\n                \\n        return [single_num_a, single_num_b]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69014,
                "title": "3-line-python-code",
                "content": "Ideas based on : [zhiqing_xiao's Solution][1]\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer[]}\\n        def singleNumber(self, nums):\\n            xor = reduce(operator.xor, nums)\\n            ans = reduce(operator.xor, filter(lambda x : x & xor & -xor, nums))\\n            return [ans, ans ^ xor]\\n\\nDetailed explanations : [leetcode-single-number-iii][2] in my blog (in Chinese)\\n\\n\\n  [1]: https://leetcode.com/discuss/52351/accepted-java-space-easy-solution-with-detail-explanations\\n  [2]: http://bookshadow.com/weblog/2015/08/17/leetcode-single-number-iii/",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3329805,
                "title": "simplest-solution-using-bit-manipulation-in-10-lines",
                "content": "# Intuition\\nWe can consider xor of all the elements of nums it will return bit xor of two single element let say xo.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow we can find the first set bit from LSB of xo.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i : nums)\\n        xo^=i;\\n        int pos = 0; \\n        while(xo)\\n        {\\n            if(xo & (1 << pos)) break;\\n            pos++;\\n        }\\n        xo = (1 << pos);\\n        vector<int> ans(2,0);\\n        for(auto i : nums)\\n        {\\n            if(xo & i) ans[0]^=i;\\n            else ans[1]^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i : nums)\\n        xo^=i;\\n        int pos = 0; \\n        while(xo)\\n        {\\n            if(xo & (1 << pos)) break;\\n            pos++;\\n        }\\n        xo = (1 << pos);\\n        vector<int> ans(2,0);\\n        for(auto i : nums)\\n        {\\n            if(xo & i) ans[0]^=i;\\n            else ans[1]^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828366,
                "title": "brute-force-with-dictnory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        dc=defaultdict(lambda:0)\\n        for a in(nums):\\n            dc[a]+=1\\n        ans=[]\\n        for a in dc:\\n            if(dc[a]==1):\\n                ans.append(a)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        dc=defaultdict(lambda:0)\\n        for a in(nums):\\n            dc[a]+=1\\n        ans=[]\\n        for a in dc:\\n            if(dc[a]==1):\\n                ans.append(a)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678091,
                "title": "c-bit-mask-xor-full-explanation",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x^=nums[i]; // will contain the xor of 2 single numbers\\n        }\\n        int cnt=0;\\n        while(x){\\n            if(x & 1)\\n                break;\\n            cnt++;\\n            x=x>>1; // left shifting by 1 till reach the last set bit\\n        }\\n        // cnt will contain the bit number of rightmost(1st) set bit\\n\\n        // it means a number must have that bit unset and other number as set\\n\\n        // now we will separate the 2 sets of array on the basis of above classification\\n\\n        // xor1 will contain xor of numbers with set bit\\n        // xor2 will contain xor of numbers with unset bit\\n\\n        \\n        /*\\n            \\n            nums = {2 1 2 5 1 4 4 7 3 3}\\n\\n            eg: 5 ^ 7 = 3 \\n                1 0 1\\n                1 1 1\\n                ------\\n            XOR = 0 1 0 => 3\\n            cnt = 1 ie 1st bit is set\\n            so now we will divide whole into 2 parts\\n\\n            1 5 1 3 3 | 2 2 7 4 4\\n\\n            instead of using an extra DS, we will keep XORing while iterating\\n                \\n        */\\n        int xor1=0,xor2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] & (1<<cnt)) \\n            // checking whether the cnt bit is set or not {bit mask = (1<<cnt)}\\n                xor1^=nums[i];\\n            else\\n                xor2^=nums[i];\\n        }\\n        vector<int> ans(2);\\n        ans[0]=xor1;\\n        ans[1]=xor2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            x^=nums[i]; // will contain the xor of 2 single numbers\\n        }\\n        int cnt=0;\\n        while(x){\\n            if(x & 1)\\n                break;\\n            cnt++;\\n            x=x>>1; // left shifting by 1 till reach the last set bit\\n        }\\n        // cnt will contain the bit number of rightmost(1st) set bit\\n\\n        // it means a number must have that bit unset and other number as set\\n\\n        // now we will separate the 2 sets of array on the basis of above classification\\n\\n        // xor1 will contain xor of numbers with set bit\\n        // xor2 will contain xor of numbers with unset bit\\n\\n        \\n        /*\\n            \\n            nums = {2 1 2 5 1 4 4 7 3 3}\\n\\n            eg: 5 ^ 7 = 3 \\n                1 0 1\\n                1 1 1\\n                ------\\n            XOR = 0 1 0 => 3\\n            cnt = 1 ie 1st bit is set\\n            so now we will divide whole into 2 parts\\n\\n            1 5 1 3 3 | 2 2 7 4 4\\n\\n            instead of using an extra DS, we will keep XORing while iterating\\n                \\n        */\\n        int xor1=0,xor2=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] & (1<<cnt)) \\n            // checking whether the cnt bit is set or not {bit mask = (1<<cnt)}\\n                xor1^=nums[i];\\n            else\\n                xor2^=nums[i];\\n        }\\n        vector<int> ans(2);\\n        ans[0]=xor1;\\n        ans[1]=xor2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544049,
                "title": "accepted-java-o-n-time-o-1-space-with-simple-explanation-and-comments",
                "content": "This question can easily solved using some simple bit manipulation in O(n) time and O(1) space.\\n\\nThe solution can be broken into the following parts:\\n\\n1) Firstly take a xor of all numbers in nums array, since xor of duplicate numbers is 0 therefore at the end we will be left with the xor of the two distinct numbers.\\n                                                       So we have  xor=a^b; where a and be are the distinct numbers to be found.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n2) Now we will have to divide the array nums in two groups such that a and b are in different groups,\\nthe reason behind this is that in these groups also all other elements will occur twice except for a and b then we can simply take xor in the respective groups and we will be left with the numbers.\\n\\n3) Now we have to find on what basis we can divide these groups.\\nWe know that there is atleast one set bit in xor because it is obviously not equal to zero.\\nWe find the last set bit which means there is a 0 at this position in a and a 1 in b. (xor of 0 and 1 is 1).\\n\\nThis becomes the basis of division and we can easily find the numbers with that particular bit as 0(will go in group 1 with a) and numbers with bit as 1(will go in group 2 with b).\\n\\nBelow is the Java code with Comments.\\n\\n```\\n\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor=0; // this will provide us the xor of the two distict numbers.\\n           for(int n:nums){\\n            xor=xor^n;\\n               }\\n\\n        int set_bit=0; // this finds the last set bit of xor.\\n        \\n        for(int i=0;i<32;i++){\\n            if((xor&(1<<i))!=0){\\n                set_bit=1<<i;\\n            }\\n        }\\n        \\n        int[] ans=new int[2];// to divide nums into two groups which will eventually contain the required         distinct numbers.\\n        \\n        for(int n:nums){\\n            if((n&set_bit)==0){\\n                ans[0]^=n;\\n            }else{\\n                ans[1]^=n;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor=0; // this will provide us the xor of the two distict numbers.\\n           for(int n:nums){\\n            xor=xor^n;\\n               }\\n\\n        int set_bit=0; // this finds the last set bit of xor.\\n        \\n        for(int i=0;i<32;i++){\\n            if((xor&(1<<i))!=0){\\n                set_bit=1<<i;\\n            }\\n        }\\n        \\n        int[] ans=new int[2];// to divide nums into two groups which will eventually contain the required         distinct numbers.\\n        \\n        for(int n:nums){\\n            if((n&set_bit)==0){\\n                ans[0]^=n;\\n            }else{\\n                ans[1]^=n;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563089,
                "title": "c-simple-and-clean-solution-explained",
                "content": "**Explanation:**\\nWe use a set to indicate which numbers we already saw.\\nIf the current number is already in the set, we remove it.\\nOtherwise, we add it.\\nBecause each number appears exactly once, at the end we will end up removing all the numbers that appear twice and will be left with the two numbers that appear only once.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        set<int> s;\\n        \\n        for (auto a : nums) {\\n            if (s.count(a)) s.erase(a);\\n            else s.insert(a);\\n        }\\n        \\n        return vector<int>(s.begin(), s.end());\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        set<int> s;\\n        \\n        for (auto a : nums) {\\n            if (s.count(a)) s.erase(a);\\n            else s.insert(a);\\n        }\\n        \\n        return vector<int>(s.begin(), s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250415,
                "title": "c-bit-manipulation-easily-understood-very-detailed-explanation",
                "content": "**Logic**:\\nHere the idea is to XOR every element in the array. As all other numbers appears exactly twice, when we XOR the entire array the resultant value will be the XOR of the numbers we need to return. Once we have the XOR, we need its operands. For this, we extract the lowest set bit in the result. If a bit is set after XOR operation, that means for the same bit position its operands might have different values. Divide the array based on this condition into two parts  and XOR both the parts separtely to find the two operands of XORed result which is our required final output.\\n\\n**Example**:\\nConsider case of [1,2,1,3,2,5]. For this set, \\nXOR of array = 6, which is XOR of 3,5.\\nExtracting lowest set bit and making all others zero for 6(110) gives: 2(010).\\nMaking two sets based on XOR result gives \\nSet 1 : [1,1,3]   All these elements have second lowest bit set to 0.\\nSet 2: [2,2,5]    All these elements have second lowest bit set to 1.\\n\\n\\n\\n**Time Complexity:**\\nO(n)\\n\\n**Space Complexity:**\\nConstant Space.\\n\\n**Code**:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long int temp_res=0;\\n\\t\\t// XOR the entire array.\\n        for(int i=0;i<nums.size();i++)\\n            temp_res^=nums[i];\\n        \\n\\t\\t// Extract the lowest set from the resultant value.\\n        int extracted_lsb=(temp_res)&(~(temp_res-1)); \\n        int res_a=0, res_b=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(extracted_lsb&nums[i])\\n\\t\\t\\t    // if bit at the position is set for num[i]. XOR it to find one value.\\n                res_a^=nums[i];\\n            else\\n\\t\\t\\t\\t// if bit at the position is unset for num[i]. XOR it to find another value.\\n                res_b^=nums[i];\\n        }\\n        vector<int> res_vec;\\n        res_vec.push_back(res_a);\\n        res_vec.push_back(res_b);\\n        return res_vec;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long int temp_res=0;\\n\\t\\t// XOR the entire array.\\n        for(int i=0;i<nums.size();i++)\\n            temp_res^=nums[i];\\n        \\n\\t\\t// Extract the lowest set from the resultant value.\\n        int extracted_lsb=(temp_res)&(~(temp_res-1)); \\n        int res_a=0, res_b=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(extracted_lsb&nums[i])\\n\\t\\t\\t    // if bit at the position is set for num[i]. XOR it to find one value.\\n                res_a^=nums[i];\\n            else\\n\\t\\t\\t\\t// if bit at the position is unset for num[i]. XOR it to find another value.\\n                res_b^=nums[i];\\n        }\\n        vector<int> res_vec;\\n        res_vec.push_back(res_a);\\n        res_vec.push_back(res_b);\\n        return res_vec;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786633,
                "title": "java-solution-with-explanation",
                "content": "\\n    public int[] singleNumber(int[] nums) {\\n       /**x ^ x =0\\n         0 ^ x = x\\nFirst, we will take xor of all the numbers in the nums array so that the resultant xor consits of xor of only those numbers which are only     occuring once in the nums array */\\n        //Pass 1\\n\\t\\t\\n        int sum =0;\\n        for(int i: nums){\\n            sum ^=i;\\n        }\\n\\t\\t\\n        /** Truth table of XOR\\n          0 ^ 0 = 0\\n          0 ^ 1 = 1\\n          1 ^ 0 = 1\\n          1 ^ 1 = 0\\n  So the xor of two bit is 1 when they are distinctive. So now we want to capture the least significant set bit in \"sum\" because at that bit the the two distinctive numbers(in the given array) are not same(that is why the xor is coming out to be set at that bit); hence we will take the 2\\'s compliment of \"sum\" and will perform & opertor to get the least significant set bit.\\nPerforming & operation after taking 2\\'s compliment of the same number always gives the least signifacnt set for that number(for both positive and negative numbers).\\n          */\\n\\t\\t  \\n        sum &= -sum;\\n        \\n        //Pass 2\\n        int[] res = new int[2];\\n        for(int i: nums){\\n            if((i & sum) == 0){ // the bit is not set\\n                res[0] ^= i; // we are taking xor so that we only get the distinctive number\\n            }\\n            else{ // the bit is set\\n                res[1] ^=i;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] singleNumber(int[] nums) {\\n       /**x ^ x =0\\n         0 ^ x = x\\nFirst, we will take xor of all the numbers in the nums array so that the resultant xor consits of xor of only those numbers which are only     occuring once in the nums array */\\n        //Pass 1\\n\\t\\t\\n        int sum =0;\\n        for(int i: nums){\\n            sum ^=i;\\n        }\\n\\t\\t\\n        /** Truth table of XOR\\n          0 ^ 0 = 0\\n          0 ^ 1 = 1\\n          1 ^ 0 = 1\\n          1 ^ 1 = 0\\n  So the xor of two bit is 1 when they are distinctive. So now we want to capture the least significant set bit in \"sum\" because at that bit the the two distinctive numbers(in the given array) are not same(that is why the xor is coming out to be set at that bit); hence we will take the 2\\'s compliment of \"sum\" and will perform & opertor to get the least significant set bit.\\nPerforming & operation after taking 2\\'s compliment of the same number always gives the least signifacnt set for that number(for both positive and negative numbers).\\n          */\\n\\t\\t  \\n        sum &= -sum;\\n        \\n        //Pass 2\\n        int[] res = new int[2];\\n        for(int i: nums){\\n            if((i & sum) == 0){ // the bit is not set\\n                res[0] ^= i; // we are taking xor so that we only get the distinctive number\\n            }\\n            else{ // the bit is set\\n                res[1] ^=i;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 510258,
                "title": "python-o-n-runtime-and-o-1-space-complexity-with-explanation",
                "content": "\\nALGORITHM:\\n1. Suppose that a and b are the numbers that occur once. \\n2. XOR all numbers. Because all other numbers occur twice, XOR-ing them will \\n   cancel them out. We are left with XOR of a and b.\\n3. Find the right most set bit in this xor. That means, starting from right, \\n   this is the first bit that is different in a and b. all other but in the \\n   right are same. \\n4. Create a mask, with only this bit set and all other bits being 0. \\n5. Maintain 2 variables a and b to get the 2 single numbers. \\n5. Iterate over all numbers in nums again. BITWISE AND the mask and each \\n   number. If num & mark == 0, XOR num with a else XOR num with b\\n6. After this iteration a and b will contain the two single occuring nums. \\n7. Return [a, b]\\n\\nRUNTIME COMPLEXITY: O(N)\\nSPACE COMPLEXITY: O(1)\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        xor = 0\\n        for n in nums:\\n            xor ^= n\\n        \\n        mask = 1\\n        while True:\\n            if xor & mask == 0:\\n                mask = mask << 1\\n            else:\\n                break\\n        \\n        a, b = 0, 0\\n        for n in nums:\\n            if n & mask == 0:\\n                a ^= n\\n            else:\\n                b ^= n\\n        return [a,b]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        xor = 0\\n        for n in nums:\\n            xor ^= n\\n        \\n        mask = 1\\n        while True:\\n            if xor & mask == 0:\\n                mask = mask << 1\\n            else:\\n                break\\n        \\n        a, b = 0, 0\\n        for n in nums:\\n            if n & mask == 0:\\n                a ^= n\\n            else:\\n                b ^= n\\n        return [a,b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238812,
                "title": "2-python-solution-o-n-space-and-o-1-space",
                "content": "```python\\nclass Solution:\\n    def singleNumber(self, nums: \\'List[int]\\') -> \\'List[int]\\':\\n        # return [_[0] for _ in collections.Counter(nums).items() if _[1] == 1]\\n        \\n        xor = 0\\n        for i in nums:\\n            xor ^= i\\n        xor &= -xor # get the last 1 of xor: 10101000 -> 1000\\n        a, b = 0, 0\\n        for i in nums: # devide the numbers into two parts, and a, b should be divided into different part\\n            if i & xor: a ^= i\\n            else: b ^= i\\n        return [a, b]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums: \\'List[int]\\') -> \\'List[int]\\':\\n        # return [_[0] for _ in collections.Counter(nums).items() if _[1] == 1]\\n        \\n        xor = 0\\n        for i in nums:\\n            xor ^= i\\n        xor &= -xor # get the last 1 of xor: 10101000 -> 1000\\n        a, b = 0, 0\\n        for i in nums: # devide the numbers into two parts, and a, b should be divided into different part\\n            if i & xor: a ^= i\\n            else: b ^= i\\n        return [a, b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68899,
                "title": "6-lines-python",
                "content": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        diff = reduce(lambda x, y: x ^ y, nums, 0) # Get the XOR of the two unique elements.\\n        diff &= -diff # Find the last set bit.\\n        res = [0, 0]\\n        for num in nums:\\n            res[num & diff == 0] ^= num\\n        return res\\n```\\n\\n*By Yangshun*",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        diff = reduce(lambda x, y: x ^ y, nums, 0) # Get the XOR of the two unique elements.\\n        diff &= -diff # Find the last set bit.\\n        res = [0, 0]\\n        for num in nums:\\n            res[num & diff == 0] ^= num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68903,
                "title": "can-i-use-chinese-to-explain-the-problem",
                "content": "\\u73b0\\u5728\\u6570\\u7ec4\\u4e2d\\u6709\\u4e24\\u4e2a\\u6570\\u5b57\\u53ea\\u51fa\\u73b01\\u6b21\\uff0c\\u76f4\\u63a5\\u5f02\\u6216\\u4e00\\u6b21\\u53ea\\u80fd\\u5f97\\u5230\\u8fd9\\u4e24\\u4e2a\\u6570\\u5b57\\u7684\\u5f02\\u6216\\u7ed3\\u679c\\uff0c\\u4f46\\u5149\\u4ece\\u8fd9\\u4e2a\\u7ed3\\u679c\\u80af\\u5b9a\\u65e0\\u6cd5\\u5f97\\u5230\\u8fd9\\u4e2a\\u4e24\\u4e2a\\u6570\\u5b57\\u3002\\u56e0\\u6b64\\u6211\\u4eec\\u6765\\u5206\\u6790\\u4e0b\\u7b80\\u5316\\u7248\\u4e2d\\u201c\\u5f02\\u6216\\u201d\\u89e3\\u6cd5\\u7684\\u5173\\u952e\\u70b9\\uff0c\\u8fd9\\u4e2a\\u5173\\u952e\\u70b9\\u4e5f\\u76f8\\u5f53\\u660e\\u663e\\u2014\\u2014\\u6570\\u7ec4\\u53ea\\u80fd\\u6709\\u4e00\\u4e2a\\u6570\\u5b57\\u51fa\\u73b01\\u6b21\\u3002\\n\\n**\\u8bbe\\u9898\\u76ee\\u4e2d\\u8fd9\\u4e24\\u4e2a\\u53ea\\u51fa\\u73b01\\u6b21\\u7684\\u6570\\u5b57\\u5206\\u522b\\u4e3aA\\u548cB\\uff0c\\u5982\\u679c\\u80fd\\u5c06A\\uff0cB\\u5206\\u5f00\\u5230\\u4e8c\\u4e2a\\u6570\\u7ec4\\u4e2d\\uff0c\\u90a3\\u663e\\u7136\\u7b26\\u5408\\u201c\\u5f02\\u6216\\u201d\\u89e3\\u6cd5\\u7684\\u5173\\u952e\\u70b9\\u4e86**\\u3002\\u56e0\\u6b64\\u8fd9\\u4e2a\\u9898\\u76ee\\u7684\\u5173\\u952e\\u70b9\\u5c31\\u662f\\u5c06A\\uff0cB\\u5206\\u5f00\\u5230\\u4e8c\\u4e2a\\u6570\\u7ec4\\u4e2d\\u3002\\u7531\\u4e8eA\\uff0cB\\u80af\\u5b9a\\u662f\\u4e0d\\u76f8\\u7b49\\u7684\\uff0c\\u56e0\\u6b64\\u5728\\u4e8c\\u8fdb\\u5236\\u4e0a\\u5fc5\\u5b9a\\u6709\\u4e00\\u4f4d\\u662f\\u4e0d\\u540c\\u7684\\u3002**\\u6839\\u636e\\u8fd9\\u4e00\\u4f4d\\u662f0\\u8fd8\\u662f1\\u53ef\\u4ee5\\u5c06A\\uff0cB\\u5206\\u5f00\\u5230A\\u7ec4\\u548cB\\u7ec4**\\u3002\\u800c\\u8fd9\\u4e2a\\u6570\\u7ec4\\u4e2d\\u5176\\u5b83\\u6570\\u5b57\\u8981\\u4e48\\u5c31\\u5c5e\\u4e8eA\\u7ec4\\uff0c\\u8981\\u4e48\\u5c31\\u5c5e\\u4e8eB\\u7ec4\\u3002\\u518d\\u5bf9A\\u7ec4\\u548cB\\u7ec4\\u5206\\u522b\\u6267\\u884c\\u201c\\u5f02\\u6216\\u201d\\u89e3\\u6cd5\\u5c31\\u53ef\\u4ee5\\u5f97\\u5230A\\uff0cB\\u4e86\\u3002\\u800c\\u8981\\u5224\\u65adA\\uff0cB\\u5728\\u54ea\\u4e00\\u4f4d\\u4e0a\\u4e0d\\u76f8\\u540c\\uff0c\\u53ea\\u8981\\u6839\\u636eA\\u5f02\\u6216B\\u7684\\u7ed3\\u679c\\u5c31\\u53ef\\u4ee5\\u77e5\\u9053\\u4e86\\uff0c\\u8fd9\\u4e2a\\u7ed3\\u679c\\u5728\\u4e8c\\u8fdb\\u5236\\u4e0a\\u4e3a1\\u7684\\u4f4d\\u5c31\\u8bf4\\u660eA\\uff0cB\\u5728\\u8fd9\\u4e00\\u4f4d\\u4e0a\\u662f\\u4e0d\\u76f8\\u540c\\u7684\\u3002\\n\\n\\u6bd4\\u5982\\n\\n```\\nint a[] = {1, 1, 3, 5, 2, 2}\\n```\\n\\u6574\\u4e2a\\u6570\\u7ec4\\u5f02\\u6216\\u7684\\u7ed3\\u679c\\u4e3a3^5\\uff0c\\u5373 **0x0011 ^ 0x0101 = 0x0110**\\n\\n\\u5bf90x0110\\uff0c\\u7b2c1\\u4f4d\\uff08\\u7531\\u4f4e\\u5411\\u9ad8\\uff0c\\u4ece0\\u5f00\\u59cb\\uff09\\u5c31\\u662f1\\u3002\\u56e0\\u6b64\\u6574\\u4e2a\\u6570\\u7ec4\\u6839\\u636e\\u7b2c1\\u4f4d\\u662f0\\u8fd8\\u662f1\\u5206\\u6210\\u4e24\\u7ec4\\u3002\\n\\n    a[0] =1  0x0001  \\u7b2c\\u4e00\\u7ec4\\n\\n    a[1] =1  0x0001  \\u7b2c\\u4e00\\u7ec4\\n\\n    a[2] =3  0x0011  \\u7b2c\\u4e8c\\u7ec4\\n\\n    a[3] =5  0x0101  \\u7b2c\\u4e00\\u7ec4\\n\\n    a[4] =2  0x0010  \\u7b2c\\u4e8c\\u7ec4\\n\\n    a[5] =2  0x0010  \\u7b2c\\u4e8c\\u7ec4\\n\\n\\u7b2c\\u4e00\\u7ec4\\u6709{1,1,5}\\uff0c\\u7b2c\\u4e8c\\u7ec4\\u6709{3,2,3}\\uff0c\\u7136\\u540e\\u5bf9\\u8fd9\\u4e8c\\u7ec4\\u5206\\u522b\\u6267\\u884c\\u201c\\u5f02\\u6216\\u201d\\u89e3\\u6cd5\\u5c31\\u53ef\\u4ee5\\u5f97\\u52305\\u548c3\\u4e86\\u3002",
                "solutionTags": [],
                "code": "```\\nint a[] = {1, 1, 3, 5, 2, 2}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68907,
                "title": "naive-python",
                "content": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        one = set()\\n        double = set()\\n        for n in nums:\\n            if n not in one:\\n                one.add(n)\\n            else:\\n                double.add(n)\\n                \\n        return list(one - double)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        one = set()\\n        double = set()\\n        for n in nums:\\n            if n not in one:\\n                one.add(n)\\n            else:\\n                double.add(n)\\n                \\n        return list(one - double)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68970,
                "title": "easiest-java-solution",
                "content": "      public int[] singleNumber(int[] nums) {\\n        int A = 0;  \\n        int B = 0;  \\n        int AXORB = 0;  \\n        for(int i = 0; i<nums.length; i++){  \\n            AXORB ^= nums[i];  \\n        }  \\n          \\n        AXORB = (AXORB & (AXORB - 1)) ^ AXORB; //find the different bit  in A and B\\n        for(int i = 0; i<nums.length; i++){  \\n            if((AXORB & nums[i]) == 0)  \\n                A ^= nums[i];  \\n            else  \\n                B ^= nums[i];  \\n        }  \\n        return new int[]{A, B};  \\n    }",
                "solutionTags": [],
                "code": "      public int[] singleNumber(int[] nums) {\\n        int A = 0;  \\n        int B = 0;  \\n        int AXORB = 0;  \\n        for(int i = 0; i<nums.length; i++){  \\n            AXORB ^= nums[i];  \\n        }  \\n          \\n        AXORB = (AXORB & (AXORB - 1)) ^ AXORB; //find the different bit  in A and B\\n        for(int i = 0; i<nums.length; i++){  \\n            if((AXORB & nums[i]) == 0)  \\n                A ^= nums[i];  \\n            else  \\n                B ^= nums[i];  \\n        }  \\n        return new int[]{A, B};  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68988,
                "title": "python-solution-with-comments",
                "content": "        \\n    # O(n) space, O(n) time\\n    def singleNumber1(self, nums):\\n        dic, res = {}, []\\n        for num in nums:\\n            dic[num] = dic.get(num, 0) + 1\\n        for k, v in dic.items():\\n            if v == 1:\\n                res.append(k)\\n        return res\\n        \\n    # Bit manipulation, O(1) space, O(n) time\\n    def singleNumber(self, nums):\\n        # \"xor\" all the nums \\n        tmp = 0\\n        for num in nums:\\n            tmp ^= num\\n        # find the rightmost \"1\" bit\\n        i = 0\\n        while tmp & 1 == 0:\\n            tmp >>= 1\\n            i += 1\\n        tmp = 1 << i\\n        # compute in two seperate groups\\n        first, second = 0, 0\\n        for num in nums:\\n            if num & tmp:\\n                first ^= num\\n            else:\\n                second ^= num\\n        return [first, second]",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "        \\n    # O(n) space, O(n) time\\n    def singleNumber1(self, nums):\\n        dic, res = {}, []\\n        for num in nums:\\n            dic[num] = dic.get(num, 0) + 1\\n        for k, v in dic.items():\\n            if v == 1:\\n                res.append(k)\\n        return res\\n        \\n    # Bit manipulation, O(1) space, O(n) time\\n    def singleNumber(self, nums):\\n        # \"xor\" all the nums \\n        tmp = 0\\n        for num in nums:\\n            tmp ^= num\\n        # find the rightmost \"1\" bit\\n        i = 0\\n        while tmp & 1 == 0:\\n            tmp >>= 1\\n            i += 1\\n        tmp = 1 << i\\n        # compute in two seperate groups\\n        first, second = 0, 0\\n        for num in nums:\\n            if num & tmp:\\n                first ^= num\\n            else:\\n                second ^= num\\n        return [first, second]",
                "codeTag": "Python3"
            },
            {
                "id": 69016,
                "title": "python-solution",
                "content": "    def singleNumber(self, nums):\\n        ab = m = reduce(operator.xor, nums)  # a ^ b\\n        m &= -m  # bit hack, isolate the rightmost 1-bit\\n        a = reduce(operator.xor, (n for n in nums if n & m))\\n        return [a, ab ^ a]  # if a & m then not b & m",
                "solutionTags": [],
                "code": "    def singleNumber(self, nums):\\n        ab = m = reduce(operator.xor, nums)  # a ^ b\\n        m &= -m  # bit hack, isolate the rightmost 1-bit\\n        a = reduce(operator.xor, (n for n in nums if n & m))\\n        return [a, ab ^ a]  # if a & m then not b & m",
                "codeTag": "Python3"
            },
            {
                "id": 3632227,
                "title": "bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x = 0;\\n        for(int i : nums) {\\n            x ^= i;\\n        }\\n\\n        int cnt = 0;\\n        while(x) {\\n            if(x & 1) {\\n                break;\\n            }\\n            cnt++;\\n            x >>= 1;\\n        }\\n\\n        int a = 0, b = 0;\\n        for(int i : nums) {\\n            if(i & (1 << cnt)) {\\n                a ^= i;\\n            }\\n            else {\\n                b ^= i;\\n            }\\n        }\\n\\n        return {a, b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x = 0;\\n        for(int i : nums) {\\n            x ^= i;\\n        }\\n\\n        int cnt = 0;\\n        while(x) {\\n            if(x & 1) {\\n                break;\\n            }\\n            cnt++;\\n            x >>= 1;\\n        }\\n\\n        int a = 0, b = 0;\\n        for(int i : nums) {\\n            if(i & (1 << cnt)) {\\n                a ^= i;\\n            }\\n            else {\\n                b ^= i;\\n            }\\n        }\\n\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511239,
                "title": "o-1-o-1-java-standard-solution-with-proper-comments",
                "content": "# Algorithm\\n\\n1. Initialize a variable \\'xor\\' to 0.\\n2. Loop through the given array \\'nums\\' and for each element \\'num\\', perform a bitwise XOR operation with \\'xor\\'.\\n3. \\'xor\\' now holds the XOR of the two distinct elements that appear only once in the array.\\n4. Find the least significant bit where the two distinct elements differ, and store its position in a variable \\'pos\\'.\\n5. Initialize two variables \\'a\\' and \\'b\\' to 0.\\n6. Loop through \\'nums\\' again and for each element \\'num\\', check if the bit at position \\'pos\\' is set (i.e., equal to 1) using a bitwise AND operation with (1<<pos).\\n7. If the bit is set, perform a bitwise XOR operation with \\'a\\', else perform a bitwise XOR operation with \\'b\\'.\\n8. \\'a\\' and \\'b\\' now hold the two distinct elements that appear only once in the array.\\n9. Return an array containing \\'a\\' and \\'b\\'.\\n# Code\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        // Initialize variable \\'xor\\' to 0.\\n        int xor = 0;\\n        \\n        // Loop through the given array \\'nums\\' and perform a bitwise XOR operation with \\'xor\\' for each element.\\n        for(int i = 0; i<nums.length; i++){\\n            xor ^= nums[i];\\n        }\\n        \\n        // Find the least significant bit where the two distinct elements differ, and store its position in \\'pos\\'.\\n        int pos = 0;\\n        for(int i = 0; i<32; i++){\\n            if((xor&(1<<i))!=0){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        \\n        // Initialize variables \\'a\\' and \\'b\\' to 0.\\n        int a = 0, b = 0;\\n        \\n        // Loop through \\'nums\\' again and perform a bitwise XOR operation with \\'a\\' or \\'b\\' depending on the bit at position \\'pos\\'.\\n        for(int i = 0; i<nums.length; i++){\\n            if((nums[i]&(1<<pos))!=0) {\\n                a ^= nums[i];\\n            } else {\\n                b ^= nums[i];\\n            }\\n        }\\n        \\n        // Return an array containing \\'a\\' and \\'b\\'.\\n        return new int[]{a,b};\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        // Initialize variable \\'xor\\' to 0.\\n        int xor = 0;\\n        \\n        // Loop through the given array \\'nums\\' and perform a bitwise XOR operation with \\'xor\\' for each element.\\n        for(int i = 0; i<nums.length; i++){\\n            xor ^= nums[i];\\n        }\\n        \\n        // Find the least significant bit where the two distinct elements differ, and store its position in \\'pos\\'.\\n        int pos = 0;\\n        for(int i = 0; i<32; i++){\\n            if((xor&(1<<i))!=0){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        \\n        // Initialize variables \\'a\\' and \\'b\\' to 0.\\n        int a = 0, b = 0;\\n        \\n        // Loop through \\'nums\\' again and perform a bitwise XOR operation with \\'a\\' or \\'b\\' depending on the bit at position \\'pos\\'.\\n        for(int i = 0; i<nums.length; i++){\\n            if((nums[i]&(1<<pos))!=0) {\\n                a ^= nums[i];\\n            } else {\\n                b ^= nums[i];\\n            }\\n        }\\n        \\n        // Return an array containing \\'a\\' and \\'b\\'.\\n        return new int[]{a,b};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158583,
                "title": "c-solution-using-unordered-map-easy-to-understand-and-implement",
                "content": "# Flow of Code\\n1. Pushing the vector elements to unordered map. \\n2. Traverse the map and pushing back the vector elements having their count = 1 to another vector A.\\n3. Returning the vector A as the Result.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        vector<int> A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A.push_back(i.first);\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> M;\\n        for(auto n:nums)\\n            M[n]++;\\n        vector<int> A;\\n        for(auto i:M){\\n            if(i.second==1)\\n                A.push_back(i.first);\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474778,
                "title": "single-number-iii",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> List[int]:\\n        setNum = set()\\n        for num in nums:\\n            if num in setNum:\\n                setNum.remove(num)\\n            else:\\n                setNum.add(num)\\n        return setNum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> List[int]:\\n        setNum = set()\\n        for num in nums:\\n            if num in setNum:\\n                setNum.remove(num)\\n            else:\\n                setNum.add(num)\\n        return setNum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2101588,
                "title": "c-bit-manipulation-with-explained-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        //the idea is to first find the xor of every element..the final xor will represent the xor of two non repeating elements e.g 1 2 1 3 2 5 final xor will be 1 1 0 . Now 1 1 0 is the xor of 3 and 5 and also of every element as well. Now if we look into the right most 1 \\n        // 1 1 0\\n        //   ^  \\n        // this 1 represents that the two non repeating elements have either 0 or 1 at that position ..both of them cant have the same value at that point.\\n        //So if we find the right set bit mask of 1 1 0  i.e --> 0 1 0  \\n        // Now if we xor all the elements whose 2nd bit from right is 1 we will get the one non repeating number i.e 2^2^3=3\\n        //Simillarly if we xor all the elements with that bit as 0 we will get 1^1^5=5\\n        //so we have 3 and 5 as answers\\n        \\n       long long wholexor=0;\\n        for(auto val:nums){\\n            wholexor=wholexor^val;\\n        }\\n        \\n       long long rbsm = wholexor & (~wholexor +1);  //finding right bit set mask\\n        \\n        int x=0,y=0;\\n        \\n        for(auto val:nums){\\n            if((val&rbsm)==0){    //xor with all elements with set bit as 0\\n                x=x^val;\\n            }\\n            else{               //xor with all elements with set bit as 1\\n                y=y^val;\\n            }\\n        }\\n        \\n        return {x,y};\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        //the idea is to first find the xor of every element..the final xor will represent the xor of two non repeating elements e.g 1 2 1 3 2 5 final xor will be 1 1 0 . Now 1 1 0 is the xor of 3 and 5 and also of every element as well. Now if we look into the right most 1 \\n        // 1 1 0\\n        //   ^  \\n        // this 1 represents that the two non repeating elements have either 0 or 1 at that position ..both of them cant have the same value at that point.\\n        //So if we find the right set bit mask of 1 1 0  i.e --> 0 1 0  \\n        // Now if we xor all the elements whose 2nd bit from right is 1 we will get the one non repeating number i.e 2^2^3=3\\n        //Simillarly if we xor all the elements with that bit as 0 we will get 1^1^5=5\\n        //so we have 3 and 5 as answers\\n        \\n       long long wholexor=0;\\n        for(auto val:nums){\\n            wholexor=wholexor^val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1860103,
                "title": "accepted-c-o-n-99-faster-beginner-friendly-solution",
                "content": "**Concept**:\\n**Explaination with example :**\\nconsider a=[1,2,1,3,2,5]\\n\\n**Step 1** - Finding xor of all elements (i.e atlast xor variable will be xor of only two unique elements)\\n\\t\\t\\t```xor=1^2^1^3^2^5 =3^5 = 6 (0110)```\\n\\t\\t\\t\\n**Step 2** - Then we will look for rightmost set index in xor \\n\\t\\t\\t(logic is if rightmost bit on that index is 1, means one of unique element must be 1 and other must be 0 on             that same index)\\n\\t\\t\\t```idx=1``` (from right and 0 indexed)\\n\\n**Step 3** - Now, setting bit mask by\\n            ```mask = 1<<idx = 0010```\\n\\t\\t\\t( So that, we will look for array elements that has bit==1 at that idx)\\n\\t\\t\\t\\n**Step 4** - Now, by taking the xorr of only elements that has bit at that idx 1...we can find 1st unique element (store in n1)\\n\\n**Step 5** -  And other element will be \\n```xor^n1```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int xorr{}; \\n        int n1{};\\n        int idx{};\\n        \\n        for(auto& it:nums)     // calculating xor of all elements.\\n            xorr^=it;\\n        \\n        int tmp=xorr;   \\n        while(1)         //finding rightmost set bit idx\\n            if(tmp & 1)\\n                break;\\n            else{\\n                tmp>>=1;\\n                ++idx;\\n            }\\n        \\n        int mask=1<<idx;   \\n\\t\\t\\tfor(auto& it:nums) //taking xox of elements that has bit 1 at that idx\\n            if(it & mask)\\n                n1^=it;  \\n\\n         return vector<int>{xorr^n1,n1};\\n    }\\n};\\n```\\n\\nHope it helps.\\nPlease upvote if u find it helpful.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```xor=1^2^1^3^2^5 =3^5 = 6 (0110)```\n```idx=1```\n```mask = 1<<idx = 0010```\n```xor^n1```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int xorr{}; \\n        int n1{};\\n        int idx{};\\n        \\n        for(auto& it:nums)     // calculating xor of all elements.\\n            xorr^=it;\\n        \\n        int tmp=xorr;   \\n        while(1)         //finding rightmost set bit idx\\n            if(tmp & 1)\\n                break;\\n            else{\\n                tmp>>=1;\\n                ++idx;\\n            }\\n        \\n        int mask=1<<idx;   \\n\\t\\t\\tfor(auto& it:nums) //taking xox of elements that has bit 1 at that idx\\n            if(it & mask)\\n                n1^=it;  \\n\\n         return vector<int>{xorr^n1,n1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562120,
                "title": "c-bit-manipulation-easy-to-understand-list-of-similar-questions-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        long long x=0;               //long long to avoid overflow\\n        \\n        for(auto i:nums)\\n            x^=i;                   // step 1 -> remove duplicates by xor all elements\\n              \\n        \\n        // now x will be the xor of the two single numbers\\n        // Observation of aXorB\\n        // 1) 0 in a place means both a and b had same digit in that place\\n        // 2) 1 in a place means a and b had different digit in that place, i.e one had 1, and other had 0 at that place\\n        \\n        //we can use fact 2 to seperate out the two values\\n        \\n        // idea -> first find a number which has 1 in the place x has\\n        \\n        // Eg -> let x = 0110\\n        // so we can pick any of 0100 and 0010\\n        \\n        long long sbit=x&(x-1);//gets us last set bit of x\\n        sbit^=x;//bit mask of last set bit of x.   e.g if x=1010 mask of x will be 0010\\n        \\n        // this is one of the numbers which could work of us\\n        \\n        // so for example let rightMostSetBit(sbit) = 0010\\n        // this can be used to make two partitions of array b1 and b2\\n        // b1 -> has 1 in the pos\\n        // b2 -> has 0 in the pos\\n        \\n        // the two numbers to find will be in seperate buckets (b) and also same numbers will be in same bucket\\n        // so if we just xor the values of two buckets we will get the two numbers we need\\n        \\n        int one=0,zero=0;\\n        for(auto i: nums)\\n        {\\n            if(i&sbit)\\n                one^=i;\\n            else\\n                zero^=i;\\n        }\\n        vector<int> v={one,zero};\\n        return v;\\n    }\\n};\\nSimilar questions:\\n\\n136. Single Number\\n137. Single Number II\\n461. Hamming Distance\\n477. Total Hamming Distance\\n191. Number of 1 Bits\\n268. Missing Number\\n\\n\\n\\n//Like if it helped you :)\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        long long x=0;               //long long to avoid overflow\\n        \\n        for(auto i:nums)\\n            x^=i;                   // step 1 -> remove duplicates by xor all elements\\n              \\n        \\n        // now x will be the xor of the two single numbers\\n        // Observation of aXorB\\n        // 1) 0 in a place means both a and b had same digit in that place\\n        // 2) 1 in a place means a and b had different digit in that place, i.e one had 1, and other had 0 at that place\\n        \\n        //we can use fact 2 to seperate out the two values\\n        \\n        // idea -> first find a number which has 1 in the place x has\\n        \\n        // Eg -> let x = 0110\\n        // so we can pick any of 0100 and 0010\\n        \\n        long long sbit=x&(x-1);//gets us last set bit of x\\n        sbit^=x;//bit mask of last set bit of x.   e.g if x=1010 mask of x will be 0010\\n        \\n        // this is one of the numbers which could work of us\\n        \\n        // so for example let rightMostSetBit(sbit) = 0010\\n        // this can be used to make two partitions of array b1 and b2\\n        // b1 -> has 1 in the pos\\n        // b2 -> has 0 in the pos\\n        \\n        // the two numbers to find will be in seperate buckets (b) and also same numbers will be in same bucket\\n        // so if we just xor the values of two buckets we will get the two numbers we need\\n        \\n        int one=0,zero=0;\\n        for(auto i: nums)\\n        {\\n            if(i&sbit)\\n                one^=i;\\n            else\\n                zero^=i;\\n        }\\n        vector<int> v={one,zero};\\n        return v;\\n    }\\n};\\nSimilar questions:\\n\\n136. Single Number\\n137. Single Number II\\n461. Hamming Distance\\n477. Total Hamming Distance\\n191. Number of 1 Bits\\n268. Missing Number\\n\\n\\n\\n//Like if it helped you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562067,
                "title": "rust-xor-other-bitwise-tricks-applied-explained",
                "content": "The \"XOR trick\" for finding a single non duplicated number in a list of other numbers that each have a duplicate is well known. This is done by XOR-ing all the numbers together; and magically, the single unique number will be the result of that operation. For instance, the result for `5 \\u2295 2 \\u2295 8 \\u2295 5 \\u2295 8` will be `2`.\\n\\nIn this problem, there are two unique numbers, and applying the trick will seem to fail because the result will be the XOR result of the two uniqe numbers; ie,  `5 \\u2295 2 \\u2295 8 \\u2295 5 \\u2295 8 \\u2295 7`  will yield `5`, which is what you get with `2 \\u2295 7`.\\n\\nIt first glance, there doesn\\'t seem to be anything we can do with this combined result because there are so many different combinations of other numbers that can produce `5` when XOR-ed. We need to exploit another trick, or property, of XOR results.\\n\\nThis other property of an XOR result is any binary `1` in the result tells us that one of the numbers it took to produce it has a `1` in that specific position, and the other one has a `0` at that same position. For instance, `5` is `0101` binary, with bit 2, the highest order bit, being a `1`. Looking at the two numbers to produce it we see, `7` is `0111` binary, and it has a `1` at bit 2; and  `2` is `0010` binary, and it has a `0` at bit 2. This is a hard rule. There is no way that both XOR-ed numbers will both have a `1` at any given bit position if there is a `1` in their XOR result at that same position.\\n\\nOne strategy we could use to flush out the two mystery numbers is to filter `nums` into two lists where we\\'re guaranteed that each mystery number winds up in a different list. Then we can apply the XOR trick to each of these lists to get each of the mystery numbers.  \\n\\nExploiting the above property, we can filter `nums` into two lists by taking the XOR result we got from XOR-ing `nums` and choosing one of the binary `1`s from it at any arbitrary position, then filter all the numbers that have a `1` in the same position into one list, and all the numbers that have a `0` at that position into the other. Then we could apply the XOR trick to each list separately to get each of the mystery numbers.\\n\\nAnother strategy would be to XOR `nums`, take its XOR result and pick an arbitrary `1`, then iterate again over `nums` while updating two separate variables, `n1` and `n2`.  If the current number of an iteration has a `1` at the chosen position, XOR it with `n1`. If the current number has a `0` at that position, XOR it with `n2`. After the loop completes, `n1` and `n2` will hold each of the mystery numbers.\\n\\nIn the code below, the line with `xor_all & -xor_all` applies another bitwise trick to get the lowest order binary `1` in the variable, `xor_all` (the XOR result of `nums`). For instance, `24 & -24` will produce `8` which is a single bit value (`0000_1000` binary); And `24` is `0001_1000` binary. We can see that the trick generated a bitmask for the lowest order bit of `24`. If you want a [comprehensive list of bitwise hacks, you can use this link as a reference](https://graphics.stanford.edu/~seander/bithacks.html).\\n\\n```rust\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {\\n        let xor_all = nums.iter()\\n                          .fold(0, |acm, &n| acm ^ n); // XOR all numbers together.\\n        let lo_bit  = xor_all & -xor_all;              // Get the value of the lowest order bit;\\n                                                       // this will be the bitmask for filtering.\\n        let mut n1  = 0;                               // The XOR accumulator vars.\\n        let mut n2  = 0;\\n        \\n        for n in nums {\\n            if n & lo_bit == 0 { n1 ^= n; }            // Apply mask and branch on\\n            else               { n2 ^= n; }            // selected bit in `lo_bit`.\\n        }\\n        vec![n1, n2]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {\\n        let xor_all = nums.iter()\\n                          .fold(0, |acm, &n| acm ^ n); // XOR all numbers together.\\n        let lo_bit  = xor_all & -xor_all;              // Get the value of the lowest order bit;\\n                                                       // this will be the bitmask for filtering.\\n        let mut n1  = 0;                               // The XOR accumulator vars.\\n        let mut n2  = 0;\\n        \\n        for n in nums {\\n            if n & lo_bit == 0 { n1 ^= n; }            // Apply mask and branch on\\n            else               { n2 ^= n; }            // selected bit in `lo_bit`.\\n        }\\n        vec![n1, n2]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338383,
                "title": "c-bitwise-solution-o-n",
                "content": "Runtime: 4 ms, faster than 99.46% of C++ online submissions for Single Number III.\\nMemory Usage: 9.9 MB, less than 73.99% of C++ online submissions for Single Number III.\\n\\n```\\nWe have to find the 2 unique number using XOR operation but need 2 pass.\\n1. First XOR all elements and we get the XOR of 2 unique elements. We can get the bit difference of 2 number\\nfrom the right most set bit of XOR number.\\n2. Then we can group the numbers based on the right most set bit of the XOR and all numbers have the set\\nbit will be in one group and others without set bit will be in another group and also the 2 unique numbers\\nwill be in the two other groups. Taking XOR of 2 different group will give us 2 unique numbers.\\n\\nExample : nums = [1,2,1,3,2,5], XOR = 6 (110), Setbit in position 1 and bit mask = 10\\nLeft group with Setbit => [2,3,2] => Left XOR = 2 ^ 3 ^ 2 = 3\\nRight group without Setbit => [1,1,5] => Right XOR = 1 ^ 1 ^ 5 = 5\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        // total XOR of nums array\\n        int txor = 0;\\n        for(int i=0;i<nums.size();i++)txor^=nums[i];\\n        \\n        // get bit mask of right most set bit of txor \\n        int mask = 1;\\n        while((txor&mask)==0)mask = mask<<1;\\n        \\n        // 2 unique numbers in nums array\\n        int a = 0; int b = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // right group without Setbit and their XOR \\n            if((nums[i]&mask)==0)a^=nums[i];\\n            \\n            // left group with Setbit and their XOR\\n            else b^=nums[i];\\n        }\\n        \\n        return {a,b};        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nWe have to find the 2 unique number using XOR operation but need 2 pass.\\n1. First XOR all elements and we get the XOR of 2 unique elements. We can get the bit difference of 2 number\\nfrom the right most set bit of XOR number.\\n2. Then we can group the numbers based on the right most set bit of the XOR and all numbers have the set\\nbit will be in one group and others without set bit will be in another group and also the 2 unique numbers\\nwill be in the two other groups. Taking XOR of 2 different group will give us 2 unique numbers.\\n\\nExample : nums = [1,2,1,3,2,5], XOR = 6 (110), Setbit in position 1 and bit mask = 10\\nLeft group with Setbit => [2,3,2] => Left XOR = 2 ^ 3 ^ 2 = 3\\nRight group without Setbit => [1,1,5] => Right XOR = 1 ^ 1 ^ 5 = 5\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        // total XOR of nums array\\n        int txor = 0;\\n        for(int i=0;i<nums.size();i++)txor^=nums[i];\\n        \\n        // get bit mask of right most set bit of txor \\n        int mask = 1;\\n        while((txor&mask)==0)mask = mask<<1;\\n        \\n        // 2 unique numbers in nums array\\n        int a = 0; int b = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // right group without Setbit and their XOR \\n            if((nums[i]&mask)==0)a^=nums[i];\\n            \\n            // left group with Setbit and their XOR\\n            else b^=nums[i];\\n        }\\n        \\n        return {a,b};        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169896,
                "title": "c-explained-faster-than-99-4",
                "content": "The idea in this problem is remember HOW we solved the previous problem! If we **xor** the **array** that has **one unique** elemnt then **we get it back**.\\nWhat if we had kind of **two** **subarrays** at which they have **one unqiue** element. but how?\\n1. Xoring the bigger array results in the two unique elements being xored `(x^y)`.\\n2. **x and y** **differ** at least in one bit(this **bit** has to be **1**).\\n3. Find the **right most bit** at which **x & y differs in**.\\n4. **Divide** the array **into two subarrays**, one that has **this bit is** set to **1** and the other is set to **0**.\\n5. **Xoring** the **first subarray** result in the **first number** and **xoring** the **second subarray** results in the **second number \\uD83E\\uDD73**\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int xorResult=0;\\n        for(int num:nums)\\n            xorResult^=num;\\n        //xorResult now has the two unique elements being xored (x^y)\\n        //If the xorResult was 001010[1]0, the right most 1 is the bit at which the two numbers differs in\\n\\t\\t//(1 in xor means the two numbers differs at this bit)\\n        int differentBit=1;\\n        while((differentBit&xorResult)==0)\\n            differentBit<<=1;\\n        //Divide the nums array into two groups, one that the numbers has the bit in it is set to 1 and the other to 0\\n        //Xoring the first group results in the first number\\n        //Xoring the second group results in the second number\\n        int firstGroupXor=0;\\n        int secondGroupXor=0;\\n        for(int num:nums)\\n            if(num&differentBit)\\n                firstGroupXor^=num;\\n            else\\n                secondGroupXor^=num;\\n\\n    return vector<int>{firstGroupXor,secondGroupXor};\\n    }\\n```\\nIf you **like** my explanations, **hit** the **Upvote**  button and If you **don\\'t**, **hit** the **Downvote** \\uD83D\\uDE06",
                "solutionTags": [],
                "code": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int xorResult=0;\\n        for(int num:nums)\\n            xorResult^=num;\\n        //xorResult now has the two unique elements being xored (x^y)\\n        //If the xorResult was 001010[1]0, the right most 1 is the bit at which the two numbers differs in\\n\\t\\t//(1 in xor means the two numbers differs at this bit)\\n        int differentBit=1;\\n        while((differentBit&xorResult)==0)\\n            differentBit<<=1;\\n        //Divide the nums array into two groups, one that the numbers has the bit in it is set to 1 and the other to 0\\n        //Xoring the first group results in the first number\\n        //Xoring the second group results in the second number\\n        int firstGroupXor=0;\\n        int secondGroupXor=0;\\n        for(int num:nums)\\n            if(num&differentBit)\\n                firstGroupXor^=num;\\n            else\\n                secondGroupXor^=num;\\n\\n    return vector<int>{firstGroupXor,secondGroupXor};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879744,
                "title": "beat-99-84-c-xor-with-explanation-o-n-time-o-1-space",
                "content": "**Explaination-**\\n1. A XOR A = 0\\n2. So if all numbers comes even times, then the XOR of that number is 0. We\\'ll be left with XOR of 2 numbers which appears exactly 1 time.\\n3. XOR of 2 numbers which not results in 0, means there are some set bits(bits with 1 value) eg. 10100 has 2 set bits.\\n4. Let\\'s say number occuring only once are 7 and 8, 7 XOR 8 = \\n     7 =  0111\\n\\t 8 = 1000\\nXOR = 1111\\n5. All the places where we have 1 in XOR, that means both the number have alternative bits, find the first set-bit (bit with value 1) so that if we XOR all the values again and the values which give 1 on XOR of that number put them in a different set, and rest in different set.\\neg.\\n    XOR = 1111 \\n\\tFirst set-bit is at position 0, from right, put all numbers in set-1 which have 0th bit as 1, and set-2 on 0th bit as 0.\\n6. now if you XOR the set-1 you will get 1 unique value, and same with set-2.\\n\\n*Feel free to ask if any doubts, I can use paper-and-pen to expain. *\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorr = 0, res1 = 0, res2 = 0;\\n        for(const int& x: nums) xorr ^= x;\\n        xorr = xorr & (~(xorr - 1));\\n        for(const int& x: nums){\\n            if(xorr & x) res1 ^= x;\\n            else res2 ^= x;\\n        }\\n        return {res1, res2};\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/564a99f7-7601-416b-9bd8-904936078a87_1601874374.9628615.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorr = 0, res1 = 0, res2 = 0;\\n        for(const int& x: nums) xorr ^= x;\\n        xorr = xorr & (~(xorr - 1));\\n        for(const int& x: nums){\\n            if(xorr & x) res1 ^= x;\\n            else res2 ^= x;\\n        }\\n        return {res1, res2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843171,
                "title": "simple-c-solution-o-1-space-bitwise-xor-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorAll = 0;\\n\\t\\t//Step 1 : find XOR of all numbers\\n        for(auto &num : nums)\\n            xorAll ^= num;\\n\\t\\t// Step 2 : find last set bit i.e., first bit at which both numbers differ (xth bit)\\n        int set = xorAll & (-xorAll);\\n        int first = 0, second = 0;\\n\\t\\t// Step 3 : XOR of all numbers having xth bit set = first and not set = second \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] & set) {\\n                first ^= nums[i];\\n            } else {\\n                second ^= nums[i];\\n            }\\n        }\\n        return {first, second};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorAll = 0;\\n\\t\\t//Step 1 : find XOR of all numbers\\n        for(auto &num : nums)\\n            xorAll ^= num;\\n\\t\\t// Step 2 : find last set bit i.e., first bit at which both numbers differ (xth bit)\\n        int set = xorAll & (-xorAll);\\n        int first = 0, second = 0;\\n\\t\\t// Step 3 : XOR of all numbers having xth bit set = first and not set = second \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] & set) {\\n                first ^= nums[i];\\n            } else {\\n                second ^= nums[i];\\n            }\\n        }\\n        return {first, second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751273,
                "title": "swift-simple-sweet-hash-table-bit-manipulation-solutions-with-complexity-and-explanation-100",
                "content": "# Approach 1: Using a hash table\\n**Time: O(n), Space: O(n)** where n is the count of nums\\nExplanation:\\nWe traverse over the array twice => Time: O(2n) = O(n)\\nWe use a hash table => Space: O(n)\\n```\\nfunc singleNumber(_ nums: [Int]) -> [Int] {\\n\\tvar dict = [Int : Int]()\\n\\tvar result = [Int]()\\n\\n\\tfor num in nums {\\n\\t\\tdict[num] = dict[num, default: 0] + 1\\n\\t}\\n\\n\\tfor num in nums {\\n\\t\\tif dict[num] == 1 { result.append(num) }\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n\\n\\n---\\n\\n# Approach 2: Bit manipulation\\nWe will do this in 3 steps:\\n**Step 1:** we XOR all elements in the array, and get the XOR (call it \"xorResult\") of the two numbers we need to find . Why? because XORing two duplicate numbers always results in 0.\\n\\n**Step 2:** Since the 2 numbers of the result are different, they will have some different bits. Interestingly, our \"xorResult\" contains the bit 1s (so called set bits) at where the two result numbers differ (refer to XOR truth table in case you need to refresh this). \\n\\nNow, we will try to find the right most set bit (call it \"rightMostSetBit\") by using a bit manipulation trick, explained [here](https://www.***.org/position-of-rightmost-set-bit/). Basically, the \"rightMostSetBit\" is the result of xorResult & -xorResult.\\n\\n**Step 3:** We have found the bit at which the 2 numbers are different (\"rightMostSetBit\"). All the numbers can be divided into two groups: \\n+ the 1st group consisting of all numbers whose bits at \"rightMostSetBit\" is 0, \\n+ the 2nd group consisting of all numbers whose bits at \"rightMostSetBit\" is 1.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number.\\n\\n*Again, the order is not important in this problem.*\\n\\n**Time: O(n), Space: O(1)**\\n```\\nfunc singleNumber(_ nums: [Int]) -> [Int] {\\n\\t// Step 1\\n\\tlet xorResult = nums.reduce(0, ^)\\n\\n\\t// Step 2\\n\\tlet rightMostSetBit = xorResult & -xorResult\\n\\n\\t// Step 3\\n\\tvar result = [0, 0]\\n\\tfor num in nums {\\n\\t\\tif num & rightMostSetBit == 0 {\\n\\t\\t\\tresult[0] ^= num\\n\\t\\t} else {\\n\\t\\t\\tresult[1] ^= num\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc singleNumber(_ nums: [Int]) -> [Int] {\\n\\tvar dict = [Int : Int]()\\n\\tvar result = [Int]()\\n\\n\\tfor num in nums {\\n\\t\\tdict[num] = dict[num, default: 0] + 1\\n\\t}\\n\\n\\tfor num in nums {\\n\\t\\tif dict[num] == 1 { result.append(num) }\\n\\t}\\n\\n\\treturn result\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> [Int] {\\n\\t// Step 1\\n\\tlet xorResult = nums.reduce(0, ^)\\n\\n\\t// Step 2\\n\\tlet rightMostSetBit = xorResult & -xorResult\\n\\n\\t// Step 3\\n\\tvar result = [0, 0]\\n\\tfor num in nums {\\n\\t\\tif num & rightMostSetBit == 0 {\\n\\t\\t\\tresult[0] ^= num\\n\\t\\t} else {\\n\\t\\t\\tresult[1] ^= num\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751249,
                "title": "javascript-clean-4-liners",
                "content": "```javascript\\nvar singleNumber = function(nums) {\\n    const sum = nums.reduce((acc, cur) => acc ^ cur, 0)\\n    const msb = sum.toString(2).length-1;\\n    const num1 = nums.filter(x => x >> msb & 1).reduce((acc, cur) => acc ^ cur, sum);\\n    return [num1, sum^num1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\nvar singleNumber = function(nums) {\\n    const sum = nums.reduce((acc, cur) => acc ^ cur, 0)\\n    const msb = sum.toString(2).length-1;\\n    const num1 = nums.filter(x => x >> msb & 1).reduce((acc, cur) => acc ^ cur, sum);\\n    return [num1, sum^num1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751008,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        f=0\\n        for i in set(nums):\\n            if nums.count(i)==1:\\n                f += 1 \\n                l.append(i)\\n            if f==2:\\n                return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        f=0\\n        for i in set(nums):\\n            if nums.count(i)==1:\\n                f += 1 \\n                l.append(i)\\n            if f==2:\\n                return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750513,
                "title": "c-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n  \\n        int totxor=0;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            totxor ^= nums[i];\\n\\n        int a=1;\\n\\n        for(int i = 1; i < 32; i++)\\n        {\\n            if((totxor & a) == a)break; //check the occurence of the first set bit in the \\'xor\\' value\\n            a <<= 1;\\n        }\\n\\n        int first=0;\\n        int second=0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if((nums[i] & a) == a) first ^= nums[i];\\n            else second ^= nums[i];\\n        }\\n\\n        return {first, second};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n  \\n        int totxor=0;\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            totxor ^= nums[i];\\n\\n        int a=1;\\n\\n        for(int i = 1; i < 32; i++)\\n        {\\n            if((totxor & a) == a)break; //check the occurence of the first set bit in the \\'xor\\' value\\n            a <<= 1;\\n        }\\n\\n        int first=0;\\n        int second=0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if((nums[i] & a) == a) first ^= nums[i];\\n            else second ^= nums[i];\\n        }\\n\\n        return {first, second};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423182,
                "title": "easy-xor-mask-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return {};\\n        int mask=0, group1=0, group2=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mask^=nums[i];\\n        }\\n        \\n        mask= mask & ~(mask-1);\\n        \\n        for(int i=0; i<n; i++){\\n            if((nums[i]&mask)==0)\\n                group1^=nums[i];\\n            else\\n                group2^=nums[i];\\n        }\\n        return {group1, group2};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 354583,
                "title": "python-o-n-time-o-1-space-with-examples",
                "content": "- bitwise XOR for all elements to get `a^b`\\n- find an arbitrary bit position `i` where `a` differs from `b` (here we find the smallest 1 bit)\\n- make a second pass on `nums` and if `num` has a 1 at `i` then `a ^= num`, else `b ^= num`\\n\\nThis will yield us a linear runtime T(n) = 2n + O(bit_length) = 2n + O(1) = O(n).\\nAnd a constant additional space complexity S(n) = 4\\\\*O(bit_length), because we store `aXORb`, `i`, `a`, `b`\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        aXORb = 0\\n        for num in nums:\\n            aXORb ^= num\\n            \\n        i = 0\\n        while i < aXORb.bit_length():\\n            # Find where aXORb is 1\\n            mask = (aXORb >> i) & 1\\n            if mask:\\n                break\\n            i += 1\\n\\t\\t\\n\\t\\ta, b = 0, 0\\n        for num in nums:\\n            if (num >> i) & 1:\\n                a ^= num\\n            else:\\n                b ^= num        \\n            \\n        # 0 0 0 0 0        B\\n        # 0 0 0 0 0        B\\n        # 1 1 1 1 0        B\\n        # 1 1 1 1 0        B\\n        # 1 0 0 0 0 (n1)   B\\n        # 0 0 0 0 1 (n2)   A\\n        \\n        # 1 0 0 0 1 (a^b)  \\n        #         ^\\n        \\n        \\n        # 0 0 0 0 1        A\\n        #           XOR\\n        # 0 0 0 0 1 (a)\\n        \\n        # 0 0 0 0 0        B\\n        # 0 0 0 0 0        B\\n        # 1 1 1 1 0        B\\n        # 1 1 1 1 0        B\\n        # 1 0 0 0 0        B\\n        #           XOR\\n        # 1 0 0 0 0 (b)\\n        \\n        \\n        ####################\\n        \\n        # 1 0 1 0 1 0      A\\n        # 0 1 0 1 0 1      B\\n        # 1 1 0 0 1 1 (n1) A\\n        # 1 1 1 1 1 1      A\\n        # 0 1 0 1 0 1      B\\n        # 1 0 1 0 1 0      A\\n        # 0 1 1 1 0 1 (n2) B\\n        # 1 1 1 1 1 1      A\\n        \\n        # 1 0 1 1 1 0 (a^b)\\n        #         ^\\n        # 1 0 1 0 1 0      A\\n        # 1 1 0 0 1 1      A\\n        # 1 1 1 1 1 1      A\\n        # 1 0 1 0 1 0      A\\n        # 1 1 1 1 1 1      A\\n        #             XOR\\n        # 1 1 0 0 1 1 (a)\\n        \\n        # 0 1 0 1 0 1      B\\n        # 0 1 0 1 0 1      B\\n        # 0 1 1 1 0 1      B\\n        #             XOR\\n        # 0 1 1 1 0 1 (b)\\n        \\n        # YAY!\\n        \\n        return {a, b}\\n        \\n        \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        aXORb = 0\\n        for num in nums:\\n            aXORb ^= num\\n            \\n        i = 0\\n        while i < aXORb.bit_length():\\n            # Find where aXORb is 1\\n            mask = (aXORb >> i) & 1\\n            if mask:\\n                break\\n            i += 1\\n\\t\\t\\n\\t\\ta, b = 0, 0\\n        for num in nums:\\n            if (num >> i) & 1:\\n                a ^= num\\n            else:\\n                b ^= num        \\n            \\n        # 0 0 0 0 0        B\\n        # 0 0 0 0 0        B\\n        # 1 1 1 1 0        B\\n        # 1 1 1 1 0        B\\n        # 1 0 0 0 0 (n1)   B\\n        # 0 0 0 0 1 (n2)   A\\n        \\n        # 1 0 0 0 1 (a^b)  \\n        #         ^\\n        \\n        \\n        # 0 0 0 0 1        A\\n        #           XOR\\n        # 0 0 0 0 1 (a)\\n        \\n        # 0 0 0 0 0        B\\n        # 0 0 0 0 0        B\\n        # 1 1 1 1 0        B\\n        # 1 1 1 1 0        B\\n        # 1 0 0 0 0        B\\n        #           XOR\\n        # 1 0 0 0 0 (b)\\n        \\n        \\n        ####################\\n        \\n        # 1 0 1 0 1 0      A\\n        # 0 1 0 1 0 1      B\\n        # 1 1 0 0 1 1 (n1) A\\n        # 1 1 1 1 1 1      A\\n        # 0 1 0 1 0 1      B\\n        # 1 0 1 0 1 0      A\\n        # 0 1 1 1 0 1 (n2) B\\n        # 1 1 1 1 1 1      A\\n        \\n        # 1 0 1 1 1 0 (a^b)\\n        #         ^\\n        # 1 0 1 0 1 0      A\\n        # 1 1 0 0 1 1      A\\n        # 1 1 1 1 1 1      A\\n        # 1 0 1 0 1 0      A\\n        # 1 1 1 1 1 1      A\\n        #             XOR\\n        # 1 1 0 0 1 1 (a)\\n        \\n        # 0 1 0 1 0 1      B\\n        # 0 1 0 1 0 1      B\\n        # 0 1 1 1 0 1      B\\n        #             XOR\\n        # 0 1 1 1 0 1 (b)\\n        \\n        # YAY!\\n        \\n        return {a, b}\\n        \\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 68943,
                "title": "examples-to-explain-the-xor-solution-and-bit-manipulation-trick",
                "content": "The concrete solution and explanation are showed on the most voted answers,now I wanna make an example to help to understand the trick more easily.\\nAssume we have the following array:\\n\\n* 0010\\n* 0010\\n* 0110\\n* 0110\\n* 0100\\n* 0001\\n\\nWe can see the last two numbers are unique,how can we find them?When we XOR all the numbers,it's the same as the result of XORing the last two numbers because duplicate numbers get zero in XOR operation.\\nHere we get 0101(stored in variable diff),which means we have two bit difference between number 0100 and 0001 at 1st and 3rd bit. So we can simply distinguish them by any bit difference.\\n\\nThe trick here is \\n```\\ndiff &=-diff\\n```\\nor more human-readable\\n```\\ndiff &=~(diff-1)\\n```\\nThe codes above both have the same aim:get the rightmost bit 1 of the variable diff. Detail reference:[Bit Manipulation](https://en.wikipedia.org/wiki/Bit_manipulation)\\nAs we know,every bit of 1 of variable diff can distinguish the two unique numbers,here we simply choose the rightmost 1 to divide all the numbers into two groups:\\n* 0010\\n* 0010\\n* 0110\\n* 0110\\n* 0100\\n\\nand\\n* 0001\\n\\nNow the problem has been converted to two simpler subproblem: [Single Number](https://leetcode.com/problems/single-number/)\\nXOR the two group respectively and we get the result.\\n\\nWhat if we use the leftmost bit 1 for division?We will get the following groups\\n* 0010\\n* 0010\\n* 0001\\n\\nand\\n* 0110\\n* 0110\\n* 0100\\n\\nAlso we succeed to put the two unique numbers into two difference groups,so the problem is solved.",
                "solutionTags": [],
                "code": "```\\ndiff &=-diff\\n```\n```\\ndiff &=~(diff-1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018076,
                "title": "fastest-and-smallest-python-code",
                "content": "# Intuition\\nBit Manipulation\\n\\n# Approach\\nExplanation is too long I don\\'t want to write it.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        p=0\\n        q=0\\n        for i in nums :\\n            p^=i;\\n        for i in nums:\\n            if ((p&(-p))&i)==0 :\\n                q^=i\\n        return [p^q,q];\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        p=0\\n        q=0\\n        for i in nums :\\n            p^=i;\\n        for i in nums:\\n            if ((p&(-p))&i)==0 :\\n                q^=i\\n        return [p^q,q];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574546,
                "title": "python-explained-bit-manipulation",
                "content": "* First we will calculate cumulative `XOR` of all elements in the array.\\n* Performing aforementioned step now we will be having `XOR` of those two elements that are present exactly once in the array, since all the other elements are present exactly twice and XOR of same elements results` 0`.\\n* Now if we perform XOR operation with all the elements except one of the elements that are present once we will get another one.\\n* Now the task is to find a way to perform above step.\\n* We have cumulative `XOR`, in this value let\\'s find out the `position` of last set bit.\\n* at this `position` one of the element that occurred once will always be having `1` and another one `0`.\\n* So in this way if we again perform XOR operation with our current cumulative `XOR` value and elements that are having `1` at `position` (last set bit `position` of `XOR` value calculated in previous step) will give us one result and on doing same operation with elements that are having `0` at  `position` will give another value.\\n--------------------------------------------\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        xor = 0\\n        for i in nums: \\n            xor ^= i\\n        \\n        rmsb = xor&(-xor) #finding last set bit postion\\n        ans = [0, 0]\\n        \\n        for i in nums:\\n            if i&rmsb == 0:\\n                ans[0] ^= i\\n            else:\\n                ans[1] ^= i\\n        \\n        return ans\\n```\\n---------------------------------------------\\n**Complexity analysis:**\\n* Time complexity : O(n)\\n* Space complexity : O(1)\\n----------------------------------------------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        xor = 0\\n        for i in nums: \\n            xor ^= i\\n        \\n        rmsb = xor&(-xor) #finding last set bit postion\\n        ans = [0, 0]\\n        \\n        for i in nums:\\n            if i&rmsb == 0:\\n                ans[0] ^= i\\n            else:\\n                ans[1] ^= i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437932,
                "title": "c-bit-manipulation-o-1-space-easy-to-understand",
                "content": "Since every number except two are repeating xor of all the numbers will give (a^b) where a and b are the distinct number. Now we just have to seperate out a and b from (a^b).\\n\\nSince a and b are not repeating they are unique and will differ in atleast on bit position. We just have to find the bit position where a and b differs.\\nLets just say a and b differs in i\\'th bit.\\nif we split the entire num array based on wheater i\\'th bit is set or not then a and b will be in two different sets.\\nAnd if we take xor of elements of first and second set seperately, you will get a and b.\\n\\nExample:\\n[1,2,1,3,2,5]\\nCumulative xor = \\'110\\'\\nSince 1st bit is set first bit of a and b differs.\\nNow we split number based on the first bit.\\nSet 1 : 2,2,3\\nSet 2 : 1,1,5\\n\\nXor Set 1 : 3\\nXor Set 2 : 5\\n\\nXor will yield the unique nums as the pairs of repeating numbers will always go to the same set\\n\\n\\n\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tint x = 0;\\n\\tfor(auto e: nums) // cumulative xor\\n\\t\\tx = (x^e); \\n\\n\\tint i = 0;\\n\\twhile(((x>>i)&1) == 0){ // Finding the bit position in which the numbers differ\\n\\t\\ti++;\\n\\t}\\n\\tint a = 0; \\n\\tint b = 0; \\n\\tfor(auto e: nums){\\n\\t\\tif(((e>>i)&1) == 0) // Set 1\\n\\t\\t\\ta = a^e;\\n\\t\\telse\\n\\t\\t\\tb = b^e; // Set 2\\n\\t}\\n\\treturn {a, b}; // Only a and b remains\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tint x = 0;\\n\\tfor(auto e: nums) // cumulative xor\\n\\t\\tx = (x^e); \\n\\n\\tint i = 0;\\n\\twhile(((x>>i)&1) == 0){ // Finding the bit position in which the numbers differ\\n\\t\\ti++;\\n\\t}\\n\\tint a = 0; \\n\\tint b = 0; \\n\\tfor(auto e: nums){\\n\\t\\tif(((e>>i)&1) == 0) // Set 1\\n\\t\\t\\ta = a^e;\\n\\t\\telse\\n\\t\\t\\tb = b^e; // Set 2\\n\\t}\\n\\treturn {a, b}; // Only a and b remains\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391568,
                "title": "c-t-n-o-n-s-n-1-detailed-explanation",
                "content": "* First calculate the exor of entire vector. This will give the exor of two unique number which appers once in the vector.\\n* ``` cpp\\n\\t\\tint xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n\\t```\\n\\t* e.g.  1,2,3,4,5,1,2,3,4,5,6,7   \\n\\t* Here 6 and 7 are the unique element\\n\\t*  **1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 =  6 ^ 7 = 0110 ^ 0111 = 0001**\\n\\n* Find the right most set bit in **xorValue**.\\n* ```\\n\\tint i=0;\\n    while(i<31){\\n\\t\\tif(xorValue&(1<<i))\\n\\t\\t\\t break;\\n\\t\\t++i;\\n\\t}\\n\\t// in our example xorValue = 0001, right most set bit at 0th index\\n   ```\\n* The right most set bit in **xorValue** value shows, that particular bit is different in both the numbers. \\n\\t* In our example at 0th index, bit is different in 6 & 7\\n*  Now based on this set bit in xorValue, we split the vector in two parts. First part contain all the numbers which has set bit at that index  and second part contain all the numbers which has unset bit at that index.\\n*  In our example, partition will be look like this\\n\\t*  **Set1 = 2,4,2,4,6**\\n\\t*  **Set2 = 1,3,5,1,3,5,7**\\n* If we exor the values of set1 then we will have 6 and similarly if we exor the values of Set2 then we will have 7.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n        int i=0;\\n        while(i<31){\\n            if(xorValue&(1<<i))\\n                break;\\n            ++i;\\n        }\\n        vector<int> set, unset;\\n        for(auto a : nums){\\n            if(a & (1<<i))\\n                set.push_back(a);\\n            else\\n                unset.push_back(a);\\n        }\\n        vector<int> ans;\\n        int n1 = 0, n2 = 0;\\n        for(auto a : set)\\n            n1 ^= a;\\n        for(auto a : unset)\\n            n2 ^= a;\\n        ans.push_back(n1);\\n        ans.push_back(n2);\\n        return ans;\\n    }\\n};\\n```\\n\\n* There is no need to create this set and unset vectors. We can solve this without extra space too.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n        int i=0;\\n        while(i<31){\\n            if(xorValue&(1<<i))\\n                break;\\n            ++i;\\n        }\\n        \\n        int n1 = 0, n2 = 0;\\n        for(auto a : nums){\\n            if(a & (1<<i))\\n                n1 = n1 ^ a;\\n            else\\n                n2 = n2 ^ a;\\n        }\\n        vector<int> ans;\\n        ans.push_back(n1);\\n        ans.push_back(n2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "``` cpp\\n\\t\\tint xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n\\t```\n```\\n\\tint i=0;\\n    while(i<31){\\n\\t\\tif(xorValue&(1<<i))\\n\\t\\t\\t break;\\n\\t\\t++i;\\n\\t}\\n\\t// in our example xorValue = 0001, right most set bit at 0th index\\n   ```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n        int i=0;\\n        while(i<31){\\n            if(xorValue&(1<<i))\\n                break;\\n            ++i;\\n        }\\n        vector<int> set, unset;\\n        for(auto a : nums){\\n            if(a & (1<<i))\\n                set.push_back(a);\\n            else\\n                unset.push_back(a);\\n        }\\n        vector<int> ans;\\n        int n1 = 0, n2 = 0;\\n        for(auto a : set)\\n            n1 ^= a;\\n        for(auto a : unset)\\n            n2 ^= a;\\n        ans.push_back(n1);\\n        ans.push_back(n2);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorValue = 0;\\n        for(auto a : nums)\\n            xorValue ^= a;\\n        int i=0;\\n        while(i<31){\\n            if(xorValue&(1<<i))\\n                break;\\n            ++i;\\n        }\\n        \\n        int n1 = 0, n2 = 0;\\n        for(auto a : nums){\\n            if(a & (1<<i))\\n                n1 = n1 ^ a;\\n            else\\n                n2 = n2 ^ a;\\n        }\\n        vector<int> ans;\\n        ans.push_back(n1);\\n        ans.push_back(n2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879257,
                "title": "solution-that-will-blow-your-mind-with-explanations-and-comments",
                "content": "Before going to the solution promise me you will try writing code on your own after reading the approach.\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n        Approach :-\\n        eg. A= {1,2,3,1,2,4} \\n        after doing xor of all array elements we will get ans as 3^4\\n        lets see what it looks like in binary\\n        3 = 011\\n        4 = 100\\n        --------\\n    ans =   111\\n \\xA0 \\xA0 \\xA0 \\xA0** If you know peoperty of xor 0^1 = 1, 1^0 = 1 but 1^1 = 0, 0^0 = \\n \\xA0 \\xA0 \\xA0 0 Observation:- In the answerxor where-ever the bit is set that means\\n                      any one of single no has bit at that position set and in \\n                      other single no the bit at that position is unset.\\n        **  Now the point is can we use this?\\n        **  Yes ofcourse, if we segregate array elements in two groups based on answerxors \\n        any of the set bit position this will make sure two single no will fall in \\n        different groups.\\n        **  After segragating into two groups if we take xor of all elements in the both \\n        groups all the repeating elements will get cancelled out and we will gat the\\n        answer1 from group1 and answer2 from group2. \\n        */\\n        int xor = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            //Taking xor of all elements in the array \\n            xor = xor ^ nums[i];\\n        }\\n        //Finding position of set bit in answer-xor\\n        int posOfSetBit = findSetBitPosition(xor);\\n        //Two variables for two groups.\\n        int ans1 = 0, ans2 = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            //Check if current element\\'s posOfSetBit is set if Yes\\n            //add it to first group and take xor.\\n            if(checkBit(nums[i], posOfSetBit)){\\n                ans1 = ans1 ^ nums[i];\\n            //else add it to second group and take xor.\\n            }else{\\n                ans2 = ans2 ^ nums[i];\\n            }\\n        }\\n        //finally add answers to ans array and return after sorting.\\n        int[] ans = {ans1, ans2};\\n        //Arrays.sort(ans);\\n        return ans;\\n\\n        //TC = O(Log(intMax) + N) || SC = O(1)\\n    }\\n\\n    public int findSetBitPosition(int xor){\\n        int pos = 0;\\n        while(pos < 32){\\n            if(checkBit(xor, pos)){\\n                return pos;\\n            }else{\\n                pos++;\\n            }\\n        }\\n        return pos;\\n    }\\n    public boolean checkBit(int val, int pos){\\n        return (val & (1 << pos)) > 0 ? true : false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n        Approach :-\\n        eg. A= {1,2,3,1,2,4}",
                "codeTag": "Java"
            },
            {
                "id": 1764031,
                "title": "c-faster-than-100-fully-explained-with-comments-xor-method",
                "content": "```\\ntypedef long long int ll; \\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        ll ans=0;\\n        for(int i=0;i<nums.size();i++) //doing xor of all the elements in the array so\\n        {                               //that all the repeated elements get cancelled\\n            ans = ans^nums[i];          //and in the last we have the xor of the two \\n        }                               //elements which occured only once.\\n        \\n        \\n        ll rmsb = ans & (~ans + 1);  //finding the rightmost set bit\\n        \\n        int x=0,y=0;        //x and y will have the two elements that we want finally\\n        \\n        \\n/* now we will separate the elements in the array whose rightmost bit is set and the elements whose rightmost bit is not set.\\nthen we will do xor of one variable ie. x with the element that is not set and will continue to do so for all the elements which are not set.\\nsimilary we would repeat the procedure for variable y and the elements which are set.\\n*/\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]&rmsb) == 0)\\n                x = x^nums[i];\\n            else \\n                y = y^nums[i];\\n        }\\n        \\n//after the for loop is over we would have our two desired elements in x and y.\\n        \\n        vector<int> res;\\n        res.push_back(x);\\n        res.push_back(y);\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        ll ans=0;\\n        for(int i=0;i<nums.size();i++) //doing xor of all the elements in the array so\\n        {                               //that all the repeated elements get cancelled\\n            ans = ans^nums[i];          //and in the last we have the xor of the two \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1673939,
                "title": "python-clean-bit-manipulation",
                "content": "Taking XOR of a number itself will give you 0. So taking XOR of all numbers in this array will give you num1^num2\\nNow we want to get num1 and num2 based on num1^num2. \\n\\nWe can find the rightmost bit that num1 and num2 differ. Then use the same principle, and the difference bit to find the 2 numbers from the array seperately.\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n            \\n        rightmost_one = 1\\n        while not res & 1:\\n            res = res >> 1\\n            rightmost_one = rightmost_one << 1\\n            \\n        num1, num2 = 0, 0\\n        for num in nums:\\n            if (rightmost_one & num) != 0:\\n                num1 ^= num\\n            else:\\n                num2 ^= num\\n                \\n        return [num1, num2]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n            \\n        rightmost_one = 1\\n        while not res & 1:\\n            res = res >> 1\\n            rightmost_one = rightmost_one << 1\\n            \\n        num1, num2 = 0, 0\\n        for num in nums:\\n            if (rightmost_one & num) != 0:\\n                num1 ^= num\\n            else:\\n                num2 ^= num\\n                \\n        return [num1, num2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638082,
                "title": "easy-to-understand-in-c-unordered-map",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second==1){\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1621526,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int uni=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            uni^=nums[i];\\n            \\n        }\\n        int rsbm=uni&-uni;\\n        int uni1=0;\\n        int uni2=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if((nums[i] & rsbm)==0)\\n            {\\n                uni1^=nums[i];\\n            }\\n            else\\n            {\\n                uni2^=nums[i];\\n            }\\n                \\n        }\\n        int[] res=new int[2];\\n        res[0]=uni1;\\n        res[1]=uni2;\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int uni=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            uni^=nums[i];\\n            \\n        }\\n        int rsbm=uni&-uni;\\n        int uni1=0;\\n        int uni2=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if((nums[i] & rsbm)==0)\\n            {\\n                uni1^=nums[i];\\n            }\\n            else\\n            {\\n                uni2^=nums[i];\\n            }\\n                \\n        }\\n        int[] res=new int[2];\\n        res[0]=uni1;\\n        res[1]=uni2;\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562975,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> List[int]:\\n\\ts = (sum(nums) - 2 * sum(set(nums))) * -1\\n\\n\\tfor i in nums:    \\n\\t\\tif s - i in nums:\\n\\t\\t\\treturn[i, s-i]\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> List[int]:\\n\\ts = (sum(nums) - 2 * sum(set(nums))) * -1\\n\\n\\tfor i in nums:    \\n\\t\\tif s - i in nums:\\n\\t\\t\\treturn[i, s-i]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1561975,
                "title": "simple-java-o-n-time-solution-with-o-1-space-explanation-link-provided",
                "content": "**You may refer the given link for detailed explanation -**\\n[https://florian.github.io/xor-trick/#application-4-finding-two-missingduplicate-numbers]\\n\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int uXORv = 0 , n = nums.length , i;\\n        for(i = 0; i < n; i++){\\n            uXORv ^= nums[i];\\n        }\\n        for(i = 0; i < 31; i++){\\n            if((uXORv & 1) == 1){\\n                break;\\n            }\\n            uXORv = uXORv >> 1;\\n        }\\n        int u = 0, v = 0;\\n        for(int j = 0; j < n; j++){\\n            int cpy = nums[j] >> i;\\n            if((cpy & 1) == 1){\\n                u ^= nums[j];\\n            }\\n            else{\\n                v ^= nums[j];\\n            }\\n        }\\n        int[] res = new int [2];\\n        res[0] = u;\\n        res[1] = v;\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int uXORv = 0 , n = nums.length , i;\\n        for(i = 0; i < n; i++){\\n            uXORv ^= nums[i];\\n        }\\n        for(i = 0; i < 31; i++){\\n            if((uXORv & 1) == 1){\\n                break;\\n            }\\n            uXORv = uXORv >> 1;\\n        }\\n        int u = 0, v = 0;\\n        for(int j = 0; j < n; j++){\\n            int cpy = nums[j] >> i;\\n            if((cpy & 1) == 1){\\n                u ^= nums[j];\\n            }\\n            else{\\n                v ^= nums[j];\\n            }\\n        }\\n        int[] res = new int [2];\\n        res[0] = u;\\n        res[1] = v;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561898,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second ==1)\\n                res.push_back(it->first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second ==1)\\n                res.push_back(it->first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553119,
                "title": "bit-manipulation-solution",
                "content": "Time Complexity -> O(N)\\nSpace Complexity -> O(1)\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        //Most Optimal -> Bit Manipulation\\n        \\n        \\n        int xo = 0;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            \\n            xo = xo ^ nums[i];\\n        }\\n        \\n        //1.Elements that appear twice will cancel out because x ^ x = 0\\n        \\n        //Remaining \\n        // 3 ^ 5 -> 011 ^ 101 -> 110 = 6\\n        \\n        //2.We will find the right most set bit\\n        \\n        //Rightmost set bit\\n        \\n        int count = 0;\\n        while(xo != 0) {\\n            \\n            if(xo & 1) {\\n                \\n                break;\\n            }\\n            \\n            count++;\\n            \\n            xo = (xo >> 1);\\n        }\\n        \\n        //rightmost set bit at 1;\\n        \\n        vector<int>ans;\\n        \\n        //xor1 will store elements with set bit 1\\n        //xor2 will store elements with set bit 0\\n        \\n        int xor1 = 0;\\n        int xor2 = 0;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            \\n            int mask = 1 << count;\\n            \\n            if(nums[i] & mask) {\\n                \\n                xor1 = xor1 ^ nums[i];\\n            }\\n            else {\\n                \\n                xor2 = xor2 ^ nums[i];\\n            }\\n        }\\n        \\n        \\n        ans.push_back(xor1);\\n        ans.push_back(xor2);\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n## };",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        //Most Optimal -> Bit Manipulation\\n        \\n        \\n        int xo = 0;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            \\n            xo = xo ^ nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346330,
                "title": "c-time-o-n-space-o-1-easy-solution-and-explanation-with-examples-99-47-faster",
                "content": "**This is a question of Bitwise Manipulation**.\\n******\\n**Time Complexity** : O(n)\\n**Space Complexity** : O(1)\\n\\n**CORNER CASE** : if nums array has -2147483648 as a value, so decrement this value will create Runtime Error of overflow. That\\'s why it is advised to use unsigned long long.\\n\\n\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> singleNumber(vector<int>& nums) {\\n\\t\\t\\t// We want to find two elements u & v\\n\\t\\t\\tunsigned long long ans=0; // int will give Runtime Error \\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tans^=nums[i];   //ans = XOR of all elements = u XOR v \\n\\t\\t\\t}\\n\\n\\t\\t\\t//We want to segregate u & v\\n\\t\\t\\tunsigned long long temp = ans & (~(ans-1)); // ans-1 will make minimum value(if int) out of bound\\n\\t\\t\\t// captures one bit of ans variable\\n\\t\\t\\t//which will differentiate both u & v \\n\\t\\t\\tint zero_partition=0,nonzero_partition=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif((temp & nums[i]) == 0) \\n\\t\\t\\t\\t\\tzero_partition^=nums[i]; //all even occuring element will become zero\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnonzero_partition^=nums[i]; //all even occuring element will become zero\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> result;\\n\\n\\t\\t\\tresult.push_back(nonzero_partition);\\n\\t\\t\\tresult.push_back(zero_partition);\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\t};\\n```\\n\\n**For example:**\\n****\\n*nums* = [1,2,1,3,2,5]\\n\\n*ans* = 1 XOR 2 XOR 1 XOR 3 XOR 2 XOR 5 = 3 XOR 5 = 6(0110)\\n\\nWe want to segregate 3 & 5 from 6.\\n*temp* = 6 & (~5) = 6 AND (NOT 5)\\n\\n0110 =   6\\n1010 = (~5)\\n_____\\n0010 = 2\\n_____\\n\\nTraversing the nums array once again & *temp* = 2(0010)\\n\\n\\tif (temp & nums[i])==0\\n\\t\\t{1,1,5}\\n\\t\\tzero_partition = 1 XOR 1 XOR 5 = 5\\n\\t\\t\\n\\telse(i.e. not equal to zero)\\n\\t\\t{2,2,3}\\n\\t\\tnonzero_partition = 2 XOR 2 XOR 3 =3\\n\\nWe have separated 3 & 5 and next added to vector<int> result\\n\\n*result* = [3,5]",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> singleNumber(vector<int>& nums) {\\n\\t\\t\\t// We want to find two elements u & v\\n\\t\\t\\tunsigned long long ans=0; // int will give Runtime Error \\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tans^=nums[i];   //ans = XOR of all elements = u XOR v \\n\\t\\t\\t}\\n\\n\\t\\t\\t//We want to segregate u & v\\n\\t\\t\\tunsigned long long temp = ans & (~(ans-1)); // ans-1 will make minimum value(if int) out of bound\\n\\t\\t\\t// captures one bit of ans variable\\n\\t\\t\\t//which will differentiate both u & v \\n\\t\\t\\tint zero_partition=0,nonzero_partition=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif((temp & nums[i]) == 0) \\n\\t\\t\\t\\t\\tzero_partition^=nums[i]; //all even occuring element will become zero\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tnonzero_partition^=nums[i]; //all even occuring element will become zero\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> result;\\n\\n\\t\\t\\tresult.push_back(nonzero_partition);\\n\\t\\t\\tresult.push_back(zero_partition);\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245395,
                "title": "c-intuition-to-build-the-optimal-solution",
                "content": "## Basic Idea\\nThe question states that we are given an array which has exactly two elements that occur only once, while all other elements occur exactly twice in the array. For eg : [1, 2, 4, 2, 3, 3]. Here 1 and 4 are the non repeating ones and 2 and 3 occur exactly twice. Our task is to find these two non-repeating elements of the array.\\n\\nAlthough the question further puts constraints on the space and time complexity of the solution, but for now let us assume that only this is the question, with all relaxations allowed.\\n\\nThe **Naive** solution to this problem is probably not even worth mentioning, but still it just consists of choosing an element of the array, and then trying to find its second occurence. If we can, then it is not included in the answer, otherwise, it is. We stop once we get two such elements.\\nThis is indeed a very naive solution which will cost **O(n<sup>2</sup>)** in time and **O(1)** in space.\\n<br>\\n\\n## Optimized Solution with Extra Space (using HashMap) [Accepted]\\nThe first thing that comes to mind whenever we talk about finding the occurence of elements in an array is a hashmap. If you have used hashmaps before, you might know that they make searching constant time (O(1)) for a space tradeoff (O(n)).\\nWe just iterate over the array adding the elements to the hashmap, updating the number of times they occur in the array. Then we iterate over the hashmap, and include the two elements that have their occurence 1 into the result array, and then return it.\\nPretty simple algorithm, but not one that the question actually wants us to follow (;D)\\n\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tunordered_map<int, int> hashmap;\\n\\tint n = nums.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(hashmap.find(nums[i]) == hashmap.end()) hashmap.insert({nums[i], 0});\\n\\t\\thashmap[nums[i]]++;\\n\\t}\\n\\tvector<int> answer;\\n\\tint m = 0;\\n\\tfor(auto i = hashmap.begin(); i!= hashmap.end(); i++) {\\n\\t\\tif(i->second == 1) {\\n\\t\\t\\t//appears exactly once\\n\\t\\t\\tanswer.push_back(i->first);\\n\\t\\t\\tm++;\\n\\t\\t\\tif(m==2) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n<br>\\n\\n## The Actual Question (and Solution)\\nNow coming to the actual constraints set by the question. We are required to solve this question in linear (O(n)) time and constant (O(1)) space!\\nAt first, it may seem baffling to you, how could this type of occurence counting be done in O(1) space? Trust me, I felt the same way, but the problem was, we probably forgot some important information given to us on a plate by the question.\\n\\nQuoting from the first line of the question \"Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice ...\", notice the occurences of the other elements. All other elements occur exactly two times, this fact can help us eliminate all these other elements.\\n\\nLooking closely, you may notice that if we take the xor of the all the elements of the array, all other elements cancel out (since a^a = 0), and we are left with just the xor of the two elements required. So, if the answer to the case was {a,b}, then the xor of the entire array will be equal to a^b.\\n\\nBut how would we go about finding the individual elements from their xor? \\n1. We find the leftmost set bit of the xor. This bit will be 1 for one of the numbers, while 0 for the other. Let a has this bit set.\\n2. We iterate over the array again, this time xoring all elements that do not have this bit set.\\n3. At the end this xor will give us b, and the only element in the array that has this bit set would be a.\\n4. Then we return {a,b}\\n\\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tlong long xorSum = 0;\\n\\tint n = nums.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\txorSum ^= (long long) nums[i];\\n\\t}\\n\\t//this will be equal to a ^ b where a and b are the answers;\\n\\t//finding the lowest set bit in the ans;\\n\\t//this will be in one of these two (let a)\\n\\tint lset = (int) xorSum ^ (xorSum & (xorSum - 1));\\n\\t//this will be like ..0001000.. .\\n\\tint a = 0, b= 0;\\n\\t//a will be the number with this bit set.\\n\\t//b will be the the xor of all other elements\\n\\tfor(int i:nums){\\n\\t\\tif(i & lset) {\\n\\t\\t\\ta ^= i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tb ^= i;\\n\\t\\t}\\n\\t}\\n\\treturn {a,b};\\n}\\n```\\n\\n**Time:** O(n) as we iterate over the array twice.\\n**Space:** O(1) as algorithm is iterative (no recursion depth) and we only use a constant number of variables per function call.\\n<br>\\n\\n**Upvote** if you liked this post, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tunordered_map<int, int> hashmap;\\n\\tint n = nums.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(hashmap.find(nums[i]) == hashmap.end()) hashmap.insert({nums[i], 0});\\n\\t\\thashmap[nums[i]]++;\\n\\t}\\n\\tvector<int> answer;\\n\\tint m = 0;\\n\\tfor(auto i = hashmap.begin(); i!= hashmap.end(); i++) {\\n\\t\\tif(i->second == 1) {\\n\\t\\t\\t//appears exactly once\\n\\t\\t\\tanswer.push_back(i->first);\\n\\t\\t\\tm++;\\n\\t\\t\\tif(m==2) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn answer;\\n}\\n```\n```\\nvector<int> singleNumber(vector<int>& nums) {\\n\\tlong long xorSum = 0;\\n\\tint n = nums.size();\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\txorSum ^= (long long) nums[i];\\n\\t}\\n\\t//this will be equal to a ^ b where a and b are the answers;\\n\\t//finding the lowest set bit in the ans;\\n\\t//this will be in one of these two (let a)\\n\\tint lset = (int) xorSum ^ (xorSum & (xorSum - 1));\\n\\t//this will be like ..0001000.. .\\n\\tint a = 0, b= 0;\\n\\t//a will be the number with this bit set.\\n\\t//b will be the the xor of all other elements\\n\\tfor(int i:nums){\\n\\t\\tif(i & lset) {\\n\\t\\t\\ta ^= i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tb ^= i;\\n\\t\\t}\\n\\t}\\n\\treturn {a,b};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245010,
                "title": "anyone-help-me-to-find-where-is-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int s = nums[0];\\n        for(int i = 1; i < n; i++){\\n            s ^= nums[i];\\n        }\\n        \\n        int hint = s & ~(s-1); \\n        int a = 0,b = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] & hint){\\n                 a ^= nums[i];\\n            }else{\\n                 b ^= nums[i];\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int s = nums[0];\\n        for(int i = 1; i < n; i++){\\n            s ^= nums[i];\\n        }\\n        \\n        int hint = s & ~(s-1); \\n        int a = 0,b = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] & hint){\\n                 a ^= nums[i];\\n            }else{\\n                 b ^= nums[i];\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217758,
                "title": "simple-c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long int result = 0;\\n        for(const int &x : nums)\\n            result ^= x;\\n        // result = a ^ b\\n        // finding the first set bit from the right\\n        long long int mask = (result & -result);\\n        // find the first number which has set bit at mask position\\n        int a = 0;\\n        for(const int &x : nums) {\\n            if((mask & x) == mask)\\n                a ^= x;\\n        }\\n        // result = a ^ b\\n        // b = result ^ a ie. a ^ b ^ a = a ^ a ^ b = 0 ^ b = b\\n        int b = result ^ a;\\n        return {a, b};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long int result = 0;\\n        for(const int &x : nums)\\n            result ^= x;\\n        // result = a ^ b\\n        // finding the first set bit from the right\\n        long long int mask = (result & -result);\\n        // find the first number which has set bit at mask position\\n        int a = 0;\\n        for(const int &x : nums) {\\n            if((mask & x) == mask)\\n                a ^= x;\\n        }\\n        // result = a ^ b\\n        // b = result ^ a ie. a ^ b ^ a = a ^ a ^ b = 0 ^ b = b\\n        int b = result ^ a;\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958234,
                "title": "91-78-faster-kindly-comment-for-doubts",
                "content": "![image](https://assets.leetcode.com/users/images/d0ae3851-bc9d-470f-8e14-0176881313f7_1609093074.613895.png)\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& a) {\\n      int n=a.size();\\n         int x=0;\\n\\tfor(int i=0;i<n;i++){\\n\\t    x^=a[i];\\n\\t} \\n\\tint pos=0;\\n    for(int i=0;i<n;i++){\\n    if(x&1<<i){\\n        pos=i;\\n        break;\\n    }\\n    }\\n    int num1=0;\\n    for(int i=0;i<n;i++){\\n        if(a[i]&1<<pos){\\n            num1=a[i]^num1;\\n        }\\n    }\\n    int num2=num1^x;\\n        vector<int> v;\\n        v.push_back(num1);\\n        v.push_back(num2);\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& a) {\\n      int n=a.size();\\n         int x=0;\\n\\tfor(int i=0;i<n;i++){\\n\\t    x^=a[i];\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 751916,
                "title": "reducing-to-single-number-i-problem",
                "content": "Credit to this video: https://www.youtube.com/watch?v=3TSC0nlur58\\n\\n```python\\nclass Solution:\\n\\t\"\"\"\\n\\tSince all numbers are present twice, and two are present once, the XOR\\n\\tof the complete list will give us the XOR of these two numbers that are\\n\\tpresent once.\\n\\tWe use a trick to find out the lowest set bit in this result and that bit will\\n\\tbe set in one of the numbers and unset in another. Similarly that bit will be set\\n\\tfor one group of numbers, and unset for other group. We use this to segregate\\n\\tthe numbers in two groups by distributing them if the number & lowest_bit gives\\n\\t0 or gives 1.\\n\\tOnce we segregate, it is Single Number I problem again, we do XOR all to find the\\n\\tone that is extra in its group.\\n\\t\"\"\"\\n\\tdef singleNumber(self, nums):\\n\\t\\te = 0\\n\\t\\tfor i in nums:\\n\\t\\t\\te ^= i\\n\\t\\tlow_bit = e & (-e) # the trick to find the lowest set bit. This works because of how computers calculate negative numbers- by taking 2s complement\\n\\t\\tres = [0, 0]\\n\\t\\tfor i in nums:\\n\\t\\t\\tif low_bit & i:\\n\\t\\t\\t\\tres[0] ^= i\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres[1] ^= i\\n\\t\\treturn res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\t\"\"\"\\n\\tSince all numbers are present twice, and two are present once, the XOR\\n\\tof the complete list will give us the XOR of these two numbers that are\\n\\tpresent once.\\n\\tWe use a trick to find out the lowest set bit in this result and that bit will\\n\\tbe set in one of the numbers and unset in another. Similarly that bit will be set\\n\\tfor one group of numbers, and unset for other group. We use this to segregate\\n\\tthe numbers in two groups by distributing them if the number & lowest_bit gives\\n\\t0 or gives 1.\\n\\tOnce we segregate, it is Single Number I problem again, we do XOR all to find the\\n\\tone that is extra in its group.\\n\\t\"\"\"\\n\\tdef singleNumber(self, nums):\\n\\t\\te = 0\\n\\t\\tfor i in nums:\\n\\t\\t\\te ^= i\\n\\t\\tlow_bit = e & (-e) # the trick to find the lowest set bit. This works because of how computers calculate negative numbers- by taking 2s complement\\n\\t\\tres = [0, 0]\\n\\t\\tfor i in nums:\\n\\t\\t\\tif low_bit & i:\\n\\t\\t\\t\\tres[0] ^= i\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres[1] ^= i\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750854,
                "title": "javascript-easy-3-line-solution",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let set = new Set();\\n    nums.forEach(x => set.has(x) ? set.delete(x): set.add(x))\\n    return Array.from(set);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let set = new Set();\\n    nums.forEach(x => set.has(x) ? set.delete(x): set.add(x))\\n    return Array.from(set);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 750576,
                "title": "single-number-lll-easy-c-solution-using-bit-operator",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> singleNumber(vector<int>& nums)\\n    {\\n        //Xor of all element\\n        int Xor = nums[0];\\n\\n        //To divide vector in two part\\n        //one have this set bit another one doesn\\'t\\n        int rightSetBit;\\n        int n = nums.size();\\n\\n        for(int i=1; i<n; i++)\\n            Xor ^= nums[i];\\n\\n        rightSetBit = Xor & ~(Xor - 1);\\n\\n        vector<int>ans(2);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] & rightSetBit)\\n                ans[0] ^= nums[i];\\n            else\\n                ans[1] ^= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> singleNumber(vector<int>& nums)\\n    {\\n        //Xor of all element\\n        int Xor = nums[0];\\n\\n        //To divide vector in two part\\n        //one have this set bit another one doesn\\'t\\n        int rightSetBit;\\n        int n = nums.size();\\n\\n        for(int i=1; i<n; i++)\\n            Xor ^= nums[i];\\n\\n        rightSetBit = Xor & ~(Xor - 1);\\n\\n        vector<int>ans(2);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] & rightSetBit)\\n                ans[0] ^= nums[i];\\n            else\\n                ans[1] ^= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701455,
                "title": "c-very-simple-xor-solution-explained-in-detail-with-code",
                "content": "* We need to group the single numbers with other numbers such that we form two groups, with the two single numbers in different groups. If we take the XOR of those two groups separately, we\\'ll get the two single numbers as results (because every other element appears twice).\\n* To assign different groups to the single numbers, we need to find a bit in which they differ(there WILL be such a bit).\\n* To do that take XOR of the entire array, which will amount to the XOR of the two single numbers. We can take any set bit from this XOR (I\\'ve taken the rightmost), and it will indicate that the two single numbers have different bits at that position.\\n* Finally, assign all numbers with bit not set at that position to one group, and all numbers with bit set at that position to the other group. This ensures that the single numbers are in different groups.\\n* Take XOR of both groups separately to get the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int fullxor = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            fullxor ^= nums[i];\\n\\n        int shift = 1;\\n\\n        for(int s = 1; s < 32; s++)\\n        {\\n            if((fullxor & shift) == shift)break;\\n            shift <<= 1;\\n        }\\n\\n        int num1 = 0, num2 = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if((nums[i] & shift) == shift) num1 ^= nums[i];\\n            else num2 ^= nums[i];\\n        }\\n\\n        return vector<int>{num1, num2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int fullxor = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            fullxor ^= nums[i];\\n\\n        int shift = 1;\\n\\n        for(int s = 1; s < 32; s++)\\n        {\\n            if((fullxor & shift) == shift)break;\\n            shift <<= 1;\\n        }\\n\\n        int num1 = 0, num2 = 0;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if((nums[i] & shift) == shift) num1 ^= nums[i];\\n            else num2 ^= nums[i];\\n        }\\n\\n        return vector<int>{num1, num2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420136,
                "title": "java-solution-with-explanation",
                "content": "1. The two single nums at least have one bit different (one is 1 and the other is 0). We can tell the different bit from the xor result of all elements.\\n1. Then we can use the different bit of two single nums to split all the elements into two sets: one set has all elements with the traget bit as 1, and the other set has all elements with the target bit as 0. Each set will contain only one single num.\\n1. Then we can use xor all the elements of each set to extract the single nums.\\n\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor = 0;\\n        for(int num : nums) {\\n            xor ^= num;\\n        }\\n        int k = 0;\\n        while(((xor >> k) & 1) != 1) {\\n            k ++;\\n        }\\n        int singleNum1 = 0;\\n        for(int num : nums) {\\n            if(((num >> k) & 1) == 1) {\\n                singleNum1 ^= num;\\n            }\\n        }\\n        return new int[]{singleNum1, xor ^ singleNum1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xor = 0;\\n        for(int num : nums) {\\n            xor ^= num;\\n        }\\n        int k = 0;\\n        while(((xor >> k) & 1) != 1) {\\n            k ++;\\n        }\\n        int singleNum1 = 0;\\n        for(int num : nums) {\\n            if(((num >> k) & 1) == 1) {\\n                singleNum1 ^= num;\\n            }\\n        }\\n        return new int[]{singleNum1, xor ^ singleNum1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403959,
                "title": "python-bit",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        r = 0\\n        for n in nums:\\n            r ^= n\\n        \\n        # 1 to the right most\\n        mask = r & ~(r-1)\\n        \\n        res = [0, 0]\\n        for n in nums:\\n            if n & mask:\\n                res[0] ^= n\\n            else:\\n                res[1] ^= n\\n        \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        r = 0\\n        for n in nums:\\n            r ^= n\\n        \\n        # 1 to the right most\\n        mask = r & ~(r-1)\\n        \\n        res = [0, 0]\\n        for n in nums:\\n            if n & mask:\\n                res[0] ^= n\\n            else:\\n                res[1] ^= n\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 336278,
                "title": "intuitive-python-o-n-solution-with-explanation",
                "content": "XOR of same bits is 0.  So, for numbers which appear twice, their XOR (num^num) would set all bits to zero. \\nSo, if we XOR all the elements of the array in one pass, it will ulimately be the XOR of the two distinct elements which appear twice (because XOR of other elements was in pairs, and ultimately will not set any bit =1).\\n\\nNow, for each element in the array, see if XOR of that element with the final XOR value we got above generates a number that is in the array. If so, that is the ans pair. The logic is that if a^b=c, then a^c=b or b^c=a (https://brainly.in/question/3038497)\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        st = set(nums)\\n        \\n        xor =0\\n        for num in nums:\\n            xor = xor^num\\n        print(xor)\\n        for item in nums:\\n            if(item^xor in st):\\n                ans = [item,item^xor]\\n                return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        st = set(nums)\\n        \\n        xor =0\\n        for num in nums:\\n            xor = xor^num\\n        print(xor)\\n        for item in nums:\\n            if(item^xor in st):\\n                ans = [item,item^xor]\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255158,
                "title": "5-line-swift-solution-with-explanation",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> [Int] {\\n        // get XOR of all nums\\n        let xorAll = nums.reduce(0, ^)\\n        \\n        // find any mask that can mark one different bit of the target two nums\\n        let mask = xorAll & (~xorAll + 1)\\n\\n        // or: \\n        // let mask = xorAll & -xorAll\\n\\n        // traditional: \\n        // var mask = 1\\n        // while mask & xorAll == 0 {\\n        //     mask = mask << 1\\n        // }\\n        \\n        // num2 is filtered by mask, so as some other pairs (pairs will not affact result)\\n        let num1 = nums.filter { $0 & mask != 0 }.reduce(0, ^)\\n        let num2 = num1 ^ xorAll\\n        \\n        return [num1, num2]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> [Int] {\\n        // get XOR of all nums\\n        let xorAll = nums.reduce(0, ^)\\n        \\n        // find any mask that can mark one different bit of the target two nums\\n        let mask = xorAll & (~xorAll + 1)\\n\\n        // or: \\n        // let mask = xorAll & -xorAll\\n\\n        // traditional: \\n        // var mask = 1\\n        // while mask & xorAll == 0 {\\n        //     mask = mask << 1\\n        // }\\n        \\n        // num2 is filtered by mask, so as some other pairs (pairs will not affact result)\\n        let num1 = nums.filter { $0 & mask != 0 }.reduce(0, ^)\\n        let num2 = num1 ^ xorAll\\n        \\n        return [num1, num2]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68938,
                "title": "java-bit-manipulation-combining-everyone-s-explanation-into-one",
                "content": "    public int[] singleNumber(int[] nums) {\\n        int xor = 0; //xor is the xor result of the two unique number\\n        \\n        //1: get the XOR of the two numbers we need to find. the duplicate ones will be canceled out(to 0), leaving the unique two left\\n        for(int n:nums){\\n            xor^=n;\\n        }\\n        \\n        //2. find the right most set bit of the xor\\n        //can also do: int bit = xor & ~(xor-1);\\n        int mask=1;\\n        while((xor &&mask)==0){\\n            mask=mask<<1;\\n        }\\n        \\n        int num1 =0;\\n        int num2 = 0;\\n        \\n        //3. here we divide the originals nums into 2 group, 1 group has set bit the other group doesn't\\n        //note that numbers beside the single number will be canceled out \\n        for(int num: nums){\\n            if((num & mask)>0)){\\n                num1^=num;\\n            }\\n            else{\\n                num2^=num;\\n            }\\n        }\\n        \\n        result[0]=nums1;\\n        result[1]=nums2;\\n        return result;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "    public int[] singleNumber(int[] nums) {\\n        int xor = 0; //xor is the xor result of the two unique number\\n        \\n        //1: get the XOR of the two numbers we need to find. the duplicate ones will be canceled out(to 0), leaving the unique two left\\n        for(int n:nums){\\n            xor^=n;\\n        }\\n        \\n        //2. find the right most set bit of the xor\\n        //can also do: int bit = xor & ~(xor-1);\\n        int mask=1;\\n        while((xor &&mask)==0){\\n            mask=mask<<1;\\n        }\\n        \\n        int num1 =0;\\n        int num2 = 0;\\n        \\n        //3. here we divide the originals nums into 2 group, 1 group has set bit the other group doesn't\\n        //note that numbers beside the single number will be canceled out \\n        for(int num: nums){\\n            if((num & mask)>0)){\\n                num1^=num;\\n            }\\n            else{\\n                num2^=num;\\n            }\\n        }\\n        \\n        result[0]=nums1;\\n        result[1]=nums2;\\n        return result;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68996,
                "title": "a-3-line-ruby-solution",
                "content": "    # @param {Integer[]} nums\\n    # @return {Integer[]}\\n    def single_number(nums)\\n        xor = nums.reduce(:^)\\n        diff = xor & -xor\\n        nums.partition{|n| n & diff == 0}.map{|ary| ary.reduce(:^)}\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    # @param {Integer[]} nums\\n    # @return {Integer[]}\\n    def single_number(nums)\\n        xor = nums.reduce(:^)\\n        diff = xor & -xor\\n        nums.partition{|n| n & diff == 0}.map{|ary| ary.reduce(:^)}\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 3689775,
                "title": "easy-c-solution-easy-to-understand-approach",
                "content": "### Refer this [link](https://leetcode.com/problems/single-number-iii/solutions/68900/accepted-c-java-o-n-time-o-1-space-easy-solution-with-detail-explanations/) to understand the solution. The approach was followed from the link and this is my implementation.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long Xor_val = 0;\\n        for(int i = 0 ; i<nums.size();i++)\\n            Xor_val^=nums[i];\\n        long long diffBit =  Xor_val & (-Xor_val);\\n        int ans1 = 0, ans2 = 0;\\n        for(int i = 0; i<nums.size();i++){\\n            if(diffBit & nums[i])\\n                ans1^=nums[i];\\n            else\\n                ans2^=nums[i];\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        long long Xor_val = 0;\\n        for(int i = 0 ; i<nums.size();i++)\\n            Xor_val^=nums[i];\\n        long long diffBit =  Xor_val & (-Xor_val);\\n        int ans1 = 0, ans2 = 0;\\n        for(int i = 0; i<nums.size();i++){\\n            if(diffBit & nums[i])\\n                ans1^=nums[i];\\n            else\\n                ans2^=nums[i];\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540316,
                "title": "single-number-iii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int i;\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second==1)\\n            {\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a321b206-07ef-4a14-81d0-967e565ff3e7_1684467764.5740762.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int i;\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second==1)\\n            {\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427643,
                "title": "beginner-friendly-easy-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n      HashMap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        In this code, we first create a HashMap to store the frequency of each number in the array. We then iterate through the array and add each number to the hashmap. After that, we iterate through the hashmap to find the element that appears exactly once. Finally, we return the single element or -1 if no single element is found.\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n\\n        int[] arr=new int[2];\\n\\n        HashMap<Integer, Integer> hm= new HashMap<Integer, Integer>();\\n        // key:value\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                //update the value to +1\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n\\n            }\\n            else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n        int index=0;\\n        for(Map.Entry<Integer, Integer> entry:hm.entrySet()){\\n            if(entry.getValue()==1){\\n\\n             arr[index++]= entry.getKey();\\n             if(index==2) break;\\n\\n        }\\n        }\\n\\n    return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n\\n        int[] arr=new int[2];\\n\\n        HashMap<Integer, Integer> hm= new HashMap<Integer, Integer>();\\n        // key:value\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                //update the value to +1\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n\\n            }\\n            else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n\\n        int index=0;\\n        for(Map.Entry<Integer, Integer> entry:hm.entrySet()){\\n            if(entry.getValue()==1){\\n\\n             arr[index++]= entry.getKey();\\n             if(index==2) break;\\n\\n        }\\n        }\\n\\n    return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398616,
                "title": "java-1-ms-100-beats-unique-solution-using-hashset-with-explanation",
                "content": "#### CODE\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        int[] result = new int[2];\\n        int i = 0;\\n        for (int num : set) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        int[] result = new int[2];\\n        int i = 0;\\n        for (int num : set) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221599,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){m[nums[i]]++;}\\n        vector<int>ans;\\n        for(auto it: m){\\n            if(it.second!=2){ans.push_back(it.first);}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){m[nums[i]]++;}\\n        vector<int>ans;\\n        for(auto it: m){\\n            if(it.second!=2){ans.push_back(it.first);}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148547,
                "title": "simple-c-solution-beginners-friendly-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        int i=0,l = nums.size();\\n        while(i<l-1){\\n            if(nums[i]==nums[i+1]){\\n                i = i+2;\\n            }\\n            else{\\n                ans.push_back(nums[i]);\\n                i++;\\n            }\\n        }\\n        if(i==l-1&&(nums[l-2]!=nums[l-1])){\\n            ans.push_back(nums[l-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        int i=0,l = nums.size();\\n        while(i<l-1){\\n            if(nums[i]==nums[i+1]){\\n                i = i+2;\\n            }\\n            else{\\n                ans.push_back(nums[i]);\\n                i++;\\n            }\\n        }\\n        if(i==l-1&&(nums[l-2]!=nums[l-1])){\\n            ans.push_back(nums[l-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122902,
                "title": "c-bit-mask-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unsigned int Xor=0;\\n        for(auto x:nums){\\n            Xor^=x;\\n        }\\n        Xor=Xor&-Xor;  \\n        int ans1=0,ans2=0;\\n        for(auto x:nums){\\n            if(x&Xor) {\\n              ans1^=x;\\n            }\\n            else{\\n              ans2^=x;\\n            }\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unsigned int Xor=0;\\n        for(auto x:nums){\\n            Xor^=x;\\n        }\\n        Xor=Xor&-Xor;  \\n        int ans1=0,ans2=0;\\n        for(auto x:nums){\\n            if(x&Xor) {\\n              ans1^=x;\\n            }\\n            else{\\n              ans2^=x;\\n            }\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044529,
                "title": "best-and-easy-using-bruteforce-and-bit-manipulation-approaches-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic intution to solve this problem is that we have to use bitwise xor for this question and how this came into my mind is that, for this kind of questions where we have duplicates we generally use this xor operation as the xor of same numbers will be 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Approach 1 - Bruteforce\\nIn this approach we can simply create a hashmap and store the counts of the elements in it and iterate it over to get the result. Thats pretty simple to implement.\\n\\n\\nBut this is not the optimised way isn\\'t it? So, we will see approach 2.\\n\\n### Approach 2 - Using bit manipulation\\n\\nThe approach to solve this problem is that we will find xor of all the numbers in the vector. now this xor is basically the xor of two unique elements (our result).\\nIn this xor and two non-unique elements we have many things to observe like-\\n- In the bitwise representation of xor atleast one bit will be 1. otherwise the two numbers will be same.\\n- wherever the bit is 1 in the xor, we can for sure say that the bit in either of the numbers is 1 and in another one it is 0.\\n\\nNow solution is -\\nstep 1 - find xor of all elements of the array.\\nstep 2 - In the bitwise representation of this xor wherever we find a bit 1, we will mark this position and perform the next steps.\\nstep 3 - Now we will basically find two xor\\'s, one for the elements whose bit is set at that position and another one is for those whose bit is not set at that position.\\n\\nAfter this we can for sure say that the two xor\\'s which we found is none other than our two unique elements.\\n#### why? Lets see\\nSo, suppose the two numbers are x and y and for x the bit is set at position 3. now it is fixed that at position 3 the bit will be 0 for y. so, when we calculate xor\\'s these elements cannot be in the same xor and rest are duplicates so those will be 0 and finally we will only have our results.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_bit_set(int n, int pos) {\\n        int mask = 1 << pos;\\n        if((n & mask) != 0) return true;\\n        return false;\\n    }\\n\\n    int change_bit(int n, int pos) {\\n        int mask = 1 << pos;\\n        if(is_bit_set(n, pos)) {\\n            mask = 1 << pos;\\n            mask ^= INT_MAX;\\n            return n & mask;\\n        } else {\\n            mask = 1 << pos;\\n            return n | mask;\\n        }\\n    }\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int global_xor = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            global_xor ^= nums[i];\\n        }\\n\\n        for(int i=0; i<32; i++) {\\n            if(is_bit_set(global_xor, i)) {\\n                int xor0 = 0, xor1 = 0;\\n                for(int j=0; j<n; j++) {\\n                    if(is_bit_set(nums[j], i)) {\\n                        xor1 ^= nums[j];\\n                    } else {\\n                        xor0 ^= nums[j];\\n                    }\\n                }\\n                v.push_back(xor0);\\n                v.push_back(xor1);\\n                break;\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the approaches and solution!",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_bit_set(int n, int pos) {\\n        int mask = 1 << pos;\\n        if((n & mask) != 0) return true;\\n        return false;\\n    }\\n\\n    int change_bit(int n, int pos) {\\n        int mask = 1 << pos;\\n        if(is_bit_set(n, pos)) {\\n            mask = 1 << pos;\\n            mask ^= INT_MAX;\\n            return n & mask;\\n        } else {\\n            mask = 1 << pos;\\n            return n | mask;\\n        }\\n    }\\n\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int global_xor = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++) {\\n            global_xor ^= nums[i];\\n        }\\n\\n        for(int i=0; i<32; i++) {\\n            if(is_bit_set(global_xor, i)) {\\n                int xor0 = 0, xor1 = 0;\\n                for(int j=0; j<n; j++) {\\n                    if(is_bit_set(nums[j], i)) {\\n                        xor1 ^= nums[j];\\n                    } else {\\n                        xor0 ^= nums[j];\\n                    }\\n                }\\n                v.push_back(xor0);\\n                v.push_back(xor1);\\n                break;\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017999,
                "title": "fastest-and-smallest-java-code-1ms",
                "content": "# Intuition\\nBit Manipulation\\n\\n# Approach\\nExplanation is too long I don\\'t want to write it.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int p=0,q=0;\\n        for(int i:nums) p^=i;\\n        for(int i:nums)\\n        q^=(((p&(-p))&i)==0)?i:0;\\n        return new int[] {p^q,q};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int p=0,q=0;\\n        for(int i:nums) p^=i;\\n        for(int i:nums)\\n        q^=(((p&(-p))&i)==0)?i:0;\\n        return new int[] {p^q,q};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013534,
                "title": "java-easy-solution-beat-100-using-xor-very-easy-approach-beginner-friendly-with-comment",
                "content": "If you have any doubt please ask!!!\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int ans[]=new int[2];\\n        int xor=0;\\n        //find the XOR of all the numbers\\n        for(int i=0;i<nums.length;i++){\\n            xor=xor^nums[i];\\n            \\n        }\\n       \\n        //find the rightmost set bit (rmsb of x=x & 2\\'s compliment of x)\\n        int rmsb=xor&(~xor+1);\\n        //find the group of number whose bit corresponding to righmost set bit is on and similiarly find the group with bit corresponding to rsb is off and then find the xor of both group you will get the 2 number\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if((nums[i]&rmsb)==rmsb){\\n                ans[0]=ans[0]^nums[i];\\n            }\\n            else{\\n                ans[1]=ans[1]^nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int ans[]=new int[2];\\n        int xor=0;\\n        //find the XOR of all the numbers\\n        for(int i=0;i<nums.length;i++){\\n            xor=xor^nums[i];\\n            \\n        }\\n       \\n        //find the rightmost set bit (rmsb of x=x & 2\\'s compliment of x)\\n        int rmsb=xor&(~xor+1);\\n        //find the group of number whose bit corresponding to righmost set bit is on and similiarly find the group with bit corresponding to rsb is off and then find the xor of both group you will get the 2 number\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if((nums[i]&rmsb)==rmsb){\\n                ans[0]=ans[0]^nums[i];\\n            }\\n            else{\\n                ans[1]=ans[1]^nums[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011708,
                "title": "simple-approach-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n\\n        //variables used\\n        int xor_nums = 0;\\n        int i = 0;\\n        int first_zero_position = 0;\\n        int result_1 = 0;\\n        int result_2 = 0;\\n\\n        // get the xor of all elements\\n        for(i = 0; i < nums.size(); i++)\\n        {\\n            xor_nums ^= nums[i];\\n        }\\n\\n        // xor_nums contain XOR of two single occuring numbers\\n        // find out the position of first set bit in xor_nums\\n        for(i = 0; i<32 ; i++)\\n        {\\n            if((xor_nums >> i) & 1)\\n            {\\n                first_zero_position = i;\\n                break;\\n            }\\n        }\\n\\n        //divide the original vector in two groups\\n        // group 1: all those elements with set bit at first_zero_position\\n        // group 2: all those elements with unset bit at first_zero_position\\n        // take Xor of each element in each group :(Now this question is like Single Number I)\\n        for(i = 0 ; i < nums.size() ; i++)\\n        {\\n            if((nums[i] >> first_zero_position) & 1)\\n            {\\n                result_1 ^= nums[i];\\n            }\\n            else\\n            {\\n                result_2 ^= nums[i];\\n            }\\n        }\\n\\n        return {result_1, result_2};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n\\n        //variables used\\n        int xor_nums = 0;\\n        int i = 0;\\n        int first_zero_position = 0;\\n        int result_1 = 0;\\n        int result_2 = 0;\\n\\n        // get the xor of all elements\\n        for(i = 0; i < nums.size(); i++)\\n        {\\n            xor_nums ^= nums[i];\\n        }\\n\\n        // xor_nums contain XOR of two single occuring numbers\\n        // find out the position of first set bit in xor_nums\\n        for(i = 0; i<32 ; i++)\\n        {\\n            if((xor_nums >> i) & 1)\\n            {\\n                first_zero_position = i;\\n                break;\\n            }\\n        }\\n\\n        //divide the original vector in two groups\\n        // group 1: all those elements with set bit at first_zero_position\\n        // group 2: all those elements with unset bit at first_zero_position\\n        // take Xor of each element in each group :(Now this question is like Single Number I)\\n        for(i = 0 ; i < nums.size() ; i++)\\n        {\\n            if((nums[i] >> first_zero_position) & 1)\\n            {\\n                result_1 ^= nums[i];\\n            }\\n            else\\n            {\\n                result_2 ^= nums[i];\\n            }\\n        }\\n\\n        return {result_1, result_2};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792961,
                "title": "c-easy-bitmask-solution-with-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps\\n-  Calculate the overall xor of the array and as we have only two odd occurence numbers so resultant<code>(xorr)</code> will be xor of two required numbers.\\n- xor of different bits is 1 so using this property find first ever set bit in <code>xorr</code> let say <code>id</code>.\\n- So for <code>id</code> one number will take all <code>idth</code> set bit nyumbers and other remaining non set. \\n\\n# Complexity**Italic**\\n- Time complexity: <code> O(n) </code>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: <code> O(1) </code>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorr = 0;\\n        for(auto it: nums){\\n            xorr^=it;\\n        }\\n        vector<int> ans(2,0);\\n        int id = -1;\\n        for(int i = 0 ;i < 64; i++){\\n            if((1<<i)&xorr){\\n                id = i;\\n                break;\\n            }\\n        }\\n        for(auto it: nums){\\n            if(it&(1<<id)){\\n                ans[0]^=it;\\n            }else{\\n                ans[1]^=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int xorr = 0;\\n        for(auto it: nums){\\n            xorr^=it;\\n        }\\n        vector<int> ans(2,0);\\n        int id = -1;\\n        for(int i = 0 ;i < 64; i++){\\n            if((1<<i)&xorr){\\n                id = i;\\n                break;\\n            }\\n        }\\n        for(auto it: nums){\\n            if(it&(1<<id)){\\n                ans[0]^=it;\\n            }else{\\n                ans[1]^=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385418,
                "title": "java-solution-with-explanation-o-n-time-complexity",
                "content": "Example: a[]={3,1,9,7,3,1}\\n**Step 1:** Get the xor of all the elements.\\n\\t\\t\\t\\t\\tsum=3^1^9^7^3^1 = 9^7 = 1110 (Binary representaion of 14)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tNote: XORing two similar elements gives zero (3^3=0).\\n\\n**Step 2:** Get anumber which has only one set-bit of the \\'sum\\' variable.\\n\\t\\t\\t\\t   We can get the rightmost set-bit ,(In two ways), By apllying Bitwise & between \\'sum\\' and it\\'s \\n\\t\\t\\t\\t   2\\'s complement. \\n\\t\\t(a.) set_bit = ```(sum & -sum);```\\n\\t\\t(b.) set_bit = ```sum & ~(sum-1);```\\n\\t\\t\\n\\t\\tBoth are same because, (-sum) and ~(sum-1) both give 2s complement.\\n\\t\\t\\n\\t\\tBack to Example: sum=1110 , -sum=0010;\\n\\t\\t set_bit = (sum & -sum) =(1110 & 0010) =0010.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\n**Step 3:** Now Divide the Array into two groups on the basis of rightmost-set-bit, \\n\\t\\t\\t\\t   By applying Bitwise & between each element of array and the ```set_bit```.\\n\\t\\t\\t\\t   \\n\\t\\t\\t\\t   (a.)  ((a[i] & set_bit) > 0) : Group1: { 3,7,3}\\n\\t\\t\\t\\t   (b.)  ((a[i] & set_bit) == 0) : Group2: {1,9,1}\\n\\t\\t\\t\\t\\n**Step 4:** Apply XOR operation on both the groups separately.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t(a.) sum1 = 3^7^3 = 7\\n\\t\\t\\t\\t\\t(b.) sum2 = 1^9^1 = 9\\n\\t\\t\\t\\t\\t\\nsum1=7 ,sum2=9 are the unique elements.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int sum=0,n=nums.length;\\n        for(int i=0;i<n;i++)\\n            sum^=nums[i];\\n        //Bitwise & sum and it\\'s 2\\'s complement, to find it\\'s rightmost set-bit(1) (Example: 0010)\\n        \\n        sum=(sum & -sum); //rightmost-set-bit.\\n        int sum1=0,sum2=0;\\n        //dividing the array into two groups on the basis of the rightmost-set-bit being either 0 or 1.\\n        \\n        for(int i=0;i<n;i++){\\n            if((nums[i] & sum) > 0){ //If rightmost set bit of(arr[i] & sum) is 1.\\n                sum1^=nums[i];\\n            }\\n            else{                   //If rightmost set bit of(arr[i] & sum) is 0.\\n                sum2^=nums[i];\\n            }\\n        }\\n        return (new int[]{sum1,sum2});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```(sum & -sum);```\n```sum & ~(sum-1);```\n```set_bit```\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int sum=0,n=nums.length;\\n        for(int i=0;i<n;i++)\\n            sum^=nums[i];\\n        //Bitwise & sum and it\\'s 2\\'s complement, to find it\\'s rightmost set-bit(1) (Example: 0010)\\n        \\n        sum=(sum & -sum); //rightmost-set-bit.\\n        int sum1=0,sum2=0;\\n        //dividing the array into two groups on the basis of the rightmost-set-bit being either 0 or 1.\\n        \\n        for(int i=0;i<n;i++){\\n            if((nums[i] & sum) > 0){ //If rightmost set bit of(arr[i] & sum) is 1.\\n                sum1^=nums[i];\\n            }\\n            else{                   //If rightmost set bit of(arr[i] & sum) is 0.\\n                sum2^=nums[i];\\n            }\\n        }\\n        return (new int[]{sum1,sum2});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368937,
                "title": "python-fast-using-counters",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x = Counter(nums)\\n        return([y for y in x if x[y] == 1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        x = Counter(nums)\\n        return([y for y in x if x[y] == 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174732,
                "title": "simple-java-solution-o-n-time-o-1-space-faster-than-100",
                "content": "Memory Usage is only 42.5MB, less than 92%\\nPlease upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] arr) {\\n        int res = 0;\\n        for(int val : arr) {\\n          res ^= val;\\n        }\\n\\n        int rsbm = (res & -res);\\n\\n        int val1 = 0;\\n        int val2 = 0;\\n\\n        for(int val : arr) {\\n          if((val & rsbm) == 0) {\\n            val1 ^= val;\\n          } else {\\n            val2 ^= val;\\n          }\\n        }\\n        \\n        return new int[]{val1, val2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] arr) {\\n        int res = 0;\\n        for(int val : arr) {\\n          res ^= val;\\n        }\\n\\n        int rsbm = (res & -res);\\n\\n        int val1 = 0;\\n        int val2 = 0;\\n\\n        for(int val : arr) {\\n          if((val & rsbm) == 0) {\\n            val1 ^= val;\\n          } else {\\n            val2 ^= val;\\n          }\\n        }\\n        \\n        return new int[]{val1, val2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130899,
                "title": "c-bit-manipulation-xor-operator-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> res(2);\\n        //xor of all value present in nums example [1,2,1,3,2,5] 1^2^3^1^2^5 = 3^5\\n        //Note property of xor a^a = 0 && a^0 = a\\n        int xorNums = 0; //this value contains xor of required nums 3^5\\n        for(const int &x: nums) \\n            xorNums ^= x;\\n        \\n        //xorNums 3 binary rep 011, 5 binary rep 101 \\n        // 3^5 = 110 it is guranteed that in xorNums if set bit is present then \\n        // at that position firstNumber bit is 0 and other is 1 bcoz we are taking xor \\n        // and if one num bit is 1 and other is 0 then that bit will become 1 so we           // find rightmost set bit\\n        int mask = 1;\\n        while((xorNums & mask) == 0) \\n            mask <<= 1;\\n        \\n        res[0] = xorNums;\\n        res[1] = xorNums;\\n        //In nums array we are taking xor of those number whose rightmost bit is set\\n        // [1,2,1,3,2,5] binary rep 1 = 001, 2 = 010, 3 = 011, 5 = 101\\n        // firstNum = 3^5(xorNums)^2^2^3 which gives 5\\n        // secondNum = 3^5(xorNums)^1^1^5 which gives 3 \\n        for(const int&x: nums)  {\\n            if((x & mask) == 0)\\n                res[0] ^= x;\\n            else\\n               res[1] ^= x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> res(2);\\n        //xor of all value present in nums example [1,2,1,3,2,5] 1^2^3^1^2^5 = 3^5\\n        //Note property of xor a^a = 0 && a^0 = a\\n        int xorNums = 0; //this value contains xor of required nums 3^5\\n        for(const int &x: nums) \\n            xorNums ^= x;\\n        \\n        //xorNums 3 binary rep 011, 5 binary rep 101 \\n        // 3^5 = 110 it is guranteed that in xorNums if set bit is present then \\n        // at that position firstNumber bit is 0 and other is 1 bcoz we are taking xor \\n        // and if one num bit is 1 and other is 0 then that bit will become 1 so we           // find rightmost set bit\\n        int mask = 1;\\n        while((xorNums & mask) == 0) \\n            mask <<= 1;\\n        \\n        res[0] = xorNums;\\n        res[1] = xorNums;\\n        //In nums array we are taking xor of those number whose rightmost bit is set\\n        // [1,2,1,3,2,5] binary rep 1 = 001, 2 = 010, 3 = 011, 5 = 101\\n        // firstNum = 3^5(xorNums)^2^2^3 which gives 5\\n        // secondNum = 3^5(xorNums)^1^1^5 which gives 3 \\n        for(const int&x: nums)  {\\n            if((x & mask) == 0)\\n                res[0] ^= x;\\n            else\\n               res[1] ^= x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017662,
                "title": "using-xor",
                "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        if (nums.size() == 2) {\\n            return nums;\\n        }\\n        int n=nums.size();\\n        \\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            res ^= nums[i];\\n        }\\n        \\n        int lsb = res & ~(res-1);\\n        int x = 0;\\n        int y = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] & lsb) {\\n                x ^= nums[i];\\n            } else {\\n                y ^= nums[i];\\n            }\\n        }\\n\\n        return vector<int>{x,y};\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        if (nums.size() == 2) {\\n            return nums;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1973953,
                "title": "c-o-n-time-use-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i = 0 ; i <nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for (auto x :mp)\\n        {\\n            if(x.second == 1)\\n            {\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> ans;\\n        for(int i = 0 ; i <nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for (auto x :mp)\\n        {\\n            if(x.second == 1)\\n            {\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968891,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n        Approach :-\\n        eg. A= {1,2,3,1,2,4} \\n        after doing xor of all array elements we will get ans as 3^4\\n        lets see what it looks like in binary\\n        3 = 011\\n        4 = 100\\n        --------\\n    ans =   111\\n        ** If you know peoperty of xor 0^1 = 1, 1^0 = 1 but 1^1 = 0, 0^0 = 1\\n        Observation:- In the answerxor where-ever the bit is set that means\\n                      any one of single no has bit at that position set and in \\n                      other single no the bit at that position is unset.\\n        **  Now the point is can we use this?\\n        **  Yes ofcourse, if we segregate array elements in two groups based on answerxors \\n        any of the set bit position this will make sure two single no will fall in \\n        different groups.\\n        **  After segragating into two groups if we take xor of all elements in the both \\n        groups all the repeating elements will get cancelled out and we will gat the\\n        answer1 from group1 and answer2 from group2. \\n        */\\n        int xor = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            //Taking xor of all elements in the array \\n            xor = xor ^ nums[i];\\n        }\\n        //Finding position of set bit in answer-xor\\n        int posOfSetBit = findSetBitPosition(xor);\\n        //Two variables for two groups.\\n        int ans1 = 0, ans2 = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            //Check if current element\\'s posOfSetBit is set if Yes\\n            //add it to first group and take xor.\\n            if(checkBit(nums[i], posOfSetBit)){\\n                ans1 = ans1 ^ nums[i];\\n            //else add it to second group and take xor.\\n            }else{\\n                ans2 = ans2 ^ nums[i];\\n            }\\n        }\\n        //finally add answers to ans array and return after sorting.\\n        int[] ans = {ans1, ans2};\\n        //Arrays.sort(ans);\\n        return ans;\\n\\n        //TC = O(Log(intMax) + N) || SC = O(1)\\n    }\\n\\n    public int findSetBitPosition(int xor){\\n        int pos = 0;\\n        while(pos < 32){\\n            if(checkBit(xor, pos)){\\n                return pos;\\n            }else{\\n                pos++;\\n            }\\n        }\\n        return pos;\\n    }\\n    public boolean checkBit(int val, int pos){\\n        return (val & (1 << pos)) > 0 ? true : false;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] singleNumber(int[] nums) {\\n        /*\\n        Approach :-\\n        eg. A= {1,2,3,1,2,4}",
                "codeTag": "Java"
            },
            {
                "id": 1949792,
                "title": "c-easy-bit-manipulation-bitmasking-o-n",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums)\\n    {\\n        if(nums.size()==2)\\n        {\\n            return nums;\\n        }\\n        int ans=0,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=ans^nums[i];\\n        }\\n        temp=ans;\\n        vector<int>a;\\n        vector<int>res;\\n        int count=0;\\n        while((ans&1)!=1)\\n        {\\n            count++;\\n            ans=ans>>1;\\n        }\\n        long int bin_num=1<<count;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]&bin_num)>0)\\n            {\\n                a.push_back(nums[i]);\\n            }\\n        }\\n        int num1=0,num2=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            num1=num1^a[i];\\n        }\\n        num2=temp^num1;\\n        res.push_back(num1);\\n        res.push_back(num2);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946951,
                "title": "three-line-code",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let obj={};\\n    for(let i of nums){\\n      if(obj[i]!==undefined){delete obj[i];}\\n      else{obj[i]=i;}\\n    }\\n    return Object.values(obj);  \\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let obj={};\\n    for(let i of nums){\\n      if(obj[i]!==undefined){delete obj[i];}\\n      else{obj[i]=i;}\\n    }\\n    return Object.values(obj);  \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901006,
                "title": "java-hashmap-solution",
                "content": "class Solution {\\npublic int[] singleNumber(int[] nums) {\\n        Map<Integer,Integer> hmap=new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n        \\thmap.put(nums[i], hmap.getOrDefault(nums[i], 0)+1);\\n        }\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> itr:hmap.entrySet()) {\\n        \\tif(itr.getValue()==1) {\\n        \\t\\tans.add(itr.getKey());\\n        \\t}\\n        }\\n        int[] arr = ans.stream().mapToInt(i -> i).toArray();\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int[] singleNumber(int[] nums) {\\n        Map<Integer,Integer> hmap=new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n        \\thmap.put(nums[i], hmap.getOrDefault(nums[i], 0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893706,
                "title": "single-number-iii-solution-java",
                "content": "class Solution {\\n  public int[] singleNumber(int[] nums) {\\n    final int xors = Arrays.stream(nums).reduce((a, b) -> a ^ b).getAsInt();\\n    final int lowbit = xors & -xors;\\n    int[] ans = new int[2];\\n\\n    // seperate nums into two groups by the lowbit\\n    for (final int num : nums)\\n      if ((num & lowbit) > 0)\\n        ans[0] ^= num;\\n      else\\n        ans[1] ^= num;\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int[] singleNumber(int[] nums) {\\n    final int xors = Arrays.stream(nums).reduce((a, b) -> a ^ b).getAsInt();\\n    final int lowbit = xors & -xors;\\n    int[] ans = new int[2];\\n\\n    // seperate nums into two groups by the lowbit\\n    for (final int num : nums)\\n      if ((num & lowbit) > 0)\\n        ans[0] ^= num;\\n      else\\n        ans[1] ^= num;\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1772989,
                "title": "accepted-c-o-n-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        long long res=0,a=0,b=0;\\n        for(auto x : nums)\\n            res^=x;\\n        for(auto x : nums)\\n        {\\n            if(x & res & ~(res-1))\\n                a^=x;\\n            else\\n                b^=x;\\n        }\\n        a=a^res;\\n        b^=res;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        vector<int> ans;\\n        long long res=0,a=0,b=0;\\n        for(auto x : nums)\\n            res^=x;\\n        for(auto x : nums)\\n        {\\n            if(x & res & ~(res-1))\\n                a^=x;\\n            else\\n                b^=x;\\n        }\\n        a=a^res;\\n        b^=res;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771314,
                "title": "single-number",
                "content": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        return singleNumberMini(nums, 0, new ArrayList<>(1), new ArrayList<>(1));\\n    }\\n    \\n    private static int[] singleNumberMini(int[] nums, int index, List<Integer> res, List<Integer> removeList) {\\n        int a = nums[index];\\n        if (res.contains(a)) {\\n            removeList.add(a);\\n        } else {\\n            res.add(a);\\n        }\\n        if (index == nums.length - 1) {\\n            res.removeAll(removeList);\\n            return res.stream().mapToInt(Integer::intValue).toArray();\\n        } else {\\n            return singleNumberMini(nums, index + 1, res, removeList);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        return singleNumberMini(nums, 0, new ArrayList<>(1), new ArrayList<>(1));\\n    }\\n    \\n    private static int[] singleNumberMini(int[] nums, int index, List<Integer> res, List<Integer> removeList) {\\n        int a = nums[index];\\n        if (res.contains(a)) {\\n            removeList.add(a);\\n        } else {\\n            res.add(a);\\n        }\\n        if (index == nums.length - 1) {\\n            res.removeAll(removeList);\\n            return res.stream().mapToInt(Integer::intValue).toArray();\\n        } else {\\n            return singleNumberMini(nums, index + 1, res, removeList);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733536,
                "title": "java-bit-manipulation-using-rmsb-approach-very-easy-to-understand-fast",
                "content": "**Approach :**\\nTake the XOR of all elements of nums array (num). Then, the result will be the XOR of the **two     non-repating numbers** (which is the answer). \\nNow, we can take rmsb (Right-Most-Significant-Bit) of the num(XOR of two non-repating numbers) and use it as a mask for segregating values whose that particular bit is 0(Zero) or 1(one) by calculating (mask & nums[i]).\\n\\nNow when we have two sets for rmsb of num\\n1. it is zero for nums[i].\\n2. it is one for nums[i].\\n\\nNow, we take XOR of both the sets and remaining elements in each set will be the **two non-repating numbers**. So, at last we put them in an array and return.\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n    int num=0;\\n    for(int i=0;i<nums.length;i++){\\n    num=num^nums[i];\\n    }\\n    \\n    int rmsb=num & -num;\\n    int x=0;\\n    int y=0;\\n    \\n    for(int i=0;i<nums.length;i++){\\n    if((rmsb & nums[i])==0){\\n    x=x^nums[i];\\n    }\\n    else{\\n    y=y^nums[i];\\n    }\\n    }\\n        \\n    int[]ans=new int[2];\\n    ans[0]=y;\\n    ans[1]=x;\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n    int num=0;\\n    for(int i=0;i<nums.length;i++){\\n    num=num^nums[i];\\n    }\\n    \\n    int rmsb=num & -num;\\n    int x=0;\\n    int y=0;\\n    \\n    for(int i=0;i<nums.length;i++){\\n    if((rmsb & nums[i])==0){\\n    x=x^nums[i];\\n    }\\n    else{\\n    y=y^nums[i];\\n    }\\n    }\\n        \\n    int[]ans=new int[2];\\n    ans[0]=y;\\n    ans[1]=x;\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712697,
                "title": "c-solution-bit-manipulation-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        long long x = 0;\\n        for(int i:nums) x ^= i;\\n        \\n        // finding the least significant setbit\\n        // for a fact you may find any of the set bits in xor\\n        // this basically helps you classify whole array in two types \\n        // one with this set bit as set, another as this set bit as unset and both of this grps\\n        // will contain either of these elements each\\n        long long lssb = x&(-x);\\n        \\n        for(int i:nums) {\\n            if(i&lssb) a ^= i;\\n            else b ^= i;\\n        }\\n        \\n        return vector<int>{a,b};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        long long x = 0;\\n        for(int i:nums) x ^= i;\\n        \\n        // finding the least significant setbit\\n        // for a fact you may find any of the set bits in xor\\n        // this basically helps you classify whole array in two types \\n        // one with this set bit as set, another as this set bit as unset and both of this grps\\n        // will contain either of these elements each\\n        long long lssb = x&(-x);\\n        \\n        for(int i:nums) {\\n            if(i&lssb) a ^= i;\\n            else b ^= i;\\n        }\\n        \\n        return vector<int>{a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682400,
                "title": "easy-explainable",
                "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        //sort\\n        sort(nums.begin(),nums.end()) ;\\n        //ans vector\\n         vector<int> ans;\\n        //check 1 to (size-2) \\n        for(int i = 1 ; i< nums.size()-1 ; i++){\\n    if((nums[i] !=nums[i-1]) && (nums[i] !=nums[i+1]) )\\n        ans.push_back(nums[i]);\\n        }\\n        \\n        //check 0  \\n        if(nums[0] != nums[1])\\n            ans.push_back(nums[0]);\\n        \\n        //check (size-1) \\n    if(nums[nums.size()-1] != nums[nums.size()-2])\\n        ans.push_back(nums[nums.size()-1]);\\n\\n        //ans\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        //sort\\n        sort(nums.begin(),nums.end()) ;\\n        //ans vector\\n         vector<int> ans;\\n        //check 1 to (size-2) \\n        for(int i = 1 ; i< nums.size()-1 ; i++){\\n    if((nums[i] !=nums[i-1]) && (nums[i] !=nums[i+1]) )\\n        ans.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1563260,
                "title": "random-python-solutions",
                "content": "If anyone can help me out that\\'d be cool. \\n\\nInstructions for this problem say \"You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\"\\n\\nI\\'m under the impression that constant extra space means I can\\'t exceed more then the length of \"nums\" in a seperate data structure? So if the length of nums is 5, then I can at maximum, create a list of 5 nums right? \\n\\nAlso, the \"in\" keyword is technically a loop right? So are any of my solutions even meeting the requirements for this problem? Thanks!\\n\\n1.\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        lookup = Counter(nums).most_common()\\n        \\n        return [lookup[-2][0],lookup[-1][0]]\\n```\\n\\n2.\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        lookup = set()\\n        \\n        for num in nums:\\n            if num not in lookup:\\n                lookup.add(num)\\n            else:\\n                lookup.discard(num)\\n                \\n        return lookup\\n```\\n3.\\t\\t\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n       lookup = defaultdict()\\n        \\n        for num in nums:\\n            if num in lookup:\\n                del lookup[num]\\n            else:\\n                lookup[num] = 1\\n                \\n                \\n        return lookup.keys()\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        lookup = Counter(nums).most_common()\\n        \\n        return [lookup[-2][0],lookup[-1][0]]\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n        lookup = set()\\n        \\n        for num in nums:\\n            if num not in lookup:\\n                lookup.add(num)\\n            else:\\n                lookup.discard(num)\\n                \\n        return lookup\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        \\n       lookup = defaultdict()\\n        \\n        for num in nums:\\n            if num in lookup:\\n                del lookup[num]\\n            else:\\n                lookup[num] = 1\\n                \\n                \\n        return lookup.keys()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562929,
                "title": "c-easy-bits-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return {};\\n        int xr = nums[0];\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            xr ^= nums[i];\\n        }\\n        \\n        int mask = 1;\\n        int x = xr;\\n        cout<<x<<endl;\\n        while((x & mask) == 0 )\\n        {\\n            //cout<<mask<<endl;\\n            mask = mask<<1;\\n        }\\n        \\n        int first = 0;\\n        int second  = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if((mask & nums[i]) == 0) first ^= nums[i];\\n            else second ^= nums[i];\\n        }\\n        \\n        return {first,second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return {};\\n        int xr = nums[0];\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            xr ^= nums[i];\\n        }\\n        \\n        int mask = 1;\\n        int x = xr;\\n        cout<<x<<endl;\\n        while((x & mask) == 0 )\\n        {\\n            //cout<<mask<<endl;\\n            mask = mask<<1;\\n        }\\n        \\n        int first = 0;\\n        int second  = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if((mask & nums[i]) == 0) first ^= nums[i];\\n            else second ^= nums[i];\\n        }\\n        \\n        return {first,second};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1562663,
                "title": "bit-manipulation-solution",
                "content": "* Suppose X and Y are 2 numbers that appear once and all other numbers appear twice.\\n* If we `XOR` all the array\\'s elements, the value would be actually `X XOR Y`. This value will be surely not zero since X and Y are different.\\n* We will pick up any bit that is 1 in `X XOR Y`, name it `mask` for example.\\n* suppose X has bit 0 at mask\\'s position and Y has bit 1 at mask\\'s position.\\n* here we divide all elements into 2 types. One has bit 0 at mask\\'s position, the other has bit 1 at mask\\'s position. we can be sure that all duplicate elements can be in the same pile.\\n* we walk through the array again, the first `XOR` result will be equal to X and the second `XOR` result will be equal to Y\\n\\nBelow is the code, hope it can help.\\n\\n```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xorVal = 0;\\n        for (int num : nums) {\\n            xorVal ^= num;\\n        }\\n        int mask = 1;\\n        while ((xorVal & mask) == 0) {\\n            mask <<= 1;\\n        }\\n        int res1 = 0;\\n        int res2 = 0;\\n        for (int num : nums) {\\n            if ((num & mask) == 0) {\\n                res1 ^= num;\\n            } else {\\n                res2 ^= num;\\n            }\\n        }\\n        return new int[]{res1, res2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] singleNumber(int[] nums) {\\n        int xorVal = 0;\\n        for (int num : nums) {\\n            xorVal ^= num;\\n        }\\n        int mask = 1;\\n        while ((xorVal & mask) == 0) {\\n            mask <<= 1;\\n        }\\n        int res1 = 0;\\n        int res2 = 0;\\n        for (int num : nums) {\\n            if ((num & mask) == 0) {\\n                res1 ^= num;\\n            } else {\\n                res2 ^= num;\\n            }\\n        }\\n        return new int[]{res1, res2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562266,
                "title": "python-bit-manipulation-detailed-explanation",
                "content": "#### Complexity Analysis: \\n\\n\\tO(n) time | O(1) space - where n is the length of the input array\\n\\n#### Explanation \\n\\nIn this question, we need to figure out the two numbers which appears only once. \\nThe first step is to `xor` all the numbers in the array, you can get a number which has at least one bit difference between the two numbers. \\nUse the number from Example 1: \\n\\n\\t\"\"\"\\n\\tInput: nums = [1,2,1,3,2,5]\\n\\tOutput: [3,5]\\n\\tExplanation:  [5, 3] is also a valid answer.\\n\\t\"\"\"\\n\\t\\nThe number 3 is `011` and the number 5 is `101` so it has different bit at the second the 2nd and 3rd bit. \\nThen we can use this to dvivide all the number into two groups. \\n\\t\\n\\t\"\"\"\\n\\tLet say if we use the rightmost different bit between the number 3 and the number 5.\\n\\tThe input array can be divided as two groups \\n\\tGroup 1: [2, 3, 2] -> these numbers\\' 2nd bit are 1\\n\\tGroup 2: [1, 1, 5] -> these numbers\\' 2nd bit are 0\\n\\t\"\"\"\\n\\nFinally, we can `xor` all the numbers within these two groups to get the number which appears only once in each group. \\n\\t\\n\\t\"\"\"\\n\\tGroup 1 after xor is [3]\\n\\tGroup 2 after xor is [5]\\n\\t\"\"\"\\n\\n#### Code\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        xor = 0 \\n        for num in nums: # xor all the number in the input array\\n            xor ^= num\\n        \\n        rightmost1Bit = 1\\n        while xor & rightmost1Bit == 0: # Find the rightmost different bit which returns 1 with & operation\\n            rightmost1Bit <<= 1\\n        res = [0, 0]\\n        for num in nums: # Divide number in the input array into two groups and do xor at the same time. \\n            if num & rightmost1Bit: # Use & operator to find the number with the same rightmost 1 bit. \\n                res[0] ^= num\\n            else:\\n                res[1] ^= num\\n        return res\\n",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "#### Complexity Analysis: \\n\\n\\tO(n) time | O(1) space - where n is the length of the input array\\n\\n#### Explanation \\n\\nIn this question, we need to figure out the two numbers which appears only once. \\nThe first step is to `xor` all the numbers in the array, you can get a number which has at least one bit difference between the two numbers. \\nUse the number from Example 1: \\n\\n\\t\"\"\"\\n\\tInput: nums = [1,2,1,3,2,5]\\n\\tOutput: [3,5]\\n\\tExplanation:  [5, 3] is also a valid answer.\\n\\t\"\"\"\\n\\t\\nThe number 3 is `011` and the number 5 is `101` so it has different bit at the second the 2nd and 3rd bit. \\nThen we can use this to dvivide all the number into two groups. \\n\\t\\n\\t\"\"\"\\n\\tLet say if we use the rightmost different bit between the number 3 and the number 5.\\n\\tThe input array can be divided as two groups \\n\\tGroup 1: [2, 3, 2] -> these numbers\\' 2nd bit are 1\\n\\tGroup 2: [1, 1, 5] -> these numbers\\' 2nd bit are 0\\n\\t\"\"\"\\n\\nFinally, we can `xor` all the numbers within these two groups to get the number which appears only once in each group. \\n\\t\\n\\t\"\"\"\\n\\tGroup 1 after xor is [3]\\n\\tGroup 2 after xor is [5]\\n\\t\"\"\"\\n\\n#### Code\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        xor = 0 \\n        for num in nums: # xor all the number in the input array\\n            xor ^= num\\n        \\n        rightmost1Bit = 1\\n        while xor & rightmost1Bit == 0: # Find the rightmost different bit which returns 1 with & operation\\n            rightmost1Bit <<= 1\\n        res = [0, 0]\\n        for num in nums: # Divide number in the input array into two groups and do xor at the same time. \\n            if num & rightmost1Bit: # Use & operator to find the number with the same rightmost 1 bit. \\n                res[0] ^= num\\n            else:\\n                res[1] ^= num\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1562247,
                "title": "c-bit-manipulation",
                "content": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int x = 0;\\n        for(int i: nums){\\n            x = x ^ i;\\n        }\\n        //x = a ^ b since all except these are coming twice\\n        //now, we find the right most bit which is set, this will divide our array into 2 groups, each group will have 1 answer\\n        int i;\\n        for(i=0; i<32; i++){\\n            if(x & 1<<i) break;\\n        }\\n        int a = 0, b = 0;\\n        \\n        for(int j: nums){\\n            if(j & 1<<i){\\n                a = a ^ j;\\n            }\\n            else{\\n                b = b ^ j;\\n            }\\n        }\\n        \\n        return {a, b};\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> singleNumber(vector<int>& nums) {\\n        int x = 0;\\n        for(int i: nums){\\n            x = x ^ i;\\n        }\\n        //x = a ^ b since all except these are coming twice\\n        //now, we find the right most bit which is set, this will divide our array into 2 groups, each group will have 1 answer\\n        int i;\\n        for(i=0; i<32; i++){\\n            if(x & 1<<i) break;\\n        }\\n        int a = 0, b = 0;\\n        \\n        for(int j: nums){\\n            if(j & 1<<i){\\n                a = a ^ j;\\n            }\\n            else{\\n                b = b ^ j;\\n            }\\n        }\\n        \\n        return {a, b};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562132,
                "title": "c-bitmasking-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int gxor = 0;\\n        for(int i=0; i<n; i++) gxor ^= nums[i];\\n        \\n        int pos = 0;\\n        while(gxor) {\\n            if(gxor&1) break;\\n            \\n            pos++;\\n            gxor >>= 1;\\n        }\\n        \\n        int xor1 = 0, xor2 = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i]&(1<<pos)) xor1 ^= nums[i];\\n            else xor2 ^= nums[i];\\n        }\\n        \\n        return {xor1, xor2};\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int gxor = 0;\\n        for(int i=0; i<n; i++) gxor ^= nums[i];\\n        \\n        int pos = 0;\\n        while(gxor) {\\n            if(gxor&1) break;\\n            \\n            pos++;\\n            gxor >>= 1;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564543,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1564777,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1565176,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1565497,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1570079,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1568365,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1868325,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1751775,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1955684,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1694890,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1564543,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1564777,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1565176,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1565497,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1570079,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1568365,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1868325,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1751775,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1955684,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1694890,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "If you were stuck by this problem, it's easy to find a solution in the discussion. However, usually, the solution lacks some explanations.\\n\\nI'm sharing my understanding here:\\n\\nThe two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. \\n\\nOne important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. \\n\\nLet\\u2019s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1.\\n\\nThus, all the numbers can be partitioned into two groups according to their bits at location i. \\nthe first group consists of all numbers whose bits at i is 0.\\nthe second group consists of all numbers whose bits at i is 1. \\n\\nNotice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group.\\n\\nby XoRing all numbers in the first group, we can get the first number.\\nby XoRing all numbers in the second group, we can get the second number."
                    },
                    {
                        "username": "hanjyun",
                        "content": "god damn Genius!"
                    },
                    {
                        "username": "anurag-k",
                        "content": "such a brilliant solution."
                    },
                    {
                        "username": "rishav_k",
                        "content": "how did you think that way ?"
                    },
                    {
                        "username": "Beluma",
                        "content": "What a strange brain can get the solution!:)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashmap\n\n  \n**Approach 2:** Two bitmasks \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "rampaging9",
                        "content": "\\u8FD9\\u4E2A\\u9898\\u7684\\u521D\\u7EA7\\u7248\\u672C\\u4E2D \\uFF0C\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B0\\u4E00\\u6B21\\uFF0Cxor \\u4E00\\u904D\\u5373\\u53EF\\u5F97\\u5230\\u7B54\\u6848\\u3002\\u4E3A\\u4EC0\\u4E48\\u5462\\uFF1F\\n1. A xor A=0\\n2. 0 xor A=A\\n3.  \\u5E76\\u4E14 xor \\u6EE1\\u8DB3\\u4EA4\\u6362\\u5F8B\\u548C\\u7ED3\\u5408\\u5F8B\\u3002\\n\\n\\u6BD4\\u5982 2 2 3 1 3\\uFF0C2 xor 2 xor 3 xor 1 xor 3 \\n= 2 xor 2 xor 3 xor 3 xor 1\\n=(2 xor 2) xor (3 xor 3) xor 1 \\n= 0 xor 0 xor 1 \\n= 1\\n\\n \\u5728\\u8FD9\\u9053\\u52A0\\u5F3A\\u7248\\u7684\\u9898\\u76EE\\u91CC\\uFF0C\\u4E5F\\u4F1A\\u5F88\\u81EA\\u7136\\u7684\\u60F3\\u5230 xor \\u4E00\\u904D\\uFF0C\\u90A3\\u7ED3\\u679C\\u662F\\u4EC0\\u4E48\\u5462\\u3002\\u5047\\u8BBE\\u53EA\\u51FA\\u73B0\\u4E00\\u6B21\\u7684\\u4E24\\u4E2A\\u6570\\u662F A\\u3001B\\uFF0C\\u90A3\\u6211\\u4EEC\\u6700\\u540E\\u53EA\\u80FD\\u5F97\\u5230\\u4E00\\u4E2A\\u503C = A xor B\\uFF0C\\u4F46\\u6CA1\\u6709\\u529E\\u6CD5\\u77E5\\u9053 A \\u662F\\u591A\\u5C11\\uFF0CB \\u662F\\u591A\\u5C11\\u3002\\n\\u90A3\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u6709\\u6CA1\\u6709\\u7528\\u5462\\uFF1F\\u6709\\uFF0Cxor \\u662F\\u6309\\u4F4D\\u6BD4\\u8F83\\uFF0C\\u76F8\\u540C\\u4E3A0\\uFF0C\\u4E0D\\u540C\\u4E3A1\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5F97\\u5230\\u7684\\u8FD9\\u4E2A\\u503C\\u91CC\\uFF0C**\\u6240\\u6709\\u76841\\u90FD\\u4EE3\\u8868\\u4E86\\uFF1A\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\uFF0CA \\u548C B \\u662F\\u4E0D\\u540C\\u7684**\\uFF0C\\u8FD9\\u7ED9\\u6211\\u4EEC\\u533A\\u5206 A B \\u63D0\\u4F9B\\u4E86\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF1A\\n\\n\\u6211\\u4EEC\\u968F\\u4FBF\\u627E\\u4E00\\u4E2A\\u662F1\\u7684\\u4F4D\\u7F6E\\uFF08**\\u4E5F\\u5C31\\u662F A\\u548CB \\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u7684\\u503C\\u53CD\\u6B63\\u6709\\u4E00\\u4E2A\\u662F0 \\u6709\\u4E00\\u4E2A\\u662F1**\\uFF09\\uFF0C\\u518D\\u6B21\\u904D\\u5386\\u4E00\\u904D\\u6570\\u7EC4\\uFF0C**\\u6309\\u7167\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\u5206\\u6210\\u4E24\\u7EC4\\uFF0C\\u90A3\\u4E48 A \\u548C B \\u4E00\\u5B9A\\u4F1A\\u88AB\\u5206\\u5F00**\\u3002\\u800C\\u5BF9\\u4E8E\\u5176\\u4ED6\\u7684\\u6570\\u5B57\\uFF0C\\u65E0\\u8BBA\\u4ED6\\u4EEC\\u5728\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E0A\\u662F0\\u8FD8\\u662F1\\uFF0C**\\u603B\\u4E4B\\u4ED6\\u4EEC\\u4F1A\\u4E24\\u4E24\\u4E00\\u5BF9\\u5206\\u5230\\u4E24\\u4E2A\\u7EC4\\u4E2D\\u7684\\u4EFB\\u610F\\u4E00\\u4E2A\\u7EC4\\u91CC\\u53BB**\\u3002\\n\\n\\u8FD9\\u5C31\\u8F6C\\u5316\\u6210\\u4E86\\u521D\\u7EA7\\u7248\\u672C\\u7684\\u95EE\\u9898\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u7EC4\\u4E2D\\u90FD\\u53EA\\u6709\\u4E00\\u4E2A\\u6570\\u51FA\\u73B01\\u6B21\\uFF0C\\u5BF9\\u4E24\\u4E2A\\u7EC4\\u5206\\u522B\\u505A\\u4E00\\u6B21xor \\uFF0C\\u5F97\\u5230\\u4E24\\u4E2A\\u6570\\u5C31\\u662F A \\u548C B\\u3002\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "eng please"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "ruvhnrvjmprgifgbjfajavrkrlv  iethe  rjgopejpgjsrjrel;jegl"
                    },
                    {
                        "username": "alexander1089",
                        "content": "I kinda suck at bitwise problems so I wanna know how bad is it if I can\\'t come up with the bitwise solution for this problem. I can come up with a solution using HashMap and element counting."
                    },
                    {
                        "username": "zenfred",
                        "content": "The HashMap solution is better in extensibility, i.e. it can be reused to find 3, 4, or more single numbers. The bit operation solution is more akin to a brain teaser."
                    },
                    {
                        "username": "vishaal21",
                        "content": "well its not bad because u are atleast can think of the solution but that soutionn is not feasible here beacuse we have to use constant space."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for excellent explanation on xor approach and well-commented code in C/C++/Java/Python:\\nhttps://www.techiedelight.com/find-two-odd-occurring-element-array-without-extra-space/\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Maaaaaaaaaaaaaaan!\nThis was one of the most satisfying solutions to figure out ever!\n\nI don't know if that's the most common way, it's sort of weird. But I did it by aggregating all numbers together with XOR as in the previous version. That gives you the XOR(A,B) where A and B are the unique numbers cause all equal elements cancel out. That tells you all the distinct bits between A and B\n then I make two separate bins, filtered according to a distinct bit between A and B. This ensures that the two unique numbers end up in different bins, and all equal numbers end up in the same bin.\nThen you can just aggregate both bins since they both have a single unique number, it is just like the vanilla version! (you don't need to actually create the bins, it is O(1) space, you just aggregate them to the right counter as you go)\n\nSorry, I'm still pumped haha\n\nEDIT: ok, looking at the posts in the solution tab, it seems it is the most common way and maybe the only one. Oh well, still happy to have figured it out"
                    },
                    {
                        "username": "RunchangZ",
                        "content": "I believe this question need more test cases, my wrong ans also can pass it. Check out this test case [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it\\'s correct"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "i hate this type of problems cuz either you know it or you dont, unless you major in math somehow \\uD83D\\uDE05"
                    },
                    {
                        "username": "shreyashnalawade01248",
                        "content": "ISSUE WHILE FINDING THE RIGHT MOST SET BIT: \\n\\nHey there! \\nI faced a small issue with the code and did not find any good answers so after figuring out what was wrong I am posting it here \\n\\nThe LINE of code that is causing problem is this: \\n `int rsbm= (ans& ((~ans)+1) );`\\nif you use int for rmsb then the int type will overflow for 8th test case \\ntherefore easy fix for this is to use long \\n ` long rsbm= (ans& (long(~ans)+1) );`\\n\\nHope this helps ! \\n\\n"
                    }
                ]
            },
            {
                "id": 1571499,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1575186,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 2071484,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 2064810,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 2015665,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1956386,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1955980,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1944277,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1881488,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            },
            {
                "id": 1777640,
                "content": [
                    {
                        "username": "yefengzhishu",
                        "content": "Why diff&[~(diff - 1)] can pick one bit that is one?Could anybody help me with this problem?Thank you very much in advance!"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(260)Single%20Number%20III"
                    },
                    {
                        "username": "ahrix268",
                        "content": "there are $10$ types of people:\n\n- the one who knows about bit manipulation\n\n- and the one goes to solutions tab\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using **bit manipulation**, this problem can be broken down into three steps (seen from the plane ✈️):\n\nStep 1: Find the first bit (from right to left) that differs between x and y, where x and y are the values that appear only once in the array.\nStep 2: Create two groups, where the first one will contain the numbers that have this bit set and the other the ones that don't.\nStep 3: Apply XOR on the two goups in order to get your result. `Tip` \n\nNeed more help? 👇\n\nGetting all the bits that differ between x and y comes down to applying XOR on the entire array. Why does this work? That's because the XOR operation is commutative, so (in this case) you will be left with `x ^ y` because all the other values will cancel out (`a ^ a = 0`). `Hint`\n\nIf you know that the `i-th` bit of two numbers differs, you can be sure that one number will have this bit as 0 while the other as 1. `Hint`"
                    },
                    {
                        "username": "ankitk742",
                        "content": "1. Sort the list first\\n2. Now keep check of the number i when running exor becomes zero\\n3. After exor of whole list we will get a exor b\\n4. The i we kept track on will contain either a or b \\n5. Now u can easily get a and another number by a exor b exor a "
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "\\nstep 1: Find xor of all elements let \"xxor\"\\nstep 2: Find rightmost set bit of \"xxor\" let (i) bit set\\nstep 3: Divide all elements into 2 set -> \\n        set 1 contain xor of all ele whose ith bit set\\n        set 2 contain xor of all ele whose ith bit is not set\\nstep 4 :canditate1 will be in set1 and candidate2 will be in set2.\\n\\n\\n# Code Below First try it by urself\\n```\\nclass Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n    \\n         int xxor=0;\\n         for(auto x:nums) xxor^=x;\\n         int i=0;//store  rightmost setbit\\n         for(i=0;i<32;i++)\\n         {\\n             if(xxor &(1<<i)) break;\\n         }\\n         int xors1=0; // stores xor of all ele whose ith bit set\\n         int xors2=0;//  stores xor of all ele whose ith bit notset\\n         for(auto x:nums)\\n         {\\n             if(x &(1<<i)) xors1^=x;\\n             else xors2^=x;\\n         }\\n         return {xors1,xors2};\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "why this much worries, create unordered map thats it."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "you have to optimise it :)"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "1. To find the two elements that appear only once in the given array `nums`, we can utilize the XOR (exclusive OR) operation. The XOR operation between two equal numbers results in 0, so by XORing all the numbers in the array, we can find the XOR value of the two distinct numbers that appear only once.\n2. Find two groups with Group 1: Numbers that have a set bit (1) in the same position as the rightmost bit. Group 2: Numbers that have a cleared bit (0) in the same position as the rightmost bit. (The two distinct numbers we're looking for will fall into different groups. This is because the rightmost bit is set in one of the numbers and cleared in the other.) And we use XOR to get all of them."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "class Solution {\\npublic:\\n    vector<int> singleNumber(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x^nums[i];\\n\\n        } \\n        int cnt=0;\\n        while(x!=0)\\n        {\\n            if((x & 1)==1){\\n            cnt++;\\n            break;}\\n            else\\n            x=x>>1;\\n        }\\n       // int mask=(1<<cnt);\\n     int x1=0,x2=0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if((nums[i] & (1<<cnt))==0)\\n             {\\n                 x1=x1^nums[i];\\n\\n             }\\n             else\\n             x2=x2^nums[i];\\n\\n         }\\n      vector<int> ans;\\nans.push_back(x1);\\nans.push_back(x2);\\nreturn ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pathak9696",
                        "content": "why it fail at 21st testcase???"
                    },
                    {
                        "username": "prani05",
                        "content": "java code to verify:\\npublic class Solution {\\n public int[] singleNumber(int[] nums) {\\n int ab = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n ab = ab ^ nums[i];\\n }\\n int oneIndex = 0;\\n for (int i = 0; i < 32; i ++) {\\n if (((ab >>> i) & 1) == 1) {\\n oneIndex = i;\\n break;\\n }\\n }\\n int[] result = new int[2];\\n result[0] = 0;\\n for (int i = 0; i < nums.length; i ++) {\\n if (((nums[i] >>> oneIndex) & 1) == 1) {\\n result[0] = result[0] ^ nums[i];\\n }\\n }\\n result[1] = ab ^ result[0];\\n return result;\\n         }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort Transformed Array",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569206,
                "content": [
                    {
                        "username": "kkspeed3",
                        "content": "Given a sorted array of integers nums and integer values a, b and c. Apply a **quadratic function** of the form f(x) = ax2 + bx + c to each element x in the array. \\n\\nWhy *a* could be 0 when the question clearly states **quadratic function**?\\n\\nAccording to Wikipedia: In algebra, a quadratic function, a quadratic polynomial, a polynomial of degree 2, or simply a quadratic, is a polynomial function in one or more variables in which the highest-degree term is of the **second** degree. Doesn\\'t that imply *a* cannot be 0?"
                    },
                    {
                        "username": "Medium",
                        "content": "Check this testcase out. The expected output is reversed in leetcode solver.\\n\\n[-4,-2,2,4]\\n0\\n-1\\n5"
                    },
                    {
                        "username": "diyue",
                        "content": "High school memories... "
                    }
                ]
            },
            {
                "id": 1571635,
                "content": [
                    {
                        "username": "kkspeed3",
                        "content": "Given a sorted array of integers nums and integer values a, b and c. Apply a **quadratic function** of the form f(x) = ax2 + bx + c to each element x in the array. \\n\\nWhy *a* could be 0 when the question clearly states **quadratic function**?\\n\\nAccording to Wikipedia: In algebra, a quadratic function, a quadratic polynomial, a polynomial of degree 2, or simply a quadratic, is a polynomial function in one or more variables in which the highest-degree term is of the **second** degree. Doesn\\'t that imply *a* cannot be 0?"
                    },
                    {
                        "username": "Medium",
                        "content": "Check this testcase out. The expected output is reversed in leetcode solver.\\n\\n[-4,-2,2,4]\\n0\\n-1\\n5"
                    },
                    {
                        "username": "diyue",
                        "content": "High school memories... "
                    }
                ]
            },
            {
                "id": 1963625,
                "content": [
                    {
                        "username": "kkspeed3",
                        "content": "Given a sorted array of integers nums and integer values a, b and c. Apply a **quadratic function** of the form f(x) = ax2 + bx + c to each element x in the array. \\n\\nWhy *a* could be 0 when the question clearly states **quadratic function**?\\n\\nAccording to Wikipedia: In algebra, a quadratic function, a quadratic polynomial, a polynomial of degree 2, or simply a quadratic, is a polynomial function in one or more variables in which the highest-degree term is of the **second** degree. Doesn\\'t that imply *a* cannot be 0?"
                    },
                    {
                        "username": "Medium",
                        "content": "Check this testcase out. The expected output is reversed in leetcode solver.\\n\\n[-4,-2,2,4]\\n0\\n-1\\n5"
                    },
                    {
                        "username": "diyue",
                        "content": "High school memories... "
                    }
                ]
            }
        ]
    },
    {
        "title": "LFU Cache",
        "question_content": "<p>Design and implement a data structure for a <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\" target=\"_blank\">Least Frequently Used (LFU)</a> cache.</p>\n\n<p>Implement the <code>LFUCache</code> class:</p>\n\n<ul>\n\t<li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li>\n\t<li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li>\n</ul>\n\n<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>\n\n<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>\n\n<p>The functions&nbsp;<code data-stringify-type=\"code\">get</code>&nbsp;and&nbsp;<code data-stringify-type=\"code\">put</code>&nbsp;must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n<strong>Explanation</strong>\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n&nbsp;                // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<span style=\"display: none;\">&nbsp;</span>",
        "solutions": [
            {
                "id": 207673,
                "title": "python-concise-solution-detailed-explanation-two-dict-doubly-linked-list",
                "content": "\\n## What is my data structure?\\n  \\n  \\n  \\n### 1. A Doubly linked Node \\n  \\n```\\nclass Node:\\n\\t+ key: int\\n\\t+ value: int\\n\\t+ freq: int\\n\\t+ prev: Node\\n\\t+ next: Node\\n```\\n  \\n  \\n  \\n### 2. A Doubly Linked List\\n\\n**Note: This part could be replaced by `OrderedDict`, I implemented it by hand for clarity**\\n```\\nclass DLinkedList:\\n\\t- sentinel: Node\\n\\t+ size: int\\n\\t+ append(node: Node) -> None\\n\\t+ pop(node: Node) -> Node\\n```\\n\\n\\n\\n### 3. Our LFUCache\\n\\n```\\nclass LFUCache:\\n\\t- node: dict[key: int, node: Node]\\n\\t- freq: dict[freq: int, lst: DlinkedList]\\n\\t- minfreq: int\\n\\t+ get(key: int) -> int\\n\\t+ put(key: int, value: int) -> None\\n```\\n\\n\\n\\n\\n## Visualization\\n\\n![image](https://assets.leetcode.com/users/k_kkkyle/image_1545365613.png)\\n\\n\\n\\n\\n\\n## Explanation\\n\\nEach key is mapping to the corresponding node (`self._node`), where we can retrieve the node in `O(1)` time.\\n\\nEach frequency `freq` is mapped to a Doubly Linked List (`self._freq`), where all nodes in the `DLinkedList` have the same frequency, `freq`. Moreover, each node will be always inserted in the head (indicating most recently used). \\n\\nA minimum frequency `self._minfreq` is maintained to keep track of the minimum frequency of across all nodes in this cache, such that the DLinkedList with the min frequency can always be retrieved in O(1) time.\\n\\n\\n\\n## Here is how the algorithm works\\n\\n**get(key)**\\n\\n1. query the `node` by calling `self._node[key]`\\n2. find the frequency by checking `node.freq`, assigned as `f`, and query the `DLinkedList` that this node is in, through calling `self._freq[f]`\\n3. pop this node\\n4. update node\\'s frequence, append the node to the new `DLinkedList` with frequency `f+1`\\n5. if the `DLinkedList` is empty and `self._minfreq == f`, update `self._minfreq` to `f+1`.\\n6. return `node.val`\\n\\n**put(key, value)**\\n\\n- If key is already in cache, do the same thing as `get(key)`, and update `node.val` as `value`\\n- Otherwise:\\n\\t1. if the cache is full, pop the least frequenly used element (\\\\*)\\n\\t2. add new node to `self._node`\\n\\t3. add new node to `self._freq[1]`\\n\\t4. reset `self._minfreq` to 1\\n\\n(\\\\*) The least frequently used element is the **tail element in the DLinkedList with frequency self.\\\\_minfreq**\\n\\n\\n## Implementation\\n\\nBelow is the implementation with detailed comment as well.\\n\\n``` python\\nimport collections\\n\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.freq = 1\\n        self.prev = self.next = None\\n\\nclass DLinkedList:\\n    \"\"\" An implementation of doubly linked list.\\n\\t\\n\\tTwo APIs provided:\\n    \\n    append(node): append the node to the head of the linked list.\\n    pop(node=None): remove the referenced node. \\n                    If None is given, remove the one from tail, which is the least recently used.\\n                    \\n    Both operation, apparently, are in O(1) complexity.\\n    \"\"\"\\n    def __init__(self):\\n        self._sentinel = Node(None, None) # dummy node\\n        self._sentinel.next = self._sentinel.prev = self._sentinel\\n        self._size = 0\\n    \\n    def __len__(self):\\n        return self._size\\n    \\n    def append(self, node):\\n        node.next = self._sentinel.next\\n        node.prev = self._sentinel\\n        node.next.prev = node\\n        self._sentinel.next = node\\n        self._size += 1\\n    \\n    def pop(self, node=None):\\n        if self._size == 0:\\n            return\\n        \\n        if not node:\\n            node = self._sentinel.prev\\n\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self._size -= 1\\n        \\n        return node\\n        \\nclass LFUCache:\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \\n        Three things to maintain:\\n        \\n        1. a dict, named as `self._node`, for the reference of all nodes given key.\\n           That is, O(1) time to retrieve node given a key.\\n           \\n        2. Each frequency has a doubly linked list, store in `self._freq`, where key\\n           is the frequency, and value is an object of `DLinkedList`\\n        \\n        3. The min frequency through all nodes. We can maintain this in O(1) time, taking\\n           advantage of the fact that the frequency can only increment by 1. Use the following\\n\\t\\t   two rules:\\n           \\n           Rule 1: Whenever we see the size of the DLinkedList of current min frequency is 0,\\n                   the min frequency must increment by 1.\\n           \\n           Rule 2: Whenever put in a new (key, value), the min frequency must 1 (the new node)\\n           \\n        \"\"\"\\n        self._size = 0\\n        self._capacity = capacity\\n        \\n        self._node = dict() # key: Node\\n        self._freq = collections.defaultdict(DLinkedList)\\n        self._minfreq = 0\\n        \\n        \\n    def _update(self, node):\\n        \"\"\" \\n        This is a helper function that used in the following two cases:\\n        \\n            1. when `get(key)` is called; and\\n            2. when `put(key, value)` is called and the key exists.\\n         \\n        The common point of these two cases is that:\\n        \\n            1. no new node comes in, and\\n            2. the node is visited one more times -> node.freq changed -> \\n               thus the place of this node will change\\n        \\n        The logic of this function is:\\n        \\n            1. pop the node from the old DLinkedList (with freq `f`)\\n            2. append the node to new DLinkedList (with freq `f+1`)\\n            3. if old DlinkedList has size 0 and self._minfreq is `f`,\\n               update self._minfreq to `f+1`\\n        \\n        All of the above opeartions took O(1) time.\\n        \"\"\"\\n        freq = node.freq\\n        \\n        self._freq[freq].pop(node)\\n        if self._minfreq == freq and not self._freq[freq]:\\n            self._minfreq += 1\\n        \\n        node.freq += 1\\n        freq = node.freq\\n        self._freq[freq].append(node)\\n    \\n    def get(self, key):\\n        \"\"\"\\n        Through checking self._node[key], we can get the node in O(1) time.\\n        Just performs self._update, then we can return the value of node.\\n        \\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self._node:\\n            return -1\\n        \\n        node = self._node[key]\\n        self._update(node)\\n        return node.val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        If `key` already exists in self._node, we do the same operations as `get`, except\\n        updating the node.val to new value.\\n        \\n        Otherwise, the following logic will be performed\\n        \\n        1. if the cache reaches its capacity, pop the least frequently used item. (*)\\n        2. add new node to self._node\\n        3. add new node to the DLinkedList with frequency 1\\n        4. reset self._minfreq to 1\\n        \\n        (*) How to pop the least frequently used item? Two facts:\\n        \\n        1. we maintain the self._minfreq, the minimum possible frequency in cache.\\n        2. All cache with the same frequency are stored as a DLinkedList, with\\n           recently used order (Always append at head)\\n          \\n        Consequence? ==> The tail of the DLinkedList with self._minfreq is the least\\n                         recently used one, pop it...\\n        \\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self._capacity == 0:\\n            return\\n        \\n        if key in self._node:\\n            node = self._node[key]\\n            self._update(node)\\n            node.val = value\\n        else:\\n            if self._size == self._capacity:\\n                node = self._freq[self._minfreq].pop()\\n                del self._node[node.key]\\n                self._size -= 1\\n                \\n            node = Node(key, value)\\n            self._node[key] = node\\n            self._freq[1].append(node)\\n            self._minfreq = 1\\n            self._size += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n\\t+ key: int\\n\\t+ value: int\\n\\t+ freq: int\\n\\t+ prev: Node\\n\\t+ next: Node\\n```\n```\\nclass DLinkedList:\\n\\t- sentinel: Node\\n\\t+ size: int\\n\\t+ append(node: Node) -> None\\n\\t+ pop(node: Node) -> Node\\n```\n```\\nclass LFUCache:\\n\\t- node: dict[key: int, node: Node]\\n\\t- freq: dict[freq: int, lst: DlinkedList]\\n\\t- minfreq: int\\n\\t+ get(key: int) -> int\\n\\t+ put(key: int, value: int) -> None\\n```\n``` python\\nimport collections\\n\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.freq = 1\\n        self.prev = self.next = None\\n\\nclass DLinkedList:\\n    \"\"\" An implementation of doubly linked list.\\n\\t\\n\\tTwo APIs provided:\\n    \\n    append(node): append the node to the head of the linked list.\\n    pop(node=None): remove the referenced node. \\n                    If None is given, remove the one from tail, which is the least recently used.\\n                    \\n    Both operation, apparently, are in O(1) complexity.\\n    \"\"\"\\n    def __init__(self):\\n        self._sentinel = Node(None, None) # dummy node\\n        self._sentinel.next = self._sentinel.prev = self._sentinel\\n        self._size = 0\\n    \\n    def __len__(self):\\n        return self._size\\n    \\n    def append(self, node):\\n        node.next = self._sentinel.next\\n        node.prev = self._sentinel\\n        node.next.prev = node\\n        self._sentinel.next = node\\n        self._size += 1\\n    \\n    def pop(self, node=None):\\n        if self._size == 0:\\n            return\\n        \\n        if not node:\\n            node = self._sentinel.prev\\n\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self._size -= 1\\n        \\n        return node\\n        \\nclass LFUCache:\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \\n        Three things to maintain:\\n        \\n        1. a dict, named as `self._node`, for the reference of all nodes given key.\\n           That is, O(1) time to retrieve node given a key.\\n           \\n        2. Each frequency has a doubly linked list, store in `self._freq`, where key\\n           is the frequency, and value is an object of `DLinkedList`\\n        \\n        3. The min frequency through all nodes. We can maintain this in O(1) time, taking\\n           advantage of the fact that the frequency can only increment by 1. Use the following\\n\\t\\t   two rules:\\n           \\n           Rule 1: Whenever we see the size of the DLinkedList of current min frequency is 0,\\n                   the min frequency must increment by 1.\\n           \\n           Rule 2: Whenever put in a new (key, value), the min frequency must 1 (the new node)\\n           \\n        \"\"\"\\n        self._size = 0\\n        self._capacity = capacity\\n        \\n        self._node = dict() # key: Node\\n        self._freq = collections.defaultdict(DLinkedList)\\n        self._minfreq = 0\\n        \\n        \\n    def _update(self, node):\\n        \"\"\" \\n        This is a helper function that used in the following two cases:\\n        \\n            1. when `get(key)` is called; and\\n            2. when `put(key, value)` is called and the key exists.\\n         \\n        The common point of these two cases is that:\\n        \\n            1. no new node comes in, and\\n            2. the node is visited one more times -> node.freq changed -> \\n               thus the place of this node will change\\n        \\n        The logic of this function is:\\n        \\n            1. pop the node from the old DLinkedList (with freq `f`)\\n            2. append the node to new DLinkedList (with freq `f+1`)\\n            3. if old DlinkedList has size 0 and self._minfreq is `f`,\\n               update self._minfreq to `f+1`\\n        \\n        All of the above opeartions took O(1) time.\\n        \"\"\"\\n        freq = node.freq\\n        \\n        self._freq[freq].pop(node)\\n        if self._minfreq == freq and not self._freq[freq]:\\n            self._minfreq += 1\\n        \\n        node.freq += 1\\n        freq = node.freq\\n        self._freq[freq].append(node)\\n    \\n    def get(self, key):\\n        \"\"\"\\n        Through checking self._node[key], we can get the node in O(1) time.\\n        Just performs self._update, then we can return the value of node.\\n        \\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self._node:\\n            return -1\\n        \\n        node = self._node[key]\\n        self._update(node)\\n        return node.val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        If `key` already exists in self._node, we do the same operations as `get`, except\\n        updating the node.val to new value.\\n        \\n        Otherwise, the following logic will be performed\\n        \\n        1. if the cache reaches its capacity, pop the least frequently used item. (*)\\n        2. add new node to self._node\\n        3. add new node to the DLinkedList with frequency 1\\n        4. reset self._minfreq to 1\\n        \\n        (*) How to pop the least frequently used item? Two facts:\\n        \\n        1. we maintain the self._minfreq, the minimum possible frequency in cache.\\n        2. All cache with the same frequency are stored as a DLinkedList, with\\n           recently used order (Always append at head)\\n          \\n        Consequence? ==> The tail of the DLinkedList with self._minfreq is the least\\n                         recently used one, pop it...\\n        \\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self._capacity == 0:\\n            return\\n        \\n        if key in self._node:\\n            node = self._node[key]\\n            self._update(node)\\n            node.val = value\\n        else:\\n            if self._size == self._capacity:\\n                node = self._freq[self._minfreq].pop()\\n                del self._node[node.key]\\n                self._size -= 1\\n                \\n            node = Node(key, value)\\n            self._node[key] = node\\n            self._freq[1].append(node)\\n            self._minfreq = 1\\n            self._size += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94521,
                "title": "java-o-1-very-easy-solution-using-3-hashmaps-and-linkedhashset",
                "content": "```Java\\npublic class LFUCache {\\n    HashMap<Integer, Integer> vals;\\n    HashMap<Integer, Integer> counts;\\n    HashMap<Integer, LinkedHashSet<Integer>> lists;\\n    int cap;\\n    int min = -1;\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n        vals = new HashMap<>();\\n        counts = new HashMap<>();\\n        lists = new HashMap<>();\\n        lists.put(1, new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if(!vals.containsKey(key))\\n            return -1;\\n        int count = counts.get(key);\\n        counts.put(key, count+1);\\n        lists.get(count).remove(key);\\n        if(count==min && lists.get(count).size()==0)\\n            min++;\\n        if(!lists.containsKey(count+1))\\n            lists.put(count+1, new LinkedHashSet<>());\\n        lists.get(count+1).add(key);\\n        return vals.get(key);\\n    }\\n    \\n    public void set(int key, int value) {\\n        if(cap<=0)\\n            return;\\n        if(vals.containsKey(key)) {\\n            vals.put(key, value);\\n            get(key);\\n            return;\\n        } \\n        if(vals.size() >= cap) {\\n            int evit = lists.get(min).iterator().next();\\n            lists.get(min).remove(evit);\\n            vals.remove(evit);\\n        }\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        min = 1;\\n        lists.get(1).add(key);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic class LFUCache {\\n    HashMap<Integer, Integer> vals;\\n    HashMap<Integer, Integer> counts;\\n    HashMap<Integer, LinkedHashSet<Integer>> lists;\\n    int cap;\\n    int min = -1;\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n        vals = new HashMap<>();\\n        counts = new HashMap<>();\\n        lists = new HashMap<>();\\n        lists.put(1, new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if(!vals.containsKey(key))\\n            return -1;\\n        int count = counts.get(key);\\n        counts.put(key, count+1);\\n        lists.get(count).remove(key);\\n        if(count==min && lists.get(count).size()==0)\\n            min++;\\n        if(!lists.containsKey(count+1))\\n            lists.put(count+1, new LinkedHashSet<>());\\n        lists.get(count+1).add(key);\\n        return vals.get(key);\\n    }\\n    \\n    public void set(int key, int value) {\\n        if(cap<=0)\\n            return;\\n        if(vals.containsKey(key)) {\\n            vals.put(key, value);\\n            get(key);\\n            return;\\n        } \\n        if(vals.size() >= cap) {\\n            int evit = lists.get(min).iterator().next();\\n            lists.get(min).remove(evit);\\n            vals.remove(evit);\\n        }\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        min = 1;\\n        lists.get(1).add(key);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94547,
                "title": "java-o-1-solution-using-two-hashmap-and-one-doublelinkedlist",
                "content": "\\n\\n\\n```\\npublic class LFUCache {\\n    class Node {\\n        int key, val, cnt;\\n        Node prev, next;\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            cnt = 1;\\n        }\\n    }\\n    \\n    class DLList {\\n        Node head, tail;\\n        int size;\\n        DLList() {\\n            head = new Node(0, 0);\\n            tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n        \\n        void add(Node node) {\\n            head.next.prev = node;\\n            node.next = head.next;\\n            node.prev = head;\\n            head.next = node;\\n            size++;\\n        }\\n        \\n        void remove(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;\\n        }\\n        \\n        Node removeLast() {\\n            if (size > 0) {\\n                Node node = tail.prev;\\n                remove(node);\\n                return node;\\n            }\\n            else return null;\\n        }\\n    }\\n    \\n    int capacity, size, min;\\n    Map<Integer, Node> nodeMap;\\n    Map<Integer, DLList> countMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        nodeMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = nodeMap.get(key);\\n        if (node == null) return -1;\\n        update(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        Node node;\\n        if (nodeMap.containsKey(key)) {\\n            node = nodeMap.get(key);\\n            node.val = value;\\n            update(node);\\n        }\\n        else {\\n            node = new Node(key, value);\\n            nodeMap.put(key, node);\\n            if (size == capacity) {\\n                DLList lastList = countMap.get(min);\\n                nodeMap.remove(lastList.removeLast().key);\\n                size--;\\n            }\\n            size++;\\n            min = 1;\\n            DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n            newList.add(node);\\n            countMap.put(node.cnt, newList);\\n        }\\n    }\\n    \\n    private void update(Node node) {\\n        DLList oldList = countMap.get(node.cnt);\\n        oldList.remove(node);\\n        if (node.cnt == min && oldList.size == 0) min++; \\n        node.cnt++;\\n        DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n        newList.add(node);\\n        countMap.put(node.cnt, newList);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LFUCache {\\n    class Node {\\n        int key, val, cnt;\\n        Node prev, next;\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            cnt = 1;\\n        }\\n    }\\n    \\n    class DLList {\\n        Node head, tail;\\n        int size;\\n        DLList() {\\n            head = new Node(0, 0);\\n            tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n        \\n        void add(Node node) {\\n            head.next.prev = node;\\n            node.next = head.next;\\n            node.prev = head;\\n            head.next = node;\\n            size++;\\n        }\\n        \\n        void remove(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;\\n        }\\n        \\n        Node removeLast() {\\n            if (size > 0) {\\n                Node node = tail.prev;\\n                remove(node);\\n                return node;\\n            }\\n            else return null;\\n        }\\n    }\\n    \\n    int capacity, size, min;\\n    Map<Integer, Node> nodeMap;\\n    Map<Integer, DLList> countMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        nodeMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = nodeMap.get(key);\\n        if (node == null) return -1;\\n        update(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        Node node;\\n        if (nodeMap.containsKey(key)) {\\n            node = nodeMap.get(key);\\n            node.val = value;\\n            update(node);\\n        }\\n        else {\\n            node = new Node(key, value);\\n            nodeMap.put(key, node);\\n            if (size == capacity) {\\n                DLList lastList = countMap.get(min);\\n                nodeMap.remove(lastList.removeLast().key);\\n                size--;\\n            }\\n            size++;\\n            min = 1;\\n            DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n            newList.add(node);\\n            countMap.put(node.cnt, newList);\\n        }\\n    }\\n    \\n    private void update(Node node) {\\n        DLList oldList = countMap.get(node.cnt);\\n        oldList.remove(node);\\n        if (node.cnt == min && oldList.size == 0) min++; \\n        node.cnt++;\\n        DLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n        newList.add(node);\\n        countMap.put(node.cnt, newList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94516,
                "title": "concise-c-o-1-solution-using-3-hash-maps-with-explanation",
                "content": "//minFreq is the smallest frequency so far\\n//The main idea is to put all keys with the same frequency to a linked list so the most recent one can be evicted;\\n//mIter stored the key's position in the linked list;\\n\\n```\\nclass LFUCache {\\n    int cap;\\n    int size;\\n    int minFreq;\\n    unordered_map<int, pair<int, int>> m; //key to {value,freq};\\n    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;\\n    unordered_map<int, list<int>>  fm;  //freq to key list;\\npublic:\\n    LFUCache(int capacity) {\\n        cap=capacity;\\n        size=0;\\n    }\\n    \\n    int get(int key) {\\n        if(m.count(key)==0) return -1;\\n        \\n        fm[m[key].second].erase(mIter[key]);\\n        m[key].second++;\\n        fm[m[key].second].push_back(key);\\n        mIter[key]=--fm[m[key].second].end();\\n        \\n        if(fm[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        return m[key].first;\\n    }\\n    \\n   void set(int key, int value) {\\n        if(cap<=0) return;\\n        \\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            m[key].first=value;\\n            return;\\n        }\\n        \\n        if(size>=cap )\\n        {\\n            m.erase( fm[minFreq].front() );\\n            mIter.erase( fm[minFreq].front() );\\n            fm[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        m[key]={value, 1};\\n        fm[1].push_back(key);\\n        mIter[key]=--fm[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    int cap;\\n    int size;\\n    int minFreq;\\n    unordered_map<int, pair<int, int>> m; //key to {value,freq};\\n    unordered_map<int, list<int>::iterator> mIter; //key to list iterator;\\n    unordered_map<int, list<int>>  fm;  //freq to key list;\\npublic:\\n    LFUCache(int capacity) {\\n        cap=capacity;\\n        size=0;\\n    }\\n    \\n    int get(int key) {\\n        if(m.count(key)==0) return -1;\\n        \\n        fm[m[key].second].erase(mIter[key]);\\n        m[key].second++;\\n        fm[m[key].second].push_back(key);\\n        mIter[key]=--fm[m[key].second].end();\\n        \\n        if(fm[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        return m[key].first;\\n    }\\n    \\n   void set(int key, int value) {\\n        if(cap<=0) return;\\n        \\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            m[key].first=value;\\n            return;\\n        }\\n        \\n        if(size>=cap )\\n        {\\n            m.erase( fm[minFreq].front() );\\n            mIter.erase( fm[minFreq].front() );\\n            fm[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        m[key]={value, 1};\\n        fm[1].push_back(key);\\n        mIter[key]=--fm[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166683,
                "title": "python-only-use-ordereddict-get-o-1-put-o-1-simple-and-brief-explained",
                "content": "First, `OrderedDict` is a `dict` + `double linked list`.\\n\\nA count2node is a `dict of OrderedDict`, so you can look up like this `count2node[count][key]` to remove/update the node in O(1), or `count2node[count].popitem(last=True)` to remove the oldest node in O(1). \\n\\nWith this tool, we can easily write a simple code like this:\\n```\\nfrom collections import defaultdict\\nfrom collections import OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, val, count):\\n        self.key = key\\n        self.val = val\\n        self.count = count\\n    \\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.key2node = {}\\n        self.count2node = defaultdict(OrderedDict)\\n        self.minCount = None\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        del self.count2node[node.count][key]\\n        \\n        # clean memory\\n        if not self.count2node[node.count]:\\n            del self.count2node[node.count]\\n        \\n        node.count += 1\\n        self.count2node[node.count][key] = node\\n        \\n        # NOTICE check minCount!!!\\n        if not self.count2node[self.minCount]:\\n            self.minCount += 1\\n            \\n            \\n        return node.val\\n        \\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if not self.cap:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            self.get(key) # NOTICE, put makes count+1 too\\n            return\\n        \\n        if len(self.key2node) == self.cap:\\n            # popitem(last=False) is FIFO, like queue\\n            # it return key and value!!!\\n            k, n = self.count2node[self.minCount].popitem(last=False) \\n            del self.key2node[k] \\n        \\n        self.count2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.minCount = 1\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom collections import OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, val, count):\\n        self.key = key\\n        self.val = val\\n        self.count = count\\n    \\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.key2node = {}\\n        self.count2node = defaultdict(OrderedDict)\\n        self.minCount = None\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        del self.count2node[node.count][key]\\n        \\n        # clean memory\\n        if not self.count2node[node.count]:\\n            del self.count2node[node.count]\\n        \\n        node.count += 1\\n        self.count2node[node.count][key] = node\\n        \\n        # NOTICE check minCount!!!\\n        if not self.count2node[self.minCount]:\\n            self.minCount += 1\\n            \\n            \\n        return node.val\\n        \\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if not self.cap:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            self.get(key) # NOTICE, put makes count+1 too\\n            return\\n        \\n        if len(self.key2node) == self.cap:\\n            # popitem(last=False) is FIFO, like queue\\n            # it return key and value!!!\\n            k, n = self.count2node[self.minCount].popitem(last=False) \\n            del self.key2node[k] \\n        \\n        self.count2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.minCount = 1\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111409,
                "title": "day-29-c-easiest-beginner-friendly-sol-hashmap-and-doubly-linked-list",
                "content": "# Intuition of this Problem:\\n**For get(key) -->** *gets the value of the key if exists, else -1;*\\n\\n**for put(key, value) -->**\\n***condition 1:** updates the value of the key if present, else inserts the key directly.\\n**condition 2:** when cache is full -->\\n    - case i : if cache is full, removes the LFU guy\\n    - case ii : if cache is full, but exists multiple LFU guys (or a tie exists), then remove the LRU one and then add new node.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. The class LFUCache has three unordered_map data structures:\\n    - keyVal: stores the key-value pairs, with the key as the first element of the pair and the value as the second element.\\n    - freqList: stores the keys in a list, with the key\\'s frequency as the index of the list.\\n    - pos: stores the position of each key in the freqList.\\n1. The class also has a private integer variable \\'capacity\\' that is initialized in the constructor and represents the maximum number of key-value pairs that can be stored in the cache.\\n2. The get() function is used to retrieve a value from the cache given a key. If the key is not found in the keyVal map, -1 is returned. Otherwise, the following steps are taken:\\n    - The key\\'s current frequency is retrieved from keyVal.\\n    - The key is removed from the list at index equal to its current frequency in the freqList map.\\n    - The key\\'s frequency in keyVal is incremented by 1.\\n    - The key is added to the list at index equal to its new frequency in the freqList map.\\n    - The key\\'s position in the freqList map is updated in the pos map.\\n    - If the list at index equal to the current minimum frequency is empty, the minimum frequency is incremented by 1.\\n    - The value associated with the key is returned.\\n1. The put() function is used to add a new key-value pair to the cache or update the value of an existing key.\\n    - If the capacity is 0, the function returns immediately.\\n    - If the key already exists in the keyVal map, the following steps are taken:\\n        - The key\\'s value is updated in the keyVal map.\\n        - The key is removed from the list at index equal to its current frequency in the freqList map.\\n        - The key\\'s frequency in keyVal is incremented by 1.\\n        - The key is added to the list at index equal to its new frequency in the freqList map.\\n        - The key\\'s position in the freqList map is updated in the pos map.\\n        - If the list at index equal to the current minimum frequency is empty, the minimum frequency is incremented by 1.\\n    - If the key does not already exist in the keyVal map and the size of keyVal is equal to the capacity, the following steps are taken:\\n        - The key at the front of the list at index equal to the current minimum frequency in the freqList map is removed from all three maps (keyVal, freqList, pos).\\n    - A new key-value pair is added to keyVal, with a frequency of 1.\\n    - The key is added to the list at index 1 in the freqList map.The key\\'s position in the freqList map is updated in the pos map.\\n    - The minimum frequency is set to 1.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code:\\n```C++ []\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n```Java []\\n\\n```\\n```Python []\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity:\\n    - get(): O(1)\\n    - put(): O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** //where n is the capacity of the cache.\\n\\nIn this implementation, we are using three unordered_maps to store the key-value pairs, the frequency lists, and the positions of the keys in the frequency lists. This allows us to quickly access, update and remove elements in O(1) time complexity. The get() and put() operations both have O(1) time complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```C++ []\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\n```Java []\\n\\n```\n```Python []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94515,
                "title": "java-o-1-accept-solution-using-hashmap-doublelinkedlist-and-linkedhashset",
                "content": "Two HashMaps are used, one to store <key, value> pair, another store the <key, node>.\\nI use double linked list to keep the frequent of each key. In each double linked list node, keys with the same count are saved using java built in LinkedHashSet. This can keep the order.\\nEvery time, one key is referenced, first find the current node corresponding to the key, If the following node exist and the frequent is larger by one, add key to the keys of the following node, else create a new node and add it following the current node. \\nAll operations are guaranteed to be O(1).\\n```\\npublic class LFUCache {\\n    private Node head = null;\\n    private int cap = 0;\\n    private HashMap<Integer, Integer> valueHash = null;\\n    private HashMap<Integer, Node> nodeHash = null;\\n    \\n    public LFUCache(int capacity) {\\n        this.cap = capacity;\\n        valueHash = new HashMap<Integer, Integer>();\\n        nodeHash = new HashMap<Integer, Node>();\\n    }\\n    \\n    public int get(int key) {\\n        if (valueHash.containsKey(key)) {\\n            increaseCount(key);\\n            return valueHash.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if ( cap == 0 ) return;\\n        if (valueHash.containsKey(key)) {\\n            valueHash.put(key, value);\\n        } else {\\n            if (valueHash.size() < cap) {\\n                valueHash.put(key, value);\\n            } else {\\n                removeOld();\\n                valueHash.put(key, value);\\n            }\\n            addToHead(key);\\n        }\\n        increaseCount(key);\\n    }\\n    \\n    private void addToHead(int key) {\\n        if (head == null) {\\n            head = new Node(0);\\n            head.keys.add(key);\\n        } else if (head.count > 0) {\\n            Node node = new Node(0);\\n            node.keys.add(key);\\n            node.next = head;\\n            head.prev = node;\\n            head = node;\\n        } else {\\n            head.keys.add(key);\\n        }\\n        nodeHash.put(key, head);      \\n    }\\n    \\n    private void increaseCount(int key) {\\n        Node node = nodeHash.get(key);\\n        node.keys.remove(key);\\n        \\n        if (node.next == null) {\\n            node.next = new Node(node.count+1);\\n            node.next.prev = node;\\n            node.next.keys.add(key);\\n        } else if (node.next.count == node.count+1) {\\n            node.next.keys.add(key);\\n        } else {\\n            Node tmp = new Node(node.count+1);\\n            tmp.keys.add(key);\\n            tmp.prev = node;\\n            tmp.next = node.next;\\n            node.next.prev = tmp;\\n            node.next = tmp;\\n        }\\n\\n        nodeHash.put(key, node.next);\\n        if (node.keys.size() == 0) remove(node);\\n    }\\n    \\n    private void removeOld() {\\n        if (head == null) return;\\n        int old = 0;\\n        for (int n: head.keys) {\\n            old = n;\\n            break;\\n        }\\n        head.keys.remove(old);\\n        if (head.keys.size() == 0) remove(head);\\n        nodeHash.remove(old);\\n        valueHash.remove(old);\\n    }\\n    \\n    private void remove(Node node) {\\n        if (node.prev == null) {\\n            head = node.next;\\n        } else {\\n            node.prev.next = node.next;\\n        } \\n        if (node.next != null) {\\n            node.next.prev = node.prev;\\n        }\\n    }\\n    \\n    class Node {\\n        public int count = 0;\\n        public LinkedHashSet<Integer> keys = null;\\n        public Node prev = null, next = null;\\n        \\n        public Node(int count) {\\n            this.count = count;\\n            keys = new LinkedHashSet<Integer>();\\n            prev = next = null;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "Two HashMaps are used, one to store <key, value> pair, another store the <key, node>.\\nI use double linked list to keep the frequent of each key. In each double linked list node, keys with the same count are saved using java built in LinkedHashSet. This can keep the order.\\nEvery time, one key is referenced, first find the current node corresponding to the key, If the following node exist and the frequent is larger by one, add key to the keys of the following node, else create a new node and add it following the current node. \\nAll operations are guaranteed to be O(1).\\n```\\npublic class LFUCache {\\n    private Node head = null;\\n    private int cap = 0;\\n    private HashMap<Integer, Integer> valueHash = null;\\n    private HashMap<Integer, Node> nodeHash = null;\\n    \\n    public LFUCache(int capacity) {\\n        this.cap = capacity;\\n        valueHash = new HashMap<Integer, Integer>();\\n        nodeHash = new HashMap<Integer, Node>();\\n    }\\n    \\n    public int get(int key) {\\n        if (valueHash.containsKey(key)) {\\n            increaseCount(key);\\n            return valueHash.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if ( cap == 0 ) return;\\n        if (valueHash.containsKey(key)) {\\n            valueHash.put(key, value);\\n        } else {\\n            if (valueHash.size() < cap) {\\n                valueHash.put(key, value);\\n            } else {\\n                removeOld();\\n                valueHash.put(key, value);\\n            }\\n            addToHead(key);\\n        }\\n        increaseCount(key);\\n    }\\n    \\n    private void addToHead(int key) {\\n        if (head == null) {\\n            head = new Node(0);\\n            head.keys.add(key);\\n        } else if (head.count > 0) {\\n            Node node = new Node(0);\\n            node.keys.add(key);\\n            node.next = head;\\n            head.prev = node;\\n            head = node;\\n        } else {\\n            head.keys.add(key);\\n        }\\n        nodeHash.put(key, head);      \\n    }\\n    \\n    private void increaseCount(int key) {\\n        Node node = nodeHash.get(key);\\n        node.keys.remove(key);\\n        \\n        if (node.next == null) {\\n            node.next = new Node(node.count+1);\\n            node.next.prev = node;\\n            node.next.keys.add(key);\\n        } else if (node.next.count == node.count+1) {\\n            node.next.keys.add(key);\\n        } else {\\n            Node tmp = new Node(node.count+1);\\n            tmp.keys.add(key);\\n            tmp.prev = node;\\n            tmp.next = node.next;\\n            node.next.prev = tmp;\\n            node.next = tmp;\\n        }\\n\\n        nodeHash.put(key, node.next);\\n        if (node.keys.size() == 0) remove(node);\\n    }\\n    \\n    private void removeOld() {\\n        if (head == null) return;\\n        int old = 0;\\n        for (int n: head.keys) {\\n            old = n;\\n            break;\\n        }\\n        head.keys.remove(old);\\n        if (head.keys.size() == 0) remove(head);\\n        nodeHash.remove(old);\\n        valueHash.remove(old);\\n    }\\n    \\n    private void remove(Node node) {\\n        if (node.prev == null) {\\n            head = node.next;\\n        } else {\\n            node.prev.next = node.next;\\n        } \\n        if (node.next != null) {\\n            node.next.prev = node.prev;\\n        }\\n    }\\n    \\n    class Node {\\n        public int count = 0;\\n        public LinkedHashSet<Integer> keys = null;\\n        public Node prev = null, next = null;\\n        \\n        public Node(int count) {\\n            this.count = count;\\n            keys = new LinkedHashSet<Integer>();\\n            prev = next = null;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3111521,
                "title": "o-1-time-full-explanation-hashtable-c-java-python3",
                "content": "# What is Cache & LFU Cache ?\\n1. A cache is a data structure that stores a limited number of items and is used to quickly retrieve items that have been previously accessed.\\n2. An LFU cache evicts the least frequently used item when it reaches capacity, as opposed to an LRU (Least Recently Used) cache, which evicts the least recently used item. \\n# Explanation to Approach :\\n- Here we are using three maps to store the key-value pairs, the key-frequency pairs and the frequency-key pairs. \\n- The implementation uses a combination of a HashMap and a LinkedHashSet to keep track of the keys and their frequencies, and to maintain the order of the keys. \\n- When the cache reaches its maximum capacity, the least frequently used item will be removed. \\n- This is done by keeping track of the number of times each item is accessed and removing the one that has been accessed the least amount of times. \\n- The get() method returns the value associated with the given key, and updates the key\\'s frequency. \\n- The put() method adds a new key-value pair to the cache, and evicts the least frequently used key if the cache is at capacity.\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ | Java] : with Comments\\n```C++ []\\nstruct Node {\\n  int key;\\n  int value;\\n  int freq;\\n  list<int>::const_iterator it;\\n};\\n\\nclass LFUCache {\\n public:\\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\\n\\n  int get(int key) {\\n    if (!keyToNode.count(key))\\n      return -1;\\n\\n    Node& node = keyToNode[key];\\n    touch(node);\\n    return node.value;\\n  }\\n\\n  void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToNode.count(key)) {\\n      Node& node = keyToNode[key];\\n      node.value = value;\\n      touch(node);\\n      return;\\n    }\\n\\n    if (keyToNode.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      const int keyToEvict = freqToList[minFreq].back();\\n      freqToList[minFreq].pop_back();\\n      keyToNode.erase(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    freqToList[1].push_front(key);\\n    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};\\n  }\\n\\n private:\\n  int capacity;\\n  int minFreq;\\n  unordered_map<int, Node> keyToNode;\\n  unordered_map<int, list<int>> freqToList;\\n\\n  void touch(Node& node) {\\n    // Update the node\\'s frequency\\n    const int prevFreq = node.freq;\\n    const int newFreq = ++node.freq;\\n\\n    // Remove the iterator from prevFreq\\'s list\\n    freqToList[prevFreq].erase(node.it);\\n    if (freqToList[prevFreq].empty()) {\\n      freqToList.erase(prevFreq);\\n      // Update minFreq if needed\\n      if (prevFreq == minFreq)\\n        ++minFreq;\\n    }\\n\\n    // Insert the key to the front of newFreq\\'s list\\n    freqToList[newFreq].push_front(node.key);\\n    node.it = cbegin(freqToList[newFreq]);\\n  }\\n};\\n```\\n```Java []\\nclass LFUCache {\\n  public LFUCache(int capacity) {\\n    this.capacity = capacity;\\n  }\\n\\n  public int get(int key) {\\n    if (!keyToVal.containsKey(key))\\n      return -1;\\n\\n    final int freq = keyToFreq.get(key);\\n    freqToLRUKeys.get(freq).remove(key);\\n    if (freq == minFreq && freqToLRUKeys.get(freq).isEmpty()) {\\n      freqToLRUKeys.remove(freq);\\n      ++minFreq;\\n    }\\n\\n    // Increase key\\'s freq by 1\\n    // Add this key to next freq\\'s list\\n    putFreq(key, freq + 1);\\n    return keyToVal.get(key);\\n  }\\n\\n  public void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToVal.containsKey(key)) {\\n      keyToVal.put(key, value);\\n      get(key); // Update key\\'s count\\n      return;\\n    }\\n\\n    if (keyToVal.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      final int keyToEvict = freqToLRUKeys.get(minFreq).iterator().next();\\n      freqToLRUKeys.get(minFreq).remove(keyToEvict);\\n      keyToVal.remove(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    putFreq(key, minFreq);    // Add new key and freq\\n    keyToVal.put(key, value); // Add new key and value\\n  }\\n\\n  private int capacity;\\n  private int minFreq = 0;\\n  private Map<Integer, Integer> keyToVal = new HashMap<>();\\n  private Map<Integer, Integer> keyToFreq = new HashMap<>();\\n  private Map<Integer, LinkedHashSet<Integer>> freqToLRUKeys = new HashMap<>();\\n\\n  private void putFreq(int key, int freq) {\\n    keyToFreq.put(key, freq);\\n    freqToLRUKeys.putIfAbsent(freq, new LinkedHashSet<>());\\n    freqToLRUKeys.get(freq).add(key);\\n  }\\n}\\n```\\n```Python3 []\\nfrom collections import deque, defaultdict, OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.freq = 1\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.minFreq = 0\\n        self.keyToNode = dict()\\n        self.freqToList = defaultdict(deque)\\n        self.freqToKey = defaultdict(set)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.keyToNode:\\n            return -1\\n        \\n        node = self.keyToNode[key]\\n        self.touch(node)\\n        return node.value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.keyToNode:\\n            node = self.keyToNode[key]\\n            node.value = value\\n            self.touch(node)\\n            return\\n        \\n        if len(self.keyToNode) == self.capacity:\\n            keyToEvict = self.freqToList[self.minFreq].pop()\\n            self.freqToKey[self.minFreq].remove(keyToEvict)\\n            del self.keyToNode[keyToEvict]\\n        \\n        self.minFreq = 1\\n        self.freqToList[1].appendleft(key)\\n        self.freqToKey[1].add(key)\\n        self.keyToNode[key] = Node(key, value)\\n        \\n\\n    def touch(self, node):\\n        prevFreq = node.freq\\n        newFreq = node.freq + 1\\n        self.freqToList[prevFreq].remove(node.key)\\n        self.freqToKey[prevFreq].remove(node.key)\\n        \\n        if len(self.freqToList[prevFreq]) == 0:\\n            del self.freqToList[prevFreq]\\n            if prevFreq == self.minFreq:\\n                self.minFreq += 1\\n        \\n        if newFreq not in self.freqToList:\\n            self.freqToList[newFreq] = deque()\\n            self.freqToKey[newFreq] = set()\\n            \\n        self.freqToList[newFreq].appendleft(node.key)\\n        self.freqToKey[newFreq].add(node.key)\\n        node.freq = newFreq\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/ea631a63-772d-4688-87ed-a27454217a2e_1674962684.5984573.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nstruct Node {\\n  int key;\\n  int value;\\n  int freq;\\n  list<int>::const_iterator it;\\n};\\n\\nclass LFUCache {\\n public:\\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\\n\\n  int get(int key) {\\n    if (!keyToNode.count(key))\\n      return -1;\\n\\n    Node& node = keyToNode[key];\\n    touch(node);\\n    return node.value;\\n  }\\n\\n  void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToNode.count(key)) {\\n      Node& node = keyToNode[key];\\n      node.value = value;\\n      touch(node);\\n      return;\\n    }\\n\\n    if (keyToNode.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      const int keyToEvict = freqToList[minFreq].back();\\n      freqToList[minFreq].pop_back();\\n      keyToNode.erase(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    freqToList[1].push_front(key);\\n    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};\\n  }\\n\\n private:\\n  int capacity;\\n  int minFreq;\\n  unordered_map<int, Node> keyToNode;\\n  unordered_map<int, list<int>> freqToList;\\n\\n  void touch(Node& node) {\\n    // Update the node\\'s frequency\\n    const int prevFreq = node.freq;\\n    const int newFreq = ++node.freq;\\n\\n    // Remove the iterator from prevFreq\\'s list\\n    freqToList[prevFreq].erase(node.it);\\n    if (freqToList[prevFreq].empty()) {\\n      freqToList.erase(prevFreq);\\n      // Update minFreq if needed\\n      if (prevFreq == minFreq)\\n        ++minFreq;\\n    }\\n\\n    // Insert the key to the front of newFreq\\'s list\\n    freqToList[newFreq].push_front(node.key);\\n    node.it = cbegin(freqToList[newFreq]);\\n  }\\n};\\n```\n```Java []\\nclass LFUCache {\\n  public LFUCache(int capacity) {\\n    this.capacity = capacity;\\n  }\\n\\n  public int get(int key) {\\n    if (!keyToVal.containsKey(key))\\n      return -1;\\n\\n    final int freq = keyToFreq.get(key);\\n    freqToLRUKeys.get(freq).remove(key);\\n    if (freq == minFreq && freqToLRUKeys.get(freq).isEmpty()) {\\n      freqToLRUKeys.remove(freq);\\n      ++minFreq;\\n    }\\n\\n    // Increase key\\'s freq by 1\\n    // Add this key to next freq\\'s list\\n    putFreq(key, freq + 1);\\n    return keyToVal.get(key);\\n  }\\n\\n  public void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToVal.containsKey(key)) {\\n      keyToVal.put(key, value);\\n      get(key); // Update key\\'s count\\n      return;\\n    }\\n\\n    if (keyToVal.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      final int keyToEvict = freqToLRUKeys.get(minFreq).iterator().next();\\n      freqToLRUKeys.get(minFreq).remove(keyToEvict);\\n      keyToVal.remove(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    putFreq(key, minFreq);    // Add new key and freq\\n    keyToVal.put(key, value); // Add new key and value\\n  }\\n\\n  private int capacity;\\n  private int minFreq = 0;\\n  private Map<Integer, Integer> keyToVal = new HashMap<>();\\n  private Map<Integer, Integer> keyToFreq = new HashMap<>();\\n  private Map<Integer, LinkedHashSet<Integer>> freqToLRUKeys = new HashMap<>();\\n\\n  private void putFreq(int key, int freq) {\\n    keyToFreq.put(key, freq);\\n    freqToLRUKeys.putIfAbsent(freq, new LinkedHashSet<>());\\n    freqToLRUKeys.get(freq).add(key);\\n  }\\n}\\n```\n```Python3 []\\nfrom collections import deque, defaultdict, OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.freq = 1\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.minFreq = 0\\n        self.keyToNode = dict()\\n        self.freqToList = defaultdict(deque)\\n        self.freqToKey = defaultdict(set)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.keyToNode:\\n            return -1\\n        \\n        node = self.keyToNode[key]\\n        self.touch(node)\\n        return node.value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.keyToNode:\\n            node = self.keyToNode[key]\\n            node.value = value\\n            self.touch(node)\\n            return\\n        \\n        if len(self.keyToNode) == self.capacity:\\n            keyToEvict = self.freqToList[self.minFreq].pop()\\n            self.freqToKey[self.minFreq].remove(keyToEvict)\\n            del self.keyToNode[keyToEvict]\\n        \\n        self.minFreq = 1\\n        self.freqToList[1].appendleft(key)\\n        self.freqToKey[1].add(key)\\n        self.keyToNode[key] = Node(key, value)\\n        \\n\\n    def touch(self, node):\\n        prevFreq = node.freq\\n        newFreq = node.freq + 1\\n        self.freqToList[prevFreq].remove(node.key)\\n        self.freqToKey[prevFreq].remove(node.key)\\n        \\n        if len(self.freqToList[prevFreq]) == 0:\\n            del self.freqToList[prevFreq]\\n            if prevFreq == self.minFreq:\\n                self.minFreq += 1\\n        \\n        if newFreq not in self.freqToList:\\n            self.freqToList[newFreq] = deque()\\n            self.freqToKey[newFreq] = set()\\n            \\n        self.freqToList[newFreq].appendleft(node.key)\\n        self.freqToKey[newFreq].add(node.key)\\n        node.freq = newFreq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369104,
                "title": "python-two-dicts-explanation",
                "content": "OrderedDict in python is implemented by a dict+linkedList, which is essentially a LRU cache.\\n\"keyfreq\" dict represents a normal dict that maps one key to one frequency.\\n\"freqkeys\" dict represents a dict that maps one freq to many keys, and these \"many keys\" are stored in OrderedDict.\\nWith this two dicts, given one key, we can find its frequency, and with its frequency, we can find all other keys of the same frequency.\\nWhen there are many items of same frequency, the OrderedDict in freqkeys dict correctly records the item order in LRC fashion where the first item will be the one to pop out.\\n\\n```\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity=capacity\\n        self.minfreq=None\\n        self.keyfreq={}\\n        self.freqkeys=collections.defaultdict(collections.OrderedDict)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.keyfreq:\\n            return -1\\n        freq=self.keyfreq[key]\\n        val=self.freqkeys[freq][key]\\n        del self.freqkeys[freq][key]\\n        if not self.freqkeys[freq]:\\n            if freq==self.minfreq:\\n                self.minfreq+=1\\n            del self.freqkeys[freq]\\n        self.keyfreq[key]=freq+1\\n        self.freqkeys[freq+1][key]=val\\n        return val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity<=0:\\n            return\\n        if key in self.keyfreq:\\n            freq=self.keyfreq[key]\\n            self.freqkeys[freq][key]=value\\n            self.get(key)\\n            return\\n        if self.capacity==len(self.keyfreq):\\n            delkey,delval=self.freqkeys[self.minfreq].popitem(last=False)\\n            del self.keyfreq[delkey]\\n        self.keyfreq[key]=1\\n        self.freqkeys[1][key]=value\\n        self.minfreq=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity=capacity\\n        self.minfreq=None\\n        self.keyfreq={}\\n        self.freqkeys=collections.defaultdict(collections.OrderedDict)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.keyfreq:\\n            return -1\\n        freq=self.keyfreq[key]\\n        val=self.freqkeys[freq][key]\\n        del self.freqkeys[freq][key]\\n        if not self.freqkeys[freq]:\\n            if freq==self.minfreq:\\n                self.minfreq+=1\\n            del self.freqkeys[freq]\\n        self.keyfreq[key]=freq+1\\n        self.freqkeys[freq+1][key]=val\\n        return val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity<=0:\\n            return\\n        if key in self.keyfreq:\\n            freq=self.keyfreq[key]\\n            self.freqkeys[freq][key]=value\\n            self.get(key)\\n            return\\n        if self.capacity==len(self.keyfreq):\\n            delkey,delval=self.freqkeys[self.minfreq].popitem(last=False)\\n            del self.keyfreq[delkey]\\n        self.keyfreq[key]=1\\n        self.freqkeys[1][key]=value\\n        self.minfreq=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800188,
                "title": "python-o-1-using-dll-and-dictionary",
                "content": "**Approach:**\\n\\n*Data Structures:*\\n1. Frequency Table: A dictionary to store the mapping of different frequency values with values as DLLs storing (key, value) pairs as nodes\\n2. Cache Dicitionary: Nodes in the DLL are stored as values for each key pushed into the cache\\n\\n*Algorithm:*\\n* get(key):\\n\\t* If key is not present in cache, return -1\\n\\t* Get the node from the cache\\n\\t* Update the node frequency\\n\\t* Remove the node from the DLL of node\\'s previous frequency\\n\\t* Add the node to the DLL with the node\\'s updated frequency\\n\\t* Update min frequency value\\n\\n* put(key, value):\\n\\t* If key is present in cache\\n\\t\\t* Similar logic to that of get function\\n\\t\\t* Only difference being that we need to update the value here\\n\\t* If key not present in cache\\n\\t\\t* If the cache has already reached it\\'s capacity, delete the tail node from the DLL with least frequency\\n\\t\\t* Create the new node with the (key, value) pair passed as arguments\\n\\t\\t* Add the node to the frequency table with frequency key = 1\\n\\t\\t* Add the node to the cache \\n\\t\\t* Update min frequency to be 1\\n\\n```\\nclass ListNode:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.freq = 1\\n        self.prev = None\\n        self.next = None\\n        \\nclass DLL:\\n    def __init__(self):\\n        self.head = ListNode(0, 0)\\n        self.tail = ListNode(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n        \\n    def insertHead(self, node):\\n        headNext = self.head.next\\n        headNext.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n        node.next = headNext\\n        self.size += 1\\n        \\n    def removeNode(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n        self.size -= 1\\n        \\n    def removeTail(self):\\n        tail = self.tail.prev\\n        self.removeNode(tail)\\n        return tail\\n    \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.freqTable = collections.defaultdict(DLL)\\n        self.capacity = capacity\\n        self.minFreq = 0\\n        \\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        return self.updateCache(self.cache[key], key, self.cache[key].val)\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity:\\n            return\\n        if key in self.cache:\\n            self.updateCache(self.cache[key], key, value)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                prevTail = self.freqTable[self.minFreq].removeTail()\\n                del self.cache[prevTail.key]\\n            node = ListNode(key, value)\\n            self.freqTable[1].insertHead(node)\\n            self.cache[key] = node\\n            self.minFreq = 1\\n        \\n    \\n    def updateCache(self, node, key, value):\\n        node = self.cache[key]\\n        node.val = value\\n        prevFreq = node.freq\\n        node.freq += 1\\n        self.freqTable[prevFreq].removeNode(node)\\n        self.freqTable[node.freq].insertHead(node)\\n        if prevFreq == self.minFreq and self.freqTable[prevFreq].size == 0:\\n            self.minFreq += 1\\n        return node.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.freq = 1\\n        self.prev = None\\n        self.next = None\\n        \\nclass DLL:\\n    def __init__(self):\\n        self.head = ListNode(0, 0)\\n        self.tail = ListNode(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n        \\n    def insertHead(self, node):\\n        headNext = self.head.next\\n        headNext.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n        node.next = headNext\\n        self.size += 1\\n        \\n    def removeNode(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n        self.size -= 1\\n        \\n    def removeTail(self):\\n        tail = self.tail.prev\\n        self.removeNode(tail)\\n        return tail\\n    \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.freqTable = collections.defaultdict(DLL)\\n        self.capacity = capacity\\n        self.minFreq = 0\\n        \\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        return self.updateCache(self.cache[key], key, self.cache[key].val)\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity:\\n            return\\n        if key in self.cache:\\n            self.updateCache(self.cache[key], key, value)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                prevTail = self.freqTable[self.minFreq].removeTail()\\n                del self.cache[prevTail.key]\\n            node = ListNode(key, value)\\n            self.freqTable[1].insertHead(node)\\n            self.cache[key] = node\\n            self.minFreq = 1\\n        \\n    \\n    def updateCache(self, node, key, value):\\n        node = self.cache[key]\\n        node.val = value\\n        prevFreq = node.freq\\n        node.freq += 1\\n        self.freqTable[prevFreq].removeNode(node)\\n        self.freqTable[node.freq].insertHead(node)\\n        if prevFreq == self.minFreq and self.freqTable[prevFreq].size == 0:\\n            self.minFreq += 1\\n        return node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94657,
                "title": "java-solutions-of-three-different-ways-priorityqueue-o-capacity-treemap-o-log-capacity-doublelinkedlist-o-1",
                "content": "The first one: PriorityQueue + HashMap          set O(capacity)                get O(capacity)\\nThe second one: TreeMap + HashMap           set O(log(capacity))         get O(log(capacity))\\nThe third one: HashMap + HashMap + DoubleLinkedList                        set O(1)                      get O(1)\\n\\n**PriorityQueue + HashMap:  set O(capacity) get O(capacity)**\\n'''\\n\\n    long stamp;\\n    int capacity;\\n    int num;\\n    PriorityQueue<Pair> minHeap;\\n    HashMap<Integer, Pair> hashMap;\\n\\n    // @param capacity, an integer\\n    public LFUCache(int capacity) {\\n        // Write your code here\\n        this.capacity = capacity;\\n        num = 0;\\n        minHeap = new PriorityQueue<Pair>();\\n        hashMap = new HashMap<Integer, Pair>();\\n        stamp = 0;\\n    }\\n\\n    // @param key, an integer\\n    // @param value, an integer\\n    // @return nothing\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else if (num == capacity) {\\n            Pair old = minHeap.poll();\\n            hashMap.remove(old.key);\\n            \\n            Pair newNode = new Pair(key, value, 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else {\\n            num++;\\n            Pair pair = new Pair(key, value, 1, stamp++);\\n            hashMap.put(key, pair);\\n            minHeap.offer(pair);\\n        }\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, old.value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n            return hashMap.get(key).value;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    class Pair implements Comparable<Pair> {\\n        long stamp;\\n        int key;\\n        int value;\\n        int times;\\n        public Pair(int key, int value, int times, long stamp) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n            this.stamp = stamp;\\n        }\\n        \\n        public int compareTo(Pair that) {\\n            if (this.times == that.times) {\\n                return (int)(this.stamp - that.stamp);\\n            } else {\\n                return this.times - that.times;    \\n            }\\n        }\\n    }\\n'''\\n\\n**TreeMap + HashMap: set O(log(capacity))         get O(log(capacity))**\\n\\n'''\\n\\n    private int capacity;\\n    private int stamp;\\n    private HashMap<Integer, Tuple> hashMap;\\n    private TreeMap<Tuple, Integer> treeMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        stamp = 0;\\n        hashMap = new HashMap<Integer, Tuple>(); \\n        treeMap = new TreeMap<Tuple, Integer>(new Comparator<Tuple>() {\\n            public int compare(Tuple t1, Tuple t2) {\\n                if (t1.times == t2.times) {\\n                    return t1.stamp - t2.stamp;\\n                }\\n                return t1.times - t2.times;\\n            }\\n        });\\n    }\\n    \\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        if (!hashMap.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = hashMap.get(key);\\n        treeMap.remove(old);\\n        Tuple newTuple = new Tuple(old.value, stamp++, old.times + 1);\\n        treeMap.put(newTuple, key);\\n        hashMap.put(key, newTuple);\\n        return old.value;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (hashMap.containsKey(key)) {\\n            Tuple old = hashMap.get(key);\\n            Tuple newTuple = new Tuple(value, stamp++, old.times + 1);\\n            treeMap.remove(old);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        } else {\\n            if (treeMap.size() == capacity) {\\n                int endKey = treeMap.pollFirstEntry().getValue();\\n                hashMap.remove(endKey);\\n            }\\n            Tuple newTuple = new Tuple(value, stamp++, 1);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        }\\n    }\\n    class Tuple {\\n        int value;\\n        int times;\\n        int stamp;\\n        public Tuple (int value, int stamp, int times) {\\n            this.value = value;\\n            this.stamp = stamp;\\n            this.times = times;\\n        }\\n    }\\n'''\\n **HashMap + HashMap + DoubleLinkedList:                    set O(1)   get O(1)**\\n\\n\\nmap1 save the nodes in the cache\\nfinalNodes save the newest node which has appeared  ''key''  times.\\nUsing a doubleLinkedList to save the nodes in the cache.if a node appeared more times or is a new comer, the position in the list of this node is as back as possible. \\n\\n\\n'''\\n\\n    private int capacity;\\n    private int count;\\n    private HashMap<Integer, Tuple> map1; // whether appeared\\n    private HashMap<Integer, Tuple> finalNodes; // value : the final node of key times\\n    private Tuple dummyHead;\\n    private Tuple dummyEnd;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        count = 0;\\n        map1 = new HashMap<Integer, Tuple>();\\n        finalNodes = new HashMap<>();\\n        dummyHead = new Tuple(0, 0, 0);\\n        dummyEnd = new Tuple(0, 0, 0);\\n        dummyHead.next = dummyEnd;\\n        dummyEnd.prev = dummyHead;\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0 || !map1.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = map1.get(key);\\n        set(key, old.value);\\n        return old.value;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (map1.containsKey(key)) { // this key has appeared\\n            Tuple cur = map1.get(key);\\n            if (finalNodes.get(cur.times) == cur && finalNodes.get(cur.times + 1) == null) { // the position should not change\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n                cur.times++;\\n                cur.value = value;\\n                finalNodes.put(cur.times, cur);\\n                return;\\n            }\\n            removeNode(cur); // remove node cur\\n            if (finalNodes.get(cur.times) == cur) {\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n            }\\n            cur.times++;\\n            cur.value = value;\\n            Tuple finalNode = finalNodes.get(cur.times) == null ? finalNodes.get(cur.times - 1) : finalNodes.get(cur.times);\\n            insertNode(finalNode, cur); \\n            finalNodes.put(cur.times, cur); // cur is the final node whitch appeared cur.times\\n        } else if (count == capacity) { // reach limt of the cache\\n            Tuple head = dummyHead.next;\\n            removeNode(head); //remove the first which appeared least times and is the least Used\\n            map1.remove(head.key);\\n            if (finalNodes.get(head.times) == head) {\\n                finalNodes.remove(head.times);\\n            }\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null) {\\n                insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        } else {\\n            count++;\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null){\\n               insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        }\\n    }\\n\\n    public void insertNode(Tuple t1, Tuple t2) {\\n        t2.next = t1.next;\\n        t1.next.prev = t2;\\n        t1.next = t2;\\n        t2.prev = t1;\\n    }\\n\\n    public void removeNode(Tuple node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n    class Tuple {\\n        int key;\\n        int value;\\n        int times;\\n        Tuple prev;\\n        Tuple next;\\n        public Tuple(int key, int value, int times) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n        }\\n    }\\n'''",
                "solutionTags": [],
                "code": "The first one: PriorityQueue + HashMap          set O(capacity)                get O(capacity)\\nThe second one: TreeMap + HashMap           set O(log(capacity))         get O(log(capacity))\\nThe third one: HashMap + HashMap + DoubleLinkedList                        set O(1)                      get O(1)\\n\\n**PriorityQueue + HashMap:  set O(capacity) get O(capacity)**\\n'''\\n\\n    long stamp;\\n    int capacity;\\n    int num;\\n    PriorityQueue<Pair> minHeap;\\n    HashMap<Integer, Pair> hashMap;\\n\\n    // @param capacity, an integer\\n    public LFUCache(int capacity) {\\n        // Write your code here\\n        this.capacity = capacity;\\n        num = 0;\\n        minHeap = new PriorityQueue<Pair>();\\n        hashMap = new HashMap<Integer, Pair>();\\n        stamp = 0;\\n    }\\n\\n    // @param key, an integer\\n    // @param value, an integer\\n    // @return nothing\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else if (num == capacity) {\\n            Pair old = minHeap.poll();\\n            hashMap.remove(old.key);\\n            \\n            Pair newNode = new Pair(key, value, 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n        } else {\\n            num++;\\n            Pair pair = new Pair(key, value, 1, stamp++);\\n            hashMap.put(key, pair);\\n            minHeap.offer(pair);\\n        }\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        // Write your code here\\n        if (hashMap.containsKey(key)) {\\n            Pair old = hashMap.get(key);\\n            minHeap.remove(old);\\n            \\n            Pair newNode = new Pair(key, old.value, old.times + 1, stamp++);\\n            \\n            hashMap.put(key, newNode);\\n            minHeap.offer(newNode);\\n            return hashMap.get(key).value;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    class Pair implements Comparable<Pair> {\\n        long stamp;\\n        int key;\\n        int value;\\n        int times;\\n        public Pair(int key, int value, int times, long stamp) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n            this.stamp = stamp;\\n        }\\n        \\n        public int compareTo(Pair that) {\\n            if (this.times == that.times) {\\n                return (int)(this.stamp - that.stamp);\\n            } else {\\n                return this.times - that.times;    \\n            }\\n        }\\n    }\\n'''\\n\\n**TreeMap + HashMap: set O(log(capacity))         get O(log(capacity))**\\n\\n'''\\n\\n    private int capacity;\\n    private int stamp;\\n    private HashMap<Integer, Tuple> hashMap;\\n    private TreeMap<Tuple, Integer> treeMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        stamp = 0;\\n        hashMap = new HashMap<Integer, Tuple>(); \\n        treeMap = new TreeMap<Tuple, Integer>(new Comparator<Tuple>() {\\n            public int compare(Tuple t1, Tuple t2) {\\n                if (t1.times == t2.times) {\\n                    return t1.stamp - t2.stamp;\\n                }\\n                return t1.times - t2.times;\\n            }\\n        });\\n    }\\n    \\n    public int get(int key) {\\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        if (!hashMap.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = hashMap.get(key);\\n        treeMap.remove(old);\\n        Tuple newTuple = new Tuple(old.value, stamp++, old.times + 1);\\n        treeMap.put(newTuple, key);\\n        hashMap.put(key, newTuple);\\n        return old.value;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (hashMap.containsKey(key)) {\\n            Tuple old = hashMap.get(key);\\n            Tuple newTuple = new Tuple(value, stamp++, old.times + 1);\\n            treeMap.remove(old);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        } else {\\n            if (treeMap.size() == capacity) {\\n                int endKey = treeMap.pollFirstEntry().getValue();\\n                hashMap.remove(endKey);\\n            }\\n            Tuple newTuple = new Tuple(value, stamp++, 1);\\n            hashMap.put(key, newTuple);\\n            treeMap.put(newTuple, key);\\n        }\\n    }\\n    class Tuple {\\n        int value;\\n        int times;\\n        int stamp;\\n        public Tuple (int value, int stamp, int times) {\\n            this.value = value;\\n            this.stamp = stamp;\\n            this.times = times;\\n        }\\n    }\\n'''\\n **HashMap + HashMap + DoubleLinkedList:                    set O(1)   get O(1)**\\n\\n\\nmap1 save the nodes in the cache\\nfinalNodes save the newest node which has appeared  ''key''  times.\\nUsing a doubleLinkedList to save the nodes in the cache.if a node appeared more times or is a new comer, the position in the list of this node is as back as possible. \\n\\n\\n'''\\n\\n    private int capacity;\\n    private int count;\\n    private HashMap<Integer, Tuple> map1; // whether appeared\\n    private HashMap<Integer, Tuple> finalNodes; // value : the final node of key times\\n    private Tuple dummyHead;\\n    private Tuple dummyEnd;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        count = 0;\\n        map1 = new HashMap<Integer, Tuple>();\\n        finalNodes = new HashMap<>();\\n        dummyHead = new Tuple(0, 0, 0);\\n        dummyEnd = new Tuple(0, 0, 0);\\n        dummyHead.next = dummyEnd;\\n        dummyEnd.prev = dummyHead;\\n    }\\n\\n    public int get(int key) {\\n        if (capacity == 0 || !map1.containsKey(key)) {\\n            return -1;\\n        }\\n        Tuple old = map1.get(key);\\n        set(key, old.value);\\n        return old.value;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity == 0) {\\n            return;\\n        }\\n        if (map1.containsKey(key)) { // this key has appeared\\n            Tuple cur = map1.get(key);\\n            if (finalNodes.get(cur.times) == cur && finalNodes.get(cur.times + 1) == null) { // the position should not change\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n                cur.times++;\\n                cur.value = value;\\n                finalNodes.put(cur.times, cur);\\n                return;\\n            }\\n            removeNode(cur); // remove node cur\\n            if (finalNodes.get(cur.times) == cur) {\\n                finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);\\n            }\\n            cur.times++;\\n            cur.value = value;\\n            Tuple finalNode = finalNodes.get(cur.times) == null ? finalNodes.get(cur.times - 1) : finalNodes.get(cur.times);\\n            insertNode(finalNode, cur); \\n            finalNodes.put(cur.times, cur); // cur is the final node whitch appeared cur.times\\n        } else if (count == capacity) { // reach limt of the cache\\n            Tuple head = dummyHead.next;\\n            removeNode(head); //remove the first which appeared least times and is the least Used\\n            map1.remove(head.key);\\n            if (finalNodes.get(head.times) == head) {\\n                finalNodes.remove(head.times);\\n            }\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null) {\\n                insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        } else {\\n            count++;\\n            Tuple cur = new Tuple(key, value, 1);\\n            if (finalNodes.get(1) == null){\\n               insertNode(dummyHead, cur);\\n            } else {\\n                Tuple finalNode = finalNodes.get(1);\\n                insertNode(finalNode, cur);\\n            }\\n            finalNodes.put(1, cur);\\n            map1.put(key, cur);\\n        }\\n    }\\n\\n    public void insertNode(Tuple t1, Tuple t2) {\\n        t2.next = t1.next;\\n        t1.next.prev = t2;\\n        t1.next = t2;\\n        t2.prev = t1;\\n    }\\n\\n    public void removeNode(Tuple node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n    class Tuple {\\n        int key;\\n        int value;\\n        int times;\\n        Tuple prev;\\n        Tuple next;\\n        public Tuple(int key, int value, int times) {\\n            this.key = key;\\n            this.value = value;\\n            this.times = times;\\n        }\\n    }\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 3111462,
                "title": "95-faster-java-code",
                "content": "# Code\\n``` Java []\\nclass Node{\\n\\tint key;\\n\\tint val;\\n\\tNode next;\\n\\tNode prev;\\n\\tint freq=1;\\n\\tNode(int k,int v){\\n\\t\\tkey=k;\\n\\t\\tval=v;\\n\\t}\\n}\\nclass DoublyLinkedList{\\n\\tNode head;\\n\\tNode tail;\\n\\tDoublyLinkedList(){\\n\\t\\thead=new Node(-1,-1);\\n\\t\\ttail=new Node(-1,-1);\\n\\t\\thead.next=tail;\\n\\t\\ttail.prev=head;\\n\\t}\\n\\tvoid addNode(Node v){\\n\\t\\tNode next=head.next;\\n\\t\\thead.next=v;\\n\\t\\tv.prev=head;\\n\\t\\thead.next=v;\\n\\t\\tv.next=next;\\n\\t\\tnext.prev=v;\\n\\t}\\n\\tNode removeNode(){\\n\\t\\tNode node=tail.prev;\\n\\t\\tnode.prev.next=tail;\\n\\t\\ttail.prev=node.prev;\\n\\t\\treturn node;\\n\\t}\\n\\tNode removeNode(Node v){\\n\\t\\tNode prev=v.prev;\\n\\t\\tNode next=v.next;\\n\\t\\tprev.next=next;\\n\\t\\tnext.prev=prev;\\n\\t\\treturn v;\\n\\t}\\n\\tboolean isEmpty(){\\n\\t\\tif(head.next==tail)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n}\\nclass LFUCache {\\n    HashMap<Integer,DoublyLinkedList> freqList=new HashMap<Integer,DoublyLinkedList>();\\n\\tHashMap<Integer,Node> lfuCache =new HashMap<Integer,Node>(); \\n\\tint capacity;\\n\\tint minFreq;\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        minFreq=1;\\n    }\\n    public int get(int key) {\\n        if(lfuCache.get(key)==null)\\n        \\treturn -1;\\n       \\tNode v=lfuCache.get(key);\\n       \\tfreqList.get(v.freq).removeNode(v);\\n       \\tif(freqList.get(v.freq).isEmpty()){\\n       \\t\\tif(minFreq==v.freq){\\n                minFreq=v.freq+1;\\n            }\\n       \\t}\\n       \\tv.freq+=1;\\n       \\tif(freqList.get(v.freq)==null){\\n       \\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n       \\t\\td.addNode(v);\\n       \\t\\tfreqList.put(v.freq,d);\\n       \\t}\\n       \\telse{\\n       \\t\\tfreqList.get(v.freq).addNode(v);\\n       \\t}\\n       \\treturn v.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(lfuCache.get(key)!=null){\\n        \\tNode v=lfuCache.get(key);\\n        \\tfreqList.get(v.freq).removeNode(v);\\n        \\tif(freqList.get(v.freq).isEmpty()){\\n                if(minFreq==v.freq)\\n        \\t\\tminFreq=v.freq+1;\\n        \\t}\\n\\t       \\tv.freq+=1;\\n\\t       \\tif(freqList.get(v.freq)==null){\\n\\t       \\t\\t DoublyLinkedList d=new DoublyLinkedList();\\n\\t       \\t\\td.addNode(v);\\n\\t       \\t\\tfreqList.put(v.freq,d);\\n\\t       \\t}\\n\\t       \\telse{\\n\\t       \\t\\tfreqList.get(v.freq).addNode(v);\\n\\t       \\t}\\n\\t       \\tv.val=value;\\n\\t      }\\n\\t      else{\\n\\t     \\t\\tif(lfuCache.size()==capacity){\\n\\t     \\t\\t\\tNode v=freqList.get(minFreq).removeNode();\\n\\t     \\t\\t\\tlfuCache.remove(v.key);\\t\\t\\t\\n\\t     \\t\\t}\\n\\t     \\t\\tNode newNode = new Node(key,value);\\n\\t     \\t\\tlfuCache.put(key,newNode);\\n\\t     \\t\\tif(freqList.get(1)!=null){\\n\\t     \\t\\t\\tfreqList.get(1).addNode(newNode);\\n\\t     \\t\\t}\\n\\t     \\t\\telse{\\n\\t     \\t\\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n\\t     \\t\\t\\td.addNode(newNode);\\n\\t     \\t\\t\\tfreqList.put(1,d);\\n\\t     \\t\\t}\\n               minFreq=1;\\n\\t      }\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/3bd99926-1192-45c6-804f-63382d92328c_1674959627.4239037.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` Java []\\nclass Node{\\n\\tint key;\\n\\tint val;\\n\\tNode next;\\n\\tNode prev;\\n\\tint freq=1;\\n\\tNode(int k,int v){\\n\\t\\tkey=k;\\n\\t\\tval=v;\\n\\t}\\n}\\nclass DoublyLinkedList{\\n\\tNode head;\\n\\tNode tail;\\n\\tDoublyLinkedList(){\\n\\t\\thead=new Node(-1,-1);\\n\\t\\ttail=new Node(-1,-1);\\n\\t\\thead.next=tail;\\n\\t\\ttail.prev=head;\\n\\t}\\n\\tvoid addNode(Node v){\\n\\t\\tNode next=head.next;\\n\\t\\thead.next=v;\\n\\t\\tv.prev=head;\\n\\t\\thead.next=v;\\n\\t\\tv.next=next;\\n\\t\\tnext.prev=v;\\n\\t}\\n\\tNode removeNode(){\\n\\t\\tNode node=tail.prev;\\n\\t\\tnode.prev.next=tail;\\n\\t\\ttail.prev=node.prev;\\n\\t\\treturn node;\\n\\t}\\n\\tNode removeNode(Node v){\\n\\t\\tNode prev=v.prev;\\n\\t\\tNode next=v.next;\\n\\t\\tprev.next=next;\\n\\t\\tnext.prev=prev;\\n\\t\\treturn v;\\n\\t}\\n\\tboolean isEmpty(){\\n\\t\\tif(head.next==tail)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n}\\nclass LFUCache {\\n    HashMap<Integer,DoublyLinkedList> freqList=new HashMap<Integer,DoublyLinkedList>();\\n\\tHashMap<Integer,Node> lfuCache =new HashMap<Integer,Node>(); \\n\\tint capacity;\\n\\tint minFreq;\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        minFreq=1;\\n    }\\n    public int get(int key) {\\n        if(lfuCache.get(key)==null)\\n        \\treturn -1;\\n       \\tNode v=lfuCache.get(key);\\n       \\tfreqList.get(v.freq).removeNode(v);\\n       \\tif(freqList.get(v.freq).isEmpty()){\\n       \\t\\tif(minFreq==v.freq){\\n                minFreq=v.freq+1;\\n            }\\n       \\t}\\n       \\tv.freq+=1;\\n       \\tif(freqList.get(v.freq)==null){\\n       \\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n       \\t\\td.addNode(v);\\n       \\t\\tfreqList.put(v.freq,d);\\n       \\t}\\n       \\telse{\\n       \\t\\tfreqList.get(v.freq).addNode(v);\\n       \\t}\\n       \\treturn v.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(lfuCache.get(key)!=null){\\n        \\tNode v=lfuCache.get(key);\\n        \\tfreqList.get(v.freq).removeNode(v);\\n        \\tif(freqList.get(v.freq).isEmpty()){\\n                if(minFreq==v.freq)\\n        \\t\\tminFreq=v.freq+1;\\n        \\t}\\n\\t       \\tv.freq+=1;\\n\\t       \\tif(freqList.get(v.freq)==null){\\n\\t       \\t\\t DoublyLinkedList d=new DoublyLinkedList();\\n\\t       \\t\\td.addNode(v);\\n\\t       \\t\\tfreqList.put(v.freq,d);\\n\\t       \\t}\\n\\t       \\telse{\\n\\t       \\t\\tfreqList.get(v.freq).addNode(v);\\n\\t       \\t}\\n\\t       \\tv.val=value;\\n\\t      }\\n\\t      else{\\n\\t     \\t\\tif(lfuCache.size()==capacity){\\n\\t     \\t\\t\\tNode v=freqList.get(minFreq).removeNode();\\n\\t     \\t\\t\\tlfuCache.remove(v.key);\\t\\t\\t\\n\\t     \\t\\t}\\n\\t     \\t\\tNode newNode = new Node(key,value);\\n\\t     \\t\\tlfuCache.put(key,newNode);\\n\\t     \\t\\tif(freqList.get(1)!=null){\\n\\t     \\t\\t\\tfreqList.get(1).addNode(newNode);\\n\\t     \\t\\t}\\n\\t     \\t\\telse{\\n\\t     \\t\\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n\\t     \\t\\t\\td.addNode(newNode);\\n\\t     \\t\\t\\tfreqList.put(1,d);\\n\\t     \\t\\t}\\n               minFreq=1;\\n\\t      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443113,
                "title": "visualization-for-2-hashmap-1-doublelinkedlist-approach",
                "content": "\\nBelow visualization shows how Node map and count map are connected. In first part, 5 keys are added (all unique) and in 2nd part, 2 of the existing keys are updated\\n\\nPart 1- \\n\\n![image](https://assets.leetcode.com/users/flash-cola/image_1575397024.png)\\n\\n\\nPart 2- \\n\\n![image](https://assets.leetcode.com/users/flash-cola/image_1575396981.png)\\n\\n\\n```\\npublic class LFUCache {\\n\\tclass Node {\\n\\t\\tint key, val, cnt;\\n\\t\\tNode prev, next;\\n\\t\\tNode(int key, int val) {\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tcnt = 1;\\n\\t\\t}\\n\\t}\\n\\n\\tclass DLList {\\n\\t\\tNode head, tail;\\n\\t\\tint size;\\n\\t\\tDLList() {\\n\\t\\t\\thead = new Node(0, 0);\\n\\t\\t\\ttail = new Node(0, 0);\\n\\t\\t\\thead.next = tail;\\n\\t\\t\\ttail.prev = head;\\n\\t\\t}\\n\\n\\t\\tvoid add(Node node) {\\n\\t\\t\\thead.next.prev = node;\\n\\t\\t\\tnode.next = head.next;\\n\\t\\t\\tnode.prev = head;\\n\\t\\t\\thead.next = node;\\n\\t\\t\\tsize++;\\n\\t\\t}\\n\\n\\t\\tvoid remove(Node node) {\\n\\t\\t\\tnode.prev.next = node.next;\\n\\t\\t\\tnode.next.prev = node.prev;\\n\\t\\t\\tsize--;\\n\\t\\t}\\n\\n\\t\\tNode removeLast() {\\n\\t\\t\\tif (size > 0) {\\n\\t\\t\\t\\tNode node = tail.prev;\\n\\t\\t\\t\\tremove(node);\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t}\\n\\t\\t\\telse return null;\\n\\t\\t}\\n\\t}\\n\\n\\tint capacity, leastFrequenyCount;\\n\\t// consists of keys vs nodes [with keys and values]\\n\\tMap<Integer, Node> nodeMap;\\n\\t// consists of frequency vs doubly linked list of items\\n\\t// if key 1, key 2 and key 3 are occuring only once then,  map would like below\\n\\t// 1 -> head -> node key1 -> node key2 -> node key3\\n\\n\\t// lets say with key 1 was updated again, then map would update as below\\n\\t// 1 -> head -> node key1 -> node key3\\n\\t// 2 -> head -> node key1\\n\\tMap<Integer, DLList> countMap;\\n\\n\\tpublic LFUCache(int capacity) {\\n\\t\\tthis.capacity = capacity;\\n\\t\\tnodeMap = new HashMap<>();\\n\\t\\tcountMap = new HashMap<>();\\n\\t}\\n\\n\\tpublic int get(int key) {\\n\\t\\tNode node = nodeMap.get(key);\\n\\t\\tif (node == null) return -1;\\n\\t\\tupdate(node);\\n\\t\\treturn node.val;\\n\\t}\\n\\n\\tpublic void put(int key, int value) {\\n\\t\\tif (capacity == 0) return;\\n\\t\\tNode node;\\n\\t\\t// possibility 1\\n\\t\\tif (nodeMap.containsKey(key)) {\\n\\t\\t\\t// get current node status- use same node in count map doubly linkedlist\\n\\t\\t\\tnode = nodeMap.get(key);\\n\\t\\t\\tnode.val = value;\\n\\t\\t\\t// if exists already then there will direct impact on frequency aka count map\\n\\t\\t\\t// update count map. Move the node from old frequency key and associate it with new frequency key \\n\\t\\t\\t// new frequency key may or may not exists already\\n\\t\\t\\tupdate(node);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// possibility 2\\n\\t\\t\\tif (nodeMap.size() == capacity) {\\n\\t\\t\\t\\tDLList lastList = countMap.get(leastFrequenyCount);\\n\\t\\t\\t\\tnodeMap.remove(lastList.removeLast().key);\\n\\t\\t\\t}\\n\\t\\t\\t// possibility 3\\n\\t\\t\\tnode = new Node(key, value);\\n\\t\\t\\tnodeMap.put(key, node);\\n\\t\\t\\tleastFrequenyCount = 1;\\n\\t\\t\\tDLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n\\t\\t\\tnewList.add(node);\\n\\t\\t\\tcountMap.put(node.cnt, newList);\\n\\t\\t}\\n\\t}\\n\\n\\t// consists of frequency vs doubly linked list of items\\n\\t// if key 1, key 2 and key 3 are occurring only once then,  map would like below\\n\\t// 1 -> head -> node key1 -> node key2 -> node key3\\n\\n\\t// lets say with key 1 was updated again, then map would update as below\\n\\t// 1 -> head -> node key1 -> node key3\\n\\t// 2 -> head -> node key1\\n\\n\\tprivate void update(Node node) {\\n\\t\\tDLList oldList = countMap.get(node.cnt);\\n\\t\\toldList.remove(node);\\n\\t\\t// keep track of lowest frequency. One of the indicators of lowest frequency is, oldList size becoming zero\\n\\t\\t// it indicates that one count level has gone completely empty and lowest frequency count needs to be updated \\n\\t\\tif (node.cnt == leastFrequenyCount && oldList.size == 0) {\\n\\t\\t\\tleastFrequenyCount++;\\n\\t\\t}\\n\\t\\tnode.cnt++;\\n\\t\\tDLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n\\t\\tnewList.add(node);\\n\\t\\tcountMap.put(node.cnt, newList);\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tLFUCache c = new LFUCache(3);\\n\\t\\tc.put(3, 4);\\n\\t\\tc.put(1, 2); \\n\\t\\tc.put(2, 2); \\n\\t\\tc.put(3, 2); \\n\\t\\tc.put(2, 2); \\n\\t\\tc.put(1, 2); \\n\\t\\tc.put(4, 6); \\n\\t\\tc.put(5, 6); // 4 need to be evicted\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LFUCache {\\n\\tclass Node {\\n\\t\\tint key, val, cnt;\\n\\t\\tNode prev, next;\\n\\t\\tNode(int key, int val) {\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tcnt = 1;\\n\\t\\t}\\n\\t}\\n\\n\\tclass DLList {\\n\\t\\tNode head, tail;\\n\\t\\tint size;\\n\\t\\tDLList() {\\n\\t\\t\\thead = new Node(0, 0);\\n\\t\\t\\ttail = new Node(0, 0);\\n\\t\\t\\thead.next = tail;\\n\\t\\t\\ttail.prev = head;\\n\\t\\t}\\n\\n\\t\\tvoid add(Node node) {\\n\\t\\t\\thead.next.prev = node;\\n\\t\\t\\tnode.next = head.next;\\n\\t\\t\\tnode.prev = head;\\n\\t\\t\\thead.next = node;\\n\\t\\t\\tsize++;\\n\\t\\t}\\n\\n\\t\\tvoid remove(Node node) {\\n\\t\\t\\tnode.prev.next = node.next;\\n\\t\\t\\tnode.next.prev = node.prev;\\n\\t\\t\\tsize--;\\n\\t\\t}\\n\\n\\t\\tNode removeLast() {\\n\\t\\t\\tif (size > 0) {\\n\\t\\t\\t\\tNode node = tail.prev;\\n\\t\\t\\t\\tremove(node);\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t}\\n\\t\\t\\telse return null;\\n\\t\\t}\\n\\t}\\n\\n\\tint capacity, leastFrequenyCount;\\n\\t// consists of keys vs nodes [with keys and values]\\n\\tMap<Integer, Node> nodeMap;\\n\\t// consists of frequency vs doubly linked list of items\\n\\t// if key 1, key 2 and key 3 are occuring only once then,  map would like below\\n\\t// 1 -> head -> node key1 -> node key2 -> node key3\\n\\n\\t// lets say with key 1 was updated again, then map would update as below\\n\\t// 1 -> head -> node key1 -> node key3\\n\\t// 2 -> head -> node key1\\n\\tMap<Integer, DLList> countMap;\\n\\n\\tpublic LFUCache(int capacity) {\\n\\t\\tthis.capacity = capacity;\\n\\t\\tnodeMap = new HashMap<>();\\n\\t\\tcountMap = new HashMap<>();\\n\\t}\\n\\n\\tpublic int get(int key) {\\n\\t\\tNode node = nodeMap.get(key);\\n\\t\\tif (node == null) return -1;\\n\\t\\tupdate(node);\\n\\t\\treturn node.val;\\n\\t}\\n\\n\\tpublic void put(int key, int value) {\\n\\t\\tif (capacity == 0) return;\\n\\t\\tNode node;\\n\\t\\t// possibility 1\\n\\t\\tif (nodeMap.containsKey(key)) {\\n\\t\\t\\t// get current node status- use same node in count map doubly linkedlist\\n\\t\\t\\tnode = nodeMap.get(key);\\n\\t\\t\\tnode.val = value;\\n\\t\\t\\t// if exists already then there will direct impact on frequency aka count map\\n\\t\\t\\t// update count map. Move the node from old frequency key and associate it with new frequency key \\n\\t\\t\\t// new frequency key may or may not exists already\\n\\t\\t\\tupdate(node);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// possibility 2\\n\\t\\t\\tif (nodeMap.size() == capacity) {\\n\\t\\t\\t\\tDLList lastList = countMap.get(leastFrequenyCount);\\n\\t\\t\\t\\tnodeMap.remove(lastList.removeLast().key);\\n\\t\\t\\t}\\n\\t\\t\\t// possibility 3\\n\\t\\t\\tnode = new Node(key, value);\\n\\t\\t\\tnodeMap.put(key, node);\\n\\t\\t\\tleastFrequenyCount = 1;\\n\\t\\t\\tDLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n\\t\\t\\tnewList.add(node);\\n\\t\\t\\tcountMap.put(node.cnt, newList);\\n\\t\\t}\\n\\t}\\n\\n\\t// consists of frequency vs doubly linked list of items\\n\\t// if key 1, key 2 and key 3 are occurring only once then,  map would like below\\n\\t// 1 -> head -> node key1 -> node key2 -> node key3\\n\\n\\t// lets say with key 1 was updated again, then map would update as below\\n\\t// 1 -> head -> node key1 -> node key3\\n\\t// 2 -> head -> node key1\\n\\n\\tprivate void update(Node node) {\\n\\t\\tDLList oldList = countMap.get(node.cnt);\\n\\t\\toldList.remove(node);\\n\\t\\t// keep track of lowest frequency. One of the indicators of lowest frequency is, oldList size becoming zero\\n\\t\\t// it indicates that one count level has gone completely empty and lowest frequency count needs to be updated \\n\\t\\tif (node.cnt == leastFrequenyCount && oldList.size == 0) {\\n\\t\\t\\tleastFrequenyCount++;\\n\\t\\t}\\n\\t\\tnode.cnt++;\\n\\t\\tDLList newList = countMap.getOrDefault(node.cnt, new DLList());\\n\\t\\tnewList.add(node);\\n\\t\\tcountMap.put(node.cnt, newList);\\n\\t}\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\tLFUCache c = new LFUCache(3);\\n\\t\\tc.put(3, 4);\\n\\t\\tc.put(1, 2); \\n\\t\\tc.put(2, 2); \\n\\t\\tc.put(3, 2); \\n\\t\\tc.put(2, 2); \\n\\t\\tc.put(1, 2); \\n\\t\\tc.put(4, 6); \\n\\t\\tc.put(5, 6); // 4 need to be evicted\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937737,
                "title": "c-o-1-time-complexity-with-algorithm",
                "content": "# Algorithm\\nPlease refer http://dhruvbird.com/lfu.pdf\\n\\nOne adoption of above algorithm in real product is found at [Apache ActiveMQ Message broker](https://github.com/apache/activemq/blob/master/activemq-kahadb-store/src/main/java/org/apache/activemq/util/LFUCache.java).\\n\\nPS: A rough depiction of my current implementation is given below. \\n\\n![image](https://assets.leetcode.com/users/images/4cb3255c-f77a-495d-a3ff-804583a7d5b8_1605533049.7540417.png)\\n\\n### Correction to the picture\\nm_countKeyMap is unordered_map. \\n\\n```\\n\\n//Just for better readability\\nusing Key_t = int;\\nusing Count_t = int;\\n\\n\\nstruct Node\\n{\\n    int value;\\n    list<Key_t>::iterator itr;\\n};\\n\\nclass LFUCache\\n{\\n    unordered_map<Key_t, Node> m_values;\\n    unordered_map<Key_t, Count_t> m_counts;\\n    unordered_map<Count_t, list<Key_t>> m_countKeyMap;\\n    int m_lowestFrequency;\\n    int m_maxCapacity;\\n\\npublic:\\n    LFUCache(int capacity)\\n    {\\n        m_maxCapacity = capacity;\\n        m_lowestFrequency = 0;\\n    }\\n\\n    int get(int key)\\n    {\\n        if (m_values.find(key) == m_values.end() || m_maxCapacity <= 0)\\n        {\\n            return -1;\\n        }\\n        //update frequency, & return value\\n        put(key, m_values[key].value);\\n        return m_values[key].value;\\n    }\\n\\n    void put(int key, int value)\\n    {\\n        if (m_maxCapacity <= 0)\\n        {\\n            return;\\n        }\\n\\n        //If key is not present and capacity has exceeded,\\n        //then remove the key entry with least frequency\\n        //else just make the new key entry\\n        if (m_values.find(key) == m_values.end())\\n        {\\n            if (m_values.size() == m_maxCapacity)\\n            {\\n                int keyToDelete = m_countKeyMap[m_lowestFrequency].back(); \\n                m_countKeyMap[m_lowestFrequency].pop_back();\\n                if (m_countKeyMap[m_lowestFrequency].empty())\\n                {\\n                    m_countKeyMap.erase(m_lowestFrequency);\\n                }\\n                m_values.erase(keyToDelete);\\n                m_counts.erase(keyToDelete);\\n            }\\n            m_values[key].value = value;\\n            m_counts[key] = 0;\\n            m_lowestFrequency = 0;\\n            m_countKeyMap[m_counts[key]].push_front(key);\\n            m_values[key].itr = m_countKeyMap[0].begin();\\n        }\\n        //Just update value and frequency\\n        else\\n        {\\n            m_countKeyMap[m_counts[key]].erase(m_values[key].itr);\\n            if (m_countKeyMap[m_counts[key]].empty())\\n            {\\n                if (m_lowestFrequency == m_counts[key])\\n                    m_lowestFrequency++;\\n                m_countKeyMap.erase(m_counts[key]);\\n            }\\n            m_values[key].value = value;\\n            m_counts[key]++;\\n            m_countKeyMap[m_counts[key]].push_front(key);\\n            m_values[key].itr = m_countKeyMap[m_counts[key]].begin();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n//Just for better readability\\nusing Key_t = int;\\nusing Count_t = int;\\n\\n\\nstruct Node\\n{\\n    int value;\\n    list<Key_t>::iterator itr;\\n};\\n\\nclass LFUCache\\n{\\n    unordered_map<Key_t, Node> m_values;\\n    unordered_map<Key_t, Count_t> m_counts;\\n    unordered_map<Count_t, list<Key_t>> m_countKeyMap;\\n    int m_lowestFrequency;\\n    int m_maxCapacity;\\n\\npublic:\\n    LFUCache(int capacity)\\n    {\\n        m_maxCapacity = capacity;\\n        m_lowestFrequency = 0;\\n    }\\n\\n    int get(int key)\\n    {\\n        if (m_values.find(key) == m_values.end() || m_maxCapacity <= 0)\\n        {\\n            return -1;\\n        }\\n        //update frequency, & return value\\n        put(key, m_values[key].value);\\n        return m_values[key].value;\\n    }\\n\\n    void put(int key, int value)\\n    {\\n        if (m_maxCapacity <= 0)\\n        {\\n            return;\\n        }\\n\\n        //If key is not present and capacity has exceeded,\\n        //then remove the key entry with least frequency\\n        //else just make the new key entry\\n        if (m_values.find(key) == m_values.end())\\n        {\\n            if (m_values.size() == m_maxCapacity)\\n            {\\n                int keyToDelete = m_countKeyMap[m_lowestFrequency].back(); \\n                m_countKeyMap[m_lowestFrequency].pop_back();\\n                if (m_countKeyMap[m_lowestFrequency].empty())\\n                {\\n                    m_countKeyMap.erase(m_lowestFrequency);\\n                }\\n                m_values.erase(keyToDelete);\\n                m_counts.erase(keyToDelete);\\n            }\\n            m_values[key].value = value;\\n            m_counts[key] = 0;\\n            m_lowestFrequency = 0;\\n            m_countKeyMap[m_counts[key]].push_front(key);\\n            m_values[key].itr = m_countKeyMap[0].begin();\\n        }\\n        //Just update value and frequency\\n        else\\n        {\\n            m_countKeyMap[m_counts[key]].erase(m_values[key].itr);\\n            if (m_countKeyMap[m_counts[key]].empty())\\n            {\\n                if (m_lowestFrequency == m_counts[key])\\n                    m_lowestFrequency++;\\n                m_countKeyMap.erase(m_counts[key]);\\n            }\\n            m_values[key].value = value;\\n            m_counts[key]++;\\n            m_countKeyMap[m_counts[key]].push_front(key);\\n            m_values[key].itr = m_countKeyMap[m_counts[key]].begin();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94602,
                "title": "c-list-with-hashmap-with-explanation",
                "content": "Based on ideas from this paper http://dhruvbird.com/lfu.pdf.\\n```\\n      Increasing frequencies\\n  ----------------------------->\\n\\n+------+    +---+    +---+    +---+\\n| Head |----| 1 |----| 5 |----| 9 |  Frequencies\\n+------+    +-+-+    +-+-+    +-+-+\\n              |        |        |\\n            +-+-+    +-+-+    +-+-+     |\\n            |2,3|    |4,3|    |6,2|     |\\n            +-+-+    +-+-+    +-+-+     | Most recent \\n                       |        |       |\\n                     +-+-+    +-+-+     |\\n key,value pairs     |1,2|    |7,9|     |\\n                     +---+    +---+     v\\n\\n```\\nSimilar to bucket sort, we place key,value pairs with the same frequency into the same bucket, within each bucket, the pairs are sorted according to most recent used, i.e., the one that is most recently used (set,get) is at the bottom of each bucket.\\n\\n```c++\\n\\nclass LFUCache\\n{\\n public:\\n  struct LRUNode\\n  {\\n    int freq;\\n    list<pair<int, int> > vals;\\n    LRUNode(int f = 0) : freq(f) { }\\n  };\\n\\n  typedef list<LRUNode>::iterator iptr;\\n  typedef list<pair<int, int> >::iterator jptr;\\n\\n  LFUCache(int capacity)\\n  {\\n    capacity_ = capacity;\\n  }\\n\\n  int get(int key)\\n  {\\n    int val = -1;\\n    if (kv_.find(key) != kv_.end()) {\\n      kv_[key] = promote(key);\\n      val = kv_[key].second->second;\\n    }\\n    return val;\\n  }\\n\\n  void set(int key, int value)\\n  {\\n    if (capacity_ <= 0) return;\\n    if (kv_.find(key) == kv_.end()) {\\n      if (kv_.size() == capacity_) evict();\\n      kv_[key] = insert(key, value);\\n    } else {\\n      kv_[key] = promote(key, value);\\n    }\\n  }\\n\\n private:\\n  pair<iptr, jptr> promote(int key, int val = -1)\\n  {\\n    iptr i; jptr j;\\n    tie(i, j) = kv_[key];\\n    iptr k = next(i);\\n\\n    if (val < 0) val = j->second;\\n    int freq = i->freq + 1;\\n\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n\\n    if (k == cache_.end() || k->freq != freq)\\n      i = cache_.insert(k, LRUNode(freq));\\n    else i = k;\\n    j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n  void evict()\\n  {\\n    iptr i = cache_.begin();\\n    jptr j = i->vals.begin();\\n    kv_.erase(j->first);\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n  }\\n\\n  pair<iptr, jptr> insert(int key, int val)\\n  {\\n    iptr i = cache_.begin();\\n    if (i == cache_.end() || i->freq != 1)\\n      i = cache_.insert(i, LRUNode(1));\\n    jptr j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n private:\\n  list<LRUNode> cache_;\\n  int capacity_;\\n  unordered_map<int, pair<iptr, jptr> > kv_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n      Increasing frequencies\\n  ----------------------------->\\n\\n+------+    +---+    +---+    +---+\\n| Head |----| 1 |----| 5 |----| 9 |  Frequencies\\n+------+    +-+-+    +-+-+    +-+-+\\n              |        |        |\\n            +-+-+    +-+-+    +-+-+     |\\n            |2,3|    |4,3|    |6,2|     |\\n            +-+-+    +-+-+    +-+-+     | Most recent \\n                       |        |       |\\n                     +-+-+    +-+-+     |\\n key,value pairs     |1,2|    |7,9|     |\\n                     +---+    +---+     v\\n\\n```\n```c++\\n\\nclass LFUCache\\n{\\n public:\\n  struct LRUNode\\n  {\\n    int freq;\\n    list<pair<int, int> > vals;\\n    LRUNode(int f = 0) : freq(f) { }\\n  };\\n\\n  typedef list<LRUNode>::iterator iptr;\\n  typedef list<pair<int, int> >::iterator jptr;\\n\\n  LFUCache(int capacity)\\n  {\\n    capacity_ = capacity;\\n  }\\n\\n  int get(int key)\\n  {\\n    int val = -1;\\n    if (kv_.find(key) != kv_.end()) {\\n      kv_[key] = promote(key);\\n      val = kv_[key].second->second;\\n    }\\n    return val;\\n  }\\n\\n  void set(int key, int value)\\n  {\\n    if (capacity_ <= 0) return;\\n    if (kv_.find(key) == kv_.end()) {\\n      if (kv_.size() == capacity_) evict();\\n      kv_[key] = insert(key, value);\\n    } else {\\n      kv_[key] = promote(key, value);\\n    }\\n  }\\n\\n private:\\n  pair<iptr, jptr> promote(int key, int val = -1)\\n  {\\n    iptr i; jptr j;\\n    tie(i, j) = kv_[key];\\n    iptr k = next(i);\\n\\n    if (val < 0) val = j->second;\\n    int freq = i->freq + 1;\\n\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n\\n    if (k == cache_.end() || k->freq != freq)\\n      i = cache_.insert(k, LRUNode(freq));\\n    else i = k;\\n    j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n  void evict()\\n  {\\n    iptr i = cache_.begin();\\n    jptr j = i->vals.begin();\\n    kv_.erase(j->first);\\n    i->vals.erase(j);\\n    if (i->vals.empty())\\n      cache_.erase(i);\\n  }\\n\\n  pair<iptr, jptr> insert(int key, int val)\\n  {\\n    iptr i = cache_.begin();\\n    if (i == cache_.end() || i->freq != 1)\\n      i = cache_.insert(i, LRUNode(1));\\n    jptr j = i->vals.insert(i->vals.end(), {key, val});\\n    return {i, j};\\n  }\\n\\n private:\\n  list<LRUNode> cache_;\\n  int capacity_;\\n  unordered_map<int, pair<iptr, jptr> > kv_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112340,
                "title": "short-c-java-python-js-explained-solution-beginner-friendly",
                "content": "https://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\n\\n\\nIntuition:\\nTo implement LFU cache, we can use a hashmap to store the key-value pairs, and a doubly linked list to maintain the frequency of each key.\\nEvery time a key is accessed, we increment its frequency and move it to the appropriate position in the linked list.\\nWhen the cache reaches its capacity limit, we remove the least frequently used key from the head of the linked list.\\n\\nApproach:\\n\\nCreate a hashmap to store the key-value pairs and a doubly linked list to maintain the frequency of each key.\\nWhen a key is accessed, check if it exists in the hashmap. If it does, update its value and increment its frequency.\\nIf the key does not exist in the hashmap, check if the cache has reached its capacity limit. If it has, remove the least frequently used key from the head of the linked list.\\nAdd the key-value pair to the hashmap and insert it into the appropriate position in the linked list based on its frequency.\\n\\nTime Complexity:\\nThe time complexity of getting and setting a key is O(1) on average.\\nThe time complexity of removing the least frequently used key when the cache reaches its capacity limit is O(1) on average.\\n\\nCOde : Read Atricle for codes:\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/4fbf3da1-a258-4bdd-9fd9-d9e837b2b64d_1674974240.7890227.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "https://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\n\\n\\nIntuition:\\nTo implement LFU cache, we can use a hashmap to store the key-value pairs, and a doubly linked list to maintain the frequency of each key.\\nEvery time a key is accessed, we increment its frequency and move it to the appropriate position in the linked list.\\nWhen the cache reaches its capacity limit, we remove the least frequently used key from the head of the linked list.\\n\\nApproach:\\n\\nCreate a hashmap to store the key-value pairs and a doubly linked list to maintain the frequency of each key.\\nWhen a key is accessed, check if it exists in the hashmap. If it does, update its value and increment its frequency.\\nIf the key does not exist in the hashmap, check if the cache has reached its capacity limit. If it has, remove the least frequently used key from the head of the linked list.\\nAdd the key-value pair to the hashmap and insert it into the appropriate position in the linked list based on its frequency.\\n\\nTime Complexity:\\nThe time complexity of getting and setting a key is O(1) on average.\\nThe time complexity of removing the least frequently used key when the cache reaches its capacity limit is O(1) on average.\\n\\nCOde : Read Atricle for codes:\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\nhttps://bit.ly/3Ffj1ZU\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/4fbf3da1-a258-4bdd-9fd9-d9e837b2b64d_1674974240.7890227.jpeg)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 176097,
                "title": "clean-python-solution-using-a-dictionary-and-an-ordereddict-explained",
                "content": "Use a dictionary to store the key to (value, frequency) mapping. Use another dictionary of ordereddict to store the mapping from frequency to all the keys with that frequency. We maintain a minimum frequency so we can get the ordereddict of keys with minimum frequency. Ordereddict stores insert order of keys, so by popping from the head of the ordereddict when reaching capacity, we remove the least recent used key that also has the lowest frequency. \\n```\\nfrom collections import OrderedDict\\nfrom collections import defaultdict\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.keyToValFreq = {} # K: key, V: (val, freq)\\n        # E.g. { freq 1 : {2 : None, 4 : None, 6: None}, freq 2 : {1 : None, 3 : None, 5 : None} }\\n        self.freqToKeyValue = defaultdict(OrderedDict) # K: freq, V: {key : None}\\n        self.capacity = capacity # self.capacity does not change\\n        self.minFreq = 1 # reset to 1 when new element added\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.keyToValFreq:\\n            return -1\\n        val, freq = self.keyToValFreq.pop(key)\\n        self.freqToKeyValue[freq].pop(key)\\n        if len(self.freqToKeyValue[freq]) == 0 and freq == self.minFreq:\\n            self.minFreq = freq + 1\\n        self.freqToKeyValue[freq + 1][key] = None\\n        self.keyToValFreq[key] = (val, freq + 1)\\n        return val\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        # Need to handle edge case of LFU cache capacity = 0.\\n        if self.capacity <= 0:\\n            return\\n        \\n        if key in self.keyToValFreq:\\n            self.get(key) # Update the key freq in dict\\n            self.keyToValFreq[key] = (value, self.keyToValFreq[key][1])\\n            return\\n                \\n        if self.capacity <= len(self.keyToValFreq):\\n            delKey, _ = self.freqToKeyValue[self.minFreq].popitem(last=False) # pop first\\n            self.keyToValFreq.pop(delKey)\\n        \\n        self.keyToValFreq[key] = (value, 1)\\n        self.freqToKeyValue[1][key] = None \\n        self.minFreq = 1\\n\\n\\n",
                "solutionTags": [],
                "code": "Use a dictionary to store the key to (value, frequency) mapping. Use another dictionary of ordereddict to store the mapping from frequency to all the keys with that frequency. We maintain a minimum frequency so we can get the ordereddict of keys with minimum frequency. Ordereddict stores insert order of keys, so by popping from the head of the ordereddict when reaching capacity, we remove the least recent used key that also has the lowest frequency. \\n```\\nfrom collections import OrderedDict\\nfrom collections import defaultdict\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.keyToValFreq = {} # K: key, V: (val, freq)\\n        # E.g. { freq 1 : {2 : None, 4 : None, 6: None}, freq 2 : {1 : None, 3 : None, 5 : None} }\\n        self.freqToKeyValue = defaultdict(OrderedDict) # K: freq, V: {key : None}\\n        self.capacity = capacity # self.capacity does not change\\n        self.minFreq = 1 # reset to 1 when new element added\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.keyToValFreq:\\n            return -1\\n        val, freq = self.keyToValFreq.pop(key)\\n        self.freqToKeyValue[freq].pop(key)\\n        if len(self.freqToKeyValue[freq]) == 0 and freq == self.minFreq:\\n            self.minFreq = freq + 1\\n        self.freqToKeyValue[freq + 1][key] = None\\n        self.keyToValFreq[key] = (val, freq + 1)\\n        return val\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        # Need to handle edge case of LFU cache capacity = 0.\\n        if self.capacity <= 0:\\n            return\\n        \\n        if key in self.keyToValFreq:\\n            self.get(key) # Update the key freq in dict\\n            self.keyToValFreq[key] = (value, self.keyToValFreq[key][1])\\n            return\\n                \\n        if self.capacity <= len(self.keyToValFreq):\\n            delKey, _ = self.freqToKeyValue[self.minFreq].popitem(last=False) # pop first\\n            self.keyToValFreq.pop(delKey)\\n        \\n        self.keyToValFreq[key] = (value, 1)\\n        self.freqToKeyValue[1][key] = None \\n        self.minFreq = 1\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 513157,
                "title": "java-o-1-16-ms-beating-97-using-2-hashmaps-and-doublylinkedlist-with-detailed-explanations",
                "content": "```\\nclass LFUCache {\\n\\n    /*\\n    Approach: Create a class called Node which will be a node of a DoublyLinkedList having key, value, frequency,\\n          prevNode and nextNode.\\n          Use a HashMap (keyNodeMap: key -> Node) to handle data access by key.\\n          Then use a HashMap (freqNodeDLLMap: frequency -> DoublyLinkedList<Node>) to handle frequency.\\n          Also, maintain a variable (minumumFrequency) which will store the current minimum frequency of keys in cache.\\n          Thus if we want to add a new key, we just need to find (or create new) the likedlist by its frequency (which is 1),\\n          add the item to the start of the linked list.\\n          If cache is full and we need to remove an item, we will get the minimum frequency (minumumFrequency),\\n          get the appropriate linkedlist from freqNodeDLLMap by it, then remove the last item of that linkedlist.\\n          Also we\\'ll use the key of that removed item to remove the item from our cache (keyNodeMap).\\n          If we want to increment the freqneucy of a key, we\\'ll get the node, remove it from its current frequency linked list\\n          by joining it\\'s prevNode and nextNode (This is why we\\'re using DoublyLinkedList. No need to find a node by traversing\\n          to remove it. If we have the node, we can just join its previous and next node to remove it.). Then add the node to\\n          the linkedlist of the new (incremented) frequency.\\n          Thus, the frequency ranking management will be done in O(1) time.\\n    \\n    Complexity analysis: Time: O(1), Space: O(n).\\n\\n    */\\n    \\n    \\n    int capacity;\\n    HashMap<Integer, Node> keyNodeMap = new HashMap<>();\\n    HashMap<Integer, NodeDLinkedList> freqNodeDLLMap = new HashMap<>();\\n    int minumumFrequency = 1;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        Node node = keyNodeMap.get(key);\\n        if(node != null){                                                               //Item exists\\n            incrementFrequency(node);                                                   //Increment frequency\\n            return node.value;                                                          //Return value\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(capacity <= 0) return;\\n        \\n        if(keyNodeMap.containsKey(key)){                                                //Item exists\\n            \\n            Node node = keyNodeMap.get(key);                                            //Get old node \\n            node.value = value;                                                         //Update with new value\\n            incrementFrequency(node);                                                   //Increment frequency\\n            keyNodeMap.put(key, node);                                                  //Put (update) in cache\\n        }\\n        else{                                                                           //Item doesn\\'t exist \\n            \\n            Node node = new Node(key, value);                                           //Create new node\\n            \\n            if(keyNodeMap.size() == capacity){                                          //Cache is full\\n                Node removedLastNode = freqNodeDLLMap.get(minumumFrequency)\\n                                        .removeLastNode();                              //Remove LFU node from removedLastNode\\n                keyNodeMap.remove(removedLastNode.key);                                 //Remove LFU node from cache\\n            }\\n            \\n            incrementFrequency(node);                                                   //Add to frequency map\\n            keyNodeMap.put(key, node);                                                  //Add to cache\\n            \\n            minumumFrequency = 1;                                                       //Since new node is having freqency as 1,\\n                                                                                        //update minumumFrequency to be 1\\n        }\\n        \\n    }\\n    \\n    \\n    private void incrementFrequency(Node node){\\n        \\n        int oldFrequency = node.frequency;\\n        \\n        if(freqNodeDLLMap.containsKey(oldFrequency)){                                   //Frequency already exists\\n            NodeDLinkedList oldNodeDLinkedList = freqNodeDLLMap.get(oldFrequency);      //Get frequency linkedlist\\n            oldNodeDLinkedList.remove(node);                                            //Remove current node\\n            if(node.frequency == minumumFrequency &&                                    //If this frequency was the minumum freq.\\n                oldNodeDLinkedList.length == 0){                                        //and no node is having this freq anymore\\n                minumumFrequency++;                                                     //Increment minumum frequency\\n            }\\n        }\\n\\n        int newFrequency = oldFrequency + 1;                                            //Increment frequency\\n        node.frequency = newFrequency;                                                  //Set new frequency to node\\n        NodeDLinkedList newNodeDLinkedList =                                            //Get or create the LinkedList for \\n            freqNodeDLLMap.getOrDefault(                                                //this new frequency\\n            newFrequency, new NodeDLinkedList()\\n        );           \\n        newNodeDLinkedList.add(node);                                                   //Add node to the freq linkedlist\\n        freqNodeDLLMap.put(newFrequency, newNodeDLinkedList);                           //Put freq linkedlist to freqNodeDLLMap\\n    }\\n    \\n    \\n    private class Node{\\n        int key;\\n        int value;\\n        int frequency;\\n        Node prev;\\n        Node next;\\n        Node(int key, int value){\\n            this.key = key;\\n            this.value = value;\\n            this.frequency = frequency;\\n        }\\n    }\\n    \\n    private class NodeDLinkedList{\\n        \\n        Node head, tail;\\n        int length;\\n        \\n        //Add a node to top\\n        void add(Node node){\\n            \\n            //Remove old pointers\\n            node.prev = null;\\n            node.next = null;\\n                \\n            if(head==null){                                                               //Empty list\\n                head = node;\\n                tail = node;\\n            }\\n            else{\\n                node.next = head;                                                         //Forward linking\\n                head.prev = node;                                                         //Backward linking\\n                head = node;\\n            }\\n            \\n            length++;\\n        }\\n        \\n        //Remove a node\\n        void remove(Node node){\\n            \\n            if(node==head){                                                               //Need to remove head node\\n                if(node==tail){                                                           //Tail node is the same (list size = 1) \\n                    tail=null;                                                            //Make tail null\\n                }\\n                head = head.next;                                                         //Make head point to the next node\\n            }\\n            else{                                                                         //Need to remove later node\\n                node.prev.next = node.next;                                               //Forward linking\\n\\n                if(node==tail){                                                           //Need to remove tail node\\n                    tail = node.prev;                                                     //Point tail to prev node\\n                }\\n                else{\\n                    node.next.prev = node.prev;                                           //Backward linking\\n                }\\n            }\\n            \\n            length--;\\n            \\n        }\\n        \\n        //Remove last node\\n        Node removeLastNode(){\\n            \\n            Node tailNode = tail;\\n            \\n            if(tailNode != null){                                                         //LastNode exists \\n                remove(tailNode);\\n            }\\n            return tailNode;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n\\n    /*\\n    Approach: Create a class called Node which will be a node of a DoublyLinkedList having key, value, frequency,\\n          prevNode and nextNode.\\n          Use a HashMap (keyNodeMap: key -> Node) to handle data access by key.\\n          Then use a HashMap (freqNodeDLLMap: frequency -> DoublyLinkedList<Node>) to handle frequency.\\n          Also, maintain a variable (minumumFrequency) which will store the current minimum frequency of keys in cache.\\n          Thus if we want to add a new key, we just need to find (or create new) the likedlist by its frequency (which is 1),\\n          add the item to the start of the linked list.\\n          If cache is full and we need to remove an item, we will get the minimum frequency (minumumFrequency),\\n          get the appropriate linkedlist from freqNodeDLLMap by it, then remove the last item of that linkedlist.\\n          Also we\\'ll use the key of that removed item to remove the item from our cache (keyNodeMap).\\n          If we want to increment the freqneucy of a key, we\\'ll get the node, remove it from its current frequency linked list\\n          by joining it\\'s prevNode and nextNode (This is why we\\'re using DoublyLinkedList. No need to find a node by traversing\\n          to remove it. If we have the node, we can just join its previous and next node to remove it.). Then add the node to\\n          the linkedlist of the new (incremented) frequency.\\n          Thus, the frequency ranking management will be done in O(1) time.\\n    \\n    Complexity analysis: Time: O(1), Space: O(n).\\n\\n    */\\n    \\n    \\n    int capacity;\\n    HashMap<Integer, Node> keyNodeMap = new HashMap<>();\\n    HashMap<Integer, NodeDLinkedList> freqNodeDLLMap = new HashMap<>();\\n    int minumumFrequency = 1;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        Node node = keyNodeMap.get(key);\\n        if(node != null){                                                               //Item exists\\n            incrementFrequency(node);                                                   //Increment frequency\\n            return node.value;                                                          //Return value\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(capacity <= 0) return;\\n        \\n        if(keyNodeMap.containsKey(key)){                                                //Item exists\\n            \\n            Node node = keyNodeMap.get(key);                                            //Get old node \\n            node.value = value;                                                         //Update with new value\\n            incrementFrequency(node);                                                   //Increment frequency\\n            keyNodeMap.put(key, node);                                                  //Put (update) in cache\\n        }\\n        else{                                                                           //Item doesn\\'t exist \\n            \\n            Node node = new Node(key, value);                                           //Create new node\\n            \\n            if(keyNodeMap.size() == capacity){                                          //Cache is full\\n                Node removedLastNode = freqNodeDLLMap.get(minumumFrequency)\\n                                        .removeLastNode();                              //Remove LFU node from removedLastNode\\n                keyNodeMap.remove(removedLastNode.key);                                 //Remove LFU node from cache\\n            }\\n            \\n            incrementFrequency(node);                                                   //Add to frequency map\\n            keyNodeMap.put(key, node);                                                  //Add to cache\\n            \\n            minumumFrequency = 1;                                                       //Since new node is having freqency as 1,\\n                                                                                        //update minumumFrequency to be 1\\n        }\\n        \\n    }\\n    \\n    \\n    private void incrementFrequency(Node node){\\n        \\n        int oldFrequency = node.frequency;\\n        \\n        if(freqNodeDLLMap.containsKey(oldFrequency)){                                   //Frequency already exists\\n            NodeDLinkedList oldNodeDLinkedList = freqNodeDLLMap.get(oldFrequency);      //Get frequency linkedlist\\n            oldNodeDLinkedList.remove(node);                                            //Remove current node\\n            if(node.frequency == minumumFrequency &&                                    //If this frequency was the minumum freq.\\n                oldNodeDLinkedList.length == 0){                                        //and no node is having this freq anymore\\n                minumumFrequency++;                                                     //Increment minumum frequency\\n            }\\n        }\\n\\n        int newFrequency = oldFrequency + 1;                                            //Increment frequency\\n        node.frequency = newFrequency;                                                  //Set new frequency to node\\n        NodeDLinkedList newNodeDLinkedList =                                            //Get or create the LinkedList for \\n            freqNodeDLLMap.getOrDefault(                                                //this new frequency\\n            newFrequency, new NodeDLinkedList()\\n        );           \\n        newNodeDLinkedList.add(node);                                                   //Add node to the freq linkedlist\\n        freqNodeDLLMap.put(newFrequency, newNodeDLinkedList);                           //Put freq linkedlist to freqNodeDLLMap\\n    }\\n    \\n    \\n    private class Node{\\n        int key;\\n        int value;\\n        int frequency;\\n        Node prev;\\n        Node next;\\n        Node(int key, int value){\\n            this.key = key;\\n            this.value = value;\\n            this.frequency = frequency;\\n        }\\n    }\\n    \\n    private class NodeDLinkedList{\\n        \\n        Node head, tail;\\n        int length;\\n        \\n        //Add a node to top\\n        void add(Node node){\\n            \\n            //Remove old pointers\\n            node.prev = null;\\n            node.next = null;\\n                \\n            if(head==null){                                                               //Empty list\\n                head = node;\\n                tail = node;\\n            }\\n            else{\\n                node.next = head;                                                         //Forward linking\\n                head.prev = node;                                                         //Backward linking\\n                head = node;\\n            }\\n            \\n            length++;\\n        }\\n        \\n        //Remove a node\\n        void remove(Node node){\\n            \\n            if(node==head){                                                               //Need to remove head node\\n                if(node==tail){                                                           //Tail node is the same (list size = 1) \\n                    tail=null;                                                            //Make tail null\\n                }\\n                head = head.next;                                                         //Make head point to the next node\\n            }\\n            else{                                                                         //Need to remove later node\\n                node.prev.next = node.next;                                               //Forward linking\\n\\n                if(node==tail){                                                           //Need to remove tail node\\n                    tail = node.prev;                                                     //Point tail to prev node\\n                }\\n                else{\\n                    node.next.prev = node.prev;                                           //Backward linking\\n                }\\n            }\\n            \\n            length--;\\n            \\n        }\\n        \\n        //Remove last node\\n        Node removeLastNode(){\\n            \\n            Node tailNode = tail;\\n            \\n            if(tailNode != null){                                                         //LastNode exists \\n                remove(tailNode);\\n            }\\n            return tailNode;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94673,
                "title": "c-solution-with-detailed-explanations-using-indexed-priority-queue-i-e-hashmap-priority-queue",
                "content": "Here is my solution to implement a Least Frequently Used Cache in C++. \\n\\n* The idea is straightforward. We maintain a min-PriorityQueue with the least frequently used element at the top. However, when we access any existing element using get() or set(), its usage frequency should be increased by one, which forces us to change its position in the priority queue (re-heapify). Unfortunately, native STL PriorityQueue does not support this operation. Therefore, we need to create our own priority queue and modify it. I found the so-called [Index Priority Queue](http://algs4.cs.princeton.edu/24pq/) is suitable for this task (*believe me, it is very simple to grasp. Use it to impress your interviewer!*).  It maintains not only a priority queue but also a hash map, \"indexMap\", that maps the key of an element to its position (index) in the priority queue. Now, we can quickly access any element in the priority queue and re-heapify the PriorityQueue, when the usage frequency of an element changes.\\n\\n* Another tricky point is that when we need to evict an element, but multiple elements have the same (minimum) usage frequency, we need to evict the least recently used (the oldest) element. To handle this, I maintain a time-stamp variable for each element in the LFU Cache, which indicates the latest time stamp when we access it. Therefore, we maintain the following invariant in the priority queue: **When two elements have the same usage frequency, the least recently used one will always be closer to root node**. When there are multiple least frequently used elements, we always retrieve the one closer to the root.\\n\\n```\\nclass LFUCache {\\npublic:\\n    struct Node {\\n        int key; // key of the element.\\n        int val; // value of the ement.\\n        int fre; // usage frequency\\n        int timeStamp; // the latest time stamp when this element is accessed.\\n        Node(): key(-1), val(-1), timeStamp(-1), fre(0) {}\\n        Node(int k, int v, int ts): key(k), val(v), timeStamp(ts), fre(1) {}\\n    };\\n\\n    LFUCache(int capacity) {\\n        Cap = capacity;\\n        Node* dummy = new Node();\\n        pq.push_back(dummy); // The pq start from pq[1].\\n        ts = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!mp.count(key)) return -1;\\n        int index = mp[key];\\n        int val = pq[index]->val;\\n\\tpq[index]->fre++;\\n\\tpq[index]->timeStamp = ++ts;\\n        sink(index);\\n        return val;\\n    }\\n    \\n    void set(int key, int value) {\\n        if(Cap <= 0) return;\\n\\tif(mp.count(key)) {\\n\\t   int index = mp[key];\\n\\t   pq[index]->val = value;\\n\\t   get(key);\\n\\t}\\n\\telse {\\n\\t    if(pq.size() - 1 == Cap) {\\n\\t        int oldKey = pq[1]->key;\\n\\t\\tmp.erase(oldKey);\\n\\t\\tNode* newnode = new Node(key, value, ++ts);\\n\\t\\tpq[1] = newnode;\\n\\t\\tmp[key] = 1;\\n\\t\\tsink(1);\\n\\t    }\\n\\t    else {\\n\\t        Node* newnode = new Node(key, value, ++ts);\\n\\t\\tpq.push_back(newnode);\\n\\t\\tmp[key] = pq.size() - 1;\\n\\t\\tswim(pq.size() - 1);\\n\\t    }\\n\\t}\\n    }\\n    \\nprivate:\\n\\tvector<Node*> pq; // A priority queue, with the least usage frequency and least recently used element at the top.\\n\\tunordered_map<int, int> mp; // A mapping from the key of the element to its index in the priority queue.\\n\\tint Cap; // Capcity of the cache\\n\\tint ts; // time-stamp: indicate the time stamp of the latest operation of an element. According to the requirement of LFU cache, when we need to evict an element from the cache, but there are multiple elements with the same minimum frequency, then the least recently used element should be evicted.\\n\\n    /*\\n     * Recursively sink a node in priority queue. A node will be sinked, when its frequency is larger than any of its\\n     * children nodes, or the node has the same frequency with a child, but it is recently updated. \\n     */\\n\\tvoid sink(int index) {\\n\\t    int left = 2 * index, right = 2 * index + 1, target = index;\\n\\t    if(left < pq.size() && pq[left]->fre <= pq[target]->fre) // If the left child has the same frequency, we probably need to swap the parent node and the child node, because the parent node is recently accessed, and the left child node was accessed at an older time stamp.\\n               target = left;\\n            if(right < pq.size()) { \\n                if(pq[right]->fre < pq[target]->fre || (pq[right]->fre == pq[target]->fre && pq[right]->timeStamp < pq[target]->timeStamp)) // If right child has the same frequency and an older time stamp, we must swap it.\\n                     target = right;\\n\\t\\t}\\n\\t\\tif(target != index) {\\n\\t\\t    myswap(target, index);\\n\\t            sink(target);\\n\\t\\t}\\n\\t}\\n    \\n    /*a\\n     * Recursively swim a node in priority queue. A node will be swimmed, when its frequency is less than its\\n     * parent node. If the node has the same frequency with its parent, it is not needed to be swimmed, because\\n     * it is recently accessed.\\n     */\\n\\tvoid swim(int index) {\\n\\t    int par = index / 2;\\n\\t    while(par > 0 && pq[par]->fre > pq[index]->fre) {\\n\\t        myswap(par, index);\\n\\t\\tindex = par;\\n\\t\\tpar /= 2;\\n\\t    }\\n\\t}\\n\\n\\tvoid myswap(int id1, int id2) {\\n\\t    swap(pq[id1], pq[id2]);\\n\\t    mp[pq[id1]->key] = id1;\\n\\t    mp[pq[id2]->key] = id2;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\npublic:\\n    struct Node {\\n        int key; // key of the element.\\n        int val; // value of the ement.\\n        int fre; // usage frequency\\n        int timeStamp; // the latest time stamp when this element is accessed.\\n        Node(): key(-1), val(-1), timeStamp(-1), fre(0) {}\\n        Node(int k, int v, int ts): key(k), val(v), timeStamp(ts), fre(1) {}\\n    };\\n\\n    LFUCache(int capacity) {\\n        Cap = capacity;\\n        Node* dummy = new Node();\\n        pq.push_back(dummy); // The pq start from pq[1].\\n        ts = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!mp.count(key)) return -1;\\n        int index = mp[key];\\n        int val = pq[index]->val;\\n\\tpq[index]->fre++;\\n\\tpq[index]->timeStamp = ++ts;\\n        sink(index);\\n        return val;\\n    }\\n    \\n    void set(int key, int value) {\\n        if(Cap <= 0) return;\\n\\tif(mp.count(key)) {\\n\\t   int index = mp[key];\\n\\t   pq[index]->val = value;\\n\\t   get(key);\\n\\t}\\n\\telse {\\n\\t    if(pq.size() - 1 == Cap) {\\n\\t        int oldKey = pq[1]->key;\\n\\t\\tmp.erase(oldKey);\\n\\t\\tNode* newnode = new Node(key, value, ++ts);\\n\\t\\tpq[1] = newnode;\\n\\t\\tmp[key] = 1;\\n\\t\\tsink(1);\\n\\t    }\\n\\t    else {\\n\\t        Node* newnode = new Node(key, value, ++ts);\\n\\t\\tpq.push_back(newnode);\\n\\t\\tmp[key] = pq.size() - 1;\\n\\t\\tswim(pq.size() - 1);\\n\\t    }\\n\\t}\\n    }\\n    \\nprivate:\\n\\tvector<Node*> pq; // A priority queue, with the least usage frequency and least recently used element at the top.\\n\\tunordered_map<int, int> mp; // A mapping from the key of the element to its index in the priority queue.\\n\\tint Cap; // Capcity of the cache\\n\\tint ts; // time-stamp: indicate the time stamp of the latest operation of an element. According to the requirement of LFU cache, when we need to evict an element from the cache, but there are multiple elements with the same minimum frequency, then the least recently used element should be evicted.\\n\\n    /*\\n     * Recursively sink a node in priority queue. A node will be sinked, when its frequency is larger than any of its\\n     * children nodes, or the node has the same frequency with a child, but it is recently updated. \\n     */\\n\\tvoid sink(int index) {\\n\\t    int left = 2 * index, right = 2 * index + 1, target = index;\\n\\t    if(left < pq.size() && pq[left]->fre <= pq[target]->fre) // If the left child has the same frequency, we probably need to swap the parent node and the child node, because the parent node is recently accessed, and the left child node was accessed at an older time stamp.\\n               target = left;\\n            if(right < pq.size()) { \\n                if(pq[right]->fre < pq[target]->fre || (pq[right]->fre == pq[target]->fre && pq[right]->timeStamp < pq[target]->timeStamp)) // If right child has the same frequency and an older time stamp, we must swap it.\\n                     target = right;\\n\\t\\t}\\n\\t\\tif(target != index) {\\n\\t\\t    myswap(target, index);\\n\\t            sink(target);\\n\\t\\t}\\n\\t}\\n    \\n    /*a\\n     * Recursively swim a node in priority queue. A node will be swimmed, when its frequency is less than its\\n     * parent node. If the node has the same frequency with its parent, it is not needed to be swimmed, because\\n     * it is recently accessed.\\n     */\\n\\tvoid swim(int index) {\\n\\t    int par = index / 2;\\n\\t    while(par > 0 && pq[par]->fre > pq[index]->fre) {\\n\\t        myswap(par, index);\\n\\t\\tindex = par;\\n\\t\\tpar /= 2;\\n\\t    }\\n\\t}\\n\\n\\tvoid myswap(int id1, int id2) {\\n\\t    swap(pq[id1], pq[id2]);\\n\\t    mp[pq[id1]->key] = id1;\\n\\t    mp[pq[id2]->key] = id2;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160812,
                "title": "2-hashmap-doubly-linked-list-o-1-time-complexity-c-easy-solution-with-proper-explanation",
                "content": "#### All we need to implement LFU cache is **2 hash maps**, **1 doubly linked list** and **1 integer variable**.\\n<br/>\\n\\n **Two hash maps and a variable will function as follows:**\\n_______________________________________________________\\n<br/>\\n\\n1) **freqMap** : hashmap<  **freq**,  **list< (key,value) >**  > \\n\\nFor each frequency (of key-value pairs in LFU cache) this hashmap will store doubly linked list of key-value pairs corresponding to that freq.\\n\\t\\n\\tE.g. Doubly linked list of (key,value) with frequency of 1 and 2:\\n\\t\\n\\tfreqMap[1] = (1,2) -> (3,6) -> (1,8) -> null\\n\\tfreqMap[2] = (2,2) -> (9,4) -> (7,8) -> null\\n\\t\\n\\n2) **keyMap** : unordered_map<  **key**,  **pair< freq, list< (key,value) >::iterator>**  > keyMap;\\n\\nFor each key in the LFU cache this hashmap will map it to the location where the key is present in **freqMap** by storing both frequency (for finding the exact linked list in which the key-value is present) and iterator ( for locating key-value in the corresponding list in O(1) time ).\\n\\n3) **lowestFreq**: int\\n\\nWe also need a variable to store the lowest frequency with each key-value is present in LFU cache.\\n\\n<br/>\\n\\n\\n**put() and get() methods will work as follows:**\\n____________________________________________________\\n<br/>\\n\\n1) **put(key, value)**:\\n\\nWe will be calling **put()** method in two possible scenarios.\\n\\n**Scenario 1**: We want to add a new (not already present) key-value pair into the LFU cache. Corresponding to this scenario we have to handle two cases:\\n\\n_Case 1_: **LFU cache is not full.**\\n\\nFor this case first we will add the key-value pair to the list with frequency 1 (in **freqMap[1]**). Then we will also add this key to **keyMap** along with its frequency and location in its list. \\nNow, we must also update **lowestFreq** to be equal to 1.\\n\\n_Case 2_: **LFU cache is full.**\\n\\nIf the LFU cache is full then we must first fetch the first key-value pair from the beginning of the list (beginning because we want to remove the least recently used key) with lowest frequency. \\nAfter getting the key-value pair we must remove the the key-value pair from its list and also we must remove the key from **keyMap**. \\nNow we have made space for putting new key-value pair into the LFU cache. All we need to do now is call **put()** method with key-value to be added and _Case 1_ will handle it.\\n\\n**Scenario 2**: We want to update the value of an already present key in the LFU Cache.\\n\\nFor this first we need to find out what is the frequency **freq** of the key-value pair and the location **it** of this key-value pair in **freqMap**. \\n\\nIf the **freq** is equal to the **lowestFreq** and the current key-value pair is the only one in its linked list then it is neccessary that we increment the **lowestFreq** by 1, otherwise we can leave it as it is.\\n\\nNow using **freq** (to get the corresponding list from **freqMap**) and **it** ( to locate key-value in the list in O(1) ) we can remove the key-value pair from its current list and add it to the list associated with frequency **freq+1** in **freqMap**, then we will also update **keyMap** with new frequency and location of key-value pair.\\n\\n```cpp\\nvoid put(int key, int value) {\\n  \\n\\t// Scenario 1:\\n\\tif (!keyMap.count(key)) {\\n\\t\\tif (keyMap.size() < cap) {  // Case 1:\\n\\t\\t\\tfreqMap[1].emplace_back(key, value);\\n\\t\\t\\tkeyMap[key] = {1, --freqMap[1].end()};\\n\\t\\t\\tlowestFreq = 1;\\n\\t\\t} else {  // Case 2:\\n\\t\\t\\tif (lowestFreq == 0) return;\\n\\t\\t\\tauto [k, v] = freqMap[lowestFreq].front();\\n\\t\\t\\tfreqMap[lowestFreq].erase(freqMap[lowestFreq].begin());\\n\\t\\t\\tkeyMap.erase(k);\\n\\t\\t\\tput(key, value);\\n\\t\\t}\\n\\t\\treturn;\\n\\t} \\n // Scenario 2:\\n  if (keyMap.count(key)) {\\n\\t\\tauto [freq, it] = keyMap[key];\\n\\t\\tif (freqMap[freq].size() == 1 and freq == lowestFreq) lowestFreq++;\\n\\t\\tfreqMap[freq].erase(it);\\n\\t\\tfreqMap[freq+1].emplace_back(key, value);\\n\\t\\tkeyMap[key] = {freq, --freqMap[freq+1].end()};\\n\\t}\\n}\\n```\\n\\n2) **get(key)**:\\n\\nFirst we will check for presence of key in **keyMap**. \\n\\n_Case 1_: **If key is not present.** We must return -1 in this case.\\n\\n_Case 2_: **If key is present.** We will store, in a variable **val**, the value associated with the key. And then to update the key-value pair\\'s frequency we will call **put(key,val)** method.\\n\\n```cpp\\nint get(int key) {\\n\\tif(mp.count(key)){\\n\\t\\tint val = ( *(mp[key].second) ).second;\\n\\t\\tput(key,val);\\n\\t\\treturn val;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n\\n--------------------------------------------------------------------------------------------------------------\\n\\n**Full Code:**\\n\\n```\\nclass LFUCache {\\n    \\n    unordered_map<int, list<pair<int, int>>> freqMap;\\n    unordered_map<int, pair<int, list<pair<int, int>>::iterator>> keyMap;\\n    int lowestFreq = 0;\\n    int cap;\\n\\n    public:\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n\\n    int get(int key) {\\n        if (keyMap.count(key)) {\\n            int val = (*(keyMap[key].second)).second;\\n            put(key, val);\\n            return val;\\n        }\\n        return -1;\\n    }\\n\\n    void put(int key, int value) {\\n        if (!keyMap.count(key)) {\\n            if (keyMap.size() < cap) {\\n                freqMap[1].emplace_back(key, value);\\n                keyMap[key] = {1, --freqMap[1].end()};\\n                lowestFreq = 1;\\n            } else {\\n                if (lowestFreq == 0) return;\\n                auto [k, v] = freqMap[lowestFreq].front();\\n                freqMap[lowestFreq].erase(freqMap[lowestFreq].begin());\\n                keyMap.erase(k);\\n                put(key, value);\\n            }\\n        } else {\\n            auto [freq, it] = keyMap[key];\\n            if (freqMap[freq].size() == 1 and freq == lowestFreq) lowestFreq++;\\n            freqMap[freq].erase(it);\\n            freqMap[freq+1].emplace_back(key, value);\\n            keyMap[key] = {freq+1, --freqMap[freq+1].end()};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvoid put(int key, int value) {\\n  \\n\\t// Scenario 1:\\n\\tif (!keyMap.count(key)) {\\n\\t\\tif (keyMap.size() < cap) {  // Case 1:\\n\\t\\t\\tfreqMap[1].emplace_back(key, value);\\n\\t\\t\\tkeyMap[key] = {1, --freqMap[1].end()};\\n\\t\\t\\tlowestFreq = 1;\\n\\t\\t} else {  // Case 2:\\n\\t\\t\\tif (lowestFreq == 0) return;\\n\\t\\t\\tauto [k, v] = freqMap[lowestFreq].front();\\n\\t\\t\\tfreqMap[lowestFreq].erase(freqMap[lowestFreq].begin());\\n\\t\\t\\tkeyMap.erase(k);\\n\\t\\t\\tput(key, value);\\n\\t\\t}\\n\\t\\treturn;\\n\\t} \\n // Scenario 2:\\n  if (keyMap.count(key)) {\\n\\t\\tauto [freq, it] = keyMap[key];\\n\\t\\tif (freqMap[freq].size() == 1 and freq == lowestFreq) lowestFreq++;\\n\\t\\tfreqMap[freq].erase(it);\\n\\t\\tfreqMap[freq+1].emplace_back(key, value);\\n\\t\\tkeyMap[key] = {freq, --freqMap[freq+1].end()};\\n\\t}\\n}\\n```\n```cpp\\nint get(int key) {\\n\\tif(mp.count(key)){\\n\\t\\tint val = ( *(mp[key].second) ).second;\\n\\t\\tput(key,val);\\n\\t\\treturn val;\\n\\t}\\n\\treturn -1;\\n}\\n```\n```\\nclass LFUCache {\\n    \\n    unordered_map<int, list<pair<int, int>>> freqMap;\\n    unordered_map<int, pair<int, list<pair<int, int>>::iterator>> keyMap;\\n    int lowestFreq = 0;\\n    int cap;\\n\\n    public:\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n\\n    int get(int key) {\\n        if (keyMap.count(key)) {\\n            int val = (*(keyMap[key].second)).second;\\n            put(key, val);\\n            return val;\\n        }\\n        return -1;\\n    }\\n\\n    void put(int key, int value) {\\n        if (!keyMap.count(key)) {\\n            if (keyMap.size() < cap) {\\n                freqMap[1].emplace_back(key, value);\\n                keyMap[key] = {1, --freqMap[1].end()};\\n                lowestFreq = 1;\\n            } else {\\n                if (lowestFreq == 0) return;\\n                auto [k, v] = freqMap[lowestFreq].front();\\n                freqMap[lowestFreq].erase(freqMap[lowestFreq].begin());\\n                keyMap.erase(k);\\n                put(key, value);\\n            }\\n        } else {\\n            auto [freq, it] = keyMap[key];\\n            if (freqMap[freq].size() == 1 and freq == lowestFreq) lowestFreq++;\\n            freqMap[freq].erase(it);\\n            freqMap[freq+1].emplace_back(key, value);\\n            keyMap[key] = {freq+1, --freqMap[freq+1].end()};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94538,
                "title": "python-fast-220ms-using-heap",
                "content": "get() is O(1) since if the key already exists it updates the time and frequency, retrieves the value. It also adds the key to a set of keys to be updated later. All of these are hash map/sets.\\n\\nput is O(1) if the key is already in the map. The operations here are the same as get().\\nput is O(log k) for a new key when the cache is not at capacity. The tuple (freq = 0, time, key) is added to heap.\\n\\nIt gets a bit more tricky to put() a new key when the cache is at capacity. Now we need to pop the least frequent item (ties broken by oldest) off the heap. But first we update the (freq, time) at the top of the heap if it has been updated (i.e. there has been a get or put) since the previous update. This takes O(k log k) if everything already in the cache has been get() or put() since the last new item added. \\n\\nThanks to whoever submitted a similar idea first!\\n\\n```\\nimport heapq\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.time = 0\\n        self.map = {}               # key to value\\n        self.freq_time = {}         # key to (freq, time)\\n        self.priority_queue = []    # (freq, time, key), only updated when new key is added\\n        self.update = set()         # keys that have been get/put since last new key was added\\n\\n        \\n    def get(self, key):\\n        self.time += 1\\n\\n        if key in self.map:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n            return self.map[key]\\n        \\n        return -1\\n\\n    \\n    def put(self, key, value):\\n        if self.capacity <= 0:\\n            return \\n        \\n        self.time += 1\\n        if not key in self.map:\\n            \\n            if len(self.map) >= self.capacity:      # must remove least frequent from cache\\n                \\n                while self.priority_queue and self.priority_queue[0][2] in self.update:\\n                    # whilst (least frequent, oldest) needs to be updated, update it and add back to heap\\n                    _, _, k = heapq.heappop(self.priority_queue)\\n                    f, t = self.freq_time[k]\\n                    heapq.heappush(self.priority_queue, (f, t, k))\\n                    self.update.remove(k)\\n\\n                # remove (least frequent, oldest)\\n                _, _, k = heapq.heappop(self.priority_queue)\\n                self.map.pop(k)\\n                self.freq_time.pop(k)\\n            \\n            self.freq_time[key] = (0, self.time)\\n            heapq.heappush(self.priority_queue, (0, self.time, key))\\n            \\n        else:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n\\n        self.map[key] = value\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.time = 0\\n        self.map = {}               # key to value\\n        self.freq_time = {}         # key to (freq, time)\\n        self.priority_queue = []    # (freq, time, key), only updated when new key is added\\n        self.update = set()         # keys that have been get/put since last new key was added\\n\\n        \\n    def get(self, key):\\n        self.time += 1\\n\\n        if key in self.map:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n            return self.map[key]\\n        \\n        return -1\\n\\n    \\n    def put(self, key, value):\\n        if self.capacity <= 0:\\n            return \\n        \\n        self.time += 1\\n        if not key in self.map:\\n            \\n            if len(self.map) >= self.capacity:      # must remove least frequent from cache\\n                \\n                while self.priority_queue and self.priority_queue[0][2] in self.update:\\n                    # whilst (least frequent, oldest) needs to be updated, update it and add back to heap\\n                    _, _, k = heapq.heappop(self.priority_queue)\\n                    f, t = self.freq_time[k]\\n                    heapq.heappush(self.priority_queue, (f, t, k))\\n                    self.update.remove(k)\\n\\n                # remove (least frequent, oldest)\\n                _, _, k = heapq.heappop(self.priority_queue)\\n                self.map.pop(k)\\n                self.freq_time.pop(k)\\n            \\n            self.freq_time[key] = (0, self.time)\\n            heapq.heappush(self.priority_queue, (0, self.time, key))\\n            \\n        else:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n\\n        self.map[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111378,
                "title": "easy-solution-fully-explained-c-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                        Please Upvote If You Find It Helpful.\\n```\\n# Complexity\\nTime Complexity : O(1)\\n\\nSpace Complexity : O(N)\\n# Code\\n```\\nclass LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n```\\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n                        Please Upvote If You Find It Helpful.\\n```\n```\\nclass LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n```\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446443,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Use one hashmap `nodeHash` to store information between key:node\\n2. Use another hashmap `freqHash` to store information between freq:dll (doublylinkedlist)\\n3. Use Doublylinkedlist to store a LRU for a given freq\\n4. I use dummy head&tail for easier implementation\\n``` javascript\\nclass Node{\\n    constructor(key, value) {\\n        this.key = key;\\n        this.val = value;\\n        this.next = this.prev = null;\\n        this.freq = 1;\\n    }\\n}\\n\\nclass DoublyLinkedList {\\n    constructor() {\\n        this.head = new Node(null,null);\\n        this.tail = new Node(null,null);\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n\\n    insertHead(node) {\\n        node.prev = this.head;\\n        node.next = this.head.next;\\n        this.head.next.prev = node;\\n        this.head.next = node;\\n    }\\n\\n    removeNode(node) {\\n        let prev = node.prev;\\n        let next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n    removeTail() {\\n        let node = this.tail.prev;\\n        this.removeNode(node);\\n        return node.key;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next.val == null;\\n    }\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.currentSize = 0;\\n    this.leastFreq = 0;\\n    this.nodeHash = new Map();\\n    this.freqHash = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n    let node = this.nodeHash.get(key);\\n    if (!node) return -1;\\n    this.freqHash.get(node.freq).removeNode(node);\\n    if (node.freq==this.leastFreq && this.freqHash.get(node.freq).isEmpty()) this.leastFreq++\\n    node.freq++;\\n    // freqHash housekeeping\\n    if (this.freqHash.get(node.freq)==null) this.freqHash.set(node.freq, new DoublyLinkedList())\\n    this.freqHash.get(node.freq).insertHead(node);\\n    return node.val;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n    if (this.capacity == 0) return;\\n    let node = this.nodeHash.get(key);\\n    if (!node) { // new node\\n        this.currentSize++;\\n        if (this.currentSize > this.capacity) {\\n            let tailKey = this.freqHash.get(this.leastFreq).removeTail();\\n            this.nodeHash.delete(tailKey);\\n            this.currentSize--;\\n        }\\n        let newNode = new Node(key, value);\\n        // freqHash housekeeping\\n        if (this.freqHash.get(1)==null) this.freqHash.set(1, new DoublyLinkedList())\\n        this.freqHash.get(1).insertHead(newNode);\\n\\n        this.nodeHash.set(key, newNode);\\n        this.leastFreq = 1;\\n\\n    } else { // existed node\\n        node.val = value;\\n        this.freqHash.get(node.freq).removeNode(node);\\n        if (node.freq == this.leastFreq && this.freqHash.get(node.freq).isEmpty()) this.leastFreq++;\\n        node.freq++;\\n        // freqHash housekeeping\\n        if (this.freqHash.get(node.freq)==null) this.freqHash.set(node.freq, new DoublyLinkedList())\\n        this.freqHash.get(node.freq).insertHead(node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nclass Node{\\n    constructor(key, value) {\\n        this.key = key;\\n        this.val = value;\\n        this.next = this.prev = null;\\n        this.freq = 1;\\n    }\\n}\\n\\nclass DoublyLinkedList {\\n    constructor() {\\n        this.head = new Node(null,null);\\n        this.tail = new Node(null,null);\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n\\n    insertHead(node) {\\n        node.prev = this.head;\\n        node.next = this.head.next;\\n        this.head.next.prev = node;\\n        this.head.next = node;\\n    }\\n\\n    removeNode(node) {\\n        let prev = node.prev;\\n        let next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n    removeTail() {\\n        let node = this.tail.prev;\\n        this.removeNode(node);\\n        return node.key;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next.val == null;\\n    }\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.currentSize = 0;\\n    this.leastFreq = 0;\\n    this.nodeHash = new Map();\\n    this.freqHash = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n    let node = this.nodeHash.get(key);\\n    if (!node) return -1;\\n    this.freqHash.get(node.freq).removeNode(node);\\n    if (node.freq==this.leastFreq && this.freqHash.get(node.freq).isEmpty()) this.leastFreq++\\n    node.freq++;\\n    // freqHash housekeeping\\n    if (this.freqHash.get(node.freq)==null) this.freqHash.set(node.freq, new DoublyLinkedList())\\n    this.freqHash.get(node.freq).insertHead(node);\\n    return node.val;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n    if (this.capacity == 0) return;\\n    let node = this.nodeHash.get(key);\\n    if (!node) { // new node\\n        this.currentSize++;\\n        if (this.currentSize > this.capacity) {\\n            let tailKey = this.freqHash.get(this.leastFreq).removeTail();\\n            this.nodeHash.delete(tailKey);\\n            this.currentSize--;\\n        }\\n        let newNode = new Node(key, value);\\n        // freqHash housekeeping\\n        if (this.freqHash.get(1)==null) this.freqHash.set(1, new DoublyLinkedList())\\n        this.freqHash.get(1).insertHead(newNode);\\n\\n        this.nodeHash.set(key, newNode);\\n        this.leastFreq = 1;\\n\\n    } else { // existed node\\n        node.val = value;\\n        this.freqHash.get(node.freq).removeNode(node);\\n        if (node.freq == this.leastFreq && this.freqHash.get(node.freq).isEmpty()) this.leastFreq++;\\n        node.freq++;\\n        // freqHash housekeeping\\n        if (this.freqHash.get(node.freq)==null) this.freqHash.set(node.freq, new DoublyLinkedList())\\n        this.freqHash.get(node.freq).insertHead(node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112035,
                "title": "python-simple-two-hash-maps-explained",
                "content": "We only need two hash maps to maintain the LFU cache:\\n(1) the first hash map: maps key to (value, count) pair\\n(2) the second hash map: maps count to an OrderedDict which maintains key, value pairs\\n\\nThe get method: we need to check the first hash map, and update the count in it. Based on the new count of the key, we update the second hash map: a) move the (key, value) pair from old_cnt to old_cnt + 1; b) move the (key, value) pair inside the OrderedDict to the tail.\\n\\nThe put method: we add one new key to the first hash map. If the cache is already full, we need to pop out the item with the least count. If there are multiple keys with the same least count, we just pop out the item from the head of the OrderedDict.\\n\\n```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        # data structure 1: dictionary which maps key to count\\n        # data strcuture 2: dictionary which maps count to a orderedDict\\n        self.capacity = capacity\\n        self.used = 0\\n        self.cache_key = dict()\\n        self.cache_orderedCount = dict()\\n        self.min_cnt = 0\\n        \\n\\n    def get(self, key: int) -> int:\\n        val = -1\\n        if key in self.cache_key:\\n            val = self.cache_key[key][0]\\n            old_cnt = self.cache_key[key][1]\\n            self.cache_key[key][1] += 1\\n            # update the count dictionary\\n            del self.cache_orderedCount[old_cnt][key]\\n            # insert the key into the new count dictionary\\n            new_cnt = self.cache_key[key][1]\\n            self._updateCacheCountDict(key, val, new_cnt)\\n            # update the min count\\n            if self.min_cnt == old_cnt and len(self.cache_orderedCount[old_cnt]) == 0:\\n                self.min_cnt = new_cnt\\n        return val\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return\\n        \\n        if key in self.cache_key:\\n            self.cache_key[key][0] = value\\n            old_cnt = self.cache_key[key][1]\\n            self.cache_key[key][1] += 1\\n            new_cnt = old_cnt + 1\\n            del self.cache_orderedCount[old_cnt][key]\\n            self._updateCacheCountDict(key, value, new_cnt)\\n            # update the min count\\n            if self.min_cnt == old_cnt and len(self.cache_orderedCount[old_cnt]) == 0:\\n                self.min_cnt = new_cnt\\n        else:\\n            # the key is not in cache yet\\n            if self.used < self.capacity:\\n                # the cache is not full, we can directly add the new key value pair\\n                self.cache_key[key] = [value, 1]\\n                self._updateCacheCountDict(key, value, 1)\\n                self.used += 1\\n                self.min_cnt = 1\\n            else:\\n                # the cache is full\\n                rm_key, rm_val = self.cache_orderedCount[self.min_cnt].popitem(0)\\n                del self.cache_key[rm_key]\\n                # add new key value\\n                self.cache_key[key] = [value, 1]\\n                self._updateCacheCountDict(key, value, 1)\\n                self.min_cnt = 1\\n                \\n    def _updateCacheCountDict(self, key, value, new_cnt):\\n        if new_cnt not in self.cache_orderedCount:\\n            self.cache_orderedCount[new_cnt] = OrderedDict()\\n        self.cache_orderedCount[new_cnt][key] = value\\n        self.cache_orderedCount[new_cnt].move_to_end(key)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        # data structure 1: dictionary which maps key to count\\n        # data strcuture 2: dictionary which maps count to a orderedDict\\n        self.capacity = capacity\\n        self.used = 0\\n        self.cache_key = dict()\\n        self.cache_orderedCount = dict()\\n        self.min_cnt = 0\\n        \\n\\n    def get(self, key: int) -> int:\\n        val = -1\\n        if key in self.cache_key:\\n            val = self.cache_key[key][0]\\n            old_cnt = self.cache_key[key][1]\\n            self.cache_key[key][1] += 1\\n            # update the count dictionary\\n            del self.cache_orderedCount[old_cnt][key]\\n            # insert the key into the new count dictionary\\n            new_cnt = self.cache_key[key][1]\\n            self._updateCacheCountDict(key, val, new_cnt)\\n            # update the min count\\n            if self.min_cnt == old_cnt and len(self.cache_orderedCount[old_cnt]) == 0:\\n                self.min_cnt = new_cnt\\n        return val\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return\\n        \\n        if key in self.cache_key:\\n            self.cache_key[key][0] = value\\n            old_cnt = self.cache_key[key][1]\\n            self.cache_key[key][1] += 1\\n            new_cnt = old_cnt + 1\\n            del self.cache_orderedCount[old_cnt][key]\\n            self._updateCacheCountDict(key, value, new_cnt)\\n            # update the min count\\n            if self.min_cnt == old_cnt and len(self.cache_orderedCount[old_cnt]) == 0:\\n                self.min_cnt = new_cnt\\n        else:\\n            # the key is not in cache yet\\n            if self.used < self.capacity:\\n                # the cache is not full, we can directly add the new key value pair\\n                self.cache_key[key] = [value, 1]\\n                self._updateCacheCountDict(key, value, 1)\\n                self.used += 1\\n                self.min_cnt = 1\\n            else:\\n                # the cache is full\\n                rm_key, rm_val = self.cache_orderedCount[self.min_cnt].popitem(0)\\n                del self.cache_key[rm_key]\\n                # add new key value\\n                self.cache_key[key] = [value, 1]\\n                self._updateCacheCountDict(key, value, 1)\\n                self.min_cnt = 1\\n                \\n    def _updateCacheCountDict(self, key, value, new_cnt):\\n        if new_cnt not in self.cache_orderedCount:\\n            self.cache_orderedCount[new_cnt] = OrderedDict()\\n        self.cache_orderedCount[new_cnt][key] = value\\n        self.cache_orderedCount[new_cnt].move_to_end(key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460867,
                "title": "c-solution-doubly-linked-list-and-hashmap-full-explanation",
                "content": "All the explanations and intuitions are mentioned in the comments inside the code. Follow the code step-by-step...\\n\\nCode:\\n\\n```cpp\\n// Doubly Linked-List-Node class with prev and next pointers\\nclass Node {\\npublic:\\n    int key, val, cnt;\\n    Node *next, *prev;\\n    Node(int _key, int _val) {\\n        key = _key;\\n        val = _val;\\n        cnt = 1;    // counter for maintaining the frequency of the Node\\n    }\\n};\\n\\n\\n// Doubly Linked-List class with head and tail pointers\\nclass List {\\npublic:\\n    int len;\\n    Node *head, *tail;\\n\\n    List() {\\n        head = new Node(0, 0);\\n        tail = new Node(0, 0);\\n        head->next = tail;\\n        tail->prev = head;\\n        len = 0;\\n    }\\n\\n    // adds a new Node at the front (MRU position) of a doubly-linked-list\\n    // (adds a new node in-between two pre-existing nodes)\\n    void addNode(Node *newNode) {\\n        Node *temp = head->next;\\n        newNode->next = temp;\\n        newNode->prev = head;\\n        head->next = newNode;\\n        temp->prev = newNode;\\n        len++;\\n    }\\n\\n    // deletes a Node (generally the LRU node) from a doubly-linked-list\\n    // (breaks the prev and next links of the node to be deleted)\\n    void deleteNode(Node *delNode) {\\n        Node *delPrev = delNode->prev;\\n        Node *delNext = delNode->next;\\n        delPrev->next = delNext;\\n        delNext->prev = delPrev;\\n        len--;\\n    }\\n};\\n\\n\\n// LFU Cache class\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, Node*> addrOfKey;    // hashmap for storing the - address corresponding to a key / Node containing that key\\n    unordered_map<int, List*> freqListMap;  // hashmap for storing the - List having Nodes corresponding to its use-frequency\\n    int minFreq, currSize;\\n    int cacheCapacity;\\n\\n    /**\\n     *\\n     * Basically we are using the concept of LRUCache in this LFUCache question but with a twist\\n     *\\n     * We\\'re creating separate Lists for each use-frequency of the Nodes,\\n     * and we\\'re adding the nodes in those Lists following the LRU algorithm\\n     *\\n     * Everytime a key is being accessed (get/put), we\\'re fetching the Node corresponding to that key\\n     * and the List corresponding to that Node, then we\\'re deleting the Node from the LRU position of\\n     * the List, the Node is residing in and adding that same Node at the front (MRU position) of the List\\n     * having Nodes with use-frequency 1 greater than the use-frequency of the Node that was recently deleted.\\n     *\\n     * (list is mapped against use-frequency of the Nodes, means in a List all the nodes have\\n     * the same use-frequency and those Nodes are stored following the LRU mechanism)\\n     *\\n     */\\n    void updateFreqListMap(Node *node) {\\n        addrOfKey.erase(node->key);                     // delete the address of the key\\n        freqListMap[node->cnt]->deleteNode(node);       // delete the Node with \"cnt\" frequency from the corresponding List\\n        if (node->cnt == minFreq && freqListMap[node->cnt]->len == 0) {\\n            minFreq++;                                  // if the deleted node had the min-frequency, after deletion,\\n            // the Node with the next higher frequency will have the min-frequency\\n        }\\n        List *nextHigherFreqList = new List();\\n        if (freqListMap.find(node->cnt + 1) != freqListMap.end()) {\\n            nextHigherFreqList = freqListMap[node->cnt + 1]; // List containing Nodes which are accessed 1 time more than the deleted Node\\n            // (means the List having Nodes with use-frequency 1 more than use-frequency of the Nodes from the LFU list)\\n        }\\n        node->cnt += 1;                                      // increment the use-frequency of that Node by 1, bcz it is being accessed once more\\n        nextHigherFreqList->addNode(node);                   // add that Node at the front (MRU position) of the newly created List\\n        freqListMap[node->cnt] = nextHigherFreqList;         // Map the List against the new use-frequency\\n        addrOfKey[node->key] = node;                         // store the address of the newly added node against the key\\n    }\\n\\npublic:\\n    LFUCache(int capacity) {\\n        cacheCapacity = capacity;                           // max capacity of the cache\\n        minFreq = 0;\\n        currSize = 0;\\n    }\\n\\n    int get(int key) {\\n        if (addrOfKey.find(key) == addrOfKey.end()) {       // if no such key exists in the record\\n            return -1;\\n        }\\n        Node *resNode = addrOfKey[key];                     // if the key exists, find the Node corresponding to that key\\n        int res = resNode->val;                             // get the value stored against that key\\n        updateFreqListMap(resNode);                         // make the changes associated to the Node containing the key\\n        return res;                                         // returns the value stored against that key\\n    }\\n\\n    void put(int key, int value) {\\n        if (cacheCapacity == 0) {                           //  if the cache-size is zero, don\\'t update the value against the key and return\\n            return;\\n        }\\n        if (addrOfKey.find(key) != addrOfKey.end()) {       // if the key is present in the address-map\\n            Node *existingNode = addrOfKey[key];            // find the Node that the key is residing in\\n            existingNode->val = value;                      // update the existing value of that Node with the new given value\\n            updateFreqListMap(existingNode);                // make the changes associated to the Node containing the key\\n        } else {                                            // if the key is NOT present in the address-map\\n            if (currSize == cacheCapacity) {                // if size of the cache reaches its maximum capacity, if cache is full\\n                List *list = freqListMap[minFreq];          // fetch the head of the List having LFU Nodes\\n                Node *prevNode = list->tail->prev;          // find the LRU Node from that List\\n                int keyToBeErased = prevNode->key;          // find the key corresponding to the LRU Node\\n                addrOfKey.erase(keyToBeErased);             // delete the address of that key\\n                freqListMap[minFreq]->deleteNode(prevNode); // delete the LRU node from the LRU location of that List\\n                currSize--;                                 // decrement the current size of cache, now cache is NOT full\\n            }\\n\\n            // if the given key is NOT present in the address-map\\n            currSize++;                                     // increment the current size of the cache\\n            minFreq = 1;                                    // set the use - frequency of the Node containg that key to 1\\n\\n            List *listFreq = new List();\\n            if (freqListMap.find(minFreq) != freqListMap.end()) {\\n                listFreq = freqListMap[minFreq];            // find the List with min-frequency (List having the LFU Nodes)\\n            }\\n            Node *newNode = new Node(key, value);           // create a new Node with the given key and value\\n            listFreq->addNode(newNode);                     // add the new Node at the front (MRU position) of the List having LFU Nodes\\n            addrOfKey[key] = newNode;                       // store the address of the MRU Node from the List having LFU Nodes\\n            freqListMap[minFreq] = listFreq;                // store the List having LFU Nodes against the minimum use-frequency\\n        }\\n    }\\n};\\n```\\n\\nPlease **upvote** and **share** if you like my solution/approach/explanation.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\n// Doubly Linked-List-Node class with prev and next pointers\\nclass Node {\\npublic:\\n    int key, val, cnt;\\n    Node *next, *prev;\\n    Node(int _key, int _val) {\\n        key = _key;\\n        val = _val;\\n        cnt = 1;    // counter for maintaining the frequency of the Node\\n    }\\n};\\n\\n\\n// Doubly Linked-List class with head and tail pointers\\nclass List {\\npublic:\\n    int len;\\n    Node *head, *tail;\\n\\n    List() {\\n        head = new Node(0, 0);\\n        tail = new Node(0, 0);\\n        head->next = tail;\\n        tail->prev = head;\\n        len = 0;\\n    }\\n\\n    // adds a new Node at the front (MRU position) of a doubly-linked-list\\n    // (adds a new node in-between two pre-existing nodes)\\n    void addNode(Node *newNode) {\\n        Node *temp = head->next;\\n        newNode->next = temp;\\n        newNode->prev = head;\\n        head->next = newNode;\\n        temp->prev = newNode;\\n        len++;\\n    }\\n\\n    // deletes a Node (generally the LRU node) from a doubly-linked-list\\n    // (breaks the prev and next links of the node to be deleted)\\n    void deleteNode(Node *delNode) {\\n        Node *delPrev = delNode->prev;\\n        Node *delNext = delNode->next;\\n        delPrev->next = delNext;\\n        delNext->prev = delPrev;\\n        len--;\\n    }\\n};\\n\\n\\n// LFU Cache class\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, Node*> addrOfKey;    // hashmap for storing the - address corresponding to a key / Node containing that key\\n    unordered_map<int, List*> freqListMap;  // hashmap for storing the - List having Nodes corresponding to its use-frequency\\n    int minFreq, currSize;\\n    int cacheCapacity;\\n\\n    /**\\n     *\\n     * Basically we are using the concept of LRUCache in this LFUCache question but with a twist\\n     *\\n     * We\\'re creating separate Lists for each use-frequency of the Nodes,\\n     * and we\\'re adding the nodes in those Lists following the LRU algorithm\\n     *\\n     * Everytime a key is being accessed (get/put), we\\'re fetching the Node corresponding to that key\\n     * and the List corresponding to that Node, then we\\'re deleting the Node from the LRU position of\\n     * the List, the Node is residing in and adding that same Node at the front (MRU position) of the List\\n     * having Nodes with use-frequency 1 greater than the use-frequency of the Node that was recently deleted.\\n     *\\n     * (list is mapped against use-frequency of the Nodes, means in a List all the nodes have\\n     * the same use-frequency and those Nodes are stored following the LRU mechanism)\\n     *\\n     */\\n    void updateFreqListMap(Node *node) {\\n        addrOfKey.erase(node->key);                     // delete the address of the key\\n        freqListMap[node->cnt]->deleteNode(node);       // delete the Node with \"cnt\" frequency from the corresponding List\\n        if (node->cnt == minFreq && freqListMap[node->cnt]->len == 0) {\\n            minFreq++;                                  // if the deleted node had the min-frequency, after deletion,\\n            // the Node with the next higher frequency will have the min-frequency\\n        }\\n        List *nextHigherFreqList = new List();\\n        if (freqListMap.find(node->cnt + 1) != freqListMap.end()) {\\n            nextHigherFreqList = freqListMap[node->cnt + 1]; // List containing Nodes which are accessed 1 time more than the deleted Node\\n            // (means the List having Nodes with use-frequency 1 more than use-frequency of the Nodes from the LFU list)\\n        }\\n        node->cnt += 1;                                      // increment the use-frequency of that Node by 1, bcz it is being accessed once more\\n        nextHigherFreqList->addNode(node);                   // add that Node at the front (MRU position) of the newly created List\\n        freqListMap[node->cnt] = nextHigherFreqList;         // Map the List against the new use-frequency\\n        addrOfKey[node->key] = node;                         // store the address of the newly added node against the key\\n    }\\n\\npublic:\\n    LFUCache(int capacity) {\\n        cacheCapacity = capacity;                           // max capacity of the cache\\n        minFreq = 0;\\n        currSize = 0;\\n    }\\n\\n    int get(int key) {\\n        if (addrOfKey.find(key) == addrOfKey.end()) {       // if no such key exists in the record\\n            return -1;\\n        }\\n        Node *resNode = addrOfKey[key];                     // if the key exists, find the Node corresponding to that key\\n        int res = resNode->val;                             // get the value stored against that key\\n        updateFreqListMap(resNode);                         // make the changes associated to the Node containing the key\\n        return res;                                         // returns the value stored against that key\\n    }\\n\\n    void put(int key, int value) {\\n        if (cacheCapacity == 0) {                           //  if the cache-size is zero, don\\'t update the value against the key and return\\n            return;\\n        }\\n        if (addrOfKey.find(key) != addrOfKey.end()) {       // if the key is present in the address-map\\n            Node *existingNode = addrOfKey[key];            // find the Node that the key is residing in\\n            existingNode->val = value;                      // update the existing value of that Node with the new given value\\n            updateFreqListMap(existingNode);                // make the changes associated to the Node containing the key\\n        } else {                                            // if the key is NOT present in the address-map\\n            if (currSize == cacheCapacity) {                // if size of the cache reaches its maximum capacity, if cache is full\\n                List *list = freqListMap[minFreq];          // fetch the head of the List having LFU Nodes\\n                Node *prevNode = list->tail->prev;          // find the LRU Node from that List\\n                int keyToBeErased = prevNode->key;          // find the key corresponding to the LRU Node\\n                addrOfKey.erase(keyToBeErased);             // delete the address of that key\\n                freqListMap[minFreq]->deleteNode(prevNode); // delete the LRU node from the LRU location of that List\\n                currSize--;                                 // decrement the current size of cache, now cache is NOT full\\n            }\\n\\n            // if the given key is NOT present in the address-map\\n            currSize++;                                     // increment the current size of the cache\\n            minFreq = 1;                                    // set the use - frequency of the Node containg that key to 1\\n\\n            List *listFreq = new List();\\n            if (freqListMap.find(minFreq) != freqListMap.end()) {\\n                listFreq = freqListMap[minFreq];            // find the List with min-frequency (List having the LFU Nodes)\\n            }\\n            Node *newNode = new Node(key, value);           // create a new Node with the given key and value\\n            listFreq->addNode(newNode);                     // add the new Node at the front (MRU position) of the List having LFU Nodes\\n            addrOfKey[key] = newNode;                       // store the address of the MRU Node from the List having LFU Nodes\\n            freqListMap[minFreq] = listFreq;                // store the List having LFU Nodes against the minimum use-frequency\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112640,
                "title": "possibly-clearer-code",
                "content": "\\n#  Java\\n```\\nclass LFUCache {\\n\\n  private final Map<Integer, Integer> keyToFreq;\\n  private final TreeMap<Integer, LinkedHashSet<Integer>> freqToKey;\\n  private final Map<Integer, Integer> keyToValue;\\n  private final int capacity;\\n\\n  public LFUCache(int capacity) {\\n    keyToFreq = new HashMap<>();\\n    freqToKey = new TreeMap<>();\\n    keyToValue = new HashMap<>();\\n\\n    this.capacity = capacity;\\n  }\\n\\n  public int get(int key) {\\n    if (keyToValue.containsKey(key)) {\\n      increaseFrequency(key);\\n      return keyToValue.get(key);\\n    }\\n    return -1;\\n  }\\n\\n  public void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n\\n    if (keyToFreq.size() == capacity && !keyToValue.containsKey(key))\\n      removeLastFrequentlyUsed();\\n\\n    keyToValue.put(key, value);\\n\\n    if (keyToFreq.containsKey(key))\\n      increaseFrequency(key);\\n    else {\\n      keyToFreq.put(key, 1);\\n      freqToKey.computeIfAbsent(1, p -> new LinkedHashSet<>()).add(key);\\n    }\\n  }\\n\\n  private void increaseFrequency(int key) {\\n    int frequency = keyToFreq.get(key);\\n\\n    keyToFreq.put(key, frequency + 1);\\n    deletePreviousFrequency(key, frequency);\\n\\n    freqToKey.computeIfAbsent(frequency + 1, p -> new LinkedHashSet<>()).add(key);\\n  }\\n\\n  private void deletePreviousFrequency(int key, int frequency) {\\n    LinkedHashSet<Integer> keys = freqToKey.get(frequency);\\n    keys.remove(key);\\n\\n    if (keys.isEmpty())\\n      freqToKey.remove(frequency);\\n  }\\n\\n  private void removeLastFrequentlyUsed() {\\n    Map.Entry<Integer, LinkedHashSet<Integer>> first = freqToKey.firstEntry();\\n    LinkedHashSet<Integer> keys = first.getValue();\\n\\n    int key = keys.iterator().next();\\n\\n    keys.remove(key);\\n    if (keys.isEmpty())\\n      freqToKey.remove(first.getKey());\\n\\n    keyToFreq.remove(key);\\n    keyToValue.remove(key);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n\\n  private final Map<Integer, Integer> keyToFreq;\\n  private final TreeMap<Integer, LinkedHashSet<Integer>> freqToKey;\\n  private final Map<Integer, Integer> keyToValue;\\n  private final int capacity;\\n\\n  public LFUCache(int capacity) {\\n    keyToFreq = new HashMap<>();\\n    freqToKey = new TreeMap<>();\\n    keyToValue = new HashMap<>();\\n\\n    this.capacity = capacity;\\n  }\\n\\n  public int get(int key) {\\n    if (keyToValue.containsKey(key)) {\\n      increaseFrequency(key);\\n      return keyToValue.get(key);\\n    }\\n    return -1;\\n  }\\n\\n  public void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n\\n    if (keyToFreq.size() == capacity && !keyToValue.containsKey(key))\\n      removeLastFrequentlyUsed();\\n\\n    keyToValue.put(key, value);\\n\\n    if (keyToFreq.containsKey(key))\\n      increaseFrequency(key);\\n    else {\\n      keyToFreq.put(key, 1);\\n      freqToKey.computeIfAbsent(1, p -> new LinkedHashSet<>()).add(key);\\n    }\\n  }\\n\\n  private void increaseFrequency(int key) {\\n    int frequency = keyToFreq.get(key);\\n\\n    keyToFreq.put(key, frequency + 1);\\n    deletePreviousFrequency(key, frequency);\\n\\n    freqToKey.computeIfAbsent(frequency + 1, p -> new LinkedHashSet<>()).add(key);\\n  }\\n\\n  private void deletePreviousFrequency(int key, int frequency) {\\n    LinkedHashSet<Integer> keys = freqToKey.get(frequency);\\n    keys.remove(key);\\n\\n    if (keys.isEmpty())\\n      freqToKey.remove(frequency);\\n  }\\n\\n  private void removeLastFrequentlyUsed() {\\n    Map.Entry<Integer, LinkedHashSet<Integer>> first = freqToKey.firstEntry();\\n    LinkedHashSet<Integer> keys = first.getValue();\\n\\n    int key = keys.iterator().next();\\n\\n    keys.remove(key);\\n    if (keys.isEmpty())\\n      freqToKey.remove(first.getKey());\\n\\n    keyToFreq.remove(key);\\n    keyToValue.remove(key);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718724,
                "title": "python-solution-with-ordereddict",
                "content": "It took me a while to understand the solution for this question and here goes my final solution:\\n\\n```\\nfrom collections import defaultdict, OrderedDict\\n\\n\\nclass LFUCache:\\n    \"\"\"\\n    OrderedDict in python is implemented as double linked list. We could use it\\n    to get our least frequently used item from the keys having the same\\n    frequency in O(1) time.\\n    \"\"\"\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self._items = defaultdict(int)  # key: frequency.\\n        self._freqs = defaultdict(OrderedDict)  # frequency: {key: val}\\n        self._minFreq = 0  # Mininum used frequency for the keys in the cache.\\n\\n    def _update_freq(self, key: int, value: int = None) -> int:\\n        \"\"\"\\n        Update the _items and the _freqs with the input key, then return\\n        the latest value.\\n        \"\"\"\\n        f = self._items[key]\\n        v = self._freqs[f].pop(key)  # Remove the current key.\\n        if value is not None:  # Update with new value if any.\\n            v = value\\n\\n        self._freqs[f + 1][key] = v  # Add the key to the new frequency.\\n        self._items[key] += 1  # Update the frequency in the items.\\n        if self._minFreq == f and not self._freqs[f]:  # Update minimum freq.\\n            self._minFreq += 1\\n\\n        return v\\n\\n    def get(self, key: int) -> int:\\n        if key not in self._items:  # Not found.\\n            return -1\\n\\n        return self._update_freq(key)\\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity:  # Not able to put anything.\\n            return\\n\\n        if key in self._items:\\n            self._update_freq(key, value)\\n        else:\\n            if len(self._items) == self.capacity:  # Cache is full.\\n                # 1. Pop the least frequently used key in _freqs[mininum freq].\\n                # 2. Pop the same key from _items as it does not exist any more.\\n                self._items.pop(\\n                    self._freqs[self._minFreq].popitem(last=False)[0])\\n\\n            # Add the new key.\\n            self._minFreq = 1\\n            self._items[key] = 1\\n            self._freqs[1][key] = value\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict, OrderedDict\\n\\n\\nclass LFUCache:\\n    \"\"\"\\n    OrderedDict in python is implemented as double linked list. We could use it\\n    to get our least frequently used item from the keys having the same\\n    frequency in O(1) time.\\n    \"\"\"\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self._items = defaultdict(int)  # key: frequency.\\n        self._freqs = defaultdict(OrderedDict)  # frequency: {key: val}\\n        self._minFreq = 0  # Mininum used frequency for the keys in the cache.\\n\\n    def _update_freq(self, key: int, value: int = None) -> int:\\n        \"\"\"\\n        Update the _items and the _freqs with the input key, then return\\n        the latest value.\\n        \"\"\"\\n        f = self._items[key]\\n        v = self._freqs[f].pop(key)  # Remove the current key.\\n        if value is not None:  # Update with new value if any.\\n            v = value\\n\\n        self._freqs[f + 1][key] = v  # Add the key to the new frequency.\\n        self._items[key] += 1  # Update the frequency in the items.\\n        if self._minFreq == f and not self._freqs[f]:  # Update minimum freq.\\n            self._minFreq += 1\\n\\n        return v\\n\\n    def get(self, key: int) -> int:\\n        if key not in self._items:  # Not found.\\n            return -1\\n\\n        return self._update_freq(key)\\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity:  # Not able to put anything.\\n            return\\n\\n        if key in self._items:\\n            self._update_freq(key, value)\\n        else:\\n            if len(self._items) == self.capacity:  # Cache is full.\\n                # 1. Pop the least frequently used key in _freqs[mininum freq].\\n                # 2. Pop the same key from _items as it does not exist any more.\\n                self._items.pop(\\n                    self._freqs[self._minFreq].popitem(last=False)[0])\\n\\n            # Add the new key.\\n            self._minFreq = 1\\n            self._items[key] = 1\\n            self._freqs[1][key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697168,
                "title": "using-priority-queue-c-clean-solution",
                "content": "```\\nclass LFUCache {\\npublic:\\n    priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n    unordered_map<int,int> m;\\n    unordered_map<int,int> freq;\\n    int cap, t = 0;\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)==m.end()) return -1;\\n        put(key,m[key]);\\n        return m[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0){\\n            return;\\n        }\\n        if(m.find(key)==m.end()&&m.size()==cap){\\n            while(m.size()==cap){\\n                auto x = pq.top();\\n                if(freq[x.second.second]==x.first){\\n                    m.erase(x.second.second);\\n                    freq.erase(x.second.second);\\n                }\\n                pq.pop();\\n            }            \\n        }\\n        m[key] = value;\\n        freq[key]++;\\n        pq.push({freq[key],{t++,key}});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n    unordered_map<int,int> m;\\n    unordered_map<int,int> freq;\\n    int cap, t = 0;\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)==m.end()) return -1;\\n        put(key,m[key]);\\n        return m[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0){\\n            return;\\n        }\\n        if(m.find(key)==m.end()&&m.size()==cap){\\n            while(m.size()==cap){\\n                auto x = pq.top();\\n                if(freq[x.second.second]==x.first){\\n                    m.erase(x.second.second);\\n                    freq.erase(x.second.second);\\n                }\\n                pq.pop();\\n            }            \\n        }\\n        m[key] = value;\\n        freq[key]++;\\n        pq.push({freq[key],{t++,key}});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94536,
                "title": "java-solution-using-priorityqueue-with-detailed-explanation",
                "content": "We need to implement `get()` and `set()` in average `O(logn)` time, or we will get TLE.\\n\\nObviously, we need a hashmap to remember `key-value` pair.\\nWhat we need to do, is to remember `(frequency, recentness)` for each key; and sort them to get the smallest one.\\nSo, we need to use `Collection` such as `TreeSet` or `PriorityQueue`.\\n\\nNow, the only question is, how to update?\\nIt is difficult to update `(frequency, recentness)` in the collection, as we don't know the index.\\n(Maybe using `binary search` or `hashmap` can do this, I haven't tried it.)\\n\\nThe trick is, just ***override equals() and hashCode() function***, in order to use `remove`.\\n\\nHere is the code with detailed comment.\\n\\n```Java\\npublic class LFUCache {\\n    \\n    class Cache { // a class to remember frequency and recentness\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        // override equals() and hashCode()\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n    }\\n    \\n    int capacity, id;\\n    HashMap<Integer, Integer> hashMap, frequency;\\n    PriorityQueue<Cache> queue;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        frequency=new HashMap<>();\\n        // sort by frequency and recentness\\n        queue =new PriorityQueue<>((o1,o2) -> o1.f==o2.f?o1.r-o2.r:o1.f-o2.f); \\n    }\\n    \\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first= queue.poll(); // find the smallest one, and remove it\\n            hashMap.remove(first.key);\\n            frequency.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        frequency.put(key, 1);\\n        queue.add(new Cache(key, 1, id));\\n    }\\n    \\n    private void update(int key) { // update the priority queue\\n        int f=frequency.get(key);\\n        frequency.put(key, f+1); // get and update the frequency\\n        Cache cache=new Cache(key, f+1, id); // make a new Cache\\n        // remove the member in queue, if its key equals to the current key.\\n        // Here, queue uses `equals()` to judge the equality\\n        queue.remove(cache); \\n        queue.add(cache); // add the current Cache to the queue.\\n    }\\n}\\n```\\n\\nPS: I tried `TreeSet` instead of `PriorityQueue`, but it didn't work. Can anyone tell me why?\\n\\n<br/>\\n\\n-----------------------------------------\\n\\n-----------------------------------------\\n\\n<br/>\\n\\n**Update 2016/11/22:**\\nAs priority queue uses `O(n)` time to remove, it's better to use `TreeSet`.\\n\\nHere is the code. It's similar to the code above.\\n```\\npublic class LFUCache {\\n    \\n    class Cache implements Comparable<Cache> {\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n        public int compareTo(Cache o) {return key==o.key?0:f==o.f?r-o.r:f-o.f;}\\n    }\\n\\n    int capacity,id;\\n    HashMap<Integer, Integer> hashMap;\\n    HashMap<Integer, Cache> caches;\\n    TreeSet<Cache> treeSet;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        caches=new HashMap<>();\\n        treeSet=new TreeSet<>();\\n    }\\n\\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first=treeSet.pollFirst();\\n            hashMap.remove(first.key);\\n            caches.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        Cache cache=new Cache(key, 1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n    private void update(int key) {\\n        int f=caches.get(key).f;\\n        treeSet.remove(caches.get(key));\\n        Cache cache=new Cache(key, f+1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic class LFUCache {\\n    \\n    class Cache { // a class to remember frequency and recentness\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        // override equals() and hashCode()\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n    }\\n    \\n    int capacity, id;\\n    HashMap<Integer, Integer> hashMap, frequency;\\n    PriorityQueue<Cache> queue;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        frequency=new HashMap<>();\\n        // sort by frequency and recentness\\n        queue =new PriorityQueue<>((o1,o2) -> o1.f==o2.f?o1.r-o2.r:o1.f-o2.f); \\n    }\\n    \\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first= queue.poll(); // find the smallest one, and remove it\\n            hashMap.remove(first.key);\\n            frequency.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        frequency.put(key, 1);\\n        queue.add(new Cache(key, 1, id));\\n    }\\n    \\n    private void update(int key) { // update the priority queue\\n        int f=frequency.get(key);\\n        frequency.put(key, f+1); // get and update the frequency\\n        Cache cache=new Cache(key, f+1, id); // make a new Cache\\n        // remove the member in queue, if its key equals to the current key.\\n        // Here, queue uses `equals()` to judge the equality\\n        queue.remove(cache); \\n        queue.add(cache); // add the current Cache to the queue.\\n    }\\n}\\n```\n```\\npublic class LFUCache {\\n    \\n    class Cache implements Comparable<Cache> {\\n        int key, f, r;\\n        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}\\n        public boolean equals(Object object) {return key==((Cache) object).key;}\\n        public int hashCode() {return key;}\\n        public int compareTo(Cache o) {return key==o.key?0:f==o.f?r-o.r:f-o.f;}\\n    }\\n\\n    int capacity,id;\\n    HashMap<Integer, Integer> hashMap;\\n    HashMap<Integer, Cache> caches;\\n    TreeSet<Cache> treeSet;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        id=0;\\n        hashMap=new HashMap<>();\\n        caches=new HashMap<>();\\n        treeSet=new TreeSet<>();\\n    }\\n\\n    public int get(int key) {\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            return hashMap.get(key);\\n        }\\n        return -1;\\n    }\\n\\n    public void set(int key, int value) {\\n        if (capacity==0) return;\\n        id++;\\n        if (hashMap.containsKey(key)) {\\n            update(key);\\n            hashMap.put(key, value);\\n            return;\\n        }\\n        if (hashMap.size()==capacity) {\\n            Cache first=treeSet.pollFirst();\\n            hashMap.remove(first.key);\\n            caches.remove(first.key);\\n        }\\n        hashMap.put(key, value);\\n        Cache cache=new Cache(key, 1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n    private void update(int key) {\\n        int f=caches.get(key).f;\\n        treeSet.remove(caches.get(key));\\n        Cache cache=new Cache(key, f+1, id);\\n        caches.put(key, cache);\\n        treeSet.add(cache);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94610,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/74346/python-solution-with-detailed-explanation\\n\\n**LFU Cache** https://leetcode.com/problems/lfu-cache/\\n\\n**How do we maintain minimum frequency?**\\n* Do we need a sorted frequency list to find the keys with min_f frequency?\\n* get(key) operation increases the frequency f of key by 1. Now if f were the minimum frequency and no other key had frequency f, then min_f will be f+1, otherwise f.\\n* put(key, value): if it is an update operation, then the treatment if min_f is similar to get. Otherwise, min_f is 1.\\n* This tells us that if we can track list of keys which have the same frequency, then we dont need anything special to track min_f.\\n\\n**Data-Structure**\\n* cache: {key:[value, frequency]}\\n* node_freq: {freq:LinkedHashSet()}. The key for LinkedHashSet is the main key. LinkedHashSet helps us to maintain the least recently used variant for keys with same frequency.\\n* https://goo.gl/photos/DZqnwmeyFjDqgRjAA\\n\\n```\\nclass Node(object):\\n    def __init__(self, key, value):\\n        self.key, self.value = key, value\\n        self.prev, self.nxt = None, None \\n        return\\n\\nclass DoubleLinkedList(object):\\n    def __init__(self):\\n        self.head_sentinel, self.tail_sentinel, self.count = Node(None, None), Node(None, None), 0\\n        self.head_sentinel.nxt, self.tail_sentinel.prev = self.tail_sentinel, self.head_sentinel\\n        self.count = 0\\n \\n    def insert(self, x, node):\\n        if node == None:\\n            raise\\n        temp = x.nxt\\n        x.nxt, node.prev = node, x\\n        node.nxt, temp.prev = temp, node\\n        self.count += 1\\n\\n    def appendleft(self, node):\\n        if node == None:\\n            raise\\n        self.insert(self.head_sentinel, node)\\n\\n    def append(self, node):\\n        if node == None:\\n            raise\\n        self.insert(self.get_tail(), node)\\n\\n    def remove(self, node):\\n        if node == None:\\n            raise\\n        prev_node = node.prev\\n        prev_node.nxt, node.nxt.prev = node.nxt, prev_node\\n        self.count -= 1\\n\\n    def pop():\\n        if self.size() < 1:\\n            raise\\n        self.remove(self.get_tail())\\n\\n    def popleft():\\n        if self.size() < 1:\\n            raise\\n        self.remove(self.get_head())\\n\\n    def size(self):\\n        return self.count\\n\\n    def get_head(self):\\n        return self.head_sentinel.nxt if self.count > 0 else None\\n    \\n    def get_tail(self):\\n        return self.tail_sentinel.prev if self.count > 0 else None        \\n\\nclass LinkedHashSet():\\n    def __init__(self):\\n        self.node_map, self.dll = {}, DoubleLinkedList()\\n\\n    def size(self):\\n        return len(self.node_map)\\n        \\n    def contains(self, key):\\n        return key in self.node_map\\n    \\n    def search(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        return self.node_map[key].value\\n\\n    def appendleft(self, key, value):\\n        if self.contains(key) == False:\\n            node = Node(key, value)\\n            self.dll.appendleft(node)\\n            self.node_map[key] = node\\n        else:\\n            self.node_map[key].value = value\\n            self.moveleft(key)\\n\\n    def append(self, key, value):\\n        if self.contains(key) == False:\\n            node = Node(key, value)\\n            self.dll.append(node)\\n            self.node_map[key] = node\\n        else:\\n            self.node_map[key].value = value\\n            self.moveright(key)\\n    \\n    def moveleft(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.dll.appendleft(node)\\n\\n    def moveright(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.dll.append(node)\\n\\n    def remove(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.node_map.pop(key)\\n    \\n    def popleft(self):\\n        key = self.dll.get_head().key\\n        self.remove(key)\\n        return key\\n\\n    def pop(self):\\n        key = self.dll.get_tail().key\\n        self.remove(key)\\n        return key\\n\\nfrom collections import defaultdict\\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.min_f = -1\\n        self.cache = {} #key:(value, frequency)\\n        self.freq_map = defaultdict(LinkedHashSet) #frequency:LinkedHashSet\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.cache:\\n            # Update new frequency\\n            # Update freq_map\\n            # Move key to front in its linkedHashSet\\n            # Update new minimum frequency\\n            v, f = self.cache[key][0], self.cache[key][1]\\n            self.cache[key][1] += 1\\n            \\n            f_count_zero = False\\n            self.freq_map[f].remove(key)\\n            if self.freq_map[f].size() == 0:\\n                f_count_zero = True\\n                self.freq_map.pop(f)\\n            self.freq_map[f+1].appendleft(key, v)\\n                \\n            if f == self.min_f and f_count_zero == True:\\n                self.min_f += 1  \\n            return v\\n        return -1\\n                \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0:\\n            return None\\n        if key in self.cache:\\n            self.cache[key][0] = value\\n            self.get(key)\\n        else:\\n            curr_size = len(self.cache)\\n            if curr_size == self.cap:\\n                min_list = self.freq_map[self.min_f]\\n                x = min_list.pop()\\n                self.cache.pop(x)\\n            \\n            self.cache[key] = [value, 1]\\n            self.freq_map[1].appendleft(key, value)\\n            self.min_f = 1\\n            return\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.set(key,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, value):\\n        self.key, self.value = key, value\\n        self.prev, self.nxt = None, None \\n        return\\n\\nclass DoubleLinkedList(object):\\n    def __init__(self):\\n        self.head_sentinel, self.tail_sentinel, self.count = Node(None, None), Node(None, None), 0\\n        self.head_sentinel.nxt, self.tail_sentinel.prev = self.tail_sentinel, self.head_sentinel\\n        self.count = 0\\n \\n    def insert(self, x, node):\\n        if node == None:\\n            raise\\n        temp = x.nxt\\n        x.nxt, node.prev = node, x\\n        node.nxt, temp.prev = temp, node\\n        self.count += 1\\n\\n    def appendleft(self, node):\\n        if node == None:\\n            raise\\n        self.insert(self.head_sentinel, node)\\n\\n    def append(self, node):\\n        if node == None:\\n            raise\\n        self.insert(self.get_tail(), node)\\n\\n    def remove(self, node):\\n        if node == None:\\n            raise\\n        prev_node = node.prev\\n        prev_node.nxt, node.nxt.prev = node.nxt, prev_node\\n        self.count -= 1\\n\\n    def pop():\\n        if self.size() < 1:\\n            raise\\n        self.remove(self.get_tail())\\n\\n    def popleft():\\n        if self.size() < 1:\\n            raise\\n        self.remove(self.get_head())\\n\\n    def size(self):\\n        return self.count\\n\\n    def get_head(self):\\n        return self.head_sentinel.nxt if self.count > 0 else None\\n    \\n    def get_tail(self):\\n        return self.tail_sentinel.prev if self.count > 0 else None        \\n\\nclass LinkedHashSet():\\n    def __init__(self):\\n        self.node_map, self.dll = {}, DoubleLinkedList()\\n\\n    def size(self):\\n        return len(self.node_map)\\n        \\n    def contains(self, key):\\n        return key in self.node_map\\n    \\n    def search(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        return self.node_map[key].value\\n\\n    def appendleft(self, key, value):\\n        if self.contains(key) == False:\\n            node = Node(key, value)\\n            self.dll.appendleft(node)\\n            self.node_map[key] = node\\n        else:\\n            self.node_map[key].value = value\\n            self.moveleft(key)\\n\\n    def append(self, key, value):\\n        if self.contains(key) == False:\\n            node = Node(key, value)\\n            self.dll.append(node)\\n            self.node_map[key] = node\\n        else:\\n            self.node_map[key].value = value\\n            self.moveright(key)\\n    \\n    def moveleft(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.dll.appendleft(node)\\n\\n    def moveright(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.dll.append(node)\\n\\n    def remove(self, key):\\n        if self.contains(key) == False:\\n            raise\\n        node = self.node_map[key]\\n        self.dll.remove(node)\\n        self.node_map.pop(key)\\n    \\n    def popleft(self):\\n        key = self.dll.get_head().key\\n        self.remove(key)\\n        return key\\n\\n    def pop(self):\\n        key = self.dll.get_tail().key\\n        self.remove(key)\\n        return key\\n\\nfrom collections import defaultdict\\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.min_f = -1\\n        self.cache = {} #key:(value, frequency)\\n        self.freq_map = defaultdict(LinkedHashSet) #frequency:LinkedHashSet\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.cache:\\n            # Update new frequency\\n            # Update freq_map\\n            # Move key to front in its linkedHashSet\\n            # Update new minimum frequency\\n            v, f = self.cache[key][0], self.cache[key][1]\\n            self.cache[key][1] += 1\\n            \\n            f_count_zero = False\\n            self.freq_map[f].remove(key)\\n            if self.freq_map[f].size() == 0:\\n                f_count_zero = True\\n                self.freq_map.pop(f)\\n            self.freq_map[f+1].appendleft(key, v)\\n                \\n            if f == self.min_f and f_count_zero == True:\\n                self.min_f += 1  \\n            return v\\n        return -1\\n                \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0:\\n            return None\\n        if key in self.cache:\\n            self.cache[key][0] = value\\n            self.get(key)\\n        else:\\n            curr_size = len(self.cache)\\n            if curr_size == self.cap:\\n                min_list = self.freq_map[self.min_f]\\n                x = min_list.pop()\\n                self.cache.pop(x)\\n            \\n            self.cache[key] = [value, 1]\\n            self.freq_map[1].appendleft(key, value)\\n            self.min_f = 1\\n            return\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.set(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94520,
                "title": "python-shitty-o-1-solution-with-two-dict-and-one-linkedlist",
                "content": "```\\nclass ListNode(object):\\n    def __init__(self, key, val):\\n        self.prev = None\\n        self.next = None\\n        self.val = val\\n        self.key = key\\n\\n    def connect(self, nextNode):\\n        self.next = nextNode\\n        nextNode.prev = self\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        \\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.head = ListNode(None, None)\\n        self.tail = ListNode(None, None)\\n        self.head.connect(self.tail)\\n        #use to record the first ListNode of this count number\\n        self.cnt = {0: self.tail}\\n        # key: key , value:[ListNode, visit count]\\n        self.kv = {None:[self.tail, 0]}\\n\\n    def moveforward(self, key):\\n        node, cnt = self.kv[key]\\n        self.add('tmp', node.val, cnt + 1)\\n        self.remove(key)\\n        self.kv[key] = self.kv['tmp']\\n        self.kv[key][0].key = key\\n        del self.kv['tmp']\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.kv:\\n            return -1\\n        self.moveforward(key)\\n        return self.kv[key][0].val\\n\\n    def set(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0:\\n            return\\n        if key in self.kv:\\n            self.kv[key][0].val = value\\n            self.moveforward(key)\\n            return\\n        if len(self.kv) > self.cap:\\n            self.remove(self.tail.prev.key)\\n        self.add(key, value, 0)\\n\\n\\n    def remove(self, key):\\n        node, cnt = self.kv[key]\\n        if self.cnt[cnt] != node:\\n            node.prev.connect(node.next)\\n        elif self.kv[node.next.key][1] == cnt:\\n            node.prev.connect(node.next)\\n            self.cnt[cnt] = self.cnt[cnt].next\\n        else:\\n            node.prev.connect(node.next)\\n            del self.cnt[cnt]\\n        del self.kv[key]\\n\\n    def add(self, key, value, cnt):\\n        if cnt in self.cnt:\\n            loc = self.cnt[cnt]\\n        else:\\n            loc = self.cnt[cnt - 1]\\n        node = ListNode(key, value)\\n        loc.prev.connect(node)\\n        node.connect(loc)\\n        self.cnt[cnt] = node\\n        self.kv[key] = [node, cnt]\\n        \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.set(key,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode(object):\\n    def __init__(self, key, val):\\n        self.prev = None\\n        self.next = None\\n        self.val = val\\n        self.key = key\\n\\n    def connect(self, nextNode):\\n        self.next = nextNode\\n        nextNode.prev = self\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        \\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.head = ListNode(None, None)\\n        self.tail = ListNode(None, None)\\n        self.head.connect(self.tail)\\n        #use to record the first ListNode of this count number\\n        self.cnt = {0: self.tail}\\n        # key: key , value:[ListNode, visit count]\\n        self.kv = {None:[self.tail, 0]}\\n\\n    def moveforward(self, key):\\n        node, cnt = self.kv[key]\\n        self.add('tmp', node.val, cnt + 1)\\n        self.remove(key)\\n        self.kv[key] = self.kv['tmp']\\n        self.kv[key][0].key = key\\n        del self.kv['tmp']\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.kv:\\n            return -1\\n        self.moveforward(key)\\n        return self.kv[key][0].val\\n\\n    def set(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0:\\n            return\\n        if key in self.kv:\\n            self.kv[key][0].val = value\\n            self.moveforward(key)\\n            return\\n        if len(self.kv) > self.cap:\\n            self.remove(self.tail.prev.key)\\n        self.add(key, value, 0)\\n\\n\\n    def remove(self, key):\\n        node, cnt = self.kv[key]\\n        if self.cnt[cnt] != node:\\n            node.prev.connect(node.next)\\n        elif self.kv[node.next.key][1] == cnt:\\n            node.prev.connect(node.next)\\n            self.cnt[cnt] = self.cnt[cnt].next\\n        else:\\n            node.prev.connect(node.next)\\n            del self.cnt[cnt]\\n        del self.kv[key]\\n\\n    def add(self, key, value, cnt):\\n        if cnt in self.cnt:\\n            loc = self.cnt[cnt]\\n        else:\\n            loc = self.cnt[cnt - 1]\\n        node = ListNode(key, value)\\n        loc.prev.connect(node)\\n        node.connect(loc)\\n        self.cnt[cnt] = node\\n        self.kv[key] = [node, cnt]\\n        \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.set(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929086,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "```\\nclass LFUCache {\\npublic:\\n    LFUCache(int _capacity) {\\n        capacity=_capacity;\\n        size=0;\\n        min_freq=0;\\n    }\\n    \\n    int get(int key) {\\n        if(keysInfo.count(key)==0){\\n            return -1;\\n        }\\n        update(key);\\n        return keysInfo[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(capacity<=0)\\n            return;\\n        \\n        if(keysInfo.count(key)==1){      //If key is already present \\n            //update value\\n            keysInfo[key].first=value;\\n            update(key);\\n        }\\n        else{\\n            if(size==capacity){\\n                int key_to_remove=freq_to_key[min_freq].front();\\n                /*\\n                Remove from all three maps\\n                */\\n                freq_to_key[min_freq].pop_front();\\n                keysInfo.erase(key_to_remove);\\n                um_ref.erase(key_to_remove);\\n            }\\n            else\\n                size++;\\n            \\n            keysInfo[key]={value,1};\\n            min_freq=1;\\n            freq_to_key[1].push_back(key);\\n            um_ref[key]=(--freq_to_key[1].end());\\n        }   \\n    }\\n    \\nprivate :\\n    int capacity;\\n    int size;\\n    int min_freq;\\n    \\n    unordered_map<int,list<int> > freq_to_key;\\n    unordered_map<int,pair<int,int> > keysInfo;    //(key to {value,freq});\\n    unordered_map<int, list<int>::iterator> um_ref; //key to its iterator in freq_to_key list\\n    \\n    \\n    void update(int key){\\n        int curr_freq=keysInfo[key].second;\\n        auto it=um_ref[key];\\n        keysInfo[key].second++;\\n        freq_to_key[curr_freq].erase(it);\\n        curr_freq++;\\n        freq_to_key[curr_freq].push_back(key);\\n        um_ref[key]=(--freq_to_key[curr_freq].end());\\n        \\n        if(freq_to_key[min_freq].empty())\\n            min_freq++;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    LFUCache(int _capacity) {\\n        capacity=_capacity;\\n        size=0;\\n        min_freq=0;\\n    }\\n    \\n    int get(int key) {\\n        if(keysInfo.count(key)==0){\\n            return -1;\\n        }\\n        update(key);\\n        return keysInfo[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(capacity<=0)\\n            return;\\n        \\n        if(keysInfo.count(key)==1){      //If key is already present \\n            //update value\\n            keysInfo[key].first=value;\\n            update(key);\\n        }\\n        else{\\n            if(size==capacity){\\n                int key_to_remove=freq_to_key[min_freq].front();\\n                /*\\n                Remove from all three maps\\n                */\\n                freq_to_key[min_freq].pop_front();\\n                keysInfo.erase(key_to_remove);\\n                um_ref.erase(key_to_remove);\\n            }\\n            else\\n                size++;\\n            \\n            keysInfo[key]={value,1};\\n            min_freq=1;\\n            freq_to_key[1].push_back(key);\\n            um_ref[key]=(--freq_to_key[1].end());\\n        }   \\n    }\\n    \\nprivate :\\n    int capacity;\\n    int size;\\n    int min_freq;\\n    \\n    unordered_map<int,list<int> > freq_to_key;\\n    unordered_map<int,pair<int,int> > keysInfo;    //(key to {value,freq});\\n    unordered_map<int, list<int>::iterator> um_ref; //key to its iterator in freq_to_key list\\n    \\n    \\n    void update(int key){\\n        int curr_freq=keysInfo[key].second;\\n        auto it=um_ref[key];\\n        keysInfo[key].second++;\\n        freq_to_key[curr_freq].erase(it);\\n        curr_freq++;\\n        freq_to_key[curr_freq].push_back(key);\\n        um_ref[key]=(--freq_to_key[curr_freq].end());\\n        \\n        if(freq_to_key[min_freq].empty())\\n            min_freq++;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111713,
                "title": "best-solution-in-python",
                "content": "\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self , key , value):\\n        self.key = key \\n        self.val = value \\n        self.freq = 1 \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity \\n        self.cache = dict()\\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1 \\n\\n        node = self.cache[key]\\n\\n        self.update(node , node.val)\\n        return node.val\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return \\n        if key not in self.cache:\\n            if len(self.cache) >= self.capacity:\\n                k,v = self.usage[self.LF].popitem(last = False)\\n                self.cache.pop(k)\\n            node = ListNode(key,value)\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            self.LF = 1\\n        else:\\n            node = self.cache[key]\\n            node.val = value\\n            self.update(node,value)\\n\\n    def update(self, node , newVal):\\n        k,f = node.key , node.freq\\n        self.usage[f].pop(k)\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self , key , value):\\n        self.key = key \\n        self.val = value \\n        self.freq = 1 \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity \\n        self.cache = dict()\\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1 \\n\\n        node = self.cache[key]\\n\\n        self.update(node , node.val)\\n        return node.val\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return \\n        if key not in self.cache:\\n            if len(self.cache) >= self.capacity:\\n                k,v = self.usage[self.LF].popitem(last = False)\\n                self.cache.pop(k)\\n            node = ListNode(key,value)\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            self.LF = 1\\n        else:\\n            node = self.cache[key]\\n            node.val = value\\n            self.update(node,value)\\n\\n    def update(self, node , newVal):\\n        k,f = node.key , node.freq\\n        self.usage[f].pop(k)\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1083490,
                "title": "python-solution-using-defaultdict-and-a-dict-faster-77-45-memory-usage-88-00",
                "content": "Main Data cache: Normal Dict with {key: [value, frequency]}\\nFrequency cache: Default Dict {frequency: [key1, key2, key3]} all the keys with same frequency and frequency as key.\\n\\nPUT: if cache is full, get the keys with mimimum frequency from frequency dict and pop the 0th index key from the list as well as from the data cache.\\n\\n```\\n\\nclass LFUCache(object):\\n    import collections\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        # cache will contain key:[value, frequency]\\n        # default dict will contain all the keys  having same frequency of occurence.\\n        # {frequency:[key1, key2, key3]}\\n        self.cache = {}\\n        self.freqCache = collections.defaultdict(list)\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        val = self.cache.get(key, -1)\\n        if val == -1: \\n            return val\\n        \\n        value,freq = val\\n        # if key is found, increase the frequency in frequency cache and data cache\\n        self.freqCache[freq].remove(key)\\n        if not self.freqCache[freq]: del self.freqCache[freq]\\n        self.freqCache[freq+1].append(key)\\n\\n        self.cache[key] = [value, freq+1]  \\n        \\n        return value\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if self.capacity <=0:\\n            return\\n        val = self.cache.get(key, -1)\\n        initfreq=1\\n        \\n        if  val == -1:\\n            \\n            if len(self.cache) == self.capacity:\\n                #print self.freqCache.items()\\n                minFreq, delList = min(self.freqCache.items(), key=lambda x:x[0])\\n                #print delList\\n                delkey = delList[0]\\n                del self.cache[delkey]\\n                self.freqCache[minFreq].remove(delkey)\\n                \\n                #insert in cache\\n                self.cache.update({key:[value,initfreq]})\\n                self.freqCache[initfreq].append(key)\\n            else:\\n                self.cache.update({key:[value,initfreq]})\\n                self.freqCache[initfreq].append(key)\\n        else:\\n            oldval,freq = val\\n            \\n            self.freqCache[freq].remove(key)\\n            if not self.freqCache[freq]: del self.freqCache[freq]\\n            self.freqCache[freq+1].append(key)\\n            \\n            self.cache[key] = [value,freq+1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Main Data cache: Normal Dict with {key: [value, frequency]}\\nFrequency cache: Default Dict {frequency: [key1, key2, key3]} all the keys with same frequency and frequency as key.\\n\\nPUT: if cache is full, get the keys with mimimum frequency from frequency dict and pop the 0th index key from the list as well as from the data cache.\\n\\n```\\n\\nclass LFUCache(object):\\n    import collections\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        # cache will contain key:[value, frequency]\\n        # default dict will contain all the keys  having same frequency of occurence.\\n        # {frequency:[key1, key2, key3]}\\n        self.cache = {}\\n        self.freqCache = collections.defaultdict(list)\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        val = self.cache.get(key, -1)\\n        if val == -1: \\n            return val\\n        \\n        value,freq = val\\n        # if key is found, increase the frequency in frequency cache and data cache\\n        self.freqCache[freq].remove(key)\\n        if not self.freqCache[freq]: del self.freqCache[freq]\\n        self.freqCache[freq+1].append(key)\\n\\n        self.cache[key] = [value, freq+1]  \\n        \\n        return value\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if self.capacity <=0:\\n            return\\n        val = self.cache.get(key, -1)\\n        initfreq=1\\n        \\n        if  val == -1:\\n            \\n            if len(self.cache) == self.capacity:\\n                #print self.freqCache.items()\\n                minFreq, delList = min(self.freqCache.items(), key=lambda x:x[0])\\n                #print delList\\n                delkey = delList[0]\\n                del self.cache[delkey]\\n                self.freqCache[minFreq].remove(delkey)\\n                \\n                #insert in cache\\n                self.cache.update({key:[value,initfreq]})\\n                self.freqCache[initfreq].append(key)\\n            else:\\n                self.cache.update({key:[value,initfreq]})\\n                self.freqCache[initfreq].append(key)\\n        else:\\n            oldval,freq = val\\n            \\n            self.freqCache[freq].remove(key)\\n            if not self.freqCache[freq]: del self.freqCache[freq]\\n            self.freqCache[freq+1].append(key)\\n            \\n            self.cache[key] = [value,freq+1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 497798,
                "title": "python-dict-ordereddict-with-comments",
                "content": "```\\nfrom collections import defaultdict, OrderedDict\\n\\n\\nclass Node:\\n    def __init__(self, key, val, freq):\\n        self.key = key\\n        self.val = val\\n        self.freq = freq\\n    \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.min_freq = None\\n        \\n        # hash map for key-node\\n        self.key2node = dict()\\n        \\n        # doubly-linked hash map\\n        self.freq2node = defaultdict(OrderedDict)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        # cuz node has been \"get\", its frequency would go up\\n        # remove its old pair in freq2node\\n        del self.freq2node[node.freq][key]\\n        \\n        # further check whether old node.freq is empty in freq2node\\n        if not self.freq2node[node.freq]:\\n            del self.freq2node[node.freq]\\n        \\n        # update node in freq2node\\n        node.freq += 1\\n        self.freq2node[node.freq][key] = node\\n        \\n        # update min_freq\\n        if not self.freq2node[self.min_freq]:\\n            self.min_freq += 1\\n    \\n        return node.val\\n        \\n\\n    def put(self, key: int, value: int) -> None: \\n        if not self.capacity:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            # update key \\n            _ = self.get(key)\\n            return \\n        \\n        # already reached capacity limit\\n        if len(self.key2node) == self.capacity:\\n            # remove least frequently used node\\n            k, node = self.freq2node[self.min_freq].popitem(last=False)\\n            del self.key2node[k]\\n        \\n        self.freq2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.min_freq = 1\\n        return \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict, OrderedDict\\n\\n\\nclass Node:\\n    def __init__(self, key, val, freq):\\n        self.key = key\\n        self.val = val\\n        self.freq = freq\\n    \\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.min_freq = None\\n        \\n        # hash map for key-node\\n        self.key2node = dict()\\n        \\n        # doubly-linked hash map\\n        self.freq2node = defaultdict(OrderedDict)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        # cuz node has been \"get\", its frequency would go up\\n        # remove its old pair in freq2node\\n        del self.freq2node[node.freq][key]\\n        \\n        # further check whether old node.freq is empty in freq2node\\n        if not self.freq2node[node.freq]:\\n            del self.freq2node[node.freq]\\n        \\n        # update node in freq2node\\n        node.freq += 1\\n        self.freq2node[node.freq][key] = node\\n        \\n        # update min_freq\\n        if not self.freq2node[self.min_freq]:\\n            self.min_freq += 1\\n    \\n        return node.val\\n        \\n\\n    def put(self, key: int, value: int) -> None: \\n        if not self.capacity:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            # update key \\n            _ = self.get(key)\\n            return \\n        \\n        # already reached capacity limit\\n        if len(self.key2node) == self.capacity:\\n            # remove least frequently used node\\n            k, node = self.freq2node[self.min_freq].popitem(last=False)\\n            del self.key2node[k]\\n        \\n        self.freq2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.min_freq = 1\\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365737,
                "title": "java-o-1-solution-with-detailed-explaination-2-hashmaps-1-dll",
                "content": "```\\nclass LFUCache {\\n\\n    final int capacity;\\n    int curSize;\\n    int minFrequency;\\n    Map<Integer, DLLNode> cache;\\n    Map<Integer, DoubleLinkedList> frequencyMap;\\n\\n    /*.*/\\n    /*\\n    * @param capacity: total capacity of LFU Cache\\n    * @param curSize: current size of LFU cache\\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\\n    * double linked list by their frequencies\\n    * */\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.curSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n\\n    /** get node value by key, and then update node frequency as well as relocate that node **/\\n    public int get(int key) {\\n        DLLNode curNode = cache.get(key);\\n        if (curNode == null) {\\n            return -1;\\n        }\\n        updateNode(curNode);\\n        return curNode.val;\\n    }\\n\\n    /**\\n     * add new node into LFU cache, as well as double linked list\\n     * condition 1: if LFU cache has input key, update node value and node position in list\\n     * condition 2: if LFU cache does NOT have input key\\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\\n     *  in minimum frequency list, then add new node\\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\\n     * **/\\n    public void put(int key, int value) {\\n        // corner case: check cache capacity initialization\\n        if (capacity == 0) {\\n            return;\\n        }\\n\\n        if (cache.containsKey(key)) {\\n            DLLNode curNode = cache.get(key);\\n            curNode.val = value;\\n            updateNode(curNode);\\n        }\\n        else {\\n            curSize++;\\n            if (curSize > capacity) {\\n                // get minimum frequency list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                curSize--;\\n            }\\n            // reset min frequency to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode curNode) {\\n        int curFreq = curNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\\n        curList.removeNode(curNode);\\n\\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\\n        // we need to remove the entire list and then increase min frequency value by 1\\n        if (curFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        curNode.frequency++;\\n        // add current node to another list has current frequency + 1,\\n        // if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\\n        newList.addNode(curNode);\\n        frequencyMap.put(curNode.frequency, newList);\\n    }\\n\\n    /*\\n    * @param key: node key\\n    * @param val: node value\\n    * @param frequency: frequency count of current node\\n    * (all nodes connected in same double linked list has same frequency)\\n    * @param prev: previous pointer of current node\\n    * @param next: next pointer of current node\\n    * */\\n    class DLLNode {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    /*\\n    * @param listSize: current size of double linked list\\n    * @param head: head node of double linked list\\n    * @param tail: tail node of double linked list\\n    * */\\n    class DoubleLinkedList {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        /** add new node into head of list and increase list size by 1 **/\\n        public void addNode(DLLNode curNode) {\\n            DLLNode nextNode = head.next;\\n            curNode.next = nextNode;\\n            curNode.prev = head;\\n            head.next = curNode;\\n            nextNode.prev = curNode;\\n            listSize++;\\n        }\\n\\n        /** remove input node and decrease list size by 1**/\\n        public void removeNode(DLLNode curNode) {\\n            DLLNode prevNode = curNode.prev;\\n            DLLNode nextNode = curNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n\\n    final int capacity;\\n    int curSize;\\n    int minFrequency;\\n    Map<Integer, DLLNode> cache;\\n    Map<Integer, DoubleLinkedList> frequencyMap;\\n\\n    /*.*/\\n    /*\\n    * @param capacity: total capacity of LFU Cache\\n    * @param curSize: current size of LFU cache\\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\\n    * double linked list by their frequencies\\n    * */\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.curSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n\\n    /** get node value by key, and then update node frequency as well as relocate that node **/\\n    public int get(int key) {\\n        DLLNode curNode = cache.get(key);\\n        if (curNode == null) {\\n            return -1;\\n        }\\n        updateNode(curNode);\\n        return curNode.val;\\n    }\\n\\n    /**\\n     * add new node into LFU cache, as well as double linked list\\n     * condition 1: if LFU cache has input key, update node value and node position in list\\n     * condition 2: if LFU cache does NOT have input key\\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\\n     *  in minimum frequency list, then add new node\\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\\n     * **/\\n    public void put(int key, int value) {\\n        // corner case: check cache capacity initialization\\n        if (capacity == 0) {\\n            return;\\n        }\\n\\n        if (cache.containsKey(key)) {\\n            DLLNode curNode = cache.get(key);\\n            curNode.val = value;\\n            updateNode(curNode);\\n        }\\n        else {\\n            curSize++;\\n            if (curSize > capacity) {\\n                // get minimum frequency list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                curSize--;\\n            }\\n            // reset min frequency to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode curNode) {\\n        int curFreq = curNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\\n        curList.removeNode(curNode);\\n\\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\\n        // we need to remove the entire list and then increase min frequency value by 1\\n        if (curFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        curNode.frequency++;\\n        // add current node to another list has current frequency + 1,\\n        // if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\\n        newList.addNode(curNode);\\n        frequencyMap.put(curNode.frequency, newList);\\n    }\\n\\n    /*\\n    * @param key: node key\\n    * @param val: node value\\n    * @param frequency: frequency count of current node\\n    * (all nodes connected in same double linked list has same frequency)\\n    * @param prev: previous pointer of current node\\n    * @param next: next pointer of current node\\n    * */\\n    class DLLNode {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    /*\\n    * @param listSize: current size of double linked list\\n    * @param head: head node of double linked list\\n    * @param tail: tail node of double linked list\\n    * */\\n    class DoubleLinkedList {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        /** add new node into head of list and increase list size by 1 **/\\n        public void addNode(DLLNode curNode) {\\n            DLLNode nextNode = head.next;\\n            curNode.next = nextNode;\\n            curNode.prev = head;\\n            head.next = curNode;\\n            nextNode.prev = curNode;\\n            listSize++;\\n        }\\n\\n        /** remove input node and decrease list size by 1**/\\n        public void removeNode(DLLNode curNode) {\\n            DLLNode prevNode = curNode.prev;\\n            DLLNode nextNode = curNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484081,
                "title": "java-hashmap-treeset-o-logn",
                "content": "```\\nclass LFUCache {\\n    int tick;\\n    int size;\\n    TreeSet<Node> set;\\n    HashMap<Integer, Node> map;\\n    \\n    public LFUCache(int capacity) {\\n        tick = 0;\\n        size = capacity;\\n        map = new HashMap<>();\\n        set = new TreeSet<>((a, b) -> a.freq == b.freq ? b.tick - a.tick : b.freq - a.freq);\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)) return -1;\\n        Node node = map.get(key);\\n        addOrUpdate(node);\\n        map.put(key, node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(size == 0) return;\\n        Node node = map.get(key);\\n        if(node != null) {\\n            node.val = value;\\n            addOrUpdate(node);\\n        } else {\\n            if(map.size() == size) {\\n                Node last = set.pollLast();\\n                map.remove(last.key);\\n            }\\n            node = new Node(key, value);\\n            addOrUpdate(node);\\n        }\\n        map.put(key, node);\\n    }\\n    \\n    // remove node in treeSet and put it into treeSet again, update its reference in hashMap\\n    private void addOrUpdate(Node node) {\\n        set.remove(node);\\n        node.freq += 1;\\n        node.tick = ++tick;\\n        set.add(node);\\n    }\\n    \\n    class Node {\\n        int key;\\n        int val;\\n        int freq;\\n        int tick;\\n        Node prev;\\n        Node next;\\n        Node(int k, int v) {\\n            key = k;\\n            val = v;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass LFUCache {\\n    int tick;\\n    int size;\\n    TreeSet<Node> set;\\n    HashMap<Integer, Node> map;\\n    \\n    public LFUCache(int capacity) {\\n        tick = 0;\\n        size = capacity;\\n        map = new HashMap<>();\\n        set = new TreeSet<>((a, b) -> a.freq == b.freq ? b.tick - a.tick : b.freq - a.freq);\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)) return -1;\\n        Node node = map.get(key);\\n        addOrUpdate(node);\\n        map.put(key, node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(size == 0) return;\\n        Node node = map.get(key);\\n        if(node != null) {\\n            node.val = value;\\n            addOrUpdate(node);\\n        } else {\\n            if(map.size() == size) {\\n                Node last = set.pollLast();\\n                map.remove(last.key);\\n            }\\n            node = new Node(key, value);\\n            addOrUpdate(node);\\n        }\\n        map.put(key, node);\\n    }\\n    \\n    // remove node in treeSet and put it into treeSet again, update its reference in hashMap\\n    private void addOrUpdate(Node node) {\\n        set.remove(node);\\n        node.freq += 1;\\n        node.tick = ++tick;\\n        set.add(node);\\n    }\\n    \\n    class Node {\\n        int key;\\n        int val;\\n        int freq;\\n        int tick;\\n        Node prev;\\n        Node next;\\n        Node(int k, int v) {\\n            key = k;\\n            val = v;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 229703,
                "title": "python-easy-and-readable",
                "content": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.k = capacity\\n        self.cacheFreq = collections.defaultdict(collections.OrderedDict)\\n        self.cacheKey = {}\\n        self.leastFreq = 1\\n        \\n        \\n    def _evict(self):\\n        key, _ = self.cacheFreq[self.leastFreq].popitem(last=False)\\n        del self.cacheKey[key]\\n    \\n    \\n    def _update(self, key, new_v=None):\\n        freq, v = self.cacheKey[key][\\'freq\\'], self.cacheKey[key][\\'value\\']\\n        del self.cacheFreq[freq][key]\\n        if not self.cacheFreq[self.leastFreq]:\\n            self.leastFreq += 1\\n        \\n        self.cacheKey[key] = {\\'freq\\': freq + 1, \\'value\\': new_v or v}\\n        self.cacheFreq[freq+1][key] = new_v or v\\n        \\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.cacheKey:\\n            return -1\\n        self._update(key)\\n        return self.cacheKey[key][\\'value\\']\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if key in self.cacheKey:\\n            self._update(key, value)\\n            return\\n        self.cacheKey[key] = {\\'freq\\': 1, \\'value\\': value}\\n        self.cacheFreq[1][key] = value\\n        if len(self.cacheKey) > self.k:\\n            self._evict()\\n        self.leastFreq = 1    \\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.k = capacity\\n        self.cacheFreq = collections.defaultdict(collections.OrderedDict)\\n        self.cacheKey = {}\\n        self.leastFreq = 1\\n        \\n        \\n    def _evict(self):\\n        key, _ = self.cacheFreq[self.leastFreq].popitem(last=False)\\n        del self.cacheKey[key]\\n    \\n    \\n    def _update(self, key, new_v=None):\\n        freq, v = self.cacheKey[key][\\'freq\\'], self.cacheKey[key][\\'value\\']\\n        del self.cacheFreq[freq][key]\\n        if not self.cacheFreq[self.leastFreq]:\\n            self.leastFreq += 1\\n        \\n        self.cacheKey[key] = {\\'freq\\': freq + 1, \\'value\\': new_v or v}\\n        self.cacheFreq[freq+1][key] = new_v or v\\n        \\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.cacheKey:\\n            return -1\\n        self._update(key)\\n        return self.cacheKey[key][\\'value\\']\\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if key in self.cacheKey:\\n            self._update(key, value)\\n            return\\n        self.cacheKey[key] = {\\'freq\\': 1, \\'value\\': value}\\n        self.cacheFreq[1][key] = value\\n        if len(self.cacheKey) > self.k:\\n            self._evict()\\n        self.leastFreq = 1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111458,
                "title": "c-code",
                "content": "# Solution Code\\n\\n``` C++ []\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/33d5b62a-2980-4267-aefc-716370ba881f_1674959448.8604577.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294897,
                "title": "c-solution-to-nasty-problem",
                "content": "[RANT] \\nThis problem given as a coding test means one or more of the following:\\n1. There is an internal candidate they want to give the job to but have to follow some HR process, preferred recruiter etc etc\\n2. The person who set it is unlikely to be someone you want to work with \\n3. The person who set it is under pressure to hire unecessary people to boost headcount and budget (ie their boss wants a promotion!) \\n\\n[/RANT]\\n\\nLFU Cache is inordinately tricky. I\\'m not convinced my solution will work in the real world but it passes the pathological Leetcode tests (hey! there\\'s people paid to cook this stuff up! Kudos! a zero sized cache... ok is that realistic? :-/ )  \\n\\nI\\'m posting this because after battling I managed to put together something relatively clean that I\\'m happy with. I solved it before with a DIY doubly linked list and a single hashmap but it was defeated by Leetcodes 10,000 consecutive puts TLE that makes it ~O(N^2). \\n\\nI\\'m 67 and worked for 25 years at a global bank. The limit of my bastardry in coding tests was a pointer to a pointer. \\n\\nHope this helps someone. \\n\\nAll the best!\\n\\nUpdate: added a DIY DLL version and one using a single std::list with no need for a minfreq variable.\\n\\n```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node(int k,int v) : key(k),val(v),freq(1) {}\\n    };\\n    unordered_map<int,list<Node>::iterator> cache;\\n    unordered_map<int,list<Node>> freqs;\\n    int capacity, minfreq;\\n    \\n    void create(int key,int value) {\\n        freqs[1].push_front({key,value});\\n        cache[key] = freqs[1].begin();\\n        minfreq = 1;\\n    }\\n    void evict() {\\n        auto& list = freqs[minfreq];\\n        auto  node = list.back();\\n        cache.erase(node.key);\\n        list.pop_back();\\n        if (list.empty()) {\\n            freqs.erase(node.freq);\\n            minfreq += 1; // i\\'m guessing this does not really work!!!\\n        }\\n    }\\n    void bump(list<Node>::iterator it) {\\n        auto node = *it;\\n        freqs[node.freq].erase(it);\\n        if (freqs[node.freq].empty()) {\\n            freqs.erase(node.freq);\\n            if (node.freq == minfreq)\\n                minfreq += 1;\\n        }\\n        node.freq++;\\n        freqs[node.freq].push_front(node);\\n        cache[node.key] = freqs[node.freq].begin();\\n    }\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        this->minfreq  = 1;\\n    }\\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            int val = it->second->val;\\n            bump(it->second);\\n            return val;\\n        }\\n        return -1;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity != 0) { // pathological Leetcode case :-/\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }\\n};\\n```\\n\\nHere\\'s the version using a DIY DLL. The same should be possible with std::list and iterators in both the cache and freqs maps.\\n\\n```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node *prev, *next;\\n        Node() : key(-1), val(-1), freq(0), prev(0), next(0) {}\\n        Node(int k,int v,Node *node) : key(k), val(v), freq(1), prev(node), next(node->next) {\\n            if (next) next->prev = this;\\n            node->next = this;\\n        }\\n        ~Node() { \\n            if (next) next->prev = prev;\\n            if (prev) prev->next = next;            \\n        }\\n        Node* link(Node* node) {\\n            if (node && node != this) {\\n                if (next) next->prev = prev;\\n                if (prev) prev->next = next;            \\n                next = node->next;\\n                node->next = this;\\n                if (next) next->prev = this;\\n                prev = node;\\n            }\\n            return this;\\n        }\\n    };\\n    unordered_map<int,Node*> cache;\\n    unordered_map<int,Node*> freqs;\\n    Node *head;\\n    int   capacity;\\n    \\n    void create(int key,int value) {\\n        cache[key] = freqs[1] = new Node(key,value,(freqs.count(1) ? freqs[1] : head));\\n    }\\n    void evict() {\\n        Node *node=head->next;\\n        if (node) {\\n            if (freqs[node->freq] == node)\\n                freqs.erase(node->freq); // we are the only node\\n            cache.erase(node->key);\\n            delete node;\\n        }\\n    }\\n    void bump(Node *node) {\\n        Node *prev=node->prev;\\n        int freq = ++(node->freq);\\n        \\n        freqs[freq] = node->link(freqs.count(freq) ? freqs[freq] : freqs[freq-1]);\\n        \\n        if (node == freqs[freq-1]) {\\n            if (prev->freq == freq-1)\\n                freqs[prev->freq] = prev;\\n            else\\n                freqs.erase(freq-1);\\n        }\\n    }\\npublic:\\n    LFUCache(int capacity) : head(new Node()) { this->capacity = capacity; }\\n    \\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it == cache.end()) return -1;\\n        bump(it->second);\\n        return it->second->val;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity) {\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }   \\n};\\n```\\n\\nAnd here we are using std::list. \\n\\nIt would be interesting to make std::forward_list work as it uses \"insert after\" rather than \"insert before\" - why std::list doesn\\'t offer both is a puzzle but from what I\\'ve read std::list is a mostly unused container in the real world. The joke is \"we removed it from the standard and nobody noticed...\"\\n\\n```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node() : key(-1), val(-1), freq(0) {}\\n        Node(int k,int v) : key(k), val(v), freq(1) {}\\n    };\\n    list<Node> head;\\n    unordered_map<int,list<Node>::iterator> cache;\\n    unordered_map<int,list<Node>::iterator> freqs;\\n    int capacity;\\n    \\n    void create(int key,int value) {\\n        cache[key] = freqs[1] = head.emplace(freqs.count(1) ? freqs[1] : head.end(), key,value);\\n    }\\n    void evict() {\\n        if (! head.empty()) {\\n            auto node = prev(head.end());\\n            if (freqs[node->freq]->key == node->key)\\n                freqs.erase(node->freq); // we are the only node\\n            cache.erase(node->key);\\n            head.erase(node);\\n        }\\n    }\\n    void bump(list<Node>::iterator& node) {\\n        bool tail = node == freqs[node->freq++];\\n        int  freq = node->freq;      \\n        auto last = next(node);\\n        \\n        head.splice(freqs.count(freq) ? freqs[freq] : freqs[freq-1], head,node);\\n        freqs[freq] = node;\\n        \\n        if (tail) {\\n            if (last != head.end() && last->freq == freq-1)\\n                freqs[last->freq] = last;\\n            else\\n                freqs.erase(freq-1);\\n        }\\n    }\\npublic:\\n    LFUCache(int capacity) { this->capacity = capacity; }\\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it == cache.end()) return -1;\\n        bump(it->second);\\n        return it->second->val;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity) {\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node(int k,int v) : key(k),val(v),freq(1) {}\\n    };\\n    unordered_map<int,list<Node>::iterator> cache;\\n    unordered_map<int,list<Node>> freqs;\\n    int capacity, minfreq;\\n    \\n    void create(int key,int value) {\\n        freqs[1].push_front({key,value});\\n        cache[key] = freqs[1].begin();\\n        minfreq = 1;\\n    }\\n    void evict() {\\n        auto& list = freqs[minfreq];\\n        auto  node = list.back();\\n        cache.erase(node.key);\\n        list.pop_back();\\n        if (list.empty()) {\\n            freqs.erase(node.freq);\\n            minfreq += 1; // i\\'m guessing this does not really work!!!\\n        }\\n    }\\n    void bump(list<Node>::iterator it) {\\n        auto node = *it;\\n        freqs[node.freq].erase(it);\\n        if (freqs[node.freq].empty()) {\\n            freqs.erase(node.freq);\\n            if (node.freq == minfreq)\\n                minfreq += 1;\\n        }\\n        node.freq++;\\n        freqs[node.freq].push_front(node);\\n        cache[node.key] = freqs[node.freq].begin();\\n    }\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        this->minfreq  = 1;\\n    }\\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            int val = it->second->val;\\n            bump(it->second);\\n            return val;\\n        }\\n        return -1;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity != 0) { // pathological Leetcode case :-/\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }\\n};\\n```\n```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node *prev, *next;\\n        Node() : key(-1), val(-1), freq(0), prev(0), next(0) {}\\n        Node(int k,int v,Node *node) : key(k), val(v), freq(1), prev(node), next(node->next) {\\n            if (next) next->prev = this;\\n            node->next = this;\\n        }\\n        ~Node() { \\n            if (next) next->prev = prev;\\n            if (prev) prev->next = next;            \\n        }\\n        Node* link(Node* node) {\\n            if (node && node != this) {\\n                if (next) next->prev = prev;\\n                if (prev) prev->next = next;            \\n                next = node->next;\\n                node->next = this;\\n                if (next) next->prev = this;\\n                prev = node;\\n            }\\n            return this;\\n        }\\n    };\\n    unordered_map<int,Node*> cache;\\n    unordered_map<int,Node*> freqs;\\n    Node *head;\\n    int   capacity;\\n    \\n    void create(int key,int value) {\\n        cache[key] = freqs[1] = new Node(key,value,(freqs.count(1) ? freqs[1] : head));\\n    }\\n    void evict() {\\n        Node *node=head->next;\\n        if (node) {\\n            if (freqs[node->freq] == node)\\n                freqs.erase(node->freq); // we are the only node\\n            cache.erase(node->key);\\n            delete node;\\n        }\\n    }\\n    void bump(Node *node) {\\n        Node *prev=node->prev;\\n        int freq = ++(node->freq);\\n        \\n        freqs[freq] = node->link(freqs.count(freq) ? freqs[freq] : freqs[freq-1]);\\n        \\n        if (node == freqs[freq-1]) {\\n            if (prev->freq == freq-1)\\n                freqs[prev->freq] = prev;\\n            else\\n                freqs.erase(freq-1);\\n        }\\n    }\\npublic:\\n    LFUCache(int capacity) : head(new Node()) { this->capacity = capacity; }\\n    \\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it == cache.end()) return -1;\\n        bump(it->second);\\n        return it->second->val;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity) {\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }   \\n};\\n```\n```\\nclass LFUCache {\\n    struct Node {\\n        int key, val, freq;\\n        Node() : key(-1), val(-1), freq(0) {}\\n        Node(int k,int v) : key(k), val(v), freq(1) {}\\n    };\\n    list<Node> head;\\n    unordered_map<int,list<Node>::iterator> cache;\\n    unordered_map<int,list<Node>::iterator> freqs;\\n    int capacity;\\n    \\n    void create(int key,int value) {\\n        cache[key] = freqs[1] = head.emplace(freqs.count(1) ? freqs[1] : head.end(), key,value);\\n    }\\n    void evict() {\\n        if (! head.empty()) {\\n            auto node = prev(head.end());\\n            if (freqs[node->freq]->key == node->key)\\n                freqs.erase(node->freq); // we are the only node\\n            cache.erase(node->key);\\n            head.erase(node);\\n        }\\n    }\\n    void bump(list<Node>::iterator& node) {\\n        bool tail = node == freqs[node->freq++];\\n        int  freq = node->freq;      \\n        auto last = next(node);\\n        \\n        head.splice(freqs.count(freq) ? freqs[freq] : freqs[freq-1], head,node);\\n        freqs[freq] = node;\\n        \\n        if (tail) {\\n            if (last != head.end() && last->freq == freq-1)\\n                freqs[last->freq] = last;\\n            else\\n                freqs.erase(freq-1);\\n        }\\n    }\\npublic:\\n    LFUCache(int capacity) { this->capacity = capacity; }\\n    int get(int key) {\\n        auto it = cache.find(key);\\n        if (it == cache.end()) return -1;\\n        bump(it->second);\\n        return it->second->val;\\n    }\\n    void put(int key, int value) {\\n        auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second->val = value;\\n            bump(it->second);\\n        }\\n        else if (capacity) {\\n            if (cache.size() == capacity) evict();\\n            create(key,value);\\n        }\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918508,
                "title": "python-ddl",
                "content": "```\\nclass DLL:\\n    \\n    class DLNode:\\n        def __init__(self, key = 0, val = 0, prev = None, next = None):\\n            self.key = key\\n            self.val = val\\n            self.freq = 1\\n            self.prev = prev\\n            self.next = next\\n            \\n    def __init__(self):\\n        self.size = 0\\n        self.head = self.DLNode()\\n        self.tail = self.DLNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def remove_node(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n        self.size -= 1\\n    \\n    def insert_head(self, node):\\n        self.head.next.prev = node\\n        node.next = self.head.next\\n        node.prev = self.head\\n        self.head.next = node\\n        self.size += 1\\n            \\n    def remove_tail(self):\\n        tail = self.tail.prev\\n        self.remove_node(tail)\\n        return tail\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.freq_map = {}\\n        self.capacity = capacity\\n        self.min_freq = 0\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        node = self.cache[key]\\n        self.update_cache(node.key, node.val)\\n        return node.val\\n\\n    def put(self, key: int, val: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.cache:\\n            self.update_cache(key, val)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                lfu_node = self.freq_map[self.min_freq].remove_tail()\\n                del self.cache[lfu_node.key]\\n            self.min_freq = 1\\n            if self.min_freq not in self.freq_map:\\n                self.freq_map[self.min_freq] = DLL()\\n            node = DLL.DLNode(key, val)\\n            self.freq_map[self.min_freq].insert_head(node)\\n            self.cache[key] = node\\n            \\n        \\n    def update_cache(self, key, val):\\n        node = self.cache[key]\\n        node.val = val\\n        prev_freq = node.freq\\n        node.freq += 1\\n        self.freq_map[prev_freq].remove_node(node)\\n        if node.freq not in self.freq_map:\\n            self.freq_map[node.freq] = DLL()\\n        self.freq_map[node.freq].insert_head(node)\\n        if prev_freq == self.min_freq and self.freq_map[prev_freq].size == 0:\\n            del self.freq_map[prev_freq]\\n            self.min_freq += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass DLL:\\n    \\n    class DLNode:\\n        def __init__(self, key = 0, val = 0, prev = None, next = None):\\n            self.key = key\\n            self.val = val\\n            self.freq = 1\\n            self.prev = prev\\n            self.next = next\\n            \\n    def __init__(self):\\n        self.size = 0\\n        self.head = self.DLNode()\\n        self.tail = self.DLNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def remove_node(self, node):\\n        node.next.prev = node.prev\\n        node.prev.next = node.next\\n        self.size -= 1\\n    \\n    def insert_head(self, node):\\n        self.head.next.prev = node\\n        node.next = self.head.next\\n        node.prev = self.head\\n        self.head.next = node\\n        self.size += 1\\n            \\n    def remove_tail(self):\\n        tail = self.tail.prev\\n        self.remove_node(tail)\\n        return tail\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.freq_map = {}\\n        self.capacity = capacity\\n        self.min_freq = 0\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        node = self.cache[key]\\n        self.update_cache(node.key, node.val)\\n        return node.val\\n\\n    def put(self, key: int, val: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.cache:\\n            self.update_cache(key, val)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                lfu_node = self.freq_map[self.min_freq].remove_tail()\\n                del self.cache[lfu_node.key]\\n            self.min_freq = 1\\n            if self.min_freq not in self.freq_map:\\n                self.freq_map[self.min_freq] = DLL()\\n            node = DLL.DLNode(key, val)\\n            self.freq_map[self.min_freq].insert_head(node)\\n            self.cache[key] = node\\n            \\n        \\n    def update_cache(self, key, val):\\n        node = self.cache[key]\\n        node.val = val\\n        prev_freq = node.freq\\n        node.freq += 1\\n        self.freq_map[prev_freq].remove_node(node)\\n        if node.freq not in self.freq_map:\\n            self.freq_map[node.freq] = DLL()\\n        self.freq_map[node.freq].insert_head(node)\\n        if prev_freq == self.min_freq and self.freq_map[prev_freq].size == 0:\\n            del self.freq_map[prev_freq]\\n            self.min_freq += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922128,
                "title": "c-time-o-1-amortized-space-o-capacity",
                "content": "```\\nstruct Node {\\n    int key, val, freq;\\n    Node *prev, *next;\\n    Node() : prev(nullptr), next(nullptr){};\\n};\\n\\nstruct List {\\n    int size;\\n    Node *head, *tail;\\n    \\n    List() : size(0), head(new Node()), tail(new Node()) {\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n\\t~List() {\\n\\t\\tNode *curr = head;\\n\\t\\twhile (curr != nullptr) {\\n\\t\\t\\tNode *next = curr->next;\\n\\t\\t\\tdelete curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\t}\\n    \\n    void add(Node *node) {\\n        node->next = head->next;\\n        node->prev = head;\\n        node->next->prev = node;\\n        node->prev->next = node;\\n        ++size;\\n    }\\n    \\n    void remove(Node *node) {\\n        node->next->prev = node->prev;\\n        node->prev->next = node->next;\\n        node->next = nullptr;\\n        node->prev = nullptr;\\n        --size;\\n    }\\n    \\n    Node *last() {\\n        Node *node = tail->prev;\\n        remove(node);\\n        return node;\\n    }\\n};\\n\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) : Cap(capacity), Mfreq(0) {\\n    }\\n    \\n    ~LFUCache() {\\n        for (pair<int, List*> p: Lists) {\\n            delete p.second;\\n        }\\n    }\\n    \\n    int get(int key) {\\n        if(Nodes.count(key) == 1) {\\n            promote(key);\\n            return Nodes[key]->val;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!Cap) return;\\n        \\n        if (Nodes.count(key) == 1) {\\n            promote(key); // Done\\n            Nodes[key]->val = value;\\n        } \\n        else {\\n            if (Nodes.size() == Cap) {\\n                evict(); // Done\\n            }\\n            insert(key, value); // Done\\n        }\\n    }\\n    \\nprivate:\\n    int Cap, Mfreq;\\n    unordered_map<int, List*> Lists;\\n    unordered_map<int, Node*> Nodes; \\n    \\n    void insert(int key, int value) {\\n        Mfreq = 1;\\n        Node *node = new Node();\\n        node->key = key;\\n        node->val = value;\\n        node->freq = Mfreq;\\n        Nodes[key] = node;\\n        addToList(Mfreq, node); // Done\\n    }\\n    \\n    void addToList(int freq, Node *node) {\\n        if (Lists.count(freq) == 0) {\\n            Lists[freq] = new List();\\n        }\\n        Lists[freq]->add(node);\\n    }\\n    \\n    void evict() {\\n        Node *node = Lists[Mfreq]->last();\\n        Nodes.erase(node->key);\\n        delete node;\\n        removeIfEmpty(Mfreq); // Done\\n    }\\n    \\n    void removeIfEmpty(int freq) {\\n        if (Lists[Mfreq]->size == 0) {\\n            List *del = Lists[Mfreq];\\n            delete del;\\n            Lists.erase(Mfreq);\\n            if (freq == Mfreq)\\n                ++Mfreq;\\n        }\\n    }\\n    \\n    void promote(int key) {\\n        Node *node = Nodes[key];\\n        int freq = node->freq++;\\n        Lists[freq]->remove(node);\\n        removeIfEmpty(freq);\\n        addToList(freq+1, node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Doubly-Linked List"
                ],
                "code": "```\\nstruct Node {\\n    int key, val, freq;\\n    Node *prev, *next;\\n    Node() : prev(nullptr), next(nullptr){};\\n};\\n\\nstruct List {\\n    int size;\\n    Node *head, *tail;\\n    \\n    List() : size(0), head(new Node()), tail(new Node()) {\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n\\t~List() {\\n\\t\\tNode *curr = head;\\n\\t\\twhile (curr != nullptr) {\\n\\t\\t\\tNode *next = curr->next;\\n\\t\\t\\tdelete curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\t}\\n    \\n    void add(Node *node) {\\n        node->next = head->next;\\n        node->prev = head;\\n        node->next->prev = node;\\n        node->prev->next = node;\\n        ++size;\\n    }\\n    \\n    void remove(Node *node) {\\n        node->next->prev = node->prev;\\n        node->prev->next = node->next;\\n        node->next = nullptr;\\n        node->prev = nullptr;\\n        --size;\\n    }\\n    \\n    Node *last() {\\n        Node *node = tail->prev;\\n        remove(node);\\n        return node;\\n    }\\n};\\n\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) : Cap(capacity), Mfreq(0) {\\n    }\\n    \\n    ~LFUCache() {\\n        for (pair<int, List*> p: Lists) {\\n            delete p.second;\\n        }\\n    }\\n    \\n    int get(int key) {\\n        if(Nodes.count(key) == 1) {\\n            promote(key);\\n            return Nodes[key]->val;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!Cap) return;\\n        \\n        if (Nodes.count(key) == 1) {\\n            promote(key); // Done\\n            Nodes[key]->val = value;\\n        } \\n        else {\\n            if (Nodes.size() == Cap) {\\n                evict(); // Done\\n            }\\n            insert(key, value); // Done\\n        }\\n    }\\n    \\nprivate:\\n    int Cap, Mfreq;\\n    unordered_map<int, List*> Lists;\\n    unordered_map<int, Node*> Nodes; \\n    \\n    void insert(int key, int value) {\\n        Mfreq = 1;\\n        Node *node = new Node();\\n        node->key = key;\\n        node->val = value;\\n        node->freq = Mfreq;\\n        Nodes[key] = node;\\n        addToList(Mfreq, node); // Done\\n    }\\n    \\n    void addToList(int freq, Node *node) {\\n        if (Lists.count(freq) == 0) {\\n            Lists[freq] = new List();\\n        }\\n        Lists[freq]->add(node);\\n    }\\n    \\n    void evict() {\\n        Node *node = Lists[Mfreq]->last();\\n        Nodes.erase(node->key);\\n        delete node;\\n        removeIfEmpty(Mfreq); // Done\\n    }\\n    \\n    void removeIfEmpty(int freq) {\\n        if (Lists[Mfreq]->size == 0) {\\n            List *del = Lists[Mfreq];\\n            delete del;\\n            Lists.erase(Mfreq);\\n            if (freq == Mfreq)\\n                ++Mfreq;\\n        }\\n    }\\n    \\n    void promote(int key) {\\n        Node *node = Nodes[key];\\n        int freq = node->freq++;\\n        Lists[freq]->remove(node);\\n        removeIfEmpty(freq);\\n        addToList(freq+1, node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537093,
                "title": "java-hashmap-priorityqueue",
                "content": "Thinking Process:\\n1. There are two factors to determine this cache\\'s delete and add: one is the visited frequence; the other is the adding time(when does it add). In order to better describe these important information, we customized a class, named Node to contain them. \\n```java\\n\\tclass Node {\\n    int key;\\n    int val;\\n    int count;\\n    int timer;\\n    public Node(int k, int v, int c, int t) {\\n        this.key = k;\\n        this.val = v;\\n        this.count = c;\\n        this.timer = t;\\n    }\\n}\\n```\\n2. When we determine which Node to be deleted, we need to know their orders. So we use PriorityQueue to help us to sort according to its count(visit frequence) and update time. \\n\\t``new PriorityQueue<Node>(\\n        (a, b)->(a.count==b.count?(a.timer-b.timer):(a.count-b.count)));``\\n3. Meanwhile, in order to fasten search/get speed, we use HashMap to store all key-value information. \\n4. There are two speical cases which we need to notice: \\n\\t(1) when add the existed key-value, for example: (1,1) already in cache, and then we add (1,2). In this condition, this node\\'s count should be old count plus 1, not just 1. And its timer should be updated. \\n\\n\\t``add(new Node(key, value, node.count+1, timer++));``\\n\\n\\t(2) when two nodes have the same count/frequence, we need to use their timer to sort them.\\n\\t\\nTest cases:\\n1. cap: 0, // empty cache\\n2. cap:1, put(1,1), get(1), put(2,2), get(1) // normal case\\n3. cap: 1, put(1,1), put(1,2), get(1) // check count update case with adding\\n4. cap: 2, put(1,1), put(2,2), put(3, 3), get(1) // check timer update case\\n5. cap: 2, put(1,1), put(2,2), get(2), put(3,3), get(1) // check count update case with visit\\n\\nTime Complexity: O(logn) for get, O(logn) for put. because when we get and put, we need to update PriorityQueue informaiton. For PriorityQueue, its insert and remove operations need O(logn). n is the size of PriorityQueue; For HashMap, its insert and remove need O(1). \\n\\nSpace Complexity: O(n) , n is the cache\\'s capacity. \\n\\n```java\\nclass LFUCache {\\n    private Map<Integer, Node> map;\\n    private PriorityQueue<Node> pq;\\n    private int cap;\\n    private static int timer;\\n    public LFUCache(int capacity) {\\n        map = new HashMap();\\n        pq = new PriorityQueue<Node>(\\n            (a, b)->(a.count==b.count?(a.timer-b.timer):(a.count-b.count)));\\n        cap = capacity;\\n        timer = 0;\\n    }\\n    private void remove(Node node) {\\n        map.remove(node.key);\\n        pq.remove(node);\\n    }\\n    private void add(Node node) {\\n        map.put(node.key, node);\\n        pq.offer(node);\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            remove(node);\\n            add(new Node(node.key, node.val, node.count+1, timer++));\\n            return node.val;\\n        } else return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            remove(node);\\n            add(new Node(key, value, node.count+1, timer++));\\n        } else {\\n            if (cap!=0) {\\n                if (map.size()==cap) remove(pq.peek());\\n                add(new Node(key, value, 1, timer++));\\n            }\\n        }\\n    }\\n}\\n\\nclass Node {\\n    int key;\\n    int val;\\n    int count;\\n    int timer;\\n    public Node(int k, int v, int c, int t) {\\n        this.key = k;\\n        this.val = v;\\n        this.count = c;\\n        this.timer = t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n\\tclass Node {\\n    int key;\\n    int val;\\n    int count;\\n    int timer;\\n    public Node(int k, int v, int c, int t) {\\n        this.key = k;\\n        this.val = v;\\n        this.count = c;\\n        this.timer = t;\\n    }\\n}\\n```\n```java\\nclass LFUCache {\\n    private Map<Integer, Node> map;\\n    private PriorityQueue<Node> pq;\\n    private int cap;\\n    private static int timer;\\n    public LFUCache(int capacity) {\\n        map = new HashMap();\\n        pq = new PriorityQueue<Node>(\\n            (a, b)->(a.count==b.count?(a.timer-b.timer):(a.count-b.count)));\\n        cap = capacity;\\n        timer = 0;\\n    }\\n    private void remove(Node node) {\\n        map.remove(node.key);\\n        pq.remove(node);\\n    }\\n    private void add(Node node) {\\n        map.put(node.key, node);\\n        pq.offer(node);\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            remove(node);\\n            add(new Node(node.key, node.val, node.count+1, timer++));\\n            return node.val;\\n        } else return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            remove(node);\\n            add(new Node(key, value, node.count+1, timer++));\\n        } else {\\n            if (cap!=0) {\\n                if (map.size()==cap) remove(pq.peek());\\n                add(new Node(key, value, 1, timer++));\\n            }\\n        }\\n    }\\n}\\n\\nclass Node {\\n    int key;\\n    int val;\\n    int count;\\n    int timer;\\n    public Node(int k, int v, int c, int t) {\\n        this.key = k;\\n        this.val = v;\\n        this.count = c;\\n        this.timer = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530205,
                "title": "java-50-line-hashmap-treemap-linkedhashset",
                "content": "Let\\'s take fully advantage of Java native library.\\n```\\nclass LFUCache {\\n    int CAP;\\n    HashMap<Integer, Integer> vals  = new HashMap();   // key -> value \\n    HashMap<Integer, Integer> freqs = new HashMap();   // key -> freq\\n    // freq -> a list of keys with the same freq, sorted in access order. TreeMap entries are sorted by freq, first entry is the leastFreq entry\\n    TreeMap<Integer, LinkedHashSet<Integer>> freqToKeys = new TreeMap(); \\n    public LFUCache(int capacity) {\\n        CAP = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (vals.containsKey(key)) {\\n            // update freqs\\n            int curFreq = freqs.get(key);\\n            freqs.put(key, curFreq + 1);\\n            // update freqToKeys\\n            freqToKeys.get(curFreq).remove(key);\\n            if (freqToKeys.get(curFreq).size() == 0) freqToKeys.remove(curFreq);\\n            freqToKeys.computeIfAbsent(curFreq + 1, k -> new LinkedHashSet<Integer>()).add(key);\\n            return vals.get(key);\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (CAP <= 0) return;\\n        // remove first if CAP exceeds (remove first before adding the new entry)\\n        if (vals.size() == CAP && !vals.containsKey(key)) {\\n            Map.Entry<Integer, LinkedHashSet<Integer>> leastFreqEntry = freqToKeys.pollFirstEntry();\\n            Integer evictKey = leastFreqEntry.getValue().iterator().next(); // first key\\n            vals.remove(evictKey);\\n            freqs.remove(evictKey);\\n            leastFreqEntry.getValue().remove(evictKey);\\n            if (!leastFreqEntry.getValue().isEmpty()) freqToKeys.put(leastFreqEntry.getKey(), leastFreqEntry.getValue());\\n        }\\n        // add the entry\\n        vals.put(key, value);\\n        if (freqs.containsKey(key)) get(key);\\n        else {\\n            freqs.put(key, 1);\\n            freqToKeys.computeIfAbsent(1, k -> new LinkedHashSet<Integer>()).add(key);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    int CAP;\\n    HashMap<Integer, Integer> vals  = new HashMap();   // key -> value \\n    HashMap<Integer, Integer> freqs = new HashMap();   // key -> freq\\n    // freq -> a list of keys with the same freq, sorted in access order. TreeMap entries are sorted by freq, first entry is the leastFreq entry\\n    TreeMap<Integer, LinkedHashSet<Integer>> freqToKeys = new TreeMap(); \\n    public LFUCache(int capacity) {\\n        CAP = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (vals.containsKey(key)) {\\n            // update freqs\\n            int curFreq = freqs.get(key);\\n            freqs.put(key, curFreq + 1);\\n            // update freqToKeys\\n            freqToKeys.get(curFreq).remove(key);\\n            if (freqToKeys.get(curFreq).size() == 0) freqToKeys.remove(curFreq);\\n            freqToKeys.computeIfAbsent(curFreq + 1, k -> new LinkedHashSet<Integer>()).add(key);\\n            return vals.get(key);\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (CAP <= 0) return;\\n        // remove first if CAP exceeds (remove first before adding the new entry)\\n        if (vals.size() == CAP && !vals.containsKey(key)) {\\n            Map.Entry<Integer, LinkedHashSet<Integer>> leastFreqEntry = freqToKeys.pollFirstEntry();\\n            Integer evictKey = leastFreqEntry.getValue().iterator().next(); // first key\\n            vals.remove(evictKey);\\n            freqs.remove(evictKey);\\n            leastFreqEntry.getValue().remove(evictKey);\\n            if (!leastFreqEntry.getValue().isEmpty()) freqToKeys.put(leastFreqEntry.getKey(), leastFreqEntry.getValue());\\n        }\\n        // add the entry\\n        vals.put(key, value);\\n        if (freqs.containsKey(key)) get(key);\\n        else {\\n            freqs.put(key, 1);\\n            freqToKeys.computeIfAbsent(1, k -> new LinkedHashSet<Integer>()).add(key);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478926,
                "title": "java-using-double-linked-list-hashmap-and-heap",
                "content": "The main idea is similar to LRU but in addition to that, we need to keep a heap to maintain hit counts for all nodes. When the size of the heap reaches capacity, we just need to erase the peek element of the heap. \\n\\nBut keep in mind that:\\n* **It is possible that multiple nodes hold same minimum count.** In this case, we should not only extract the peek of the heap, but all nodes with the same minimum count. Then we start from the tail of the double linked list to find out which one appears first (also the least recently used one). After deleting that node, we need to add other nodes back to the heap.\\n* **Heaps will not monitor on counts to update itself automatically.** So when we increment the count, we need to update the heap manully by removing and adding the node with new count again to the heap.\\n\\t\\n\\t\\n\\t\\n```\\nclass LFUCache {\\n    \\n    class LinkedNode{\\n        int key;\\n        int value;\\n        LinkedNode prev;\\n        LinkedNode next;\\n        int count = 0;\\n    }\\n    \\n    private Map<Integer, LinkedNode> nodeMap;\\n    private int capacity;\\n    private LinkedNode head, tail;\\n    private PriorityQueue<LinkedNode> heap;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        head = new LinkedNode();\\n        tail = new LinkedNode();\\n        head.next = tail;\\n        tail.prev = head;\\n        nodeMap = new HashMap<>();\\n        heap = new PriorityQueue<>((a, b) -> (a.count - b.count));\\n    }\\n    \\n    public int get(int key) {\\n        if (!nodeMap.containsKey(key)) return -1;\\n        LinkedNode curNode = nodeMap.get(key);\\n        curNode.count++;\\n        updateHeap(curNode);\\n        moveToHead(curNode);\\n        return curNode.value;\\n    }\\n    \\n    private void removeLast() {\\n        List<LinkedNode> minList = new ArrayList<>();\\n        if (nodeMap.isEmpty() || heap.isEmpty()) return;\\n        int min_count = heap.peek().count;\\n\\n        while (!heap.isEmpty() && heap.peek().count == min_count) minList.add(heap.poll());\\n        if (minList.size() == 1) {\\n            System.out.println(minList.get(0).key);\\n            LinkedNode minNode = minList.get(0);\\n            deleteNode(minNode);\\n            nodeMap.remove(minNode.key);\\n        } else {\\n            LinkedNode cur = tail.prev;\\n            // find the one nearest to tail\\n            while(cur != head) {\\n                if (minList.contains(cur)) {\\n                    deleteNode(cur);\\n                    nodeMap.remove(cur.key);\\n                    // remember to add other nodes back into heap\\n                    for (LinkedNode n: minList) {\\n                        if (n != cur) heap.offer(n);\\n                    }\\n                    break;\\n                } else {\\n                    cur = cur.prev;\\n                }\\n            }\\n            \\n        }\\n    }\\n    \\n    private void moveToHead(LinkedNode node) {\\n        deleteNode(node);\\n        addToHead(node);\\n    }\\n    \\n    private void addToHead(LinkedNode node) {\\n        if (node == null) return;\\n        LinkedNode oldHead = head.next;\\n        head.next = node;\\n        node.prev = head;\\n        node.next = oldHead;\\n        oldHead.prev = node;\\n    }\\n    \\n    private void deleteNode(LinkedNode node) {\\n        if (node == null) return;\\n        LinkedNode next = node.next;\\n        node.prev.next = next;\\n        next.prev = node.prev;\\n    }\\n    \\n    // must update heap explicitly because it will not monitor on \\'count\\' changes to update itself automatically.\\n    private void updateHeap(LinkedNode node) {\\n        if (node == null) return;\\n        heap.remove(node);\\n        heap.offer(node);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (!nodeMap.containsKey(key) && heap.size() == capacity) removeLast();\\n        if (nodeMap.containsKey(key)) {\\n            LinkedNode curNode = nodeMap.get(key);\\n            curNode.value = value;\\n            curNode.count++;\\n            updateHeap(curNode);\\n            moveToHead(curNode);\\n        } else {\\n            LinkedNode newNode = new LinkedNode();\\n            newNode.key = key;\\n            newNode.value = value;\\n            nodeMap.put(key, newNode);\\n            addToHead(newNode);\\n            heap.offer(newNode);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    \\n    class LinkedNode{\\n        int key;\\n        int value;\\n        LinkedNode prev;\\n        LinkedNode next;\\n        int count = 0;\\n    }\\n    \\n    private Map<Integer, LinkedNode> nodeMap;\\n    private int capacity;\\n    private LinkedNode head, tail;\\n    private PriorityQueue<LinkedNode> heap;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        head = new LinkedNode();\\n        tail = new LinkedNode();\\n        head.next = tail;\\n        tail.prev = head;\\n        nodeMap = new HashMap<>();\\n        heap = new PriorityQueue<>((a, b) -> (a.count - b.count));\\n    }\\n    \\n    public int get(int key) {\\n        if (!nodeMap.containsKey(key)) return -1;\\n        LinkedNode curNode = nodeMap.get(key);\\n        curNode.count++;\\n        updateHeap(curNode);\\n        moveToHead(curNode);\\n        return curNode.value;\\n    }\\n    \\n    private void removeLast() {\\n        List<LinkedNode> minList = new ArrayList<>();\\n        if (nodeMap.isEmpty() || heap.isEmpty()) return;\\n        int min_count = heap.peek().count;\\n\\n        while (!heap.isEmpty() && heap.peek().count == min_count) minList.add(heap.poll());\\n        if (minList.size() == 1) {\\n            System.out.println(minList.get(0).key);\\n            LinkedNode minNode = minList.get(0);\\n            deleteNode(minNode);\\n            nodeMap.remove(minNode.key);\\n        } else {\\n            LinkedNode cur = tail.prev;\\n            // find the one nearest to tail\\n            while(cur != head) {\\n                if (minList.contains(cur)) {\\n                    deleteNode(cur);\\n                    nodeMap.remove(cur.key);\\n                    // remember to add other nodes back into heap\\n                    for (LinkedNode n: minList) {\\n                        if (n != cur) heap.offer(n);\\n                    }\\n                    break;\\n                } else {\\n                    cur = cur.prev;\\n                }\\n            }\\n            \\n        }\\n    }\\n    \\n    private void moveToHead(LinkedNode node) {\\n        deleteNode(node);\\n        addToHead(node);\\n    }\\n    \\n    private void addToHead(LinkedNode node) {\\n        if (node == null) return;\\n        LinkedNode oldHead = head.next;\\n        head.next = node;\\n        node.prev = head;\\n        node.next = oldHead;\\n        oldHead.prev = node;\\n    }\\n    \\n    private void deleteNode(LinkedNode node) {\\n        if (node == null) return;\\n        LinkedNode next = node.next;\\n        node.prev.next = next;\\n        next.prev = node.prev;\\n    }\\n    \\n    // must update heap explicitly because it will not monitor on \\'count\\' changes to update itself automatically.\\n    private void updateHeap(LinkedNode node) {\\n        if (node == null) return;\\n        heap.remove(node);\\n        heap.offer(node);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (!nodeMap.containsKey(key) && heap.size() == capacity) removeLast();\\n        if (nodeMap.containsKey(key)) {\\n            LinkedNode curNode = nodeMap.get(key);\\n            curNode.value = value;\\n            curNode.count++;\\n            updateHeap(curNode);\\n            moveToHead(curNode);\\n        } else {\\n            LinkedNode newNode = new LinkedNode();\\n            newNode.key = key;\\n            newNode.value = value;\\n            nodeMap.put(key, newNode);\\n            addToHead(newNode);\\n            heap.offer(newNode);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 212604,
                "title": "easy-java",
                "content": "\\u9898\\u610F\\uFF1A\\u5B9E\\u73B0\\u4E00\\u4E2ALFU\\u6700\\u9891\\u7E41\\u4F7F\\u7528\\u7684cache\\uFF0C\\u8D85\\u8FC7\\u5BB9\\u91CF\\uFF0C\\u5220\\u9664\\u6700\\u4E0D\\u9891\\u7E41\\u4F7F\\u7528\\u7684key\\n\\u601D\\u8DEF\\uFF1Akey->count, count->key\\uFF0C\\u56E0\\u4E3A\\u8981\\u5220\\u9664\\u6700\\u5C11\\u9891\\u7E41\\u4F7F\\u7528\\u7684\\uFF0C\\u5219\\u9700\\u8981\\u5C06\\u6BCF\\u4E2Akey\\u4F7F\\u7528\\u7684count\\u5B58\\u8D77\\u6765\\uFF0C\\u5E76\\u4E14\\u77E5\\u9053\\u6700\\u5C11\\u7684count\\u5BF9\\u5E94\\u7684key\\n\\u4F7F\\u7528\\u4E24\\u4E2Ahashmap\\uFF0C\\u4E00\\u4E2A\\u8BB0\\u5F55vals \\u4E00\\u4E2A\\u8BB0\\u5F55count\\uFF0C\\u548C\\u4E00\\u4E2ALinkedHashSet\\uFF0C\\u8BB0\\u5F55\\u76F8\\u540Ccount\\u7684keys\\uFF0C\\u4EE5\\u53CA\\u7EF4\\u62A4\\u4E00\\u4E2A\\u5168\\u5C40\\u6700\\u5C0F\\u7684countMin\\uFF0C\\n1. get \\u64CD\\u4F5C\\uFF1A\\n*    a.\\u5728count\\u4E2D\\u5C06\\u8BE5key\\u7684\\u6B21\\u6570\\u52A01\\uFF1B  \\n*    b.\\u5E94\\u8BE5\\u5728list\\u4E2D\\u5C06\\u539F\\u6765count\\u7684key\\u5220\\u9664\\uFF0C\\u5728count+1\\u4E2D\\u6DFB\\u52A0\\u8FD9\\u4E2A\\u65B0\\u7684key\\n*    c.\\u66F4\\u65B0minCount\\n2. set \\u64CD\\u4F5C\\uFF1A\\n* a.\\u5B58\\u5728\\u5219\\u76F4\\u63A5\\u91CD\\u7F6E\\uFF0C\\u5E76\\u8C03\\u7528\\u4E00\\u6B21get\\u64CD\\u4F5C  \\n* b.\\u8D85\\u8FC7\\u7A7A\\u95F4\\u4E86\\uFF0C\\u5219\\u5C06count\\u4E3Amin\\u5904\\u7684key\\u5220\\u9664  \\n* c.put\\u64CD\\u4F5C\\uFF0C\\u5C06key\\u5B58\\u5165vals  \\n* d.\\u91CD\\u7F6EminCount=1\\n\\n```\\nclass LFUCache {\\n    Map<Integer, Integer> vals;\\n    Map<Integer, Integer> counts;\\n    Map<Integer, LinkedHashSet<Integer>> list;\\n    \\n    int minCount = 1, cap;\\n\\n    public LFUCache(int capacity) {\\n        vals = new HashMap<>();\\n        counts = new HashMap<>();\\n        list = new HashMap<>();\\n        cap = capacity;\\n        list.put(1, new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if (!vals.containsKey(key)) return -1;\\n        int count = counts.get(key);\\n        counts.put(key, count + 1);\\n        list.get(count).remove(key);\\n        if (!list.containsKey(count + 1)) list.put(count + 1, new LinkedHashSet<>());\\n        list.get(count + 1).add(key);\\n        if (count == minCount && list.get(count).size() == 0) minCount++;  //\\u66F4\\u65B0minCount\\n        return vals.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cap <= 0) return;\\n        if (vals.containsKey(key)) {\\n            vals.put(key, value);\\n            get(key);\\n            return;\\n        }\\n        if (vals.size() >= cap) {\\n            int deleteKey = list.get(minCount).iterator().next();\\n            vals.remove(deleteKey);\\n            list.get(minCount).remove(deleteKey);\\n        }\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        minCount = 1;  //\\u91CD\\u7F6EminCount\\n        list.get(1).add(key);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    Map<Integer, Integer> vals;\\n    Map<Integer, Integer> counts;\\n    Map<Integer, LinkedHashSet<Integer>> list;\\n    \\n    int minCount = 1, cap;\\n\\n    public LFUCache(int capacity) {\\n        vals = new HashMap<>();\\n        counts = new HashMap<>();\\n        list = new HashMap<>();\\n        cap = capacity;\\n        list.put(1, new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if (!vals.containsKey(key)) return -1;\\n        int count = counts.get(key);\\n        counts.put(key, count + 1);\\n        list.get(count).remove(key);\\n        if (!list.containsKey(count + 1)) list.put(count + 1, new LinkedHashSet<>());\\n        list.get(count + 1).add(key);\\n        if (count == minCount && list.get(count).size() == 0) minCount++;  //\\u66F4\\u65B0minCount\\n        return vals.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cap <= 0) return;\\n        if (vals.containsKey(key)) {\\n            vals.put(key, value);\\n            get(key);\\n            return;\\n        }\\n        if (vals.size() >= cap) {\\n            int deleteKey = list.get(minCount).iterator().next();\\n            vals.remove(deleteKey);\\n            list.get(minCount).remove(deleteKey);\\n        }\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        minCount = 1;  //\\u91CD\\u7F6EminCount\\n        list.get(1).add(key);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113506,
                "title": "interview-ready-explanation-simplified-and-easy-to-understand-with-detailed-thought-process",
                "content": "\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n\\n    // Data Structure Requirements\\n\\n    // 1. Data structure to store key and value and also how many times that key is used in get\\n    // function. \\n\\n    // 2. For same frequency, we need to remove the key that occured first.\\n    // So, we need the order of key inputs\\n    \\n    // 3. We need to remove the least frequently used - LFU. So, we need the minimum\\n    // frequency of elements that exist currently in our data structure (cache)\\n\\n    // For Step 1, => simple unordered_map, as we need key, value and frequency too.\\n    // So, unordered_map with pair => unordered_map<int, pair<int, int>> m; {key : {value, freq}}\\n    // Time taken => O(1), queurying an unordered_map to see if a key exists or not in get function\\n\\n    // To do step 2, we need a data structure that maintains order of input\\n    // Options - array, vector, stack, queue, linked list\\n    // Not options - map, set, unordered_map, unordered_set, tree, graph\\n\\n    // To do step 3 i.e., need to find min_freq =>\\n    // We can do it O(n) by traversing the built map in Step 1.\\n    // But to do it in O(1) time, we need to store all keys in the form of frequency buckets such as\\n    // All keys having frequency 1 are in one bucket / container, \\n    // all keys having frequency 2 are in an other bucket / contrainer, similarily for 3 and so on.\\n    // If a bucket doesn\\'t have any value, we remove that bucket.\\n\\n    // To make a bucket / container pair to each frequency we need a map, \\n    // and we will store min_freq in a seperate varaible for instantly getting to the mapped container\\n    // with the min_freq in the built map.\\n    // Since the order of frequencies don\\'t matter, as we need only min_freq and we have it in another\\n    // variable, so we will use an unordered_map => {freq : {container}}\\n\\n    // Now, if we have multiple keys with same frequency, they will all be in one container\\n    // So, we need to differentiate them using order in which they arrived. We need to maintain order\\n    // Now, possible options from step 2 are =>\\n    // array, vector, stack, queue, linked list\\n    // Array - No. Why? Because we don\\'t know how many elements will come, and if we take maximum\\n    // no of elements say 2*10^5 [from question constraint]\\n    // Removing one element that came first will take O(n) time. which will be too slow. \\n    // We need O(1).\\n    // Similar is the case with vector, maintains order but removal O(n)\\n    // Stack & Queue, they can remove in O(1) but only at top and fromt. \\n    // they can\\'t access elements in middle and remove them. \\n    // But Why we need to access the elements in middle somewhere?\\n    // Because, when we will be updating the frequency of a key, we need to remove it from\\n    // the previous bucket / container and add it to the new frequency bucket / container\\n    // Here, we don\\'t know where the key is present in the previous bucket / container.\\n    // which raises another requirement => \\n\\n    // 4. Need to store the location of keys in frequency buckets.\\n    // So, the only option we have is the linked list or list<int> in c++ \\n    // list<int> is internally implements as a double linked list.\\n    // Now, why list<int> ? Because it is the only option ? NO.\\n    // Because it fulfills all our requirements.\\n    // It will store keys in order in which they appear.\\n    // We can store iterators to the location of keys in an unordered_map. Why unordereder map?\\n    // Because order of keys don\\'t matter. Their location will let us know their order.\\n    // So, we will store keys with their iterators in a unordered_map => {key : iterator of list}\\n    // So that we can remove them from previous frequency buckets in O(1) time\\n    // And add keys to new frequency buckets in O(1) time.\\n    // Updating their iterators in O(1) time as well.\\n    // \\n    // So also need two variables to globally access, total capacity and current capacity.\\n    // So we don\\'t outrun the cache memory.\\n    \\n    // So after looking at all requirements and analysis.\\n    // We need 3 maps and 3 variables.\\n\\n    // Map 1 => unordered. Structure => {key : {value, freq}}\\n    // fulfills requirement 1, randon key check in get function\\n\\n    // Map 2 => unordered. Structure => {key : list<int>}\\n    // fulfills requirement 2 & 3, order of keys stored with their frequency buckets \\n\\n    // Map 3 => unordered. Structure => {key : list<int> :: iterator}\\n    // fulfills requirement 4, randomly accessing positions of keys in frequency buckets\\n\\n    // Variable 1 => int. curr_size => stores current size of cache\\n    // Variable 2 => int. total_cap => stores total capacity of cache and accessible to all member functions\\n    // Variable 3 => int. min_freq => stores the current min_freq in the LFU.\\n\\n\\n    unordered_map<int, pair<int, int>> avl_keys;\\n    unordered_map<int, list<int>> freq_bucket;\\n    unordered_map<int, list<int>::iterator> key_pos;\\n\\n    int curr_size = 0, total_cap = 0, min_freq = 0;\\n\\n    LFUCache(int capacity) {\\n        curr_size = 0;\\n        total_cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        // Checking if the given key exists in our cacke of avl_keys\\n        if (avl_keys.find(key) == avl_keys.end()) \\n            return -1;\\n\\n        // Getting current frequecy\\n        int curr_freq = avl_keys[key].second;\\n\\n        // Removing key from previous frequency bucket using the key\\'s iterator from key_pos\\n        freq_bucket[curr_freq].erase(key_pos[key]);\\n\\n        // Increasing frequency\\n        avl_keys[key].second += 1;\\n\\n        int new_freq = avl_keys[key].second;\\n\\n        // Adding key to new frequency bucket\\n        freq_bucket[new_freq].push_back(key);\\n\\n        // Updating the key\\'s iterator to the end of new frequency bucket\\n        key_pos[key] = --freq_bucket[new_freq].end();\\n        // Any thoughts on why doing -- before the end iterator. \\n        // If you don\\'t know, you will get the answer at the end of the post.\\n\\n        // Suppose if the current key was having the minimum frequency, \\n        // We have removed it from the minimum frequency bucket\\n        // So, we need to update the minimum frequency\\n\\n        // Checking if the currrent list of min_freq is empty or not, if yes increasing min_freq by 1\\n        if (freq_bucket[min_freq].empty())\\n            min_freq += 1;\\n\\n        // returning the value paired to the current key\\n        return avl_keys[key].first;\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        // If capacity is 0, simply return\\n        if (total_cap == 0) return;\\n\\n        // If the key is present in avl_keys, update its value through get function\\n        // Why? Why not simply access current avl_keys map and update the value.\\n        // Because if we simply access current avl_keys map and update the value \\n        // it will not reflect that this key has been used, and its value is updated.\\n        // So, call get() function, if the key is present, service the current key and then\\n        // update its value to the new value passed to the function\\n        int prev_value = get(key);\\n\\n        // If key is present -1 will not be returned according to the definition of get function\\n        if (prev_value != -1) \\n        {\\n            // update to the new value\\n            avl_keys[key].first = value;\\n\\n            // return, as there is nothing else to do, and size of the cache is not increased \\n            return;\\n        }\\n\\n        // If the cache size is filled up to the top, remove the least frequent - least recent key\\n        if (curr_size >= total_cap)\\n        {\\n            // Get the first key in min_freq bucket. Why first? Because if came the earliest - least recent\\n            int lr_key = freq_bucket[min_freq].front();   // lr_key = least recent key\\n\\n            // Remove lr_key from avl_keys\\n            avl_keys.erase(lr_key);\\n\\n            // Remove the lr_key from key_pos\\n            key_pos.erase(lr_key);\\n\\n            // Remove lr_key from frequeny bucket as well\\n            freq_bucket[min_freq].pop_front();\\n\\n            // Decrease curr_size\\n            curr_size -= 1;\\n\\n        }\\n\\n        // Adding new key and its value\\n        avl_keys[key] = {value, 1};\\n\\n        // Updating min_freq\\n        min_freq = 1;\\n\\n        // Adding it in frequency bucket \\n        freq_bucket[min_freq].push_back(key);\\n\\n        // Adding new key\\'s iterator to the end of min_freq i.e. 1, as the new key arrived just now\\n        key_pos[key] = --freq_bucket[min_freq].end();\\n        // Again saw -- before the end iterator. You are about to have the answer.\\n\\n        // Increasing curr_size by 1 as new key added\\n        curr_size += 1;\\n\\n    }\\n};\\n\\n// /**\\n//  * Your LFUCache object will be instantiated and called as such:\\n//  * LFUCache* obj = new LFUCache(capacity);\\n//  * int param_1 = obj->get(key);\\n//  * obj->put(key,value);\\n//  */\\n\\n\\n// Why am I doing -- before updating the end iterator for every key.\\n// This \\'--\\' is called decrementing the iterator, i.e., moving iterator back by 1.\\n// The freq_bucket[min_freq].end() or end(freq_bucket[min_freq]) returns an iterator to the \\n// end of the freq_bucket[min_freq] container or current container. \\n// In simple words, it points to the next memory location after the end element of the container\\n\\n// Now, as our key is last(end) element but certainly inside the container, not outside the container. \\n// Using end() iterator we move to the next location after the last element, which is outside container and then we move back by 1 place to get the iterator of the last element that is inside the container and pointing to the last element.\\n// That\\'s why I\\'m decrementing the end iterator before assigning it to the last key.\\n\\n// Mathematically, for every container we have two pointers begin and end \\n// which holds values like this in range. [begin, end)\\n// Notice, the closing brackets of end, it doesn\\'t include the end iterator.\\n\\n// You can draw a similar analogy to indexing in arrays.\\n// For int arr[N]. Indexing holds [0, N) i.e. from 0 to N-1. not N.\\n\\n// If you still didn\\'t understand you can refer the following post for list<int> iterators.\\n// https://cplusplus.com/reference/list/list/\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n\\n    // Data Structure Requirements\\n\\n    // 1. Data structure to store key and value and also how many times that key is used in get\\n    // function. \\n\\n    // 2. For same frequency, we need to remove the key that occured first.\\n    // So, we need the order of key inputs\\n    \\n    // 3. We need to remove the least frequently used - LFU. So, we need the minimum\\n    // frequency of elements that exist currently in our data structure (cache)\\n\\n    // For Step 1, => simple unordered_map, as we need key, value and frequency too.\\n    // So, unordered_map with pair => unordered_map<int, pair<int, int>> m; {key : {value, freq}}\\n    // Time taken => O(1), queurying an unordered_map to see if a key exists or not in get function\\n\\n    // To do step 2, we need a data structure that maintains order of input\\n    // Options - array, vector, stack, queue, linked list\\n    // Not options - map, set, unordered_map, unordered_set, tree, graph\\n\\n    // To do step 3 i.e., need to find min_freq =>\\n    // We can do it O(n) by traversing the built map in Step 1.\\n    // But to do it in O(1) time, we need to store all keys in the form of frequency buckets such as\\n    // All keys having frequency 1 are in one bucket / container, \\n    // all keys having frequency 2 are in an other bucket / contrainer, similarily for 3 and so on.\\n    // If a bucket doesn\\'t have any value, we remove that bucket.\\n\\n    // To make a bucket / container pair to each frequency we need a map, \\n    // and we will store min_freq in a seperate varaible for instantly getting to the mapped container\\n    // with the min_freq in the built map.\\n    // Since the order of frequencies don\\'t matter, as we need only min_freq and we have it in another\\n    // variable, so we will use an unordered_map => {freq : {container}}\\n\\n    // Now, if we have multiple keys with same frequency, they will all be in one container\\n    // So, we need to differentiate them using order in which they arrived. We need to maintain order\\n    // Now, possible options from step 2 are =>\\n    // array, vector, stack, queue, linked list\\n    // Array - No. Why? Because we don\\'t know how many elements will come, and if we take maximum\\n    // no of elements say 2*10^5 [from question constraint]\\n    // Removing one element that came first will take O(n) time. which will be too slow. \\n    // We need O(1).\\n    // Similar is the case with vector, maintains order but removal O(n)\\n    // Stack & Queue, they can remove in O(1) but only at top and fromt. \\n    // they can\\'t access elements in middle and remove them. \\n    // But Why we need to access the elements in middle somewhere?\\n    // Because, when we will be updating the frequency of a key, we need to remove it from\\n    // the previous bucket / container and add it to the new frequency bucket / container\\n    // Here, we don\\'t know where the key is present in the previous bucket / container.\\n    // which raises another requirement => \\n\\n    // 4. Need to store the location of keys in frequency buckets.\\n    // So, the only option we have is the linked list or list<int> in c++ \\n    // list<int> is internally implements as a double linked list.\\n    // Now, why list<int> ? Because it is the only option ? NO.\\n    // Because it fulfills all our requirements.\\n    // It will store keys in order in which they appear.\\n    // We can store iterators to the location of keys in an unordered_map. Why unordereder map?\\n    // Because order of keys don\\'t matter. Their location will let us know their order.\\n    // So, we will store keys with their iterators in a unordered_map => {key : iterator of list}\\n    // So that we can remove them from previous frequency buckets in O(1) time\\n    // And add keys to new frequency buckets in O(1) time.\\n    // Updating their iterators in O(1) time as well.\\n    // \\n    // So also need two variables to globally access, total capacity and current capacity.\\n    // So we don\\'t outrun the cache memory.\\n    \\n    // So after looking at all requirements and analysis.\\n    // We need 3 maps and 3 variables.\\n\\n    // Map 1 => unordered. Structure => {key : {value, freq}}\\n    // fulfills requirement 1, randon key check in get function\\n\\n    // Map 2 => unordered. Structure => {key : list<int>}\\n    // fulfills requirement 2 & 3, order of keys stored with their frequency buckets \\n\\n    // Map 3 => unordered. Structure => {key : list<int> :: iterator}\\n    // fulfills requirement 4, randomly accessing positions of keys in frequency buckets\\n\\n    // Variable 1 => int. curr_size => stores current size of cache\\n    // Variable 2 => int. total_cap => stores total capacity of cache and accessible to all member functions\\n    // Variable 3 => int. min_freq => stores the current min_freq in the LFU.\\n\\n\\n    unordered_map<int, pair<int, int>> avl_keys;\\n    unordered_map<int, list<int>> freq_bucket;\\n    unordered_map<int, list<int>::iterator> key_pos;\\n\\n    int curr_size = 0, total_cap = 0, min_freq = 0;\\n\\n    LFUCache(int capacity) {\\n        curr_size = 0;\\n        total_cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        // Checking if the given key exists in our cacke of avl_keys\\n        if (avl_keys.find(key) == avl_keys.end()) \\n            return -1;\\n\\n        // Getting current frequecy\\n        int curr_freq = avl_keys[key].second;\\n\\n        // Removing key from previous frequency bucket using the key\\'s iterator from key_pos\\n        freq_bucket[curr_freq].erase(key_pos[key]);\\n\\n        // Increasing frequency\\n        avl_keys[key].second += 1;\\n\\n        int new_freq = avl_keys[key].second;\\n\\n        // Adding key to new frequency bucket\\n        freq_bucket[new_freq].push_back(key);\\n\\n        // Updating the key\\'s iterator to the end of new frequency bucket\\n        key_pos[key] = --freq_bucket[new_freq].end();\\n        // Any thoughts on why doing -- before the end iterator. \\n        // If you don\\'t know, you will get the answer at the end of the post.\\n\\n        // Suppose if the current key was having the minimum frequency, \\n        // We have removed it from the minimum frequency bucket\\n        // So, we need to update the minimum frequency\\n\\n        // Checking if the currrent list of min_freq is empty or not, if yes increasing min_freq by 1\\n        if (freq_bucket[min_freq].empty())\\n            min_freq += 1;\\n\\n        // returning the value paired to the current key\\n        return avl_keys[key].first;\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        // If capacity is 0, simply return\\n        if (total_cap == 0) return;\\n\\n        // If the key is present in avl_keys, update its value through get function\\n        // Why? Why not simply access current avl_keys map and update the value.\\n        // Because if we simply access current avl_keys map and update the value \\n        // it will not reflect that this key has been used, and its value is updated.\\n        // So, call get() function, if the key is present, service the current key and then\\n        // update its value to the new value passed to the function\\n        int prev_value = get(key);\\n\\n        // If key is present -1 will not be returned according to the definition of get function\\n        if (prev_value != -1) \\n        {\\n            // update to the new value\\n            avl_keys[key].first = value;\\n\\n            // return, as there is nothing else to do, and size of the cache is not increased \\n            return;\\n        }\\n\\n        // If the cache size is filled up to the top, remove the least frequent - least recent key\\n        if (curr_size >= total_cap)\\n        {\\n            // Get the first key in min_freq bucket. Why first? Because if came the earliest - least recent\\n            int lr_key = freq_bucket[min_freq].front();   // lr_key = least recent key\\n\\n            // Remove lr_key from avl_keys\\n            avl_keys.erase(lr_key);\\n\\n            // Remove the lr_key from key_pos\\n            key_pos.erase(lr_key);\\n\\n            // Remove lr_key from frequeny bucket as well\\n            freq_bucket[min_freq].pop_front();\\n\\n            // Decrease curr_size\\n            curr_size -= 1;\\n\\n        }\\n\\n        // Adding new key and its value\\n        avl_keys[key] = {value, 1};\\n\\n        // Updating min_freq\\n        min_freq = 1;\\n\\n        // Adding it in frequency bucket \\n        freq_bucket[min_freq].push_back(key);\\n\\n        // Adding new key\\'s iterator to the end of min_freq i.e. 1, as the new key arrived just now\\n        key_pos[key] = --freq_bucket[min_freq].end();\\n        // Again saw -- before the end iterator. You are about to have the answer.\\n\\n        // Increasing curr_size by 1 as new key added\\n        curr_size += 1;\\n\\n    }\\n};\\n\\n// /**\\n//  * Your LFUCache object will be instantiated and called as such:\\n//  * LFUCache* obj = new LFUCache(capacity);\\n//  * int param_1 = obj->get(key);\\n//  * obj->put(key,value);\\n//  */\\n\\n\\n// Why am I doing -- before updating the end iterator for every key.\\n// This \\'--\\' is called decrementing the iterator, i.e., moving iterator back by 1.\\n// The freq_bucket[min_freq].end() or end(freq_bucket[min_freq]) returns an iterator to the \\n// end of the freq_bucket[min_freq] container or current container. \\n// In simple words, it points to the next memory location after the end element of the container\\n\\n// Now, as our key is last(end) element but certainly inside the container, not outside the container. \\n// Using end() iterator we move to the next location after the last element, which is outside container and then we move back by 1 place to get the iterator of the last element that is inside the container and pointing to the last element.\\n// That\\'s why I\\'m decrementing the end iterator before assigning it to the last key.\\n\\n// Mathematically, for every container we have two pointers begin and end \\n// which holds values like this in range. [begin, end)\\n// Notice, the closing brackets of end, it doesn\\'t include the end iterator.\\n\\n// You can draw a similar analogy to indexing in arrays.\\n// For int arr[N]. Indexing holds [0, N) i.e. from 0 to N-1. not N.\\n\\n// If you still didn\\'t understand you can refer the following post for list<int> iterators.\\n// https://cplusplus.com/reference/list/list/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111800,
                "title": "c-lfu-least-frequently-used-algorithm-with-explanation",
                "content": "# Intuition\\nThe LFU cache is a data structure that is designed to efficiently store and retrieve data, while also maintaining a limited capacity and removing the least frequently used items when that capacity is exceeded. The key to achieving this is to keep track of the usage frequency of each item in the cache, and to prioritize eviction of the items with the lowest usage frequency. To implement this, we can use a combination of a hash map and a doubly linked list. The hash map stores the keys and values of the items in the cache, along with their usage frequency, while the doubly linked list keeps track of the order of the items based on their usage frequency. This allows us to quickly and efficiently access and update the items in the cache as well as remove the least frequently used items when necessary.\\n# Approach\\n1. Create a HashMap to store the key-value pairs in the cache.\\n2. Create a HashMap to store the frequency of each key in the cache.\\n3. Create a doubly linked list to store the keys in order of least frequently used to most frequently used.\\n4. Create a HashMap to store the nodes of the doubly linked list corresponding to each key in the cache.\\n5. In the put() function, check if the key already exists in the cache. If it does, update the value and increment the frequency. If the key does not exist, check if the cache has reached its capacity. If it has, remove the least frequently used key from the cache and the doubly linked list. Then insert the new key-value pair into the cache and add it to the doubly linked list with a frequency of 1.\\n6. In the get() function, check if the key exists in the cache. If it does, increment the frequency and move the key to the appropriate position in the doubly linked list. If the key does not exist, return -1.\\n7. Implement a function to remove the least frequently used key from the cache and the doubly linked list.\\n8. Implement a function to move a key to the appropriate position in the doubly linked list based on its frequency.\\n9. Implement a function to update the frequency of a key in the cache.\\n10. Test the LFUCache class with various inputs to ensure it is working correctly.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ :\\nThe time complexity for the get() method is O(1) as it only requires constant time operations such as looking up values in a hash map or list. The put() method has a time complexity of O(1) on average, as it also only requires constant time operations. However, in the worst case scenario where the cache is full and a new key-value pair needs to be added, it may require O(n) time as it needs to remove the least frequently used key-value pair, which could involve iterating through the entire cache.\\n\\n- Space complexity:\\n$$O(n)$$ :\\nThe space complexity is O(n) where n is the number of key-value pairs in the cache. This is because we are using three unordered maps to store the key-value pairs, their frequencies, and their positions in the frequency list. The size of these unordered maps will grow with the number of key-value pairs in the cache, and will not exceed the capacity of the cache.\\n\\n# Code\\n```\\nclass LFUCache {\\n    int capacity;\\n    unordered_map<int, pair<int, int>> m; // key -> {value, freq}\\n    unordered_map<int, list<int>> freq;   // freq -> list of keys\\n    unordered_map<int, list<int>::iterator> pos; // key -> position in freq list\\n\\npublic:\\n    LFUCache(int capacity) : capacity(capacity) {}\\n\\n    int get(int key) {\\n        if (m.count(key) == 0) return -1;\\n        freq[m[key].second].erase(pos[key]);\\n        m[key].second++;\\n        freq[m[key].second].push_back(key);\\n        pos[key] = --freq[m[key].second].end();\\n        if (freq[minFreq].size() == 0) minFreq++;\\n        return m[key].first;\\n    }\\n\\n    void put(int key, int value) {\\n        if (capacity <= 0) return;\\n        if (m.count(key) && get(key) != -1) {\\n            m[key].first = value;\\n            return;\\n        }\\n        if (m.size() >= capacity) {\\n            int k = freq[minFreq].front();\\n            freq[minFreq].pop_front();\\n            pos.erase(k);\\n            m.erase(k);\\n        }\\n        m[key] = {value, 1};\\n        freq[1].push_back(key);\\n        pos[key] = --freq[1].end();\\n        minFreq = 1;\\n    }\\n\\nprivate:\\n    int minFreq = INT_MAX;\\n};\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n\\n# Please Upvote\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    int capacity;\\n    unordered_map<int, pair<int, int>> m; // key -> {value, freq}\\n    unordered_map<int, list<int>> freq;   // freq -> list of keys\\n    unordered_map<int, list<int>::iterator> pos; // key -> position in freq list\\n\\npublic:\\n    LFUCache(int capacity) : capacity(capacity) {}\\n\\n    int get(int key) {\\n        if (m.count(key) == 0) return -1;\\n        freq[m[key].second].erase(pos[key]);\\n        m[key].second++;\\n        freq[m[key].second].push_back(key);\\n        pos[key] = --freq[m[key].second].end();\\n        if (freq[minFreq].size() == 0) minFreq++;\\n        return m[key].first;\\n    }\\n\\n    void put(int key, int value) {\\n        if (capacity <= 0) return;\\n        if (m.count(key) && get(key) != -1) {\\n            m[key].first = value;\\n            return;\\n        }\\n        if (m.size() >= capacity) {\\n            int k = freq[minFreq].front();\\n            freq[minFreq].pop_front();\\n            pos.erase(k);\\n            m.erase(k);\\n        }\\n        m[key] = {value, 1};\\n        freq[1].push_back(key);\\n        pos[key] = --freq[1].end();\\n        minFreq = 1;\\n    }\\n\\nprivate:\\n    int minFreq = INT_MAX;\\n};\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919055,
                "title": "c-short-solution-using-priority-queue",
                "content": "So Lets make a solution which is feasible in a high pressure interview environment\\n\\nFor starters lets have a map  **m** which maps each key to its value(most recent value)\\na map **freq** which maps key to its current frequency.\\nand  a **priority _queue** (min heap) which consists of { frequency, {time, key}}\\n\\nso the top of a priority queue always gives us the key with the lowest frequency.\\n\\nBut the actual frequency of the key may have changed since we pushed that element into the priority queue.(it might have been used again since that push)\\n\\nSo if our cache is full, we keep on popping the heap till we actually remove a element from our maps.\\nThis is like lazy deletion\\n\\n\\n```\\ntypedef pair<int,int> ii;\\n\\nclass LFUCache {\\npublic:\\n    priority_queue<pair<int,ii>, vector<pair<int,ii>>, greater<pair<int,ii>>> pq;\\n    unordered_map<int,int> m;\\n    unordered_map<int,int> freq;\\n    int cap;\\n    int t=0;\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)==m.end()) return -1;\\n        put(key,m[key]);\\n        return m[key];\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0){\\n            return;\\n        }\\n        if(m.find(key)==m.end()&&m.size()==cap){\\n\\t\\t\\t/// capacity full\\n            while(m.size()==cap){\\n\\t\\t\\t// try to actually remove an element from our maps\\n                auto x = pq.top();\\n                if(freq[x.second.second]==x.first){\\n\\t\\t\\t\\t// this entry actually is a valid entry( freq[key] = freq_while_this_element_was_inserted)\\n                    m.erase(x.second.second);\\n                    freq.erase(x.second.second);\\n                }\\n                pq.pop();\\n            }            \\n        }\\n\\t\\t// fill priority_queue and increase time\\n        m[key] = value;\\n        freq[key]++;\\n        pq.push({freq[key],{t++,key}});\\n        \\n    }\\n};\\n\\n/**\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int,int> ii;\\n\\nclass LFUCache {\\npublic:\\n    priority_queue<pair<int,ii>, vector<pair<int,ii>>, greater<pair<int,ii>>> pq;\\n    unordered_map<int,int> m;\\n    unordered_map<int,int> freq;\\n    int cap;\\n    int t=0;\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)==m.end()) return -1;\\n        put(key,m[key]);\\n        return m[key];\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0){\\n            return;\\n        }\\n        if(m.find(key)==m.end()&&m.size()==cap){\\n\\t\\t\\t/// capacity full\\n            while(m.size()==cap){\\n\\t\\t\\t// try to actually remove an element from our maps\\n                auto x = pq.top();\\n                if(freq[x.second.second]==x.first){\\n\\t\\t\\t\\t// this entry actually is a valid entry( freq[key] = freq_while_this_element_was_inserted)\\n                    m.erase(x.second.second);\\n                    freq.erase(x.second.second);\\n                }\\n                pq.pop();\\n            }            \\n        }\\n\\t\\t// fill priority_queue and increase time\\n        m[key] = value;\\n        freq[key]++;\\n        pq.push({freq[key],{t++,key}});\\n        \\n    }\\n};\\n\\n/**\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747482,
                "title": "python-ordereddict-explained",
                "content": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity                                         # stores the capacity\\n        self.di = {}                                                     # stores keys with their frequencies\\n        self.lfu = defaultdict(OrderedDict)                              # stores frequencies and all keys that have a given frequency\\n        self.least = 0                                                   # stores the minimum frequence which exists in the cache. We need this for eviction\\n        \\n    def update(self, key, value = None):                                 # help function which update the frequency of a key\\n        poz = self.di[key] + 1                                           # if a key frequency was N then after we visit it, the frequency changes to N + 1\\n        v = self.lfu[poz - 1].pop(key)                                   # if we update the position of a key in the cache then we should maintain its last value\\n        if value is not None:                                            # we call the update function in 2 cases: 1. From get function. In this case we maintain its last value; 2. From put function. In this case we should change the key\\'s value with a new one\\n            v = value                                                    # 2nd case\\n        self.lfu[poz][key], self.di[key] = v, poz                        # update the key in both dictionaries\\n        if not self.lfu[poz - 1] and self.least == poz - 1:              # if there a no more keys with the Nth frequence, and the Nth frequence was the minimal frequence then we need to increment the minimum frequence\\n            self.least += 1\\n        return self.lfu[poz][key]                                        # this line is used only when the updated function was called from the get function\\n    \\n    def get(self, key: int) -> int:\\n        return self.update(key) if key in self.di else -1                # if we find a key, then we should update its position and return its value, otherwise we return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity: return                                     # we need this line for the case when the capacity is 0 as we can\\'t put anything\\n        if key in self.di: self.update(key, value)                       # if the key is already in our cache then we only update its value with a new one\\n        else:                                                            # the key isn\\'t in our cache. Its frequence becomes 1\\n            if len(self.di) == self.capacity:                            # the cache reached its capacity\\n                del self.di[self.lfu[self.least].popitem(last=False)[0]] # firstly, we remove the key with the minimum frequence, and then we delete the key from the cache\\n            self.lfu[1][key] = value                                     # last 3 lines put the key in the cache\\n            self.di[key] = 1\\n            self.least = 1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity                                         # stores the capacity\\n        self.di = {}                                                     # stores keys with their frequencies\\n        self.lfu = defaultdict(OrderedDict)                              # stores frequencies and all keys that have a given frequency\\n        self.least = 0                                                   # stores the minimum frequence which exists in the cache. We need this for eviction\\n        \\n    def update(self, key, value = None):                                 # help function which update the frequency of a key\\n        poz = self.di[key] + 1                                           # if a key frequency was N then after we visit it, the frequency changes to N + 1\\n        v = self.lfu[poz - 1].pop(key)                                   # if we update the position of a key in the cache then we should maintain its last value\\n        if value is not None:                                            # we call the update function in 2 cases: 1. From get function. In this case we maintain its last value; 2. From put function. In this case we should change the key\\'s value with a new one\\n            v = value                                                    # 2nd case\\n        self.lfu[poz][key], self.di[key] = v, poz                        # update the key in both dictionaries\\n        if not self.lfu[poz - 1] and self.least == poz - 1:              # if there a no more keys with the Nth frequence, and the Nth frequence was the minimal frequence then we need to increment the minimum frequence\\n            self.least += 1\\n        return self.lfu[poz][key]                                        # this line is used only when the updated function was called from the get function\\n    \\n    def get(self, key: int) -> int:\\n        return self.update(key) if key in self.di else -1                # if we find a key, then we should update its position and return its value, otherwise we return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if not self.capacity: return                                     # we need this line for the case when the capacity is 0 as we can\\'t put anything\\n        if key in self.di: self.update(key, value)                       # if the key is already in our cache then we only update its value with a new one\\n        else:                                                            # the key isn\\'t in our cache. Its frequence becomes 1\\n            if len(self.di) == self.capacity:                            # the cache reached its capacity\\n                del self.di[self.lfu[self.least].popitem(last=False)[0]] # firstly, we remove the key with the minimum frequence, and then we delete the key from the cache\\n            self.lfu[1][key] = value                                     # last 3 lines put the key in the cache\\n            self.di[key] = 1\\n            self.least = 1",
                "codeTag": "Java"
            },
            {
                "id": 630931,
                "title": "javascript-o-1-runtime-80-runtime-100-space-with-3-hash-map",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n  this.keyToFreqMap = new Map();\\n  this.freqToKeyMap = new Map();\\n  this.keyToValMap = new Map();\\n  this.capacity = capacity;\\n  this.leastFreq = 0;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n  if (this.keyToValMap.has(key)) {\\n    this.leastFreq = freqAddOne(this.keyToFreqMap, this.freqToKeyMap, key, this.leastFreq);\\n    return this.keyToValMap.get(key);\\n  } else {\\n    return -1;\\n  }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if (this.capacity > 0) {\\n    // pop out least frequency used\\n    if (this.keyToValMap.size >= this.capacity && !this.keyToValMap.has(key)) {\\n      // Step 1: figure which one is the least frequenty used\\n      var leastFreqSet = this.freqToKeyMap.get(this.leastFreq)\\n      // Since set is inserted according insertion order, the head of the set must be the least recently used item\\n      var leastUsedKey = leastFreqSet.values().next().value;\\n      \\n      // remove it from all our maps\\n      leastFreqSet.delete(leastUsedKey);\\n      if (leastFreqSet.size === 0) {\\n        this.freqToKeyMap.delete(this.leastFreq);\\n        // Since the last entry on the leastFreq set is removed, so the next leastFreq will be +1 from current\\n        this.leastFreq++;\\n      }\\n      this.keyToFreqMap.delete(leastUsedKey);\\n      this.keyToValMap.delete(leastUsedKey);\\n    }\\n    // We haven\\'t seen this before, so leastFreq will be set back to 1\\n    if (!this.keyToValMap.has(key)) {\\n      this.leastFreq = 1;\\n    }\\n    // update our leastFreq count\\n    this.leastFreq = freqAddOne(this.keyToFreqMap, this.freqToKeyMap, key, this.leastFreq);\\n    this.keyToValMap.set(key, value);\\n  }\\n};\\n\\nfunction freqAddOne(keyToFreqMap, freqToKeyMap, key, leastFreq) {\\n  // Add this key to our cache\\n  // update keyToFreqMap\\n  var freq = keyToFreqMap.get(key) + 1 || 1;\\n  keyToFreqMap.set(key, freq);\\n\\n  // update freqToKeyMap\\n  if (freq > 1) {\\n    var oldFreq = freq - 1;\\n    var oldFreqSet = freqToKeyMap.get(oldFreq);\\n    oldFreqSet.delete(key);\\n    if (oldFreqSet.size === 0) {\\n      freqToKeyMap.delete(oldFreq)\\n      if (oldFreq === leastFreq) leastFreq++;\\n    }\\n  }\\n  var set = freqToKeyMap.get(freq) || new Set();\\n  set.add(key);\\n  freqToKeyMap.set(freq, set);\\n  return leastFreq;\\n}\\n\\n\\nvar cache = new LFUCache(2 /* capacity */ );\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.put(3, 3); // evicts key 2\\ncache.get(2); // returns -1 (not found)\\ncache.get(3); // returns 3.\\ncache.put(4, 4); // evicts key 1.\\ncache.get(1); // returns -1 (not found)\\ncache.get(3); // returns 3\\ncache.get(4); // returns 4\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n  this.keyToFreqMap = new Map();\\n  this.freqToKeyMap = new Map();\\n  this.keyToValMap = new Map();\\n  this.capacity = capacity;\\n  this.leastFreq = 0;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n  if (this.keyToValMap.has(key)) {\\n    this.leastFreq = freqAddOne(this.keyToFreqMap, this.freqToKeyMap, key, this.leastFreq);\\n    return this.keyToValMap.get(key);\\n  } else {\\n    return -1;\\n  }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if (this.capacity > 0) {\\n    // pop out least frequency used\\n    if (this.keyToValMap.size >= this.capacity && !this.keyToValMap.has(key)) {\\n      // Step 1: figure which one is the least frequenty used\\n      var leastFreqSet = this.freqToKeyMap.get(this.leastFreq)\\n      // Since set is inserted according insertion order, the head of the set must be the least recently used item\\n      var leastUsedKey = leastFreqSet.values().next().value;\\n      \\n      // remove it from all our maps\\n      leastFreqSet.delete(leastUsedKey);\\n      if (leastFreqSet.size === 0) {\\n        this.freqToKeyMap.delete(this.leastFreq);\\n        // Since the last entry on the leastFreq set is removed, so the next leastFreq will be +1 from current\\n        this.leastFreq++;\\n      }\\n      this.keyToFreqMap.delete(leastUsedKey);\\n      this.keyToValMap.delete(leastUsedKey);\\n    }\\n    // We haven\\'t seen this before, so leastFreq will be set back to 1\\n    if (!this.keyToValMap.has(key)) {\\n      this.leastFreq = 1;\\n    }\\n    // update our leastFreq count\\n    this.leastFreq = freqAddOne(this.keyToFreqMap, this.freqToKeyMap, key, this.leastFreq);\\n    this.keyToValMap.set(key, value);\\n  }\\n};\\n\\nfunction freqAddOne(keyToFreqMap, freqToKeyMap, key, leastFreq) {\\n  // Add this key to our cache\\n  // update keyToFreqMap\\n  var freq = keyToFreqMap.get(key) + 1 || 1;\\n  keyToFreqMap.set(key, freq);\\n\\n  // update freqToKeyMap\\n  if (freq > 1) {\\n    var oldFreq = freq - 1;\\n    var oldFreqSet = freqToKeyMap.get(oldFreq);\\n    oldFreqSet.delete(key);\\n    if (oldFreqSet.size === 0) {\\n      freqToKeyMap.delete(oldFreq)\\n      if (oldFreq === leastFreq) leastFreq++;\\n    }\\n  }\\n  var set = freqToKeyMap.get(freq) || new Set();\\n  set.add(key);\\n  freqToKeyMap.set(freq, set);\\n  return leastFreq;\\n}\\n\\n\\nvar cache = new LFUCache(2 /* capacity */ );\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.get(1); // returns 1\\ncache.put(3, 3); // evicts key 2\\ncache.get(2); // returns -1 (not found)\\ncache.get(3); // returns 3.\\ncache.put(4, 4); // evicts key 1.\\ncache.get(1); // returns -1 (not found)\\ncache.get(3); // returns 3\\ncache.get(4); // returns 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442210,
                "title": "java-hashmap-doubly-linked-list",
                "content": "![image](https://assets.leetcode.com/users/atjha/image_1575358115.png)\\n\\nWe maintain a doubly linked list of nodes containing key values. These node are arranged in increasing order of their frequency(number of times the keys have been used by get/put). Inside each node we have a doubly linked list of KeyValues with the most recently used being the rightmost.\\n\\nBoth of the lists are backed by hashmap\\'s for O(1) gets and puts. This design is kinda hybrid of All O(1) datastructure problem and LRU cache problem.\\n\\nGet\\n1. Check if key is present in lfuMap.\\n2. If present get the Node object for the key and remove the concerned KeyValue object from that Node.\\n3. Insert the removed KeyValue to the next Node or create a new Node if necessary.\\n\\nPut\\n1. If the key is already present, get the Node object for the key and remove the concerned KeyValue object from that Node.\\n2. Update the value in KeyValue object. Insert it to the next Node or create a new Node if necessary.\\n3. If the key is not present, check if cache is at capacity. If at capacity, remove the least recently used(leftmost KeyValue) key from the leftmost Node.\\n4. Create a new KeyValue object and insert it to leftmost Node or create a new leftmost Node if necessary.\\n```\\nclass LFUCache {\\n    class KeyValue {\\n        int key;\\n        int value;\\n        KeyValue next = null;\\n        KeyValue prev = null;\\n        \\n        KeyValue() {}\\n        \\n        KeyValue(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n    \\n    class Node {\\n        int freq;\\n        Node next = null;\\n        Node prev = null;\\n        \\n        KeyValue head = new KeyValue();\\n        KeyValue tail = new KeyValue();\\n        Map<Integer, KeyValue> lruMap = new HashMap<>();\\n        \\n        Node(int freq) {\\n            this.freq = freq;\\n            this.tail.next = head;\\n            this.head.prev = tail;\\n        }\\n        \\n        void remove(KeyValue kv) {\\n            kv.prev.next = kv.next;\\n            kv.next.prev = kv.prev;\\n            kv.prev = null;\\n            kv.next = null;\\n            lruMap.remove(kv.key);\\n        }\\n        \\n        KeyValue remove(int key) {\\n            KeyValue kv = lruMap.get(key);\\n            remove(kv);\\n            return kv;\\n        }\\n        \\n        int removeLru() {\\n            KeyValue kv = tail.next;\\n            remove(kv);\\n            return kv.key;\\n        }\\n        \\n        void add(KeyValue kv) {\\n            kv.prev = head.prev;\\n            head.prev.next = kv;\\n            kv.next = head;\\n            head.prev = kv;\\n            lruMap.put(kv.key, kv);\\n        }\\n        \\n        boolean isEmpty() {\\n            return lruMap.size() == 0;\\n        }\\n    }\\n    \\n    Node head = new Node(0);\\n    Node tail = new Node(0);\\n    Map<Integer, Node> lfuMap = new HashMap<>();\\n    int capacity;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.tail.next = head;\\n        this.head.prev = tail;\\n    }\\n    \\n    void remove(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    \\n    void add(Node node, Node newNode) {\\n        newNode.next = node.next;\\n        newNode.prev = node;\\n        node.next.prev = newNode;\\n        node.next = newNode;\\n    }\\n    \\n    void addKeyValueToNextNode(Node node, KeyValue kv) {\\n        if (node.next.freq == node.freq + 1) {\\n            lfuMap.put(kv.key, node.next);\\n        } else {\\n            lfuMap.put(kv.key, new Node(node.freq + 1));\\n            add(node, lfuMap.get(kv.key));\\n        }\\n        lfuMap.get(kv.key).add(kv);\\n    }\\n\\n    public int get(int key) {\\n        if (!lfuMap.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        Node node = lfuMap.get(key);\\n        KeyValue kv = node.remove(key);\\n        addKeyValueToNextNode(node, kv);\\n        if (node.isEmpty()) {\\n            remove(node);\\n        }\\n        \\n        return kv.value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity < 1) {\\n            return;\\n        }\\n        \\n        if (lfuMap.containsKey(key)) {\\n            Node node = lfuMap.get(key);\\n            KeyValue kv = node.remove(key);\\n            kv.value = value;\\n            \\n            addKeyValueToNextNode(node, kv);\\n            if (node.isEmpty()) {\\n                remove(node);\\n            }\\n        } else {\\n            if (lfuMap.size() == capacity) {\\n                int removedKey = tail.next.removeLru();\\n                lfuMap.remove(removedKey);\\n                if (tail.next.isEmpty()) {\\n                    remove(tail.next);\\n                }\\n            }\\n            addKeyValueToNextNode(tail, new KeyValue(key, value));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    class KeyValue {\\n        int key;\\n        int value;\\n        KeyValue next = null;\\n        KeyValue prev = null;\\n        \\n        KeyValue() {}\\n        \\n        KeyValue(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n    \\n    class Node {\\n        int freq;\\n        Node next = null;\\n        Node prev = null;\\n        \\n        KeyValue head = new KeyValue();\\n        KeyValue tail = new KeyValue();\\n        Map<Integer, KeyValue> lruMap = new HashMap<>();\\n        \\n        Node(int freq) {\\n            this.freq = freq;\\n            this.tail.next = head;\\n            this.head.prev = tail;\\n        }\\n        \\n        void remove(KeyValue kv) {\\n            kv.prev.next = kv.next;\\n            kv.next.prev = kv.prev;\\n            kv.prev = null;\\n            kv.next = null;\\n            lruMap.remove(kv.key);\\n        }\\n        \\n        KeyValue remove(int key) {\\n            KeyValue kv = lruMap.get(key);\\n            remove(kv);\\n            return kv;\\n        }\\n        \\n        int removeLru() {\\n            KeyValue kv = tail.next;\\n            remove(kv);\\n            return kv.key;\\n        }\\n        \\n        void add(KeyValue kv) {\\n            kv.prev = head.prev;\\n            head.prev.next = kv;\\n            kv.next = head;\\n            head.prev = kv;\\n            lruMap.put(kv.key, kv);\\n        }\\n        \\n        boolean isEmpty() {\\n            return lruMap.size() == 0;\\n        }\\n    }\\n    \\n    Node head = new Node(0);\\n    Node tail = new Node(0);\\n    Map<Integer, Node> lfuMap = new HashMap<>();\\n    int capacity;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.tail.next = head;\\n        this.head.prev = tail;\\n    }\\n    \\n    void remove(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    \\n    void add(Node node, Node newNode) {\\n        newNode.next = node.next;\\n        newNode.prev = node;\\n        node.next.prev = newNode;\\n        node.next = newNode;\\n    }\\n    \\n    void addKeyValueToNextNode(Node node, KeyValue kv) {\\n        if (node.next.freq == node.freq + 1) {\\n            lfuMap.put(kv.key, node.next);\\n        } else {\\n            lfuMap.put(kv.key, new Node(node.freq + 1));\\n            add(node, lfuMap.get(kv.key));\\n        }\\n        lfuMap.get(kv.key).add(kv);\\n    }\\n\\n    public int get(int key) {\\n        if (!lfuMap.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        Node node = lfuMap.get(key);\\n        KeyValue kv = node.remove(key);\\n        addKeyValueToNextNode(node, kv);\\n        if (node.isEmpty()) {\\n            remove(node);\\n        }\\n        \\n        return kv.value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity < 1) {\\n            return;\\n        }\\n        \\n        if (lfuMap.containsKey(key)) {\\n            Node node = lfuMap.get(key);\\n            KeyValue kv = node.remove(key);\\n            kv.value = value;\\n            \\n            addKeyValueToNextNode(node, kv);\\n            if (node.isEmpty()) {\\n                remove(node);\\n            }\\n        } else {\\n            if (lfuMap.size() == capacity) {\\n                int removedKey = tail.next.removeLru();\\n                lfuMap.remove(removedKey);\\n                if (tail.next.isEmpty()) {\\n                    remove(tail.next);\\n                }\\n            }\\n            addKeyValueToNextNode(tail, new KeyValue(key, value));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441035,
                "title": "capacity-0-expected-is-wrong",
                "content": "The test case with capacity=0 expects -1 for any find. It contradicts the statement that\"When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item\"\\n[\"LFUCache\",\"put\",\"get\"]\\n[[0],[0,0],[0]]\\n\\nExpected\\n[null,null,-1]",
                "solutionTags": [],
                "code": "The test case with capacity=0 expects -1 for any find. It contradicts the statement that\"When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item\"\\n[\"LFUCache\",\"put\",\"get\"]\\n[[0],[0,0],[0]]\\n\\nExpected\\n[null,null,-1]",
                "codeTag": "Unknown"
            },
            {
                "id": 265462,
                "title": "javascript-o-1-use-three-map-with-set",
                "content": "Inspired By http://dhruvbird.com/lfu.pdf\\n\\n```\\nfunction Node(count,lfu){\\n    this.count = count\\n    this.lfu = lfu\\n    this.set = new Set()\\n    this.prev = this.next = null\\n}\\n\\nNode.prototype.add = function(key){\\n    this.set.add(key)\\n}\\n\\nNode.prototype.pop = function() {\\n    let array = [...this.set]\\n    let key = array[0]\\n    this.remove(key)\\n    delete this.lfu.k_v_map[key]\\n    delete this.lfu.k_count_map[key]\\n    return key\\n}\\n\\nNode.prototype.remove = function(key){\\n    this.set.delete(key)\\n    let curr = this\\n    if(this.set.size === 0){\\n        curr = this.prev\\n        this.lfu.deleteNode(this)   \\n    }\\n    return curr\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n    this.capacity = capacity\\n    this.count = 0\\n    this.count_node_map = Object.create(null)\\n    this.k_v_map = Object.create(null)\\n    this.k_count_map = Object.create(null)\\n    this.head = new Node(-1,this)\\n    this.tail = new Node(-1,this)\\n    this.head.prev = this.tail.next = null\\n    this.head.next = this.tail\\n    this.tail.prev = this.head\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n    let newValue = arguments[1]\\n    if(typeof newValue !== \\'undefined\\'){\\n        this.k_v_map[key] = newValue\\n    }\\n    let v = this.k_v_map[key]\\n    if(typeof v === \\'undefined\\'){\\n        return -1\\n    }\\n    this.increaseCount(key)\\n    \\n    return v\\n};\\n\\nLFUCache.prototype.increaseCount = function(key){\\n    let count = this.k_count_map[key] ++\\n    let currNode = this.count_node_map[count]\\n    currNode = currNode.remove(key)\\n    let nextNode = this.count_node_map[count + 1]\\n    if(!nextNode){\\n        this.count_node_map[ count + 1] = nextNode = new Node(count + 1,this)\\n        this.nodeInsert(currNode, nextNode)\\n    }\\n    nextNode.add(key)\\n}\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n    let curr = this.k_v_map[key]\\n    if(this.capacity === 0){\\n        return\\n    }\\n    if(!curr && this.count >= this.capacity){\\n        this.head.next.pop()\\n        this.count --\\n    }\\n    if(!curr){\\n        this.count ++\\n        this.k_v_map[key] = value\\n        this.k_count_map[key] = 1\\n        let firstNode = this.count_node_map[1]\\n        if(!firstNode){\\n            firstNode = this.count_node_map[1] = new Node(1,this)\\n            this.nodeInsert(this.head, firstNode)\\n        }\\n        firstNode.add(key)\\n        return\\n    }\\n    this.get(key,value)\\n};\\n\\nLFUCache.prototype.nodeInsert = function(prevNode, nextNode) {\\n    let old = prevNode.next\\n    if(old){\\n        nextNode.next = old\\n        old.prev = nextNode\\n    }\\n    prevNode.next = nextNode\\n    nextNode.prev = prevNode\\n}\\n\\nLFUCache.prototype.deleteNode = function(node){\\n    node.prev.next = node.next\\n    node.next.prev = node.prev\\n    node.prev = node.next = null\\n    delete this.count_node_map[node.count]\\n}\\n\\n/** \\n * Your LFUCache object will be instantiated and called as such:\\n * var obj = new LFUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nfunction Node(count,lfu){\\n    this.count = count\\n    this.lfu = lfu\\n    this.set = new Set()\\n    this.prev = this.next = null\\n}\\n\\nNode.prototype.add = function(key){\\n    this.set.add(key)\\n}\\n\\nNode.prototype.pop = function() {\\n    let array = [...this.set]\\n    let key = array[0]\\n    this.remove(key)\\n    delete this.lfu.k_v_map[key]\\n    delete this.lfu.k_count_map[key]\\n    return key\\n}\\n\\nNode.prototype.remove = function(key){\\n    this.set.delete(key)\\n    let curr = this\\n    if(this.set.size === 0){\\n        curr = this.prev\\n        this.lfu.deleteNode(this)   \\n    }\\n    return curr\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n    this.capacity = capacity\\n    this.count = 0\\n    this.count_node_map = Object.create(null)\\n    this.k_v_map = Object.create(null)\\n    this.k_count_map = Object.create(null)\\n    this.head = new Node(-1,this)\\n    this.tail = new Node(-1,this)\\n    this.head.prev = this.tail.next = null\\n    this.head.next = this.tail\\n    this.tail.prev = this.head\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n    let newValue = arguments[1]\\n    if(typeof newValue !== \\'undefined\\'){\\n        this.k_v_map[key] = newValue\\n    }\\n    let v = this.k_v_map[key]\\n    if(typeof v === \\'undefined\\'){\\n        return -1\\n    }\\n    this.increaseCount(key)\\n    \\n    return v\\n};\\n\\nLFUCache.prototype.increaseCount = function(key){\\n    let count = this.k_count_map[key] ++\\n    let currNode = this.count_node_map[count]\\n    currNode = currNode.remove(key)\\n    let nextNode = this.count_node_map[count + 1]\\n    if(!nextNode){\\n        this.count_node_map[ count + 1] = nextNode = new Node(count + 1,this)\\n        this.nodeInsert(currNode, nextNode)\\n    }\\n    nextNode.add(key)\\n}\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n    let curr = this.k_v_map[key]\\n    if(this.capacity === 0){\\n        return\\n    }\\n    if(!curr && this.count >= this.capacity){\\n        this.head.next.pop()\\n        this.count --\\n    }\\n    if(!curr){\\n        this.count ++\\n        this.k_v_map[key] = value\\n        this.k_count_map[key] = 1\\n        let firstNode = this.count_node_map[1]\\n        if(!firstNode){\\n            firstNode = this.count_node_map[1] = new Node(1,this)\\n            this.nodeInsert(this.head, firstNode)\\n        }\\n        firstNode.add(key)\\n        return\\n    }\\n    this.get(key,value)\\n};\\n\\nLFUCache.prototype.nodeInsert = function(prevNode, nextNode) {\\n    let old = prevNode.next\\n    if(old){\\n        nextNode.next = old\\n        old.prev = nextNode\\n    }\\n    prevNode.next = nextNode\\n    nextNode.prev = prevNode\\n}\\n\\nLFUCache.prototype.deleteNode = function(node){\\n    node.prev.next = node.next\\n    node.next.prev = node.prev\\n    node.prev = node.next = null\\n    delete this.count_node_map[node.count]\\n}\\n\\n/** \\n * Your LFUCache object will be instantiated and called as such:\\n * var obj = new LFUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94543,
                "title": "c-accept-solution-with-two-dictionary-and-linkedlist",
                "content": "refer to QQBear 's 3 hashmap solution, but I didn't use  then one : key to list iterator;\\nhttps://discuss.leetcode.com/topic/69436/concise-c-o-1-solution-using-3-hash-maps-with-explanation/2\\n\\n```\\n    public class LFUCache\\n    {\\n        public int Capacity;\\n        public int min = 0;\\n        \\n        Dictionary<int, LinkedListNode<CacheItem>> cache = new Dictionary<int, LinkedListNode<CacheItem>>();\\n        Dictionary<int, LinkedList<CacheItem>> freqlist = new Dictionary<int, LinkedList<CacheItem>>();\\n        public LFUCache(int capacity)\\n        {\\n            this.Capacity = capacity;\\n        }\\n\\n        public int Get(int key)\\n        {\\n            if (Capacity <= 0) return -1;\\n            if (!this.cache.ContainsKey(key)) return -1;\\n\\n            var item = this.cache[key];\\n            // remove item from freq list;\\n            freqlist[item.Value.Count].Remove(item);\\n            // add item to freq list\\n            item.Value.Count++;\\n            if (!freqlist.ContainsKey(item.Value.Count)) {\\n                freqlist[item.Value.Count] = new LinkedList<CacheItem>();\\n            }\\n            freqlist[item.Value.Count].AddLast(item);\\n\\n            if(freqlist[min].Count == 0)\\n            {\\n                min++;\\n            }\\n            return item.Value.Value;\\n        }\\n\\n        public void Put(int key, int value)\\n        {\\n            if (this.Capacity <= 0) return;\\n\\n            var item = this.Get(key);\\n            if(item != -1)\\n            {\\n                // count already updated\\n                this.cache[key].Value.Value = value;\\n                return;\\n            }\\n\\n            if(cache.Count == this.Capacity)\\n            {\\n                // remove invalid node\\n                var expired = this.freqlist[min].First;\\n                this.cache.Remove(expired.Value.Key);\\n                this.freqlist[min].RemoveFirst();\\n            }\\n            //insert\\n            var newItem = new CacheItem { Key = key, Value = value, Count = 1 };\\n            if (!this.freqlist.ContainsKey(1)) this.freqlist[1] = new LinkedList<CacheItem>();\\n            var newNode = this.freqlist[1].AddLast(newItem);\\n            this.cache.Add(key, newNode);\\n            min = 1;\\n        }\\n\\n        public class CacheItem\\n        {\\n            public int Value;\\n            public int Key;\\n            public int Count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class LFUCache\\n    {\\n        public int Capacity;\\n        public int min = 0;\\n        \\n        Dictionary<int, LinkedListNode<CacheItem>> cache = new Dictionary<int, LinkedListNode<CacheItem>>();\\n        Dictionary<int, LinkedList<CacheItem>> freqlist = new Dictionary<int, LinkedList<CacheItem>>();\\n        public LFUCache(int capacity)\\n        {\\n            this.Capacity = capacity;\\n        }\\n\\n        public int Get(int key)\\n        {\\n            if (Capacity <= 0) return -1;\\n            if (!this.cache.ContainsKey(key)) return -1;\\n\\n            var item = this.cache[key];\\n            // remove item from freq list;\\n            freqlist[item.Value.Count].Remove(item);\\n            // add item to freq list\\n            item.Value.Count++;\\n            if (!freqlist.ContainsKey(item.Value.Count)) {\\n                freqlist[item.Value.Count] = new LinkedList<CacheItem>();\\n            }\\n            freqlist[item.Value.Count].AddLast(item);\\n\\n            if(freqlist[min].Count == 0)\\n            {\\n                min++;\\n            }\\n            return item.Value.Value;\\n        }\\n\\n        public void Put(int key, int value)\\n        {\\n            if (this.Capacity <= 0) return;\\n\\n            var item = this.Get(key);\\n            if(item != -1)\\n            {\\n                // count already updated\\n                this.cache[key].Value.Value = value;\\n                return;\\n            }\\n\\n            if(cache.Count == this.Capacity)\\n            {\\n                // remove invalid node\\n                var expired = this.freqlist[min].First;\\n                this.cache.Remove(expired.Value.Key);\\n                this.freqlist[min].RemoveFirst();\\n            }\\n            //insert\\n            var newItem = new CacheItem { Key = key, Value = value, Count = 1 };\\n            if (!this.freqlist.ContainsKey(1)) this.freqlist[1] = new LinkedList<CacheItem>();\\n            var newNode = this.freqlist[1].AddLast(newItem);\\n            this.cache.Add(key, newNode);\\n            min = 1;\\n        }\\n\\n        public class CacheItem\\n        {\\n            public int Value;\\n            public int Key;\\n            public int Count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94582,
                "title": "c-89ms-beats-99-8-using-unordered-map-list-of-list",
                "content": "I use two structure to solve this problem\\n\\nlist<pair<int, list<int>>> records the visit info(count & time) of each key, let's call it big-L\\nthe most inner <int> is the key, and list<int> rank them according to visit-time, from old to new.\\npair<int, list<int>> associate each list<int> with visit-count\\ne.g.    {2, {a, b}} means both a & b has been visited for 2 times, but b has a newer last-visit-time\\n\\nand the other structure unordered_map<int, info> keeps the value and iterators in big-L of each key\\n\\nso everytime we have to remove one element, we remove the first <int> of first pair<int, list<int>> in big-L\\n\\nand everytime we have to insert one element, just check if the first pair's count equals 1. If it is, use that pair, push new element to its back; otherwise, insert a new pair.\\n\\nand everytime an element is visited, we move it from the old pair to the next one in big-L. if no following pair exists, or following pair's count is not old-count+1, just insert a new pair with old-count+1. don't forget to update the iterators in map :D\\n\\n```\\nclass LFUCache {\\npublic:\\n    struct info\\n    {\\n        int val;\\n        list<pair<int, list<int>>>::iterator it_pair;\\n        list<int>::iterator it_key;\\n    };\\n\\n    LFUCache(int capacity) {\\n        cap_ = capacity;\\n    }\\n\\n    int get(int key) {\\n        auto it = map_.find(key);\\n        \\n        if (it == map_.end())\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            visit(it, key);\\n            return it->second.val;\\n        }\\n    }\\n\\n    void put(int key, int value) {\\n        auto it = map_.find(key);\\n        \\n        // exist\\n        if (it != map_.end())\\n        {\\n            visit(it, key);\\n            it->second.val = value;\\n        }\\n        else\\n        {\\n            if (cap_ == 0) return;\\n\\n            // del\\n            if (map_.size() == cap_)\\n            {\\n                auto it = list_.front().second.begin();\\n                map_.erase(*it);\\n                list_.front().second.erase(it);\\n\\n                if (list_.front().second.size() == 0)\\n                    list_.erase(list_.begin());\\n            }\\n            // insert\\n            if (list_.empty() || list_.front().first != 1)\\n            {\\n                list_.push_front({1, {key}});\\n            }\\n            else\\n            {\\n                list_.front().second.push_back(key);\\n            }\\n            map_[key] = {value, list_.begin(), std::prev(list_.front().second.end())};\\n        }\\n    }\\n\\nprotected:\\n    void visit(unordered_map<int, info>::iterator it, int key)\\n    {\\n        auto it_pair = it->second.it_pair;\\n        auto it_key = it->second.it_key;\\n        int count = it_pair->first + 1;\\n\\n        it_pair->second.erase(it_key);\\n        if (it_pair->second.size() == 0)\\n            it_pair = list_.erase(it_pair);\\n        else\\n            std::advance(it_pair, 1);\\n\\n        if (it_pair == list_.end() || it_pair->first != count)\\n        {\\n            it_pair = list_.insert(it_pair, {count, {key}});\\n        }\\n        else\\n        {\\n            it_pair->second.push_back(key);\\n        }\\n        it->second.it_pair = it_pair;\\n        it->second.it_key = std::prev(it_pair->second.end());\\n    }\\n\\n    int cap_;\\n    list<pair<int, list<int>>> list_;\\n    unordered_map<int, info> map_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\npublic:\\n    struct info\\n    {\\n        int val;\\n        list<pair<int, list<int>>>::iterator it_pair;\\n        list<int>::iterator it_key;\\n    };\\n\\n    LFUCache(int capacity) {\\n        cap_ = capacity;\\n    }\\n\\n    int get(int key) {\\n        auto it = map_.find(key);\\n        \\n        if (it == map_.end())\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            visit(it, key);\\n            return it->second.val;\\n        }\\n    }\\n\\n    void put(int key, int value) {\\n        auto it = map_.find(key);\\n        \\n        // exist\\n        if (it != map_.end())\\n        {\\n            visit(it, key);\\n            it->second.val = value;\\n        }\\n        else\\n        {\\n            if (cap_ == 0) return;\\n\\n            // del\\n            if (map_.size() == cap_)\\n            {\\n                auto it = list_.front().second.begin();\\n                map_.erase(*it);\\n                list_.front().second.erase(it);\\n\\n                if (list_.front().second.size() == 0)\\n                    list_.erase(list_.begin());\\n            }\\n            // insert\\n            if (list_.empty() || list_.front().first != 1)\\n            {\\n                list_.push_front({1, {key}});\\n            }\\n            else\\n            {\\n                list_.front().second.push_back(key);\\n            }\\n            map_[key] = {value, list_.begin(), std::prev(list_.front().second.end())};\\n        }\\n    }\\n\\nprotected:\\n    void visit(unordered_map<int, info>::iterator it, int key)\\n    {\\n        auto it_pair = it->second.it_pair;\\n        auto it_key = it->second.it_key;\\n        int count = it_pair->first + 1;\\n\\n        it_pair->second.erase(it_key);\\n        if (it_pair->second.size() == 0)\\n            it_pair = list_.erase(it_pair);\\n        else\\n            std::advance(it_pair, 1);\\n\\n        if (it_pair == list_.end() || it_pair->first != count)\\n        {\\n            it_pair = list_.insert(it_pair, {count, {key}});\\n        }\\n        else\\n        {\\n            it_pair->second.push_back(key);\\n        }\\n        it->second.it_pair = it_pair;\\n        it->second.it_key = std::prev(it_pair->second.end());\\n    }\\n\\n    int cap_;\\n    list<pair<int, list<int>>> list_;\\n    unordered_map<int, info> map_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117725,
                "title": "simple-fast-c-solution-hashmaps-deque-beats-96-time-98-space",
                "content": "# Intuition\\nWe need $O(1)$ access to a value given a key and the number of times it was used, so a hashmap comes to mind. We also need $O(1)$ access to the last used element, so a queue comes to mind, but since we need to be able to remove last used elements once they\\'re removed from the cache, a deque makes more sense.\\n\\n---\\n\\n# Approach\\n\\n### Get\\nThis method is straightforward - if the key doesn\\'t exist in the cache, return -1. For this, we store a hashmap of key / value pairs. Otherwise, increment the number of uses of the key - for this, we store a hashmap of key / use pairs. Next, push the key to the back of a deque associated with the new number of uses of this key - we can store a hashmap of use / keys pairs, where keys are stored in a deque. Finally, return the value associated with the key.\\n\\n### Put\\nFirst to deal with the edge case of a 0 capacity cache, just immediately return. Otherwise, if we are about to insert a new key into the cache (i.e. the key doesn\\'t yet exist), and the cache is already at capacity, we must remove an element.\\n\\nFor this, we need to know the minimum number of uses of any given key in the cache. Assuming our cache has no stale values, we are free to access the uses deque associated with the minimum number of uses and remove the element at the front - this must be the element that was used last (solving potential ties) with the minimum number of uses. We can also remove the value and uses associated with that key at this point. However, we can\\'t assume the cache has no stale values...\\n\\n##### Refreshing the Cache\\nThe tricky part of this solution is in refreshing the cache, so for this, define a new method `refreshCache`. In this method, the goal is to remove any stale values in the `uses` map that associates use values with deques of keys. The stale values come about like so: when we `get` a key, we update the uses of that key (say to 1) and push it to the back of the deque that represents keys with uses of (say) 1. In this case, we would push the key to `uses[1]`. Now, if we get that key again, we update its uses to 2, and push it to `uses[2]`, however we never removed that key from `uses[1]`, so now that previous deque has a stale value, which we need to remove as needed rather than immediately to maintain an amortised $O(1)$ time complexity for both get and put methods.\\n\\nIn `refreshCache`, we go through the deque associated with `min_uses`, i.e. `uses[min_uses]`. If at any point the front of that deque is not stale, then we don\\'t need to refresh the cache anymore. A value is stale if the number of uses of that key differs from the current number of uses associated to the current deque, i.e. if `key_use[the_key] != min_uses`. Otherwise, it\\'s a stale value, so remove it from the deque. Now, if the deque is empty, remove it from the uses map entirely, and find the next candidate `min_uses`, which will just be the next greatest value of uses for which there exist (potentially stale) keys. Otherwise, we keep going through the deque until it is either empty or we find a non-stale value, and keep doing this process for increasing `min_uses` until we find a non-stale value in some deque.\\n\\n\\n##### Finishing off the Put\\nFinally, after refreshing and pruning the cache if it was at capacity and a new key was to be inserted, increment the number of uses of that key and push it to the back of its new uses deque as with `get`, and update the value associated with the key. Note, we also need to update the min uses at this stage, because if e.g. all previous keys were used 4 times, then `min_uses == 4`, however if we now insert a new key, it\\'s only used once, so we need to update `min_uses` to `1`, i.e. set `min_uses = min(min_uses, uses of current key)`.\\n \\n---\\n\\n# Complexity\\n\\n### Time complexity\\n\\n`Get`: $O(1)$. Hashmaps provide $O(1)$ time reads and writes, and deques provide $O(1)$ time insertions to the end and beginning.\\n<br/>\\n\\n`Put`: amortised $O(1)$. As with `get`, all the individual operations are $O(1)$ time, however the tricky part is with `refreshCache`. While the individual operations here are also $O(1)$ time, we iterate while the current deque isn\\'t empty and until we find a non-stale value, so this obviously can\\'t be $O(1)$ time. However, thinking about what these loops are iterating over, they are only iterating over in the worst case all of the remaining elements in the cache, and there can only be as many elements in the cache as times `put` and `get` was called. So, across all $n$ calls to `put` and `get`, `refreshCache` will have spent $O(n)$ time, so we get amortised $O(1)$ time for each individual call.\\n\\n### Space complexity:\\n$O(n + m)$ for capacity $n$ and $m$ calls to `get` and `put`. We store 2 hashmaps that store at most $n$ values associated to all $n$ keys in the cache in $O(2n) = O(n)$ space. We also store the `uses` hashmap of deques, which stores a new value each time either `get` or `put` are called. While refresh cache will prune some stale values, it won\\'t remove them all at once, e.g. if `uses[1]` looks like `{fresh, stale, stale, ...}`, even though all the elements in the deque apart from the first are stale, as soon as the first fresh element is found, no further work to remove stale elements is done, so if `get` was continually called on the stale values, these keys would be constantly put into higher and highers uses deques, but no values would be pruned.\\n\\n---\\n\\n# Code\\n```\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, int> key_val;\\n    unordered_map<int, int> key_use;\\n    unordered_map<int, deque<int>> uses;\\n    int min_uses;\\n    int capacity;\\n\\n    // Remove stale values from the uses[min_uses] deque\\n    void refreshCache() {\\n        while (!uses[min_uses].empty()) {\\n            int tmp_key = uses[min_uses].front();\\n            // Found a non-stale value, so refreshing done\\n            if (key_use[tmp_key] == min_uses) break;\\n\\n            // This is a stale value - remove it from the deque\\n            uses[min_uses].pop_front();\\n\\n            // uses[min_uses] was populated only by stale values, so remove it\\n            if (uses[min_uses].empty()) {\\n                uses.erase(min_uses);\\n                // Find the next candidate min_uses\\n                while (!uses.count(min_uses)) ++min_uses;\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int capacity): min_uses(INT_MAX), capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // Key doesn\\'t exist in cache\\n        if (!key_val.count(key)) return -1;\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        return key_val[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0) return;\\n\\n        // Prune the cache if at capacity and inserting a new value\\n        if (key_val.size() == capacity && !key_val.count(key)) {\\n            refreshCache();\\n\\n            // Finished removing all stale values from the cache\\n            // We now know this value must be valid. Erase the value\\n            // With the minimum number of uses that was used last\\n            int to_remove = uses[min_uses].front();\\n            uses[min_uses].pop_front();\\n            key_val.erase(to_remove);\\n            key_use.erase(to_remove);\\n        }\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        // If the number of uses of this newly insert key is a new minimum, update\\n        min_uses = min(min_uses, key_use[key]);\\n\\n        key_val[key] = value;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nWe need $O(1)$ access to a value given a key and the number of times it was used, so a hashmap comes to mind. We also need $O(1)$ access to the last used element, so a queue comes to mind, but since we need to be able to remove last used elements once they\\'re removed from the cache, a deque makes more sense.\\n\\n---\\n\\n# Approach\\n\\n### Get\\nThis method is straightforward - if the key doesn\\'t exist in the cache, return -1. For this, we store a hashmap of key / value pairs. Otherwise, increment the number of uses of the key - for this, we store a hashmap of key / use pairs. Next, push the key to the back of a deque associated with the new number of uses of this key - we can store a hashmap of use / keys pairs, where keys are stored in a deque. Finally, return the value associated with the key.\\n\\n### Put\\nFirst to deal with the edge case of a 0 capacity cache, just immediately return. Otherwise, if we are about to insert a new key into the cache (i.e. the key doesn\\'t yet exist), and the cache is already at capacity, we must remove an element.\\n\\nFor this, we need to know the minimum number of uses of any given key in the cache. Assuming our cache has no stale values, we are free to access the uses deque associated with the minimum number of uses and remove the element at the front - this must be the element that was used last (solving potential ties) with the minimum number of uses. We can also remove the value and uses associated with that key at this point. However, we can\\'t assume the cache has no stale values...\\n\\n##### Refreshing the Cache\\nThe tricky part of this solution is in refreshing the cache, so for this, define a new method `refreshCache`. In this method, the goal is to remove any stale values in the `uses` map that associates use values with deques of keys. The stale values come about like so: when we `get` a key, we update the uses of that key (say to 1) and push it to the back of the deque that represents keys with uses of (say) 1. In this case, we would push the key to `uses[1]`. Now, if we get that key again, we update its uses to 2, and push it to `uses[2]`, however we never removed that key from `uses[1]`, so now that previous deque has a stale value, which we need to remove as needed rather than immediately to maintain an amortised $O(1)$ time complexity for both get and put methods.\\n\\nIn `refreshCache`, we go through the deque associated with `min_uses`, i.e. `uses[min_uses]`. If at any point the front of that deque is not stale, then we don\\'t need to refresh the cache anymore. A value is stale if the number of uses of that key differs from the current number of uses associated to the current deque, i.e. if `key_use[the_key] != min_uses`. Otherwise, it\\'s a stale value, so remove it from the deque. Now, if the deque is empty, remove it from the uses map entirely, and find the next candidate `min_uses`, which will just be the next greatest value of uses for which there exist (potentially stale) keys. Otherwise, we keep going through the deque until it is either empty or we find a non-stale value, and keep doing this process for increasing `min_uses` until we find a non-stale value in some deque.\\n\\n\\n##### Finishing off the Put\\nFinally, after refreshing and pruning the cache if it was at capacity and a new key was to be inserted, increment the number of uses of that key and push it to the back of its new uses deque as with `get`, and update the value associated with the key. Note, we also need to update the min uses at this stage, because if e.g. all previous keys were used 4 times, then `min_uses == 4`, however if we now insert a new key, it\\'s only used once, so we need to update `min_uses` to `1`, i.e. set `min_uses = min(min_uses, uses of current key)`.\\n \\n---\\n\\n# Complexity\\n\\n### Time complexity\\n\\n`Get`: $O(1)$. Hashmaps provide $O(1)$ time reads and writes, and deques provide $O(1)$ time insertions to the end and beginning.\\n<br/>\\n\\n`Put`: amortised $O(1)$. As with `get`, all the individual operations are $O(1)$ time, however the tricky part is with `refreshCache`. While the individual operations here are also $O(1)$ time, we iterate while the current deque isn\\'t empty and until we find a non-stale value, so this obviously can\\'t be $O(1)$ time. However, thinking about what these loops are iterating over, they are only iterating over in the worst case all of the remaining elements in the cache, and there can only be as many elements in the cache as times `put` and `get` was called. So, across all $n$ calls to `put` and `get`, `refreshCache` will have spent $O(n)$ time, so we get amortised $O(1)$ time for each individual call.\\n\\n### Space complexity:\\n$O(n + m)$ for capacity $n$ and $m$ calls to `get` and `put`. We store 2 hashmaps that store at most $n$ values associated to all $n$ keys in the cache in $O(2n) = O(n)$ space. We also store the `uses` hashmap of deques, which stores a new value each time either `get` or `put` are called. While refresh cache will prune some stale values, it won\\'t remove them all at once, e.g. if `uses[1]` looks like `{fresh, stale, stale, ...}`, even though all the elements in the deque apart from the first are stale, as soon as the first fresh element is found, no further work to remove stale elements is done, so if `get` was continually called on the stale values, these keys would be constantly put into higher and highers uses deques, but no values would be pruned.\\n\\n---\\n\\n# Code\\n```\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, int> key_val;\\n    unordered_map<int, int> key_use;\\n    unordered_map<int, deque<int>> uses;\\n    int min_uses;\\n    int capacity;\\n\\n    // Remove stale values from the uses[min_uses] deque\\n    void refreshCache() {\\n        while (!uses[min_uses].empty()) {\\n            int tmp_key = uses[min_uses].front();\\n            // Found a non-stale value, so refreshing done\\n            if (key_use[tmp_key] == min_uses) break;\\n\\n            // This is a stale value - remove it from the deque\\n            uses[min_uses].pop_front();\\n\\n            // uses[min_uses] was populated only by stale values, so remove it\\n            if (uses[min_uses].empty()) {\\n                uses.erase(min_uses);\\n                // Find the next candidate min_uses\\n                while (!uses.count(min_uses)) ++min_uses;\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int capacity): min_uses(INT_MAX), capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // Key doesn\\'t exist in cache\\n        if (!key_val.count(key)) return -1;\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        return key_val[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0) return;\\n\\n        // Prune the cache if at capacity and inserting a new value\\n        if (key_val.size() == capacity && !key_val.count(key)) {\\n            refreshCache();\\n\\n            // Finished removing all stale values from the cache\\n            // We now know this value must be valid. Erase the value\\n            // With the minimum number of uses that was used last\\n            int to_remove = uses[min_uses].front();\\n            uses[min_uses].pop_front();\\n            key_val.erase(to_remove);\\n            key_use.erase(to_remove);\\n        }\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        // If the number of uses of this newly insert key is a new minimum, update\\n        min_uses = min(min_uses, key_use[key]);\\n\\n        key_val[key] = value;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3114654,
                "title": "python-short-and-clean-doublylinkedlist-and-hashmap",
                "content": "# Approach\\nTLDR; Similar to [Editorial Solution](https://leetcode.com/problems/lfu-cache/solutions/2815229/lfu-cache/) but shorter and cleaner.\\n\\n# Complexity\\n- Time complexity:\\n    `LFUCache.get`: $$O(1)$$\\n    `LFUCache.put`: $$O(1)$$\\n\\n- Space complexity:\\n    `LFUCache.get`: $$O(1)$$\\n    `LFUCache.put`: $$O(1)$$\\n\\n    $$O(n)$$ after `n` calls to `LFUCache.put`\\n\\n# Code\\n```python\\nfrom dataclasses import dataclass\\n\\n\\nclass DLLNode:\\n\\n    def __init__(self, value=None, prev=None, next_=None):\\n        self.value = value\\n        self.prev = prev\\n        self.next = next_\\n\\n\\nclass LFUCache:\\n    @dataclass\\n    class Data:\\n        key: int\\n        value: int\\n        freq: int\\n        node: DLLNode\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache: dict[int, LFUCache.Data] = {}\\n        self.freq_to_dll = defaultdict(DoublyLinkedList)\\n        self.min_freq = 1\\n        self.used = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache: return -1\\n\\n        d = self.cache[key]\\n        self.freq_to_dll[d.freq].remove(d.node)\\n        self.freq_to_dll[d.freq + 1].append(d.node)\\n        self.cache[key] = LFUCache.Data(key, d.value, d.freq + 1, d.node)\\n        self.min_freq += self.min_freq == d.freq and not self.freq_to_dll[d.freq]\\n\\n        return d.value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n\\n        if key in self.cache:\\n            self.cache[key].value = value\\n            self.get(key)\\n            return\\n\\n        if self.used == self.capacity:\\n            mf_dll = self.freq_to_dll[self.min_freq]\\n            mf_lru_key = mf_dll.popleft().value\\n            self.cache.pop(mf_lru_key)\\n            self.used -= 1\\n\\n        d = LFUCache.Data(key, value, 1, DLLNode(key))\\n        self.freq_to_dll[d.freq].append(d.node)\\n        self.cache[key] = d\\n        self.used += 1\\n        self.min_freq = 1\\n\\n\\nclass DoublyLinkedList:\\n\\n    def __init__(self):\\n        self.head, self.tail = DLLNode(), DLLNode()\\n        self.head.next, self.tail.prev = self.tail, self.head\\n\\n    def append(self, node: DLLNode) -> None:\\n        a, b, c = self.tail.prev, node, self.tail\\n        a.next, c.prev = b, b\\n        b.next, b.prev = c, a\\n\\n    def appendleft(self, node: DLLNode) -> None: raise NotImplementedError()\\n\\n    def pop(self) -> DLLNode: raise NotImplementedError()\\n\\n    def popleft(self) -> DLLNode:\\n        node = self.head.next\\n        self.remove(node)\\n        return node\\n\\n    def remove(self, node: DLLNode) -> None:\\n        a, b, c = node.prev, node, node.next\\n        a.next, c.prev = c, a\\n        b.next, b.prev = None, None\\n\\n    def __bool__(self) -> bool:\\n        return self.head.next != self.tail\\n\\n    def __iter__(self): raise NotImplementedError()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```python\\nfrom dataclasses import dataclass\\n\\n\\nclass DLLNode:\\n\\n    def __init__(self, value=None, prev=None, next_=None):\\n        self.value = value\\n        self.prev = prev\\n        self.next = next_\\n\\n\\nclass LFUCache:\\n    @dataclass\\n    class Data:\\n        key: int\\n        value: int\\n        freq: int\\n        node: DLLNode\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache: dict[int, LFUCache.Data] = {}\\n        self.freq_to_dll = defaultdict(DoublyLinkedList)\\n        self.min_freq = 1\\n        self.used = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache: return -1\\n\\n        d = self.cache[key]\\n        self.freq_to_dll[d.freq].remove(d.node)\\n        self.freq_to_dll[d.freq + 1].append(d.node)\\n        self.cache[key] = LFUCache.Data(key, d.value, d.freq + 1, d.node)\\n        self.min_freq += self.min_freq == d.freq and not self.freq_to_dll[d.freq]\\n\\n        return d.value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n\\n        if key in self.cache:\\n            self.cache[key].value = value\\n            self.get(key)\\n            return\\n\\n        if self.used == self.capacity:\\n            mf_dll = self.freq_to_dll[self.min_freq]\\n            mf_lru_key = mf_dll.popleft().value\\n            self.cache.pop(mf_lru_key)\\n            self.used -= 1\\n\\n        d = LFUCache.Data(key, value, 1, DLLNode(key))\\n        self.freq_to_dll[d.freq].append(d.node)\\n        self.cache[key] = d\\n        self.used += 1\\n        self.min_freq = 1\\n\\n\\nclass DoublyLinkedList:\\n\\n    def __init__(self):\\n        self.head, self.tail = DLLNode(), DLLNode()\\n        self.head.next, self.tail.prev = self.tail, self.head\\n\\n    def append(self, node: DLLNode) -> None:\\n        a, b, c = self.tail.prev, node, self.tail\\n        a.next, c.prev = b, b\\n        b.next, b.prev = c, a\\n\\n    def appendleft(self, node: DLLNode) -> None: raise NotImplementedError()\\n\\n    def pop(self) -> DLLNode: raise NotImplementedError()\\n\\n    def popleft(self) -> DLLNode:\\n        node = self.head.next\\n        self.remove(node)\\n        return node\\n\\n    def remove(self, node: DLLNode) -> None:\\n        a, b, c = node.prev, node, node.next\\n        a.next, c.prev = c, a\\n        b.next, b.prev = None, None\\n\\n    def __bool__(self) -> bool:\\n        return self.head.next != self.tail\\n\\n    def __iter__(self): raise NotImplementedError()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114358,
                "title": "python3-859-ms-faster-than-79-52-of-python3",
                "content": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.time = 0\\n        self.map = {}              \\n        self.freq_time = {}         \\n        self.priority_queue = []    \\n        self.update = set()\\n\\n    def get(self, key: int) -> int:\\n        self.time += 1\\n\\n        if key in self.map:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n            return self.map[key]\\n        \\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return \\n        self.time += 1\\n        if not key in self.map:\\n            if len(self.map) >= self.capacity:    \\n                while self.priority_queue and self.priority_queue[0][2] in self.update:\\n                    _, _, k = heapq.heappop(self.priority_queue)\\n                    f, t = self.freq_time[k]\\n                    heapq.heappush(self.priority_queue, (f, t, k))\\n                    self.update.remove(k)\\n                _, _, k = heapq.heappop(self.priority_queue)\\n                self.map.pop(k)\\n                self.freq_time.pop(k)\\n            self.freq_time[key] = (0, self.time)\\n            heapq.heappush(self.priority_queue, (0, self.time, key))\\n        else:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n\\n        self.map[key] = value\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.time = 0\\n        self.map = {}              \\n        self.freq_time = {}         \\n        self.priority_queue = []    \\n        self.update = set()\\n\\n    def get(self, key: int) -> int:\\n        self.time += 1\\n\\n        if key in self.map:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n            return self.map[key]\\n        \\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return \\n        self.time += 1\\n        if not key in self.map:\\n            if len(self.map) >= self.capacity:    \\n                while self.priority_queue and self.priority_queue[0][2] in self.update:\\n                    _, _, k = heapq.heappop(self.priority_queue)\\n                    f, t = self.freq_time[k]\\n                    heapq.heappush(self.priority_queue, (f, t, k))\\n                    self.update.remove(k)\\n                _, _, k = heapq.heappop(self.priority_queue)\\n                self.map.pop(k)\\n                self.freq_time.pop(k)\\n            self.freq_time[key] = (0, self.time)\\n            heapq.heappush(self.priority_queue, (0, self.time, key))\\n        else:\\n            freq, _ = self.freq_time[key]\\n            self.freq_time[key] = (freq + 1, self.time) \\n            self.update.add(key)\\n\\n        self.map[key] = value\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112183,
                "title": "python-hashmap-doubly-linked-list-daily-challenge-jan-day-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconsider what kind of data structure do we need?\\n1. we need to store key & value\\n2. we need to know the relation between key & frequency\\n3. if exceed capacity, we need to know the minimum frequency and least recently used node and remove it\\n4. we need to be able to add/delete key-value pair efficiently.\\n\\nthink LRU cache, if we want to add/delete node with O(1) complexity, we can achieve by using hashmap with doubly linked list.\\n\\nthus, we can think each frequency owns a linked list and we store key-value as node in it.\\n\\nand for each frequency list:\\n`head -> most recently used node -> ... -> least recently used node -> tail`\\n\\nbecause we need to remove least recently used node among all the frequency lists if capacity exceed limit, we maintain a `self.min` variable for us to find target list in O(1) operation.\\n\\n\\n#### Summary\\n```\\nhashmap ->  doubly linked-list\\nfreq1 ->  [key1, key2, key3...]  -> min freq\\nfreq2 ->  [key1, key2, key3...]\\nfreq3 ->  [key1, key2, key3...]\\n\\nself.min -> for removing least recently used node\\n```\\n\\n# Approach\\n\\njust remember to update these 4 varaible for `get` and `put` operation:\\n\\n- self.freq2node: store frequency lists\\n- self.key2node: store each key-value pair in cache\\n- self.key2freq: store frequency of each key-value pair\\n- self.min: store current minimum frequency\\n\\n1. `get`\\n    1. if not exists in cache, return `-1`\\n    2. return value from cache and update its frequency\\n    3. update self.min if needed\\n\\n2. `put`\\n    1. check edge case: `capacity = 0`\\n    2. if key already exists in cache, update value and its frequency. just like what we do in `get` operation\\n    3. if it\\'s a new key-value pair:\\n        1. remove recenly used node if capacity is full\\n        2. create a node to store key-value\\n        2. set frequency to 1\\n        3. insert to freqeuncy list\\n        3. set self.min to 1\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(capacity)$$\\n\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = self.prev = None\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n\\n        def initList():\\n            root = ListNode(-1, -1)\\n            root.next = root.prev = root\\n            return root\\n        self.freq2node = defaultdict(initList)\\n        self.key2node = {}\\n        self.key2freq = defaultdict(lambda: 1)\\n        self.min = 1\\n\\n    def _insertAfter(self, target, node):\\n        node.prev = target\\n        node.next = target.next\\n        node.next.prev = node\\n        node.prev.next = node\\n\\n    def _remove(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = node.prev = None\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key2node: return -1\\n\\n        node = self.key2node[key]\\n        val = node.val\\n        \\n        freq = self.key2freq[key]\\n        self.key2freq[key] = freq + 1\\n        \\n        self._remove(node)\\n        self._insertAfter(self.freq2node[freq+1], node)\\n        \\n        if self.freq2node[self.min].next.key == -1:\\n            self.min = freq+1\\n        \\n        return val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.cap == 0: return\\n        if key in self.key2node:\\n            node = self.key2node[key]\\n            node.val = value\\n            \\n            freq = self.key2freq[key]\\n            self.key2freq[key] = freq+1\\n            self._remove(node)\\n            self._insertAfter(self.freq2node[freq+1], node)\\n            if self.freq2node[self.min].next.key == -1:\\n                self.min = freq+1\\n            return\\n\\n        node = ListNode(key, value)\\n        if len(self.key2node) ==  self.cap:\\n            lru = self.freq2node[self.min].prev\\n            self._remove(lru)\\n            del self.key2node[lru.key]\\n            del self.key2freq[lru.key]\\n\\n        self.key2node[key] = node\\n        self.key2freq[key] = 1\\n        self._insertAfter(self.freq2node[1], node)\\n        self.min = 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nhashmap ->  doubly linked-list\\nfreq1 ->  [key1, key2, key3...]  -> min freq\\nfreq2 ->  [key1, key2, key3...]\\nfreq3 ->  [key1, key2, key3...]\\n\\nself.min -> for removing least recently used node\\n```\n```\\nclass ListNode:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = self.prev = None\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n\\n        def initList():\\n            root = ListNode(-1, -1)\\n            root.next = root.prev = root\\n            return root\\n        self.freq2node = defaultdict(initList)\\n        self.key2node = {}\\n        self.key2freq = defaultdict(lambda: 1)\\n        self.min = 1\\n\\n    def _insertAfter(self, target, node):\\n        node.prev = target\\n        node.next = target.next\\n        node.next.prev = node\\n        node.prev.next = node\\n\\n    def _remove(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = node.prev = None\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key2node: return -1\\n\\n        node = self.key2node[key]\\n        val = node.val\\n        \\n        freq = self.key2freq[key]\\n        self.key2freq[key] = freq + 1\\n        \\n        self._remove(node)\\n        self._insertAfter(self.freq2node[freq+1], node)\\n        \\n        if self.freq2node[self.min].next.key == -1:\\n            self.min = freq+1\\n        \\n        return val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.cap == 0: return\\n        if key in self.key2node:\\n            node = self.key2node[key]\\n            node.val = value\\n            \\n            freq = self.key2freq[key]\\n            self.key2freq[key] = freq+1\\n            self._remove(node)\\n            self._insertAfter(self.freq2node[freq+1], node)\\n            if self.freq2node[self.min].next.key == -1:\\n                self.min = freq+1\\n            return\\n\\n        node = ListNode(key, value)\\n        if len(self.key2node) ==  self.cap:\\n            lru = self.freq2node[self.min].prev\\n            self._remove(lru)\\n            del self.key2node[lru.key]\\n            del self.key2freq[lru.key]\\n\\n        self.key2node[key] = node\\n        self.key2freq[key] = 1\\n        self._insertAfter(self.freq2node[1], node)\\n        self.min = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984277,
                "title": "python-heap",
                "content": "1. Use a ever increasing variable `self.timestamp` to record the time we `get` or `put` a `key`,  \\n2. Use a Counter `self.counts` to record the counts we used a `key`\\n3. Use a heap `self.pq`  of (`count, timestamp, key`)  to pop the least frequent used `key`\\n4. Use a dict `self.time` to record the last time we use the `key`\\n3. Update the `self.time` ,  `self.pq` , `self.counts`  when we `get` or `put`\\n\\n```python\\nfrom collections import Counter\\nimport heapq\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.timestamp = 0\\n        self.pq = []  # record (count, timestamp, key)\\n        self.keys = dict()\\n        self.time = dict()\\n        self.counts = Counter()\\n        self.capacity = capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.keys:\\n            self.timestamp += 1\\n            self.counts[key] += 1\\n            self.time[key] = self.timestamp\\n            heapq.heappush(self.pq, (self.counts[key], self.time[key], key))\\n            # print(self.keys)\\n            return self.keys[key]\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return None\\n        self.timestamp += 1\\n        if len(self.keys) == self.capacity and key not in self.keys:  # pop the least recent used keys\\n            while self.pq and (self.pq[0][2] not in self.keys or self.pq[0][1] < self.time[self.pq[0][2]]):  # key not in keys or key have used after the timestamp\\n                heapq.heappop(self.pq)\\n            _, _, pre_key = heapq.heappop(self.pq)\\n            del self.keys[pre_key]\\n            del self.time[pre_key]\\n            del self.counts[pre_key]\\n        self.keys[key] = value\\n        self.time[key] = self.timestamp\\n        self.counts[key] += 1\\n        heapq.heappush(self.pq, (self.counts[key], self.time[key], key))\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\nimport heapq\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.timestamp = 0\\n        self.pq = []  # record (count, timestamp, key)\\n        self.keys = dict()\\n        self.time = dict()\\n        self.counts = Counter()\\n        self.capacity = capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.keys:\\n            self.timestamp += 1\\n            self.counts[key] += 1\\n            self.time[key] = self.timestamp\\n            heapq.heappush(self.pq, (self.counts[key], self.time[key], key))\\n            # print(self.keys)\\n            return self.keys[key]\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return None\\n        self.timestamp += 1\\n        if len(self.keys) == self.capacity and key not in self.keys:  # pop the least recent used keys\\n            while self.pq and (self.pq[0][2] not in self.keys or self.pq[0][1] < self.time[self.pq[0][2]]):  # key not in keys or key have used after the timestamp\\n                heapq.heappop(self.pq)\\n            _, _, pre_key = heapq.heappop(self.pq)\\n            del self.keys[pre_key]\\n            del self.time[pre_key]\\n            del self.counts[pre_key]\\n        self.keys[key] = value\\n        self.time[key] = self.timestamp\\n        self.counts[key] += 1\\n        heapq.heappush(self.pq, (self.counts[key], self.time[key], key))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586277,
                "title": "short-and-easy-to-understand-java-o-1-solution-using-hashmap",
                "content": "```\\nclass LFUCache {\\n    private Map<Integer, Integer> keyToValueMap;\\n    private Map<Integer, Integer> keyToCountMap;\\n    private Map<Integer, LinkedHashSet<Integer>> countToKeysMap;\\n    private int capacity;\\n    private int minCount;\\n\\n    public LFUCache(int capacity) {\\n        this.keyToValueMap = new HashMap<>();\\n        this.keyToCountMap = new HashMap<>();\\n        this.countToKeysMap = new HashMap<>();\\n        this.countToKeysMap.put(1, new LinkedHashSet<>());\\n        this.capacity = capacity;\\n        this.minCount = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToValueMap.containsKey(key)) return -1;\\n        int count = keyToCountMap.get(key);\\n        keyToCountMap.put(key, count + 1);\\n        countToKeysMap.get(count).remove(key);\\n        if (!countToKeysMap.containsKey(count + 1)) countToKeysMap.put(count + 1, new LinkedHashSet<>());\\n        countToKeysMap.get(count + 1).add(key);\\n        if (count == minCount && countToKeysMap.get(count).isEmpty()) minCount++;\\n        return keyToValueMap.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (keyToValueMap.containsKey(key)) {\\n            keyToValueMap.put(key, value);\\n            get(key);\\n            return;\\n        }\\n        if (keyToValueMap.size() == capacity) {\\n            int keyToRemove = countToKeysMap.get(minCount).iterator().next();\\n            keyToValueMap.remove(keyToRemove);\\n            keyToCountMap.remove(keyToRemove);\\n            countToKeysMap.get(minCount).remove(keyToRemove);\\n        }\\n        minCount = 1;\\n        keyToValueMap.put(key, value);\\n        keyToCountMap.put(key, 1);\\n        countToKeysMap.get(1).add(key);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    private Map<Integer, Integer> keyToValueMap;\\n    private Map<Integer, Integer> keyToCountMap;\\n    private Map<Integer, LinkedHashSet<Integer>> countToKeysMap;\\n    private int capacity;\\n    private int minCount;\\n\\n    public LFUCache(int capacity) {\\n        this.keyToValueMap = new HashMap<>();\\n        this.keyToCountMap = new HashMap<>();\\n        this.countToKeysMap = new HashMap<>();\\n        this.countToKeysMap.put(1, new LinkedHashSet<>());\\n        this.capacity = capacity;\\n        this.minCount = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToValueMap.containsKey(key)) return -1;\\n        int count = keyToCountMap.get(key);\\n        keyToCountMap.put(key, count + 1);\\n        countToKeysMap.get(count).remove(key);\\n        if (!countToKeysMap.containsKey(count + 1)) countToKeysMap.put(count + 1, new LinkedHashSet<>());\\n        countToKeysMap.get(count + 1).add(key);\\n        if (count == minCount && countToKeysMap.get(count).isEmpty()) minCount++;\\n        return keyToValueMap.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (keyToValueMap.containsKey(key)) {\\n            keyToValueMap.put(key, value);\\n            get(key);\\n            return;\\n        }\\n        if (keyToValueMap.size() == capacity) {\\n            int keyToRemove = countToKeysMap.get(minCount).iterator().next();\\n            keyToValueMap.remove(keyToRemove);\\n            keyToCountMap.remove(keyToRemove);\\n            countToKeysMap.get(minCount).remove(keyToRemove);\\n        }\\n        minCount = 1;\\n        keyToValueMap.put(key, value);\\n        keyToCountMap.put(key, 1);\\n        countToKeysMap.get(1).add(key);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543658,
                "title": "c-solution",
                "content": "```\\n       public class LFUCache\\n       {\\n            private int _capacity = 0;\\n            private Dictionary<int, LinkedList<int[]>> _frequencyList = new Dictionary<int, LinkedList<int[]>>();\\n            private Dictionary<int, LinkedListNode<int[]>> _cache = new Dictionary<int, LinkedListNode<int[]>>();\\n\\n            public LFUCache(int capacity)\\n            {\\n                _capacity = capacity;\\n            }\\n\\n            public int Get(int key)\\n            {\\n                if (!_cache.ContainsKey(key))\\n                    return -1;\\n                else\\n                {\\n                    _cache[key].Value[1] += 1;\\n                    Reorder(_cache[key]);\\n                }\\n\\n                return _cache[key].Value[2];\\n            }\\n\\n            public void Put(int key, int value)\\n            {\\n                if (_capacity == 0)\\n                    return;\\n\\n                if (_cache.ContainsKey(key))\\n                    _cache[key].Value[2] = value;\\n                else\\n                {\\n                    _cache.Add(key, new LinkedListNode<int[]>(new int[] { key, -1, value }));\\n\\n                    if (_cache.Count > _capacity)\\n                    {\\n                        int min = _frequencyList.Keys.Min();\\n\\n                        _cache.Remove(_frequencyList[min].Last.Value[0]);\\n                        _frequencyList[min].RemoveLast();\\n\\n                        if (_frequencyList[min].Count == 1)\\n                            _frequencyList.Remove(min);\\n                    }\\n                }\\n\\n                _cache[key].Value[1] += 1;\\n                Reorder(_cache[key]);\\n            }\\n\\n            private void Reorder(LinkedListNode<int[]> item)\\n            {\\n                if (item.Previous != null)\\n                {\\n                    _frequencyList[item.Value[1] - 1].Remove(item);\\n\\n                    if (_frequencyList[item.Value[1] - 1].Count == 1)\\n                        _frequencyList.Remove(item.Value[1] - 1);\\n                }\\n\\n                if (!_frequencyList.ContainsKey(item.Value[1]))\\n                {\\n                    _frequencyList.Add(item.Value[1], new LinkedList<int[]>());\\n                    _frequencyList[item.Value[1]].AddFirst(new int[] { Int32.MinValue, Int32.MinValue, Int32.MinValue });\\n                }\\n\\n                _frequencyList[item.Value[1]].AddAfter(_frequencyList[item.Value[1]].First, item);\\n            }\\n        }",
                "solutionTags": [],
                "code": "```\\n       public class LFUCache\\n       {\\n            private int _capacity = 0;\\n            private Dictionary<int, LinkedList<int[]>> _frequencyList = new Dictionary<int, LinkedList<int[]>>();\\n            private Dictionary<int, LinkedListNode<int[]>> _cache = new Dictionary<int, LinkedListNode<int[]>>();\\n\\n            public LFUCache(int capacity)\\n            {\\n                _capacity = capacity;\\n            }\\n\\n            public int Get(int key)\\n            {\\n                if (!_cache.ContainsKey(key))\\n                    return -1;\\n                else\\n                {\\n                    _cache[key].Value[1] += 1;\\n                    Reorder(_cache[key]);\\n                }\\n\\n                return _cache[key].Value[2];\\n            }\\n\\n            public void Put(int key, int value)\\n            {\\n                if (_capacity == 0)\\n                    return;\\n\\n                if (_cache.ContainsKey(key))\\n                    _cache[key].Value[2] = value;\\n                else\\n                {\\n                    _cache.Add(key, new LinkedListNode<int[]>(new int[] { key, -1, value }));\\n\\n                    if (_cache.Count > _capacity)\\n                    {\\n                        int min = _frequencyList.Keys.Min();\\n\\n                        _cache.Remove(_frequencyList[min].Last.Value[0]);\\n                        _frequencyList[min].RemoveLast();\\n\\n                        if (_frequencyList[min].Count == 1)\\n                            _frequencyList.Remove(min);\\n                    }\\n                }\\n\\n                _cache[key].Value[1] += 1;\\n                Reorder(_cache[key]);\\n            }\\n\\n            private void Reorder(LinkedListNode<int[]> item)\\n            {\\n                if (item.Previous != null)\\n                {\\n                    _frequencyList[item.Value[1] - 1].Remove(item);\\n\\n                    if (_frequencyList[item.Value[1] - 1].Count == 1)\\n                        _frequencyList.Remove(item.Value[1] - 1);\\n                }\\n\\n                if (!_frequencyList.ContainsKey(item.Value[1]))\\n                {\\n                    _frequencyList.Add(item.Value[1], new LinkedList<int[]>());\\n                    _frequencyList[item.Value[1]].AddFirst(new int[] { Int32.MinValue, Int32.MinValue, Int32.MinValue });\\n                }\\n\\n                _frequencyList[item.Value[1]].AddAfter(_frequencyList[item.Value[1]].First, item);\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 510984,
                "title": "c-unordered-map-tuple-easy-to-understand",
                "content": "```\\nclass LFUCache {\\npublic:\\n    typedef unordered_map<int, list<int>> FreqList;\\n    typedef unordered_map<int, tuple<int, int, list<int>::iterator>> Cache;\\n    \\n    FreqList    freq;\\n    Cache       cache;\\n    \\n    int minFreq;\\n    int maxSize;\\n    \\n    LFUCache(int capacity) : maxSize(capacity)\\n    {\\n        \\n    }\\n    \\n    void update(int key)\\n    {\\n        auto& f = ::get<1>(cache[key]);\\n        auto& i = ::get<2>(cache[key]);\\n        \\n        freq[f].erase(i);\\n        if (freq[f].empty() && minFreq == f)\\n            minFreq++;\\n        \\n        f = f + 1;\\n        i = freq[f].insert(freq[f].begin(), key);\\n    }\\n    \\n    int get(int key)\\n    {\\n        if (cache.count(key) == 0)\\n            return -1;\\n        \\n        update(key);\\n        \\n        return ::get<0>(cache[key]);\\n    }\\n    \\n    void put(int key, int value)\\n    {\\n        if (maxSize <= 0)\\n            return;\\n        \\n        if (cache.count(key))\\n        {\\n            update(key);\\n            ::get<0>(cache[key]) = value;\\n            \\n            return;\\n        }\\n        \\n        if (cache.size() == maxSize)\\n        {\\n            cache.erase(freq[minFreq].back());\\n            freq[minFreq].pop_back();\\n        }\\n    \\n        minFreq = 1;\\n        freq[minFreq].push_front(key);\\n        \\n        cache[key] = make_tuple( value, minFreq, freq[minFreq].begin() ); \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    typedef unordered_map<int, list<int>> FreqList;\\n    typedef unordered_map<int, tuple<int, int, list<int>::iterator>> Cache;\\n    \\n    FreqList    freq;\\n    Cache       cache;\\n    \\n    int minFreq;\\n    int maxSize;\\n    \\n    LFUCache(int capacity) : maxSize(capacity)\\n    {\\n        \\n    }\\n    \\n    void update(int key)\\n    {\\n        auto& f = ::get<1>(cache[key]);\\n        auto& i = ::get<2>(cache[key]);\\n        \\n        freq[f].erase(i);\\n        if (freq[f].empty() && minFreq == f)\\n            minFreq++;\\n        \\n        f = f + 1;\\n        i = freq[f].insert(freq[f].begin(), key);\\n    }\\n    \\n    int get(int key)\\n    {\\n        if (cache.count(key) == 0)\\n            return -1;\\n        \\n        update(key);\\n        \\n        return ::get<0>(cache[key]);\\n    }\\n    \\n    void put(int key, int value)\\n    {\\n        if (maxSize <= 0)\\n            return;\\n        \\n        if (cache.count(key))\\n        {\\n            update(key);\\n            ::get<0>(cache[key]) = value;\\n            \\n            return;\\n        }\\n        \\n        if (cache.size() == maxSize)\\n        {\\n            cache.erase(freq[minFreq].back());\\n            freq[minFreq].pop_back();\\n        }\\n    \\n        minFreq = 1;\\n        freq[minFreq].push_front(key);\\n        \\n        cache[key] = make_tuple( value, minFreq, freq[minFreq].begin() ); \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 315216,
                "title": "java-o-1-solution-with-comments",
                "content": "```\\npublic class LFUCache {\\n\\n      HashMap<Integer, Integer> valuesCache;// cache Key and Value\\n      HashMap<Integer, Integer> countsCache;// Key and counters\\n      HashMap<Integer, LinkedHashSet<Integer>> lists;// Counter and item list\\n      int size; // \\u041C\\u0430x capacity\\n      int min = -1; // Track current min\\n\\n      public LFUCache(int capacity) {\\n         size = capacity;\\n         valuesCache = new HashMap<>();\\n         countsCache = new HashMap<>();\\n         lists = new HashMap<>();\\n         lists.put(1, new LinkedHashSet<>());\\n      }\\n\\n      public int get(int key) {\\n         if (!valuesCache.containsKey(key)) {\\n            return -1;\\n         }\\n         // Get the count from countsCache map\\n         int count = countsCache.get(key);\\n         // increase the counter\\n         countsCache.put(key, count + 1);\\n         // remove the element from the counter to linkedhashset\\n         lists.get(count).remove(key);\\n\\n         // when current min does not have any data, next one would be the min\\n         if (count == min && lists.get(count).size() == 0) {\\n            min++;\\n         }\\n         if (!lists.containsKey(count + 1)) {\\n            lists.put(count + 1, new LinkedHashSet<>());\\n         }\\n         lists.get(count + 1).add(key);\\n\\n         return valuesCache.get(key);\\n      }\\n\\n      public void put(int key, int value) {\\n         if (size <= 0) {\\n            return;\\n         }\\n         // If key does exist, we are returning from here\\n         if (valuesCache.containsKey(key)) {\\n            valuesCache.put(key, value); // Update the value if needed\\n            get(key);\\n            return;\\n         }\\n         if (valuesCache.size() >= size) {\\n            int entryToRemove = lists.get(min).iterator().next();\\n            lists.get(min).remove(entryToRemove);\\n            valuesCache.remove(entryToRemove);\\n            countsCache.remove(entryToRemove);\\n         }\\n         // If the key is new, insert the value and current min should be 1 of course\\n         valuesCache.put(key, value);\\n         countsCache.put(key, 1);\\n         min = 1; // As this is new key, it can occur only once here\\n         lists.get(1).add(key);\\n      }\\n   }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LFUCache {\\n\\n      HashMap<Integer, Integer> valuesCache;// cache Key and Value\\n      HashMap<Integer, Integer> countsCache;// Key and counters\\n      HashMap<Integer, LinkedHashSet<Integer>> lists;// Counter and item list\\n      int size; // \\u041C\\u0430x capacity\\n      int min = -1; // Track current min\\n\\n      public LFUCache(int capacity) {\\n         size = capacity;\\n         valuesCache = new HashMap<>();\\n         countsCache = new HashMap<>();\\n         lists = new HashMap<>();\\n         lists.put(1, new LinkedHashSet<>());\\n      }\\n\\n      public int get(int key) {\\n         if (!valuesCache.containsKey(key)) {\\n            return -1;\\n         }\\n         // Get the count from countsCache map\\n         int count = countsCache.get(key);\\n         // increase the counter\\n         countsCache.put(key, count + 1);\\n         // remove the element from the counter to linkedhashset\\n         lists.get(count).remove(key);\\n\\n         // when current min does not have any data, next one would be the min\\n         if (count == min && lists.get(count).size() == 0) {\\n            min++;\\n         }\\n         if (!lists.containsKey(count + 1)) {\\n            lists.put(count + 1, new LinkedHashSet<>());\\n         }\\n         lists.get(count + 1).add(key);\\n\\n         return valuesCache.get(key);\\n      }\\n\\n      public void put(int key, int value) {\\n         if (size <= 0) {\\n            return;\\n         }\\n         // If key does exist, we are returning from here\\n         if (valuesCache.containsKey(key)) {\\n            valuesCache.put(key, value); // Update the value if needed\\n            get(key);\\n            return;\\n         }\\n         if (valuesCache.size() >= size) {\\n            int entryToRemove = lists.get(min).iterator().next();\\n            lists.get(min).remove(entryToRemove);\\n            valuesCache.remove(entryToRemove);\\n            countsCache.remove(entryToRemove);\\n         }\\n         // If the key is new, insert the value and current min should be 1 of course\\n         valuesCache.put(key, value);\\n         countsCache.put(key, 1);\\n         min = 1; // As this is new key, it can occur only once here\\n         lists.get(1).add(key);\\n      }\\n   }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94523,
                "title": "concise-python-o-1-beats-95-using-two-maps",
                "content": "Two hashmaps: the freq_map keeps track of freq-> linked list of node.\\nkey_map tracks key->val\\n\\n```\\nPREV,NEXT,KEY,VAL,FREQ = 0,1,2,3,4\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.freq_map = {}\\n        self.key_map = {}\\n        self.min_freq = 1\\n\\n    def get(self, key):\\n        key_map, freq_map = self.key_map, self.freq_map\\n        if key not in key_map:\\n            return -1\\n        else:\\n            val_node = key_map[key]\\n            val_node[PREV][NEXT],val_node[NEXT][PREV] = val_node[NEXT],val_node[PREV]\\n            if freq_map[self.min_freq] is freq_map[self.min_freq][NEXT]:\\n                self.min_freq+=1\\n            freq = val_node[FREQ]\\n            root = freq_map.setdefault(freq+1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,freq+1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            val_node[FREQ]+=1\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            return key_map[key][VAL]\\n\\n    def set(self, key, value):\\n        key_map, freq_map, cap = self.key_map, self.freq_map, self.capacity\\n        if not cap:\\n            return\\n        if key in key_map:\\n            key_map[key][VAL] = value\\n            self.get(key)\\n        else:\\n            if len(key_map) == cap:\\n                root = freq_map[self.min_freq]\\n                node_evict = root[NEXT]\\n                root[NEXT],node_evict[NEXT][PREV] = node_evict[NEXT], root\\n                del key_map[node_evict[KEY]]\\n            self.min_freq = 1\\n            val_node = [None,None,key,value,1]\\n            root = freq_map.setdefault(1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            key_map[key] = val_node\\n```",
                "solutionTags": [],
                "code": "```\\nPREV,NEXT,KEY,VAL,FREQ = 0,1,2,3,4\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.freq_map = {}\\n        self.key_map = {}\\n        self.min_freq = 1\\n\\n    def get(self, key):\\n        key_map, freq_map = self.key_map, self.freq_map\\n        if key not in key_map:\\n            return -1\\n        else:\\n            val_node = key_map[key]\\n            val_node[PREV][NEXT],val_node[NEXT][PREV] = val_node[NEXT],val_node[PREV]\\n            if freq_map[self.min_freq] is freq_map[self.min_freq][NEXT]:\\n                self.min_freq+=1\\n            freq = val_node[FREQ]\\n            root = freq_map.setdefault(freq+1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,freq+1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            val_node[FREQ]+=1\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            return key_map[key][VAL]\\n\\n    def set(self, key, value):\\n        key_map, freq_map, cap = self.key_map, self.freq_map, self.capacity\\n        if not cap:\\n            return\\n        if key in key_map:\\n            key_map[key][VAL] = value\\n            self.get(key)\\n        else:\\n            if len(key_map) == cap:\\n                root = freq_map[self.min_freq]\\n                node_evict = root[NEXT]\\n                root[NEXT],node_evict[NEXT][PREV] = node_evict[NEXT], root\\n                del key_map[node_evict[KEY]]\\n            self.min_freq = 1\\n            val_node = [None,None,key,value,1]\\n            root = freq_map.setdefault(1,[])\\n            if not root:\\n                root[:] = [root,root,None,None,1]\\n            val_node[PREV],val_node[NEXT] = root[PREV],root\\n            root[PREV][NEXT] = root[PREV] = val_node\\n            key_map[key] = val_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94660,
                "title": "short-java-o-1-solution-using-linkedhashmap-and-hashmap-with-explaination",
                "content": "The basic idea is to keep two maps:\\n1) keyToFreq: key -> frequency\\n2) freqToEntry: frequency -> (key,value) pairs with the same frequency, in LRU order (using LinkedHashMap)\\n\\nAnother important idea is to store and update the current minimum frequency. When it reaches the capacity, I remove the oldest entry from freqToEntry.get(min), and the next minimum frequency will be 1.\\n\\nHere is my code: \\n\\n```\\npublic class LFUCache {\\n\\n    Map<Integer, LinkedHashMap<Integer, Integer>> freqToEntry;\\n    Map<Integer, Integer> keyToFreq;\\n    int capacity;\\n    int min;\\n\\n    public LFUCache(int capacity) {\\n        freqToEntry = new HashMap<>();\\n        keyToFreq = new HashMap<>();\\n        this.capacity = capacity;\\n        this.min = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if(capacity==0 || !keyToFreq.containsKey(key)) {\\n            return -1;\\n        }else{\\n            int freq = keyToFreq.get(key);\\n            int value = freqToEntry.get(freq).get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToEntry.get(freq).remove(key);\\n            freqToEntry.computeIfAbsent(freq+1, x->new LinkedHashMap<>()).put(key, value);\\n            if(freq==min && freqToEntry.get(freq).size()==0) min = min+1;\\n            return value;\\n        }\\n    }\\n    \\n    public void set(int key, int value) {\\n        if(capacity==0) return;\\n        if(keyToFreq.containsKey(key)){\\n            int freq = keyToFreq.get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToEntry.get(freq).remove(key);\\n            freqToEntry.computeIfAbsent(freq+1, x->new LinkedHashMap<>()).put(key, value);\\n            if(freq==min && freqToEntry.get(freq).size()==0) min = min+1;\\n        }else{\\n            if(keyToFreq.size()==capacity) removeOldest();\\n            keyToFreq.put(key, 1);\\n            freqToEntry.computeIfAbsent(1, x->new LinkedHashMap<>()).put(key, value);\\n            min = 1;\\n        }\\n    }\\n    \\n    private void removeOldest(){\\n        int rmKey = freqToEntry.get(min).keySet().iterator().next();\\n        keyToFreq.remove(rmKey);\\n        freqToEntry.get(min).remove(rmKey);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LFUCache {\\n\\n    Map<Integer, LinkedHashMap<Integer, Integer>> freqToEntry;\\n    Map<Integer, Integer> keyToFreq;\\n    int capacity;\\n    int min;\\n\\n    public LFUCache(int capacity) {\\n        freqToEntry = new HashMap<>();\\n        keyToFreq = new HashMap<>();\\n        this.capacity = capacity;\\n        this.min = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if(capacity==0 || !keyToFreq.containsKey(key)) {\\n            return -1;\\n        }else{\\n            int freq = keyToFreq.get(key);\\n            int value = freqToEntry.get(freq).get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToEntry.get(freq).remove(key);\\n            freqToEntry.computeIfAbsent(freq+1, x->new LinkedHashMap<>()).put(key, value);\\n            if(freq==min && freqToEntry.get(freq).size()==0) min = min+1;\\n            return value;\\n        }\\n    }\\n    \\n    public void set(int key, int value) {\\n        if(capacity==0) return;\\n        if(keyToFreq.containsKey(key)){\\n            int freq = keyToFreq.get(key);\\n            keyToFreq.put(key, freq+1);\\n            freqToEntry.get(freq).remove(key);\\n            freqToEntry.computeIfAbsent(freq+1, x->new LinkedHashMap<>()).put(key, value);\\n            if(freq==min && freqToEntry.get(freq).size()==0) min = min+1;\\n        }else{\\n            if(keyToFreq.size()==capacity) removeOldest();\\n            keyToFreq.put(key, 1);\\n            freqToEntry.computeIfAbsent(1, x->new LinkedHashMap<>()).put(key, value);\\n            min = 1;\\n        }\\n    }\\n    \\n    private void removeOldest(){\\n        int rmKey = freqToEntry.get(min).keySet().iterator().next();\\n        keyToFreq.remove(rmKey);\\n        freqToEntry.get(min).remove(rmKey);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94593,
                "title": "c-solution-using-hash-table-and-binary-search-tree",
                "content": "I use the hash table to search for the cache node with the key and  the binary search tree to keep the order of cache nodes with frequency. \\nAll the operations require O(log N) complexity.\\n\\n```\\nstruct CacheNode{\\n    int key;\\n    int val;\\n    int freq;\\n    CacheNode(int k, int v):freq(1), key(k), val(v){}\\n};\\n\\nstruct Compare{\\n    bool operator()(const CacheNode& a, const CacheNode& b){\\n        return a.freq < b.freq;\\n    }\\n};\\n\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n    }\\n    \\n    int get(int key) {\\n        auto it = cacheMap.find(key);\\n        if (size == 0 || it == cacheMap.end()) return -1;\\n        CacheNode temp = *(it->second);\\n        temp.freq++;\\n        cacheSet.erase(it->second);\\n        cacheMap[key] = cacheSet.insert(temp);\\n        return temp.val;\\n    }\\n    \\n    void set(int key, int value) {\\n        if(size == 0) return;\\n        auto it = cacheMap.find(key);\\n        if (it == cacheMap.end()){\\n            if(cacheMap.size() == size){\\n                cacheMap.erase((cacheSet.begin())->key);\\n                cacheSet.erase(cacheSet.begin());\\n            }\\n            CacheNode temp = CacheNode(key, value);\\n            cacheMap[key] = cacheSet.insert(temp);\\n            return;\\n        }\\n        CacheNode temp = *(it->second);\\n        temp.freq++;\\n        temp.val = value;\\n        cacheSet.erase(it->second);\\n        cacheMap[key] = cacheSet.insert(temp);\\n    }\\n    \\nprivate:\\n    int size;\\n    std::multiset<CacheNode, Compare> cacheSet;\\n    unordered_map<int, std::multiset<CacheNode, Compare>::iterator> cacheMap;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct CacheNode{\\n    int key;\\n    int val;\\n    int freq;\\n    CacheNode(int k, int v):freq(1), key(k), val(v){}\\n};\\n\\nstruct Compare{\\n    bool operator()(const CacheNode& a, const CacheNode& b){\\n        return a.freq < b.freq;\\n    }\\n};\\n\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n    }\\n    \\n    int get(int key) {\\n        auto it = cacheMap.find(key);\\n        if (size == 0 || it == cacheMap.end()) return -1;\\n        CacheNode temp = *(it->second);\\n        temp.freq++;\\n        cacheSet.erase(it->second);\\n        cacheMap[key] = cacheSet.insert(temp);\\n        return temp.val;\\n    }\\n    \\n    void set(int key, int value) {\\n        if(size == 0) return;\\n        auto it = cacheMap.find(key);\\n        if (it == cacheMap.end()){\\n            if(cacheMap.size() == size){\\n                cacheMap.erase((cacheSet.begin())->key);\\n                cacheSet.erase(cacheSet.begin());\\n            }\\n            CacheNode temp = CacheNode(key, value);\\n            cacheMap[key] = cacheSet.insert(temp);\\n            return;\\n        }\\n        CacheNode temp = *(it->second);\\n        temp.freq++;\\n        temp.val = value;\\n        cacheSet.erase(it->second);\\n        cacheMap[key] = cacheSet.insert(temp);\\n    }\\n    \\nprivate:\\n    int size;\\n    std::multiset<CacheNode, Compare> cacheSet;\\n    unordered_map<int, std::multiset<CacheNode, Compare>::iterator> cacheMap;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006530,
                "title": "very-very-very-easy-o-1-time-complexity-sollution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<h5>This LFU (Least Frequently Used) cache implementation utilizes three unordered_maps: one for storing key-value pairs, one for mapping keys to their respective nodes in the cache, and one for maintaining frequency-level linked lists of nodes. The code efficiently updates frequencies and manages cache size, achieving O(1) average time complexity for get and put operations, with a space complexity of O(N), where N is the cache\\'s maximum capacity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<h4>here the map freq actually stores three things \\n    the key and then a pair that stores head and tail \\n    freq[n].first is actually head and \\n    freq[n].second is actually the tail \\n    for any n belonging to frequencies used \\n\\n<h4>the adress map links key to the nodes address \\n    and address can be found of any node \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naverage time complexity : o(1)\\nworse time complexity : o(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity : o(n)\\n\\n\\n# Code\\n```\\n\\nclass Node {\\npublic:\\n    int data;\\n    int occur;\\n    Node* next;\\n    Node* prev;\\n\\n    Node(int data) {\\n        this->data = data;\\n        this->occur = 1;\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\n\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, Node*> address;\\n    unordered_map<int, int> map;\\n    unordered_map<int, pair<Node*, Node*>> freq;\\n\\n    /*\\n    here the map freq actually stores three things \\n    the key and then a pair that stores head and tail \\n    freq[n].first is actually head and \\n    freq[n].second is actually the tail \\n    for any n belonging to frequencies used \\n\\n    the adress map links key to the nodes address \\n    and address can be found of any node \\n    */\\n\\n    int maxSizeCache; // stores the capacity \\n    int minFreq;      // stores the minimum frequency at that perticular time\\n    int curSize;      // stores the size at that perticular time\\n\\n    /* FUNCTION TO UPDATE THE FREQUENCY MAP ACCORDINGLY */\\n\\n    void update(Node* node) {\\n      \\n        int freqKey = node->occur;        // stores the frequency of the perticular node\\n        auto& freqList = freq[freqKey];   // pair of head and tail for perticular freq[n]\\n\\n      //STEP 1 : deleting the node \\n\\n               // case 1 : if there exists only one node in entire linked list \\n               //          at that perticular frequency \\n               if (node == freqList.first && node == freqList.second) \\n               {\\n                     freq.erase(freqKey);\\n                     if (minFreq == freqKey) \\n                     {\\n                        minFreq++;\\n                     }\\n               } \\n\\n\\n               // case 2 : if the exists node in head position in the linked list \\n               //          head pointer needs to be updated\\n               else if (node == freqList.first) \\n               {\\n                     freqList.first = node->next;\\n                     freqList.first->prev = nullptr;\\n               } \\n\\n               // case 3 : if the exists node in tail position in the linked list \\n               //          tail pointer needs to be updated\\n               else if (node == freqList.second) \\n               {\\n                     freqList.second = node->prev;\\n                     freqList.second->next = nullptr;\\n               } \\n\\n               // case 4 : exists somewhere in the midile of linked list  \\n               //          no pointer needs to beupdated just node needs to be removed       \\n               else \\n               {\\n                     node->prev->next = node->next;\\n                     node->next->prev = node->prev;\\n               }\\n\\n        // STEP 2 : updating the occurance of the node \\n        node->occur++;\\n\\n        // STEP # : inserting the node \\n\\n               // check wether the list for perticular frequency exists or not \\n\\n               //if it exists then simply add to tail \\n               if (freq.find(freqKey + 1) != freq.end()) \\n               {\\n                     auto& nextFreqList = freq[freqKey + 1];\\n                     nextFreqList.second->next = node;\\n                     node->prev = nextFreqList.second;\\n                     nextFreqList.second = node;\\n               } \\n\\n               //else create a linked list and add to the freq[n]\\n               else \\n               {\\n                     auto add = make_pair(node, node);\\n                     freq[freqKey + 1] = add;\\n               }\\n    }\\n\\npublic:\\n\\n   // constructor intiallization \\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity;\\n        minFreq = 1;\\n        curSize = 0;\\n    }\\n\\n    int get(int key) \\n    {\\n        // update the frequency map and return the value of key \\n        if (map.find(key) != map.end()) {update(address[key]);  return map[key]; } \\n        // in any othe case retuen -1 \\n        else return -1;     \\n    }\\n\\n    void put(int key, int value) \\n    {\\n        // exceptional case of 0 size \\n        if (maxSizeCache == 0) return;\\n\\n        //case 1 : key already exists then change the value and update the map \\n        if (map.find(key) != map.end()) {map[key] = value; update(address[key]);} \\n        \\n        //case 2 : new addition \\n        else \\n        {\\n            // performing deletion if size oveloads the capacity \\n\\n            if (curSize >= maxSizeCache)\\n             {\\n                \\n                auto& minFreqList = freq[minFreq]; //storing head - tail pairs \\n\\n                int keyToRemove = minFreqList.first->data; // the key value needed to remove \\n\\n                map.erase(keyToRemove); //erasing from th map (key , value) \\n\\n                address.erase(keyToRemove); //erasing address\\n\\n                //case if nothing exists after deletion in that freq[n]\\n                if (minFreqList.first == minFreqList.second) freq.erase(minFreq);\\n                \\n                // else update tail pointer normal way \\n                else \\n                {\\n                    minFreqList.first = minFreqList.first->next;\\n                    minFreqList.first->prev = nullptr;\\n                }\\n\\n                curSize--; // regulate size \\n             }\\n\\n\\n             // inserting a new element \\n            map[key] = value;   // creating (key , value) pair \\n            minFreq = 1;\\n\\n            // creation of entirely new node \\n            Node* newNode = new Node(key);\\n            address[key] = newNode;\\n\\n            // if in freq [1] there already exists an \\n            // linked list simple connect newnode and \\n            // then update tail pointer\\n\\n            if (freq.find(1) != freq.end()) \\n            {\\n                auto& firstFreqList = freq[1];\\n                firstFreqList.second->next = newNode;\\n                newNode->prev = firstFreqList.second;\\n                firstFreqList.second = newNode;\\n            } \\n           \\n            // if no element exists in freq[1]\\n            // then push a linked list in freq[1]  \\n            else \\n            {\\n                auto add = make_pair(newNode, newNode);\\n                freq[1] = add;\\n            }\\n\\n            curSize++; // incrementing for addition of an element \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Node {\\npublic:\\n    int data;\\n    int occur;\\n    Node* next;\\n    Node* prev;\\n\\n    Node(int data) {\\n        this->data = data;\\n        this->occur = 1;\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\n\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, Node*> address;\\n    unordered_map<int, int> map;\\n    unordered_map<int, pair<Node*, Node*>> freq;\\n\\n    /*\\n    here the map freq actually stores three things \\n    the key and then a pair that stores head and tail \\n    freq[n].first is actually head and \\n    freq[n].second is actually the tail \\n    for any n belonging to frequencies used \\n\\n    the adress map links key to the nodes address \\n    and address can be found of any node \\n    */\\n\\n    int maxSizeCache; // stores the capacity \\n    int minFreq;      // stores the minimum frequency at that perticular time\\n    int curSize;      // stores the size at that perticular time\\n\\n    /* FUNCTION TO UPDATE THE FREQUENCY MAP ACCORDINGLY */\\n\\n    void update(Node* node) {\\n      \\n        int freqKey = node->occur;        // stores the frequency of the perticular node\\n        auto& freqList = freq[freqKey];   // pair of head and tail for perticular freq[n]\\n\\n      //STEP 1 : deleting the node \\n\\n               // case 1 : if there exists only one node in entire linked list \\n               //          at that perticular frequency \\n               if (node == freqList.first && node == freqList.second) \\n               {\\n                     freq.erase(freqKey);\\n                     if (minFreq == freqKey) \\n                     {\\n                        minFreq++;\\n                     }\\n               } \\n\\n\\n               // case 2 : if the exists node in head position in the linked list \\n               //          head pointer needs to be updated\\n               else if (node == freqList.first) \\n               {\\n                     freqList.first = node->next;\\n                     freqList.first->prev = nullptr;\\n               } \\n\\n               // case 3 : if the exists node in tail position in the linked list \\n               //          tail pointer needs to be updated\\n               else if (node == freqList.second) \\n               {\\n                     freqList.second = node->prev;\\n                     freqList.second->next = nullptr;\\n               } \\n\\n               // case 4 : exists somewhere in the midile of linked list  \\n               //          no pointer needs to beupdated just node needs to be removed       \\n               else \\n               {\\n                     node->prev->next = node->next;\\n                     node->next->prev = node->prev;\\n               }\\n\\n        // STEP 2 : updating the occurance of the node \\n        node->occur++;\\n\\n        // STEP # : inserting the node \\n\\n               // check wether the list for perticular frequency exists or not \\n\\n               //if it exists then simply add to tail \\n               if (freq.find(freqKey + 1) != freq.end()) \\n               {\\n                     auto& nextFreqList = freq[freqKey + 1];\\n                     nextFreqList.second->next = node;\\n                     node->prev = nextFreqList.second;\\n                     nextFreqList.second = node;\\n               } \\n\\n               //else create a linked list and add to the freq[n]\\n               else \\n               {\\n                     auto add = make_pair(node, node);\\n                     freq[freqKey + 1] = add;\\n               }\\n    }\\n\\npublic:\\n\\n   // constructor intiallization \\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity;\\n        minFreq = 1;\\n        curSize = 0;\\n    }\\n\\n    int get(int key) \\n    {\\n        // update the frequency map and return the value of key \\n        if (map.find(key) != map.end()) {update(address[key]);  return map[key]; } \\n        // in any othe case retuen -1 \\n        else return -1;     \\n    }\\n\\n    void put(int key, int value) \\n    {\\n        // exceptional case of 0 size \\n        if (maxSizeCache == 0) return;\\n\\n        //case 1 : key already exists then change the value and update the map \\n        if (map.find(key) != map.end()) {map[key] = value; update(address[key]);} \\n        \\n        //case 2 : new addition \\n        else \\n        {\\n            // performing deletion if size oveloads the capacity \\n\\n            if (curSize >= maxSizeCache)\\n             {\\n                \\n                auto& minFreqList = freq[minFreq]; //storing head - tail pairs \\n\\n                int keyToRemove = minFreqList.first->data; // the key value needed to remove \\n\\n                map.erase(keyToRemove); //erasing from th map (key , value) \\n\\n                address.erase(keyToRemove); //erasing address\\n\\n                //case if nothing exists after deletion in that freq[n]\\n                if (minFreqList.first == minFreqList.second) freq.erase(minFreq);\\n                \\n                // else update tail pointer normal way \\n                else \\n                {\\n                    minFreqList.first = minFreqList.first->next;\\n                    minFreqList.first->prev = nullptr;\\n                }\\n\\n                curSize--; // regulate size \\n             }\\n\\n\\n             // inserting a new element \\n            map[key] = value;   // creating (key , value) pair \\n            minFreq = 1;\\n\\n            // creation of entirely new node \\n            Node* newNode = new Node(key);\\n            address[key] = newNode;\\n\\n            // if in freq [1] there already exists an \\n            // linked list simple connect newnode and \\n            // then update tail pointer\\n\\n            if (freq.find(1) != freq.end()) \\n            {\\n                auto& firstFreqList = freq[1];\\n                firstFreqList.second->next = newNode;\\n                newNode->prev = firstFreqList.second;\\n                firstFreqList.second = newNode;\\n            } \\n           \\n            // if no element exists in freq[1]\\n            // then push a linked list in freq[1]  \\n            else \\n            {\\n                auto add = make_pair(newNode, newNode);\\n                freq[1] = add;\\n            }\\n\\n            curSize++; // incrementing for addition of an element \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278730,
                "title": "460-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the Node class with attributes key, val, freq, prev, and next.\\n2. Define the DoublyLinkedList class with attributes head and tail, and methods add_node_to_head, remove_node, is_empty, and remove_tail_node.\\n3. Initialize the LFUCache class with attributes capacity, size, min_freq, node_dict, and freq_dict.\\n4. Define the update_freq_dict method which takes a node as input and updates its frequency.\\n5. Define the get method which takes a key as input and returns the value of the corresponding node if it exists in node_dict.\\n6. Define the put method which takes a key and value as input and updates the cache.\\na. If the cache is full, remove the least frequently used node.\\nb. Create a new node with the given key and value, and add it to the head of the DoublyLinkedList with frequency 1.\\nc. Update the node_dict and freq_dict accordingly.\\n7. Return the value if get method is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, key, val, freq):\\n        self.key = key\\n        self.val = val\\n        self.freq = freq\\n        self.prev = None\\n        self.next = None\\n\\nclass DoublyLinkedList:\\n    def __init__(self):\\n        self.head = Node(None, None, 0)\\n        self.tail = Node(None, None, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def add_node_to_head(self, node):\\n        node.next = self.head.next\\n        node.prev = self.head\\n        self.head.next.prev = node\\n        self.head.next = node\\n    \\n    def remove_node(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        \\n    def is_empty(self):\\n        return self.head.next == self.tail\\n    \\n    def remove_tail_node(self):\\n        if self.is_empty():\\n            return None\\n        tail_node = self.tail.prev\\n        self.remove_node(tail_node)\\n        return tail_node\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.size = 0\\n        self.min_freq = 0\\n        self.node_dict = {}\\n        self.freq_dict = {}\\n    \\n    def update_freq_dict(self, node):\\n        freq = node.freq\\n        self.freq_dict[freq].remove_node(node)\\n        if self.min_freq == freq and self.freq_dict[freq].is_empty():\\n            self.min_freq += 1\\n        node.freq += 1\\n        freq = node.freq\\n        if freq not in self.freq_dict:\\n            self.freq_dict[freq] = DoublyLinkedList()\\n        self.freq_dict[freq].add_node_to_head(node)\\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.node_dict:\\n            return -1\\n        node = self.node_dict[key]\\n        self.update_freq_dict(node)\\n        return node.val\\n    \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.node_dict:\\n            node = self.node_dict[key]\\n            node.val = value\\n            self.update_freq_dict(node)\\n        else:\\n            if self.size == self.capacity:\\n                min_freq_list = self.freq_dict[self.min_freq]\\n                node_to_remove = min_freq_list.remove_tail_node()\\n                del self.node_dict[node_to_remove.key]\\n                self.size -= 1\\n            \\n            new_node = Node(key, value, 1)\\n            self.node_dict[key] = new_node\\n            if 1 not in self.freq_dict:\\n                self.freq_dict[1] = DoublyLinkedList()\\n            self.freq_dict[1].add_node_to_head(new_node)\\n            self.min_freq = 1\\n            self.size += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Design"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, key, val, freq):\\n        self.key = key\\n        self.val = val\\n        self.freq = freq\\n        self.prev = None\\n        self.next = None\\n\\nclass DoublyLinkedList:\\n    def __init__(self):\\n        self.head = Node(None, None, 0)\\n        self.tail = Node(None, None, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def add_node_to_head(self, node):\\n        node.next = self.head.next\\n        node.prev = self.head\\n        self.head.next.prev = node\\n        self.head.next = node\\n    \\n    def remove_node(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        \\n    def is_empty(self):\\n        return self.head.next == self.tail\\n    \\n    def remove_tail_node(self):\\n        if self.is_empty():\\n            return None\\n        tail_node = self.tail.prev\\n        self.remove_node(tail_node)\\n        return tail_node\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.size = 0\\n        self.min_freq = 0\\n        self.node_dict = {}\\n        self.freq_dict = {}\\n    \\n    def update_freq_dict(self, node):\\n        freq = node.freq\\n        self.freq_dict[freq].remove_node(node)\\n        if self.min_freq == freq and self.freq_dict[freq].is_empty():\\n            self.min_freq += 1\\n        node.freq += 1\\n        freq = node.freq\\n        if freq not in self.freq_dict:\\n            self.freq_dict[freq] = DoublyLinkedList()\\n        self.freq_dict[freq].add_node_to_head(node)\\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.node_dict:\\n            return -1\\n        node = self.node_dict[key]\\n        self.update_freq_dict(node)\\n        return node.val\\n    \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.node_dict:\\n            node = self.node_dict[key]\\n            node.val = value\\n            self.update_freq_dict(node)\\n        else:\\n            if self.size == self.capacity:\\n                min_freq_list = self.freq_dict[self.min_freq]\\n                node_to_remove = min_freq_list.remove_tail_node()\\n                del self.node_dict[node_to_remove.key]\\n                self.size -= 1\\n            \\n            new_node = Node(key, value, 1)\\n            self.node_dict[key] = new_node\\n            if 1 not in self.freq_dict:\\n                self.freq_dict[1] = DoublyLinkedList()\\n            self.freq_dict[1].add_node_to_head(new_node)\\n            self.min_freq = 1\\n            self.size += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113754,
                "title": "striver-solution-explainer-well-along-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n//here i will use doubly linked list for my implemenation \\n\\nstruct Node{\\n    int key,value,cnt;\\n    Node* prev;\\n    Node* next;\\n    Node(int _key,int _value){\\n        key=_key;\\n        value=_value;\\n        cnt=1;\\n    }\\n    //each query get will give us a key jske corresponding we need to return its value \\n    //har access due to get or put uski frequency bad jaegi\\n    //jaise hi koi new element aega then the least frequency is automatically set to 1\\n\\n};\\nstruct List{\\n    int size;\\n    Node* head;\\n    Node* tail;\\n    //so that we can get rid of corner cases we can directly  insert and delete from 2 dummy nodes\\n    List(){\\n        head=new Node(0,0);\\n        tail=new Node(0,0);\\n        head->next=tail;\\n        tail->prev=head;\\n        size=0;\\n        //dummy nodes will not contribute to the  size of the node \\n    }\\n    void addfront(Node* node){\\n        //for adding or removing from a dll we simply do noe pointer rearrangemen\\n        Node* temp=head->next;\\n        node->next=temp;\\n        node->prev=head;\\n        temp->prev=node;\\n        head->next=node;\\n        size++;\\n        //understand  the node   pointer rearrangement here \\n\\n\\n    }\\n    void removenode(Node* delnode){\\n        //jabhi node delete hogi lfu walin list nme se hogi \\n        //if  there occurs a tie then thge lru once is used \\n        //you should not forgot these corner test cases\\n        //fist understand the logic then code it  well\\n        Node* delprev=delnode->prev;\\n        Node* delnext=delnode->next;\\n        delprev->next=delnext;\\n        delnext->prev=delprev;\\n        size--;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nclass LFUCache {\\npublic:\\n//now here we will mention what all data struture we required to implement thre lru catch operation class\\nmap<int,Node*>keynode;\\nmap<int,List*>freqlistmap;\\nint maxsizecache;\\nint minfreq;\\nint currsize;//this will keep track of the node jo abhi tak black box ie lfu cache me jachuke h \\n// cause there is a limit n on this according  to the questions\\n\\n    LFUCache(int capacity) {\\n        //this is the construtor of this class this will intialise all the things \\n        maxsizecache=capacity;\\n        minfreq=0;\\n        currsize=0;\\n\\n        \\n    }\\n    void updatefreqlistmap(Node* node){\\n        //\\n        keynode.erase(node->key);\\n        freqlistmap[node->cnt]->removenode(node);\\n        if(node->cnt==minfreq && freqlistmap[node->cnt]->size==0){\\n            minfreq++;\\n        }\\n        List* nexthigherfreqlist=new List();\\n        if(freqlistmap.find(node->cnt+1)!=freqlistmap.end()){\\n            nexthigherfreqlist=freqlistmap[node->cnt+1];\\n        }\\n        node->cnt++;\\n        nexthigherfreqlist->addfront(node);\\n        freqlistmap[node->cnt]=nexthigherfreqlist;\\n        keynode[node->key]=node;\\n    }\\n    \\n    int get(int key) {\\n\\n\\n        if(keynode.find(key)!=keynode.end()){\\n            //then this is present already just find the value of it\\n            Node* node=keynode[key];\\n            int val=node->value;\\n            //since i have called get function on this kye \\n            //uski access frequency bad jaegi \\n            //to hi update karni padegi inside the data strutres accordinglyu \\n            updatefreqlistmap(node);\\n            return val;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n\\n        //deal the corner cases and the base cases first \\n        if(maxsizecache==0){\\n            //ek test case bhi daal denge chech karne  ke liye \\n            return ;\\n        }\\n\\n        if(keynode.find(key)!=keynode.end()){\\n            Node* node=keynode[key];\\n            node->value=value;\\n            updatefreqlistmap(node);//whenever this function is called access frequency is increaesd by \\n            //dry run karke flow samjha karo dosto\\n\\n        }else{\\n            //the given entry will be going inside the lru cache for first time\\n            //kya kya possib\\n            if(currsize==maxsizecache){\\n                //then we need to delete the lfu and create space for the incoming\\n                List* list=freqlistmap[minfreq];\\n                keynode.erase(list->tail->prev->key);\\n                //use node ko dono hashmap me sse delte karna hoga\\n                freqlistmap[minfreq]->removenode(list->tail->prev);\\n                currsize--;\\n            }\\n            currsize++;\\n            //new value has to be added which is not there previously \\n            //whenever a new element comes the min freq inside the lfu data struture is automatically set to 1\\n            minfreq=1;\\n            List* list=new List();\\n            if(freqlistmap.find(minfreq)!=freqlistmap.end()){\\n                list=freqlistmap[minfreq];\\n\\n            }\\n            Node* node=new Node(key,value);\\n            list->addfront(node);\\n            keynode[key]=node;\\n            freqlistmap[minfreq]=list;\\n        }\\n\\n        \\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n//here i will use doubly linked list for my implemenation \\n\\nstruct Node{\\n    int key,value,cnt;\\n    Node* prev;\\n    Node* next;\\n    Node(int _key,int _value){\\n        key=_key;\\n        value=_value;\\n        cnt=1;\\n    }\\n    //each query get will give us a key jske corresponding we need to return its value \\n    //har access due to get or put uski frequency bad jaegi\\n    //jaise hi koi new element aega then the least frequency is automatically set to 1\\n\\n};\\nstruct List{\\n    int size;\\n    Node* head;\\n    Node* tail;\\n    //so that we can get rid of corner cases we can directly  insert and delete from 2 dummy nodes\\n    List(){\\n        head=new Node(0,0);\\n        tail=new Node(0,0);\\n        head->next=tail;\\n        tail->prev=head;\\n        size=0;\\n        //dummy nodes will not contribute to the  size of the node \\n    }\\n    void addfront(Node* node){\\n        //for adding or removing from a dll we simply do noe pointer rearrangemen\\n        Node* temp=head->next;\\n        node->next=temp;\\n        node->prev=head;\\n        temp->prev=node;\\n        head->next=node;\\n        size++;\\n        //understand  the node   pointer rearrangement here \\n\\n\\n    }\\n    void removenode(Node* delnode){\\n        //jabhi node delete hogi lfu walin list nme se hogi \\n        //if  there occurs a tie then thge lru once is used \\n        //you should not forgot these corner test cases\\n        //fist understand the logic then code it  well\\n        Node* delprev=delnode->prev;\\n        Node* delnext=delnode->next;\\n        delprev->next=delnext;\\n        delnext->prev=delprev;\\n        size--;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\nclass LFUCache {\\npublic:\\n//now here we will mention what all data struture we required to implement thre lru catch operation class\\nmap<int,Node*>keynode;\\nmap<int,List*>freqlistmap;\\nint maxsizecache;\\nint minfreq;\\nint currsize;//this will keep track of the node jo abhi tak black box ie lfu cache me jachuke h \\n// cause there is a limit n on this according  to the questions\\n\\n    LFUCache(int capacity) {\\n        //this is the construtor of this class this will intialise all the things \\n        maxsizecache=capacity;\\n        minfreq=0;\\n        currsize=0;\\n\\n        \\n    }\\n    void updatefreqlistmap(Node* node){\\n        //\\n        keynode.erase(node->key);\\n        freqlistmap[node->cnt]->removenode(node);\\n        if(node->cnt==minfreq && freqlistmap[node->cnt]->size==0){\\n            minfreq++;\\n        }\\n        List* nexthigherfreqlist=new List();\\n        if(freqlistmap.find(node->cnt+1)!=freqlistmap.end()){\\n            nexthigherfreqlist=freqlistmap[node->cnt+1];\\n        }\\n        node->cnt++;\\n        nexthigherfreqlist->addfront(node);\\n        freqlistmap[node->cnt]=nexthigherfreqlist;\\n        keynode[node->key]=node;\\n    }\\n    \\n    int get(int key) {\\n\\n\\n        if(keynode.find(key)!=keynode.end()){\\n            //then this is present already just find the value of it\\n            Node* node=keynode[key];\\n            int val=node->value;\\n            //since i have called get function on this kye \\n            //uski access frequency bad jaegi \\n            //to hi update karni padegi inside the data strutres accordinglyu \\n            updatefreqlistmap(node);\\n            return val;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n\\n        //deal the corner cases and the base cases first \\n        if(maxsizecache==0){\\n            //ek test case bhi daal denge chech karne  ke liye \\n            return ;\\n        }\\n\\n        if(keynode.find(key)!=keynode.end()){\\n            Node* node=keynode[key];\\n            node->value=value;\\n            updatefreqlistmap(node);//whenever this function is called access frequency is increaesd by \\n            //dry run karke flow samjha karo dosto\\n\\n        }else{\\n            //the given entry will be going inside the lru cache for first time\\n            //kya kya possib\\n            if(currsize==maxsizecache){\\n                //then we need to delete the lfu and create space for the incoming\\n                List* list=freqlistmap[minfreq];\\n                keynode.erase(list->tail->prev->key);\\n                //use node ko dono hashmap me sse delte karna hoga\\n                freqlistmap[minfreq]->removenode(list->tail->prev);\\n                currsize--;\\n            }\\n            currsize++;\\n            //new value has to be added which is not there previously \\n            //whenever a new element comes the min freq inside the lfu data struture is automatically set to 1\\n            minfreq=1;\\n            List* list=new List();\\n            if(freqlistmap.find(minfreq)!=freqlistmap.end()){\\n                list=freqlistmap[minfreq];\\n\\n            }\\n            Node* node=new Node(key,value);\\n            list->addfront(node);\\n            keynode[key]=node;\\n            freqlistmap[minfreq]=list;\\n        }\\n\\n        \\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113305,
                "title": "c-similiar-to-lru-cache-using-ordered-set",
                "content": "# Intuition\\nSo in LRU Cache (https://leetcode.com/problems/lru-cache/solutions/3113033/c-using-set-and-maps-ologn-insert-and-delete/), We had Count or you can say recent value in this solution.\\nSimiliarly in LFU Cache....we sort the keys using both (frequency and recent value). \\nNote: Recent Value is used to keep the most recent keys accessed ahead and by assigning them higher recent values....we ensure that they stay at the end of set (which is our cache).\\n\\n# Approach\\nSo in LFU Cache, the frequency matters and thus the first element of  pair which is first element of final pair in set is preferred to be frequency and the second value of the same pair is recent value.\\nSo if two elements have same frequency, the last recently used will be closer to end than the one which was not recently used compared to other, which is exactly what we want in our LFU Cache as per description of the problem.\\nAlso the get operations counts as access operations and thus frequency is incremented in that case too!\\n\\n# Complexity\\n- Time complexity:\\nO(logN) or just O(18)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n    int cachesize,recent=0;\\n    unordered_map<int,int>freqaccess;//how many times accessed key or frequency of access\\n    unordered_map<int,int>keyvalue;//value to key\\n    set<pair<pair<int,int>,int>>cache;//{{freq,recent},key}\\n    unordered_map<int,bool>existsincache;//existence of key in cache\\n    unordered_map<int,int>recentvalueto;//\\'recent\\' value to a key\\n\\n    LFUCache(int capacity) {\\n        cachesize=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(cachesize==0)\\n        {\\n            return -1;\\n        }\\n        if(!existsincache[key])\\n        {\\n            return -1;\\n        }\\n        cache.erase({{freqaccess[key],recentvalueto[key]},key});\\n        freqaccess[key]++;\\n        recentvalueto[key]=recent;\\n        cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n        recent++;\\n        return keyvalue[key];\\n    }\\n    \\n    void put(int key,int value) {\\n        if(cachesize==0)\\n        {\\n            return;\\n        }\\n        if(!existsincache[key])\\n        {\\n            if(cache.size()==cachesize)\\n            {\\n                existsincache[(*cache.begin()).second]=false;\\n                cache.erase(cache.begin());\\n            }\\n            keyvalue[key]=value;\\n            freqaccess[key]=1;\\n            recentvalueto[key]=recent;\\n            cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n            recent++;\\n            existsincache[key]=true;\\n        }\\n        else\\n        {\\n            keyvalue[key]=value;\\n            cache.erase({{freqaccess[key],recentvalueto[key]},key});\\n            freqaccess[key]++;\\n            recentvalueto[key]=recent;\\n            cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n            recent++;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    int cachesize,recent=0;\\n    unordered_map<int,int>freqaccess;//how many times accessed key or frequency of access\\n    unordered_map<int,int>keyvalue;//value to key\\n    set<pair<pair<int,int>,int>>cache;//{{freq,recent},key}\\n    unordered_map<int,bool>existsincache;//existence of key in cache\\n    unordered_map<int,int>recentvalueto;//\\'recent\\' value to a key\\n\\n    LFUCache(int capacity) {\\n        cachesize=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(cachesize==0)\\n        {\\n            return -1;\\n        }\\n        if(!existsincache[key])\\n        {\\n            return -1;\\n        }\\n        cache.erase({{freqaccess[key],recentvalueto[key]},key});\\n        freqaccess[key]++;\\n        recentvalueto[key]=recent;\\n        cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n        recent++;\\n        return keyvalue[key];\\n    }\\n    \\n    void put(int key,int value) {\\n        if(cachesize==0)\\n        {\\n            return;\\n        }\\n        if(!existsincache[key])\\n        {\\n            if(cache.size()==cachesize)\\n            {\\n                existsincache[(*cache.begin()).second]=false;\\n                cache.erase(cache.begin());\\n            }\\n            keyvalue[key]=value;\\n            freqaccess[key]=1;\\n            recentvalueto[key]=recent;\\n            cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n            recent++;\\n            existsincache[key]=true;\\n        }\\n        else\\n        {\\n            keyvalue[key]=value;\\n            cache.erase({{freqaccess[key],recentvalueto[key]},key});\\n            freqaccess[key]++;\\n            recentvalueto[key]=recent;\\n            cache.insert({{freqaccess[key],recentvalueto[key]},key});\\n            recent++;\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642209,
                "title": "c-most-structured-code-good-code-quality-map-dll-tc-o-1-for-operations",
                "content": "Do Upvote, if it Helped :)\\n\\n```\\nclass Node {\\npublic:\\n    int key;\\n    int val;\\n    int freq;\\n    \\n    Node* prev = NULL;\\n    Node* next = NULL;\\n    \\n    Node(int key, int val) {\\n        this->key = key;\\n        this->val = val;\\n        freq = 1;\\n    }    \\n};\\n\\n// List is a Doubly Linked List\\nclass List {\\npublic:\\n    int size;\\n    Node *head;\\n    Node *tail;\\n    \\n    List() {\\n        head = new Node(-1,-1);\\n        tail = new Node(-1,-1);\\n        head->next = tail;\\n        tail->prev = head;\\n        size = 0;\\n    }\\n    \\n    void addFront(Node *newNode) {\\n        Node *tmp = head->next;\\n        head->next = newNode;\\n        newNode->prev = head;\\n        newNode->next = tmp;\\n        tmp->prev = newNode;\\n        ++size;\\n    }\\n    \\n    void removeNode(Node *tar) {\\n        Node *tarNext = tar->next;\\n        Node *tarPrev = tar->prev;\\n        tarNext->prev = tarPrev;\\n        tarPrev->next = tarNext;\\n        --size;\\n    }    \\n    \\n};\\n\\nclass LFUCache {\\nprivate:\\n    int maxCap;     // maximum capacity of Cache\\n    int minFreq;    // minimum frequency in the map so far\\n    int currCap;    // current capacity of the Cache\\n    \\n    map<int, Node*> keyNodeMap;\\n    map<int, List*> freqListMap;\\n    \\n    void updateFreqListMap(Node *node) {\\n        keyNodeMap.erase(node->key);\\n        freqListMap[node->freq]->removeNode(node);\\n        \\n        if(node->freq == minFreq && freqListMap[node->freq]->size == 0) {\\n            ++minFreq;\\n        }\\n        \\n        List *nextHigherFreqList = new List();\\n        \\n        if(freqListMap.find(node->freq + 1) != freqListMap.end()) {\\n            nextHigherFreqList = freqListMap[node->freq + 1];\\n        }\\n        \\n        node->freq += 1;\\n        \\n        nextHigherFreqList->addFront(node);\\n        \\n        freqListMap[node->freq] = nextHigherFreqList;\\n        keyNodeMap[node->key] = node;        \\n    }\\n    \\npublic:\\n    LFUCache(int capacity) {\\n        maxCap = capacity;\\n        minFreq = 0;\\n        currCap = 0;\\n    }\\n    \\n    int get(int key) {\\n        int res = -1;\\n        if(keyNodeMap.find(key) != keyNodeMap.end()) {\\n            Node *node = keyNodeMap[key];\\n            res = node->val;\\n            updateFreqListMap(node);\\n        }\\n        return res;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(maxCap == 0) return;\\n        \\n        if(keyNodeMap.find(key) != keyNodeMap.end()) {\\n            Node *node = keyNodeMap[key];\\n            node->val = value;\\n            updateFreqListMap(node);\\n            return;\\n        }\\n        else {\\n            if(currCap == maxCap) {\\n                List *tmp = freqListMap[minFreq];\\n                keyNodeMap.erase(tmp->tail->prev->key);\\n                freqListMap[minFreq]->removeNode(tmp->tail->prev);\\n                --currCap;\\n            }\\n            \\n            // since it is a new node, hence its frequency will be 1\\n            // and therefore minFreq will get updated from whatever it was to 1.\\n            \\n            minFreq = 1;\\n            \\n            List *minFreqList = new List();\\n            if(freqListMap.find(minFreq) != freqListMap.end()) {\\n                minFreqList = freqListMap[minFreq];\\n            }\\n                \\n            Node *node = new Node(key, value);\\n            \\n            minFreqList->addFront(node);\\n            keyNodeMap[key] = node;\\n            freqListMap[minFreq] = minFreqList;\\n            \\n            ++currCap;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Node {\\npublic:\\n    int key;\\n    int val;\\n    int freq;\\n    \\n    Node* prev = NULL;\\n    Node* next = NULL;\\n    \\n    Node(int key, int val) {\\n        this->key = key;\\n        this->val = val;\\n        freq = 1;\\n    }    \\n};\\n\\n// List is a Doubly Linked List\\nclass List {\\npublic:\\n    int size;\\n    Node *head;\\n    Node *tail;\\n    \\n    List() {\\n        head = new Node(-1,-1);\\n        tail = new Node(-1,-1);\\n        head->next = tail;\\n        tail->prev = head;\\n        size = 0;\\n    }\\n    \\n    void addFront(Node *newNode) {\\n        Node *tmp = head->next;\\n        head->next = newNode;\\n        newNode->prev = head;\\n        newNode->next = tmp;\\n        tmp->prev = newNode;\\n        ++size;\\n    }\\n    \\n    void removeNode(Node *tar) {\\n        Node *tarNext = tar->next;\\n        Node *tarPrev = tar->prev;\\n        tarNext->prev = tarPrev;\\n        tarPrev->next = tarNext;\\n        --size;\\n    }    \\n    \\n};\\n\\nclass LFUCache {\\nprivate:\\n    int maxCap;     // maximum capacity of Cache\\n    int minFreq;    // minimum frequency in the map so far\\n    int currCap;    // current capacity of the Cache\\n    \\n    map<int, Node*> keyNodeMap;\\n    map<int, List*> freqListMap;\\n    \\n    void updateFreqListMap(Node *node) {\\n        keyNodeMap.erase(node->key);\\n        freqListMap[node->freq]->removeNode(node);\\n        \\n        if(node->freq == minFreq && freqListMap[node->freq]->size == 0) {\\n            ++minFreq;\\n        }\\n        \\n        List *nextHigherFreqList = new List();\\n        \\n        if(freqListMap.find(node->freq + 1) != freqListMap.end()) {\\n            nextHigherFreqList = freqListMap[node->freq + 1];\\n        }\\n        \\n        node->freq += 1;\\n        \\n        nextHigherFreqList->addFront(node);\\n        \\n        freqListMap[node->freq] = nextHigherFreqList;\\n        keyNodeMap[node->key] = node;        \\n    }\\n    \\npublic:\\n    LFUCache(int capacity) {\\n        maxCap = capacity;\\n        minFreq = 0;\\n        currCap = 0;\\n    }\\n    \\n    int get(int key) {\\n        int res = -1;\\n        if(keyNodeMap.find(key) != keyNodeMap.end()) {\\n            Node *node = keyNodeMap[key];\\n            res = node->val;\\n            updateFreqListMap(node);\\n        }\\n        return res;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(maxCap == 0) return;\\n        \\n        if(keyNodeMap.find(key) != keyNodeMap.end()) {\\n            Node *node = keyNodeMap[key];\\n            node->val = value;\\n            updateFreqListMap(node);\\n            return;\\n        }\\n        else {\\n            if(currCap == maxCap) {\\n                List *tmp = freqListMap[minFreq];\\n                keyNodeMap.erase(tmp->tail->prev->key);\\n                freqListMap[minFreq]->removeNode(tmp->tail->prev);\\n                --currCap;\\n            }\\n            \\n            // since it is a new node, hence its frequency will be 1\\n            // and therefore minFreq will get updated from whatever it was to 1.\\n            \\n            minFreq = 1;\\n            \\n            List *minFreqList = new List();\\n            if(freqListMap.find(minFreq) != freqListMap.end()) {\\n                minFreqList = freqListMap[minFreq];\\n            }\\n                \\n            Node *node = new Node(key, value);\\n            \\n            minFreqList->addFront(node);\\n            keyNodeMap[key] = node;\\n            freqListMap[minFreq] = minFreqList;\\n            \\n            ++currCap;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029072,
                "title": "java-hashmap-no-dll-easy-to-understand",
                "content": "```\\nclass LFUCache {\\n    \\n    int cap;\\n    Map<Integer,Integer> cache = new HashMap<>();\\n    Map<Integer,Integer> keycount = new HashMap<>();\\n    Map<Integer,LinkedHashSet<Integer>> freqmap = new HashMap<>();\\n    int min = -1;\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n        freqmap.put(1,new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if(cache.containsKey(key)==false)\\n            return -1;\\n        int count = keycount.get(key);\\n        keycount.put(key,count+1);\\n        freqmap.get(count).remove(key);\\n        if(count==min&&freqmap.get(count).size()==0)\\n            min++;\\n        if(freqmap.containsKey(count+1)==false)\\n            freqmap.put(count+1,new LinkedHashSet<>());\\n        freqmap.get(count+1).add(key);\\n        return cache.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(cap<=0)\\n            return;\\n        if(cache.containsKey(key))\\n        {\\n            cache.put(key,value);\\n            get(key);\\n            return;\\n        }    \\n        if(cache.size()>=cap)\\n        {\\n            int evict = freqmap.get(min).iterator().next();\\n            freqmap.get(min).remove(evict);\\n            cache.remove(evict);\\n            keycount.remove(evict);\\n        }\\n        cache.put(key,value);\\n        keycount.put(key,1);\\n        min = 1;\\n        freqmap.get(1).add(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n    \\n    int cap;\\n    Map<Integer,Integer> cache = new HashMap<>();\\n    Map<Integer,Integer> keycount = new HashMap<>();\\n    Map<Integer,LinkedHashSet<Integer>> freqmap = new HashMap<>();\\n    int min = -1;\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n        freqmap.put(1,new LinkedHashSet<>());\\n    }\\n    \\n    public int get(int key) {\\n        if(cache.containsKey(key)==false)\\n            return -1;\\n        int count = keycount.get(key);\\n        keycount.put(key,count+1);\\n        freqmap.get(count).remove(key);\\n        if(count==min&&freqmap.get(count).size()==0)\\n            min++;\\n        if(freqmap.containsKey(count+1)==false)\\n            freqmap.put(count+1,new LinkedHashSet<>());\\n        freqmap.get(count+1).add(key);\\n        return cache.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(cap<=0)\\n            return;\\n        if(cache.containsKey(key))\\n        {\\n            cache.put(key,value);\\n            get(key);\\n            return;\\n        }    \\n        if(cache.size()>=cap)\\n        {\\n            int evict = freqmap.get(min).iterator().next();\\n            freqmap.get(min).remove(evict);\\n            cache.remove(evict);\\n            keycount.remove(evict);\\n        }\\n        cache.put(key,value);\\n        keycount.put(key,1);\\n        min = 1;\\n        freqmap.get(1).add(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631797,
                "title": "java-simple-approach-priorityqueue-and-hashmap",
                "content": "```\\nclass LFUCache {\\n    HashMap<Integer, Node> hash;\\n    PriorityQueue<Node> pq;\\n    int capacity;\\n    int counter;\\n    class Node {\\n        int key;\\n        int val;\\n        int frequency;\\n        int date;\\n    }\\n    public LFUCache(int capacity) {\\n        hash = new HashMap();\\n        this.capacity = capacity;\\n        pq = new PriorityQueue<Node>((a,b)->{\\n            if(a.frequency==b.frequency){\\n                if (a.date<b.date){\\n                    return -1;\\n                }else if (a.date==b.date){\\n                    return 0;\\n                }else{\\n                    return 1;\\n                }\\n                \\n            }\\n            return a.frequency-b.frequency;\\n        });\\n    }\\n    \\n    public int get(int key) {\\n        counter++;\\n        Node node = hash.get(key);\\n        int result=-1;\\n        if(node!=null){\\n            pq.remove(node);\\n            node.frequency+=1;\\n            node.date=counter;\\n            result = node.val;\\n            pq.add(node);\\n        }\\n        return result;\\n    }\\n    \\n    public void put(int key, int value) {\\n        counter++;\\n        if(capacity==0)\\n            return;\\n        Node node = hash.get(key);\\n        if(node!=null){\\n            node.frequency+=1;\\n            node.val =value;\\n            node.date = counter;\\n            pq.remove(node);\\n            pq.add(node);\\n        }else{\\n            if(capacity==hash.size()){\\n                hash.remove(pq.poll().key);\\n            }\\n                node = new Node();\\n                node.val = value;\\n                node.key=key;\\n                node.frequency=1;\\n                node.date = counter;\\n                hash.put(key, node);\\n                pq.add(node);\\n            \\n        }\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass LFUCache {\\n    HashMap<Integer, Node> hash;\\n    PriorityQueue<Node> pq;\\n    int capacity;\\n    int counter;\\n    class Node {\\n        int key;\\n        int val;\\n        int frequency;\\n        int date;\\n    }\\n    public LFUCache(int capacity) {\\n        hash = new HashMap();\\n        this.capacity = capacity;\\n        pq = new PriorityQueue<Node>((a,b)->{\\n            if(a.frequency==b.frequency){\\n                if (a.date<b.date){\\n                    return -1;\\n                }else if (a.date==b.date){\\n                    return 0;\\n                }else{\\n                    return 1;\\n                }\\n                \\n            }\\n            return a.frequency-b.frequency;\\n        });\\n    }\\n    \\n    public int get(int key) {\\n        counter++;\\n        Node node = hash.get(key);\\n        int result=-1;\\n        if(node!=null){\\n            pq.remove(node);\\n            node.frequency+=1;\\n            node.date=counter;\\n            result = node.val;\\n            pq.add(node);\\n        }\\n        return result;\\n    }\\n    \\n    public void put(int key, int value) {\\n        counter++;\\n        if(capacity==0)\\n            return;\\n        Node node = hash.get(key);\\n        if(node!=null){\\n            node.frequency+=1;\\n            node.val =value;\\n            node.date = counter;\\n            pq.remove(node);\\n            pq.add(node);\\n        }else{\\n            if(capacity==hash.size()){\\n                hash.remove(pq.poll().key);\\n            }\\n                node = new Node();\\n                node.val = value;\\n                node.key=key;\\n                node.frequency=1;\\n                node.date = counter;\\n                hash.put(key, node);\\n                pq.add(node);\\n            \\n        }\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517076,
                "title": "java-easy-solution-with-comments",
                "content": "class LFUCache {\\n\\n    int capacity=0;\\n    HashMap<Integer,Integer> cache = new HashMap(); // cache\\n    HashMap<Integer,Integer> keyCounts= new HashMap(); // key count\\n    HashMap<Integer,LinkedHashSet<Integer>> freqMap= new HashMap(); // freq map\\n    int min=-1; //least used count\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        freqMap.put(1, new LinkedHashSet());\\n    }\\n    \\n    public int get(int key) {\\n        //if cahce does not contain key return -1\\n        if(!cache.containsKey(key)) return -1;\\n        //update the key count\\n        int count = keyCounts.get(key);\\n        keyCounts.put(key,count+1);\\n        //remove key from freq map\\n        freqMap.get(count).remove(key);\\n        //when the frqmap for the min count is empty then increment the min \\n        if(count==min && freqMap.get(count).size()==0) min++;\\n        //if the new count in freq map does not exists create a new entry and add the key to the freq map\\n        if(!freqMap.containsKey(count+1)) freqMap.put(count+1, new LinkedHashSet());\\n        freqMap.get(count+1).add(key);\\n        return cache.get(key);\\n            \\n        \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity<=0) return;\\n        //if cache contains the key return value and call get so all the updates happen\\n        if(cache.containsKey(key)){\\n            cache.put(key,value);\\n            get(key);\\n            return;\\n        }\\n        \\n        //if cache size greater than capacity then remoe the least used element. This will be cominf from the minimum freqMap . remove the key from all places\\n        if(cache.size() >=capacity){\\n            int evict =freqMap.get(min).iterator().next();\\n            cache.remove(evict);\\n            freqMap.get(min).remove(evict);\\n            keyCounts.remove(evict);\\n        }\\n        //add new entry and reset min to 1 \\n        cache.put(key,value);\\n        keyCounts.put(key,1);\\n        min=1;\\n        freqMap.get(1).add(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */",
                "solutionTags": [],
                "code": "class LFUCache {\\n\\n    int capacity=0;\\n    HashMap<Integer,Integer> cache = new HashMap(); // cache\\n    HashMap<Integer,Integer> keyCounts= new HashMap(); // key count\\n    HashMap<Integer,LinkedHashSet<Integer>> freqMap= new HashMap(); // freq map\\n    int min=-1; //least used count\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        freqMap.put(1, new LinkedHashSet());\\n    }\\n    \\n    public int get(int key) {\\n        //if cahce does not contain key return -1\\n        if(!cache.containsKey(key)) return -1;\\n        //update the key count\\n        int count = keyCounts.get(key);\\n        keyCounts.put(key,count+1);\\n        //remove key from freq map\\n        freqMap.get(count).remove(key);\\n        //when the frqmap for the min count is empty then increment the min \\n        if(count==min && freqMap.get(count).size()==0) min++;\\n        //if the new count in freq map does not exists create a new entry and add the key to the freq map\\n        if(!freqMap.containsKey(count+1)) freqMap.put(count+1, new LinkedHashSet());\\n        freqMap.get(count+1).add(key);\\n        return cache.get(key);\\n            \\n        \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity<=0) return;\\n        //if cache contains the key return value and call get so all the updates happen\\n        if(cache.containsKey(key)){\\n            cache.put(key,value);\\n            get(key);\\n            return;\\n        }\\n        \\n        //if cache size greater than capacity then remoe the least used element. This will be cominf from the minimum freqMap . remove the key from all places\\n        if(cache.size() >=capacity){\\n            int evict =freqMap.get(min).iterator().next();\\n            cache.remove(evict);\\n            freqMap.get(min).remove(evict);\\n            keyCounts.remove(evict);\\n        }\\n        //add new entry and reset min to 1 \\n        cache.put(key,value);\\n        keyCounts.put(key,1);\\n        min=1;\\n        freqMap.get(1).add(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1499801,
                "title": "c-easy-to-understand-3-unordered-maps",
                "content": "Inspiration from http://dhruvbird.com/lfu.pdf.\\nUsed unordered map of counts linking to list of keys (which are put in lru cache fashion)\\nPlease solve lru cache solution first, will easily understand this solution :)\\n```\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        m.clear();\\n        mlist.clear();\\n        mcount.clear();\\n    }\\n    \\n    int get(int key) {\\n        if(m.count(key)==0)return -1;\\n        int c = m[key].second;\\n        mcount[c].erase(mlist[key]);\\n        if(mcount[c].empty()){\\n            if(minfreq==c)minfreq++;\\n        }\\n        mcount[c+1].push_front(key);\\n        mlist[key] = mcount[c+1].begin();\\n        m[key].second++;\\n        return m[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.size()==size && m.count(key)==0){\\n            // evict\\n            if(size==0)return;\\n            int k = mcount[minfreq].back();\\n            m.erase(k);\\n            mlist.erase(k);\\n            mcount[minfreq].pop_back();\\n        }\\n        if(m.count(key)==0){\\n            m[key] = {value,1};\\n            minfreq = 1;\\n            mcount[1].push_front(key);\\n            mlist[key] = mcount[1].begin();\\n        }\\n        else{\\n            int c = m[key].second;\\n            mcount[c].erase(mlist[key]);\\n            if(mcount[c].empty()){\\n                if(minfreq==c)minfreq++;\\n            }\\n            mcount[c+1].push_front(key);\\n            mlist[key] = mcount[c+1].begin();\\n            m[key].first = value;\\n            m[key].second++;\\n        }\\n    }\\nprivate:\\n    int size;\\n    int minfreq;\\n    unordered_map<int,pair<int,int>>m;\\n    unordered_map<int,list<int>>mcount;\\n    unordered_map<int,list<int>::iterator>mlist;\\n    \\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        m.clear();\\n        mlist.clear();\\n        mcount.clear();\\n    }\\n    \\n    int get(int key) {\\n        if(m.count(key)==0)return -1;\\n        int c = m[key].second;\\n        mcount[c].erase(mlist[key]);\\n        if(mcount[c].empty()){\\n            if(minfreq==c)minfreq++;\\n        }\\n        mcount[c+1].push_front(key);\\n        mlist[key] = mcount[c+1].begin();\\n        m[key].second++;\\n        return m[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.size()==size && m.count(key)==0){\\n            // evict\\n            if(size==0)return;\\n            int k = mcount[minfreq].back();\\n            m.erase(k);\\n            mlist.erase(k);\\n            mcount[minfreq].pop_back();\\n        }\\n        if(m.count(key)==0){\\n            m[key] = {value,1};\\n            minfreq = 1;\\n            mcount[1].push_front(key);\\n            mlist[key] = mcount[1].begin();\\n        }\\n        else{\\n            int c = m[key].second;\\n            mcount[c].erase(mlist[key]);\\n            if(mcount[c].empty()){\\n                if(minfreq==c)minfreq++;\\n            }\\n            mcount[c+1].push_front(key);\\n            mlist[key] = mcount[c+1].begin();\\n            m[key].first = value;\\n            m[key].second++;\\n        }\\n    }\\nprivate:\\n    int size;\\n    int minfreq;\\n    unordered_map<int,pair<int,int>>m;\\n    unordered_map<int,list<int>>mcount;\\n    unordered_map<int,list<int>::iterator>mlist;\\n    \\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226347,
                "title": "java-o-1-build-off-lru-two-hashmaps-clean-and-clear-with-comments",
                "content": "Build off of LRU but instead instead of directly accessing elements in the doublyLinked list, cache the lists into a freq map. \\n\\ne.x\\n`this.freqMap`\\nFreq 1 -> [ Node(1) -> Node(2)]\\nFreq 2 -> [Node(5), Node(9)]\\n\\nWhen a capacity is reached and we need to evict a node. Grab the List of nodes with lowest frequency.\\nSince we track `minFreq` as a global variable we essentially always have the key to grab the all nodes with lowest freq.\\n\\nSo we would this list: `[ Node(1) -> Node(2)]`  then apply LRU to the list -> essentially just popping the tail since we will always add to head.\\n\\n\\n```\\nclass LFUCache {\\n\\n    class LinkedNode{\\n        \\n        int key;\\n        int val;\\n        int freq;\\n        \\n        LinkedNode prev;\\n        LinkedNode next;\\n        \\n        public LinkedNode(int key, int val){ this.key = key; this.val = val; this.freq = 1; }\\n    }\\n    \\n    class DoublyLinkedList{\\n        \\n        private LinkedNode head;\\n        private LinkedNode tail;\\n        \\n        private int size;\\n        \\n        public DoublyLinkedList(){\\n            \\n            this.head = new LinkedNode(-1, -1);\\n            this.tail = new LinkedNode(-1, -1);\\n            \\n            this.head.prev = null;\\n            this.head.next = this.tail;\\n            \\n            this.tail.next = null;\\n            this.tail.prev = this.head;\\n            this.size = 0;\\n        }\\n        \\n        private void addToHead(LinkedNode node){\\n            \\n            LinkedNode next = this.head.next;\\n            \\n            next.prev = node;\\n            \\n            node.next = next;\\n            node.prev = this.head;\\n            \\n            this.head.next = node;\\n            this.size += 1;\\n        }\\n        \\n        private void remove(LinkedNode node){\\n            \\n            LinkedNode prev = node.prev;\\n            LinkedNode next = node.next;\\n            \\n            prev.next = next;\\n            next.prev = prev;\\n            \\n            this.size -= 1;\\n        }\\n        \\n        private LinkedNode removeTail(){\\n            \\n            LinkedNode tail = this.tail.prev;\\n            \\n            remove(tail);\\n            \\n            return tail;\\n        }\\n    }\\n    \\n    private Map<Integer, LinkedNode> cache;\\n    private Map<Integer, DoublyLinkedList> freqMap;\\n    private int capacity;\\n    \\n    //used to track nodes with lowest freq\\n    private int minFreq;\\n    \\n    public LFUCache(int capacity) {\\n        \\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n        \\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        \\n        LinkedNode node = this.cache.get(key);\\n        \\n        if(node == null) return -1;\\n        \\n        updateNodeFreq(node);\\n        \\n        return node.val;\\n    }\\n    \\n    private void updateNodeFreq(LinkedNode node){\\n        \\n        //1: increment the freq of the node\\n        //2: remove node from current freq list\\n        //3: add node to new freq list\\n        //4: may need to update the minFreq if minFreq list is now empty and it was the freq of oldFreq\\n        \\n        int oldFreq = node.freq;\\n        int newFreq = oldFreq + 1;\\n        \\n        //1\\n        node.freq = newFreq;\\n        \\n        //2\\n        DoublyLinkedList oldFreqList = this.freqMap.get(oldFreq);\\n        \\n        oldFreqList.remove(node);\\n        \\n        //3\\n        if(!this.freqMap.containsKey(newFreq))\\n            this.freqMap.put(newFreq, new DoublyLinkedList());\\n        \\n        this.freqMap.get(newFreq).addToHead(node);\\n        \\n        //4\\n        if(oldFreqList.size == 0 && this.minFreq == oldFreq)   \\n            this.minFreq = newFreq;\\n\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(this.capacity < 1) return;\\n        \\n        LinkedNode node = this.cache.get(key);\\n        \\n        if(node != null){\\n            \\n            updateNodeFreq(node);\\n            node.val = value;\\n            \\n            return;\\n        }\\n        \\n        //need to insert a new node\\n        boolean shouldEvict = this.cache.size() >= this.capacity;\\n        \\n        //before inserting remove the lru of the least freq nodes\\n        if(shouldEvict){\\n            \\n            DoublyLinkedList evictList = this.freqMap.get(this.minFreq);\\n            LinkedNode evictedNode = evictList.removeTail();\\n            \\n            this.cache.remove(evictedNode.key);\\n            \\n        }\\n        \\n        //now add the new node\\n        node = new LinkedNode(key, value);\\n            \\n        this.cache.put(key, node);\\n        \\n        //since we are adding a new node the min freq will revert to 1\\n        this.minFreq = 1;\\n            \\n        if(!this.freqMap.containsKey(1))\\n            this.freqMap.put(1, new DoublyLinkedList());\\n            \\n        this.freqMap.get(1).addToHead(node);\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n\\n    class LinkedNode{\\n        \\n        int key;\\n        int val;\\n        int freq;\\n        \\n        LinkedNode prev;\\n        LinkedNode next;\\n        \\n        public LinkedNode(int key, int val){ this.key = key; this.val = val; this.freq = 1; }\\n    }\\n    \\n    class DoublyLinkedList{\\n        \\n        private LinkedNode head;\\n        private LinkedNode tail;\\n        \\n        private int size;\\n        \\n        public DoublyLinkedList(){\\n            \\n            this.head = new LinkedNode(-1, -1);\\n            this.tail = new LinkedNode(-1, -1);\\n            \\n            this.head.prev = null;\\n            this.head.next = this.tail;\\n            \\n            this.tail.next = null;\\n            this.tail.prev = this.head;\\n            this.size = 0;\\n        }\\n        \\n        private void addToHead(LinkedNode node){\\n            \\n            LinkedNode next = this.head.next;\\n            \\n            next.prev = node;\\n            \\n            node.next = next;\\n            node.prev = this.head;\\n            \\n            this.head.next = node;\\n            this.size += 1;\\n        }\\n        \\n        private void remove(LinkedNode node){\\n            \\n            LinkedNode prev = node.prev;\\n            LinkedNode next = node.next;\\n            \\n            prev.next = next;\\n            next.prev = prev;\\n            \\n            this.size -= 1;\\n        }\\n        \\n        private LinkedNode removeTail(){\\n            \\n            LinkedNode tail = this.tail.prev;\\n            \\n            remove(tail);\\n            \\n            return tail;\\n        }\\n    }\\n    \\n    private Map<Integer, LinkedNode> cache;\\n    private Map<Integer, DoublyLinkedList> freqMap;\\n    private int capacity;\\n    \\n    //used to track nodes with lowest freq\\n    private int minFreq;\\n    \\n    public LFUCache(int capacity) {\\n        \\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n        \\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        \\n        LinkedNode node = this.cache.get(key);\\n        \\n        if(node == null) return -1;\\n        \\n        updateNodeFreq(node);\\n        \\n        return node.val;\\n    }\\n    \\n    private void updateNodeFreq(LinkedNode node){\\n        \\n        //1: increment the freq of the node\\n        //2: remove node from current freq list\\n        //3: add node to new freq list\\n        //4: may need to update the minFreq if minFreq list is now empty and it was the freq of oldFreq\\n        \\n        int oldFreq = node.freq;\\n        int newFreq = oldFreq + 1;\\n        \\n        //1\\n        node.freq = newFreq;\\n        \\n        //2\\n        DoublyLinkedList oldFreqList = this.freqMap.get(oldFreq);\\n        \\n        oldFreqList.remove(node);\\n        \\n        //3\\n        if(!this.freqMap.containsKey(newFreq))\\n            this.freqMap.put(newFreq, new DoublyLinkedList());\\n        \\n        this.freqMap.get(newFreq).addToHead(node);\\n        \\n        //4\\n        if(oldFreqList.size == 0 && this.minFreq == oldFreq)   \\n            this.minFreq = newFreq;\\n\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(this.capacity < 1) return;\\n        \\n        LinkedNode node = this.cache.get(key);\\n        \\n        if(node != null){\\n            \\n            updateNodeFreq(node);\\n            node.val = value;\\n            \\n            return;\\n        }\\n        \\n        //need to insert a new node\\n        boolean shouldEvict = this.cache.size() >= this.capacity;\\n        \\n        //before inserting remove the lru of the least freq nodes\\n        if(shouldEvict){\\n            \\n            DoublyLinkedList evictList = this.freqMap.get(this.minFreq);\\n            LinkedNode evictedNode = evictList.removeTail();\\n            \\n            this.cache.remove(evictedNode.key);\\n            \\n        }\\n        \\n        //now add the new node\\n        node = new LinkedNode(key, value);\\n            \\n        this.cache.put(key, node);\\n        \\n        //since we are adding a new node the min freq will revert to 1\\n        this.minFreq = 1;\\n            \\n        if(!this.freqMap.containsKey(1))\\n            this.freqMap.put(1, new DoublyLinkedList());\\n            \\n        this.freqMap.get(1).addToHead(node);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221047,
                "title": "c-solution",
                "content": "```\\npublic class LFUCache {\\n\\n    public class Cache\\n    {\\n        public int key;\\n        public int val;\\n        public int freq;\\n        public Cache(int k, int v, int f)\\n        {\\n            key = k;\\n            val = v;\\n            freq = f;\\n        }\\n    }\\n    \\n    public int size = 0;\\n    public int minFreq = 0;\\n    public Dictionary<int,LinkedListNode<Cache>> cacheDic = new Dictionary<int,LinkedListNode<Cache>>();\\n    public Dictionary<int,LinkedList<Cache>> freqCacheDic = new Dictionary<int,LinkedList<Cache>>();\\n    \\n    public LFUCache(int capacity) {\\n        size = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if(size <= 0 || !cacheDic.ContainsKey(key))\\n            return -1;\\n        \\n        // get the cache by the key\\n        LinkedListNode<Cache> node = cacheDic[key];\\n        \\n        // remove the cache from freqCacheDic \\n        freqCacheDic[node.Value.freq].Remove(node);\\n        \\n        // increase the freq of node, then add it to freqCacheDic\\n        node.Value.freq++;\\n        if(!freqCacheDic.ContainsKey(node.Value.freq))\\n            freqCacheDic.Add(node.Value.freq, new LinkedList<Cache>(){});\\n        freqCacheDic[node.Value.freq].AddLast(node);\\n        \\n        // initialize minFreq\\n        // also increase minFreq when there is no cache with current minFreq\\n        if(freqCacheDic[minFreq].Count == 0)\\n            minFreq++;\\n        \\n        return node.Value.val;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        \\n        if(size <= 0)\\n            return;\\n        \\n        // check if there is any cache has this key. If yes, update the cache\\'s val.   \\n        int cacheValue = Get(key);\\n        if(cacheValue != -1)\\n        {\\n            // don\\'t need to update the the freq since it has been updated in the Get()\\n            cacheDic[key].Value.val = value;\\n        }\\n        else\\n        {\\n            // remove the lru if capacity has reached the limit\\n            if(cacheDic.Count == size)\\n            {\\n                LinkedListNode<Cache> node = freqCacheDic[minFreq].First;\\n                cacheDic.Remove(node.Value.key);\\n                freqCacheDic[minFreq].Remove(node);\\n            }\\n            // create a new cache\\n            Cache cache = new Cache(key, value, 1);           \\n            if(!freqCacheDic.ContainsKey(1))\\n                freqCacheDic.Add(1, new LinkedList<Cache>());\\n            LinkedListNode<Cache> cacheNode = freqCacheDic[1].AddLast(cache);\\n            cacheDic.Add(key, cacheNode);\\n            minFreq = 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LFUCache {\\n\\n    public class Cache\\n    {\\n        public int key;\\n        public int val;\\n        public int freq;\\n        public Cache(int k, int v, int f)\\n        {\\n            key = k;\\n            val = v;\\n            freq = f;\\n        }\\n    }\\n    \\n    public int size = 0;\\n    public int minFreq = 0;\\n    public Dictionary<int,LinkedListNode<Cache>> cacheDic = new Dictionary<int,LinkedListNode<Cache>>();\\n    public Dictionary<int,LinkedList<Cache>> freqCacheDic = new Dictionary<int,LinkedList<Cache>>();\\n    \\n    public LFUCache(int capacity) {\\n        size = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if(size <= 0 || !cacheDic.ContainsKey(key))\\n            return -1;\\n        \\n        // get the cache by the key\\n        LinkedListNode<Cache> node = cacheDic[key];\\n        \\n        // remove the cache from freqCacheDic \\n        freqCacheDic[node.Value.freq].Remove(node);\\n        \\n        // increase the freq of node, then add it to freqCacheDic\\n        node.Value.freq++;\\n        if(!freqCacheDic.ContainsKey(node.Value.freq))\\n            freqCacheDic.Add(node.Value.freq, new LinkedList<Cache>(){});\\n        freqCacheDic[node.Value.freq].AddLast(node);\\n        \\n        // initialize minFreq\\n        // also increase minFreq when there is no cache with current minFreq\\n        if(freqCacheDic[minFreq].Count == 0)\\n            minFreq++;\\n        \\n        return node.Value.val;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        \\n        if(size <= 0)\\n            return;\\n        \\n        // check if there is any cache has this key. If yes, update the cache\\'s val.   \\n        int cacheValue = Get(key);\\n        if(cacheValue != -1)\\n        {\\n            // don\\'t need to update the the freq since it has been updated in the Get()\\n            cacheDic[key].Value.val = value;\\n        }\\n        else\\n        {\\n            // remove the lru if capacity has reached the limit\\n            if(cacheDic.Count == size)\\n            {\\n                LinkedListNode<Cache> node = freqCacheDic[minFreq].First;\\n                cacheDic.Remove(node.Value.key);\\n                freqCacheDic[minFreq].Remove(node);\\n            }\\n            // create a new cache\\n            Cache cache = new Cache(key, value, 1);           \\n            if(!freqCacheDic.ContainsKey(1))\\n                freqCacheDic.Add(1, new LinkedList<Cache>());\\n            LinkedListNode<Cache> cacheNode = freqCacheDic[1].AddLast(cache);\\n            cacheDic.Add(key, cacheNode);\\n            minFreq = 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128946,
                "title": "c-constant-time-get-and-put-using-two-hash-maps-and-doubly-linked-list-with-explanations",
                "content": "**Key points:**\\n* This is the longest solution I ever typed on leetcode. Feel like finished a marathon, tied but happy.\\n* Constant time get requires a hash map from key to something that leads to the value. I created a key lookup table from key to ListNode.\\n* Constant time put requires constant time access to existing item, constant time access to least visited item in lowest frequency items, constant time to adjust data structure after changes. To deal with these requirements, I used a hash map from frequency to a doubly linked list of nodes. Nodes in the linked list is ordered by most recent access.\\n* When get happened, I do lookup in key lookup table. If not found, return -1. If I found it, it is fairly easy to get the return value. The hard part is to adjust the frequency. I used prompte function to achieve this goal. In the prompte function,\\n\\t* First remove the node from its current frequency list.\\n\\t* Do necessary maintenance with the old frequency list.\\n\\t* Bump the node frequency and add it to the end of next frequency list.\\n* When put happened, I do look up in key lookup table. If found, I update the value and use the promote function to adjust node\\'s frequency. (Move from one frequency list to the next as explained in previous item.)\\n* If the key was not found, it means a new node. I check capacity first to see if we need to evict node or not. If no need for eviction, just add the new node into frequency 1 list.\\n* If I run out of capacity, using my carefully maintained lowestFreq_ to find the lowest frequency list and remove the first item in the list. Instead of deleting old node and create new after, I just recycle the old node to live green :)\\n* I thought about using std::list and std::list::iterator but I just can\\'t be sure when iterators will get invalidated so I just repurposed the classic ListNode structure to make it link in both ways and carry key, value and frequency in it. Everything under my control, I like it this way.\\n* The node needs to contain both key and frequency so that given a node we can find it in both tables.\\n* All operations above got no loops or recursion hence cost constant time.\\n* There is a bloody 0 capacity test case I didn\\'t guard against. Cost me a wrong submit. Come on, for real, is this necessary??!!\\n```\\nclass LFUCache {\\npublic:\\n  struct ListNode {\\n    int key;\\n    int val;\\n    int freq;\\n    ListNode *next;\\n    ListNode *prev;\\n  };\\n  \\n  LFUCache(int capacity) : capacity_(capacity), size_(0), lowestFreq_(0) {\\n  }\\n  \\n  int get(int key) {\\n    auto itor = keyLut_.find(key);\\n    if (itor == keyLut_.end())\\n      return -1;\\n    int ret = itor->second->val;\\n    promote(itor->second);\\n    return ret;\\n  }\\n  \\n  void put(int key, int value) {\\n    if (!capacity_)\\n      return;\\n    auto itor = keyLut_.find(key);\\n    if (itor == keyLut_.end()) {\\n      // New key, need to check capacity\\n      ListNode * node = 0;\\n      if (capacity_ == size_) {\\n        // Full capacity, need to kill some old node and recycle it as new\\n        auto fItor = freqLut_.find(lowestFreq_);\\n        node = fItor->second.first;\\n        if (node->next) {\\n          fItor->second.first = node->next;\\n          node->next->prev = 0;\\n        }\\n        else\\n          freqLut_.erase(fItor);\\n        keyLut_.erase(node->key);\\n      }\\n      // If nothing recycled, increase size.\\n      else {\\n        node = new ListNode();\\n        ++size_;\\n      }\\n      node->key = key;\\n      node->val = value;\\n      node->freq = 1;\\n      node->next = 0;\\n      auto fItor = freqLut_.find(1);\\n      if (fItor == freqLut_.end()) {\\n        freqLut_.insert({1, {node, node}});\\n        node->prev = 0;\\n      }\\n      else {\\n        fItor->second.second->next = node;\\n        node->prev = fItor->second.second;\\n        fItor->second.second = node;\\n      }\\n      keyLut_.insert({key, node});\\n      lowestFreq_ = 1;\\n    }\\n    else {\\n      itor->second->val = value;\\n      promote(itor->second);\\n    }\\n  }\\n\\nprivate:\\n  void promote(ListNode * node) {\\n    // Remove node from freq list\\n    auto itor = freqLut_.find(node->freq);\\n    if (itor->second.first == node) {\\n      // The node is at the beginning of the list\\n      if (node->next) {\\n        // List length is more than 1\\n        itor->second.first = node->next;\\n        node->next->prev = 0;\\n      }\\n      else {\\n        // List length is 1\\n        freqLut_.erase(itor);\\n        if (lowestFreq_ == node->freq)\\n          ++lowestFreq_;\\n      }\\n    }\\n    else if (itor->second.second == node) {\\n      // The node is at the end of the list\\n      itor->second.second = node->prev;\\n      node->prev->next = 0;\\n    }\\n    else {\\n      // The node is in the middle of the list\\n      node->prev->next = node->next;\\n      node->next->prev = node->prev;\\n    }\\n    \\n    // Add node to the end of freq+1 list\\n    node->next = 0;\\n    itor = freqLut_.find(++node->freq);\\n    if (itor == freqLut_.end()) {\\n      // Start a new freq list\\n      freqLut_.insert({node->freq, {node, node}});\\n      node->prev = 0;\\n    }\\n    else {\\n      // Append to an existing freq list\\n      itor->second.second->next = node;\\n      node->prev = itor->second.second;\\n      itor->second.second = node;\\n    }\\n  }\\n  \\n  // freq to the head and tail of the list of nodes in most recent access order\\n  std::unordered_map<int, std::pair<ListNode *, ListNode *>> freqLut_;\\n  // key to the node\\n  std::unordered_map<int, ListNode *> keyLut_;\\n  int capacity_;\\n  int size_;\\n  int lowestFreq_;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n  struct ListNode {\\n    int key;\\n    int val;\\n    int freq;\\n    ListNode *next;\\n    ListNode *prev;\\n  };\\n  \\n  LFUCache(int capacity) : capacity_(capacity), size_(0), lowestFreq_(0) {\\n  }\\n  \\n  int get(int key) {\\n    auto itor = keyLut_.find(key);\\n    if (itor == keyLut_.end())\\n      return -1;\\n    int ret = itor->second->val;\\n    promote(itor->second);\\n    return ret;\\n  }\\n  \\n  void put(int key, int value) {\\n    if (!capacity_)\\n      return;\\n    auto itor = keyLut_.find(key);\\n    if (itor == keyLut_.end()) {\\n      // New key, need to check capacity\\n      ListNode * node = 0;\\n      if (capacity_ == size_) {\\n        // Full capacity, need to kill some old node and recycle it as new\\n        auto fItor = freqLut_.find(lowestFreq_);\\n        node = fItor->second.first;\\n        if (node->next) {\\n          fItor->second.first = node->next;\\n          node->next->prev = 0;\\n        }\\n        else\\n          freqLut_.erase(fItor);\\n        keyLut_.erase(node->key);\\n      }\\n      // If nothing recycled, increase size.\\n      else {\\n        node = new ListNode();\\n        ++size_;\\n      }\\n      node->key = key;\\n      node->val = value;\\n      node->freq = 1;\\n      node->next = 0;\\n      auto fItor = freqLut_.find(1);\\n      if (fItor == freqLut_.end()) {\\n        freqLut_.insert({1, {node, node}});\\n        node->prev = 0;\\n      }\\n      else {\\n        fItor->second.second->next = node;\\n        node->prev = fItor->second.second;\\n        fItor->second.second = node;\\n      }\\n      keyLut_.insert({key, node});\\n      lowestFreq_ = 1;\\n    }\\n    else {\\n      itor->second->val = value;\\n      promote(itor->second);\\n    }\\n  }\\n\\nprivate:\\n  void promote(ListNode * node) {\\n    // Remove node from freq list\\n    auto itor = freqLut_.find(node->freq);\\n    if (itor->second.first == node) {\\n      // The node is at the beginning of the list\\n      if (node->next) {\\n        // List length is more than 1\\n        itor->second.first = node->next;\\n        node->next->prev = 0;\\n      }\\n      else {\\n        // List length is 1\\n        freqLut_.erase(itor);\\n        if (lowestFreq_ == node->freq)\\n          ++lowestFreq_;\\n      }\\n    }\\n    else if (itor->second.second == node) {\\n      // The node is at the end of the list\\n      itor->second.second = node->prev;\\n      node->prev->next = 0;\\n    }\\n    else {\\n      // The node is in the middle of the list\\n      node->prev->next = node->next;\\n      node->next->prev = node->prev;\\n    }\\n    \\n    // Add node to the end of freq+1 list\\n    node->next = 0;\\n    itor = freqLut_.find(++node->freq);\\n    if (itor == freqLut_.end()) {\\n      // Start a new freq list\\n      freqLut_.insert({node->freq, {node, node}});\\n      node->prev = 0;\\n    }\\n    else {\\n      // Append to an existing freq list\\n      itor->second.second->next = node;\\n      node->prev = itor->second.second;\\n      itor->second.second = node;\\n    }\\n  }\\n  \\n  // freq to the head and tail of the list of nodes in most recent access order\\n  std::unordered_map<int, std::pair<ListNode *, ListNode *>> freqLut_;\\n  // key to the node\\n  std::unordered_map<int, ListNode *> keyLut_;\\n  int capacity_;\\n  int size_;\\n  int lowestFreq_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123409,
                "title": "python-remove-from-head-and-add-to-tail-of-dll",
                "content": "Hi,\\n\\n***This is my first post on Leetcode. Please do let me know where I can impove.***\\n\\nProblem that we are facing when thinking about this solution is \\n1. How to keep track of minimum_frequency.\\n2. How to update (increment or reset it) if element with that frequency is not there.\\n3. How to delete from **current** frequency list to **current+1** frequency list.\\n4. How to keep order maintain for same Frequency so that when need to delete, we delete element with LFU and  Least Recently Used.\\n\\nHere is my approach :\\n\\n1.  I know for every put or get we have to increment the frequency of already present element --> One method that will update frequency for both put and get operation.\\n2.  I will store all the elements that are of same frequency in same list.\\n\\t\\t![image](https://assets.leetcode.com/users/images/4d6c1351-20b5-4fed-b674-0b0f714b99dd_1616483349.3254328.png)\\n\\t\\t\\n\\t\\tElement will be of type Doubly Linkedlist\\n\\t\\tFreq_element mapping will be store in **defaultdict(DLL)**\\n\\t\\tIf a new element needs to be added I know I have to add it at the head of list with frequency 1.\\n\\t\\tI will keep min_freq which will be update to 1 as soon as new element is added.\\n\\t\\tIf the elements are removed and there is no element with min_freq then I will update min_freq +=1 and when again if new elements are added min_freq value will be increase to 1.\\n\\t\\tWhen I have to add new element I will always add at the rear of linkedlist and when I have to remove I will always remove from the front of linkedlist  because first element of the LinkedList will be LRU of same frequency.\\n\\t\\t\\nIn Simple :\\nKeeping 3 dict \\n1. To keep track of freq and LRU --> defaultdict(DLL) -->self.d\\n2. To keep the key value pair --> dict() -->self.cache\\n3. To keep address of every key so that when need to delete can be done in O(1).\\n\\n*  If element is not present:\\n\\t* \\tCheck if capacity limit is reached,\\n\\t\\t\\t* If yes, then delete the element with min_freq and LRU\\n\\t\\t\\t* Add the current element to the defaultdict(DLL) with min_freq =1\\n\\t\\t\\t* Add the value in cache and keytoL mapping dict.\\n* Else, update the frequency and value of element.\\n\\n* For get:\\n\\t* If element is not present return -1\\n\\t* else, update the frequency of element and then return value from cache.\\n\\n***Code:***\\n\\n```\\nimport collections\\n\\n\\nclass LinkedList:\\n\\n    def __init__(self, key, val):\\n        self.val = val\\n        self.key = key\\n        self.next = None\\n        self.prev = None\\n        # self.freq = 1\\n        # self.size = 0\\n\\n    def __str__(self):\\n        return \"{} {}\".format(self.key, self.val)\\n\\n\\nclass DLL:\\n\\n    def __init__(self):\\n        self.head = LinkedList(\"Head\", \"H\")\\n        self.tail = LinkedList(\"Tail\", \"T\")\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n\\n    def insertAtTail(self, key, val):\\n        temp = LinkedList(key, val)\\n        tail = self.tail.prev\\n        tail.next = temp\\n        temp.prev = tail\\n        temp.next = self.tail\\n        self.tail.prev = temp\\n        self.size += 1\\n        return temp\\n\\n    def removeFromHead(self):\\n        temp = self.head.next\\n        self.removeNode(temp)\\n\\n        return temp\\n\\n    def removeNode(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self.size -= 1\\n        # del node\\n\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.d = collections.defaultdict(DLL)\\n        self.cache = dict()\\n        self.keyToLmap = dict()\\n        self.size = 0\\n        self.min_freq = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        self.updateFreq(key, self.cache[key][1])\\n        return self.cache[key][1]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.cap == 0:\\n            return\\n        if key not in self.cache:\\n            if self.size == self.cap:\\n                \"\"\"\\n                1. capacity is now full so we have to remove LFU.\\n                2. LFU number we have in min_freq so we have to remove from d[min_freq]\\n                3. First element from d[min_freq] will be removed.\\n                \"\"\"\\n                temp = self.d[self.min_freq].removeFromHead()\\n                del self.cache[temp.key]\\n                del self.keyToLmap[temp.key]\\n            temp = self.d[1].insertAtTail(key, value)\\n            self.keyToLmap[key] = temp\\n            self.min_freq = 1\\n            self.cache[key] = (1, value)\\n            if self.size < self.cap: self.size += 1\\n        else:\\n            self.updateFreq(key, value)\\n\\n    def updateFreq(self, key, value):\\n        \"\"\"\\n        Update Freq works in following way:\\n            1. Retrieve freq and value of key\\n            2. From keyToLmap dict get address of linkedlist of key\\n            3. Remove key value from current freq.\\n            4. Append key to freq+1 list.\\n        :param value:\\n        :param key:\\n        :return:\\n        \"\"\"\\n        prevFreq, _ = self.cache[key]\\n        currFreq = prevFreq + 1\\n        self.d[prevFreq].removeNode(self.keyToLmap[key])\\n        self.keyToLmap[key] = self.d[currFreq].insertAtTail(key, value)\\n        if self.d[self.min_freq].size == 0:\\n            self.min_freq += 1\\n        self.cache[key] = (currFreq, value)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nimport collections\\n\\n\\nclass LinkedList:\\n\\n    def __init__(self, key, val):\\n        self.val = val\\n        self.key = key\\n        self.next = None\\n        self.prev = None\\n        # self.freq = 1\\n        # self.size = 0\\n\\n    def __str__(self):\\n        return \"{} {}\".format(self.key, self.val)\\n\\n\\nclass DLL:\\n\\n    def __init__(self):\\n        self.head = LinkedList(\"Head\", \"H\")\\n        self.tail = LinkedList(\"Tail\", \"T\")\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n\\n    def insertAtTail(self, key, val):\\n        temp = LinkedList(key, val)\\n        tail = self.tail.prev\\n        tail.next = temp\\n        temp.prev = tail\\n        temp.next = self.tail\\n        self.tail.prev = temp\\n        self.size += 1\\n        return temp\\n\\n    def removeFromHead(self):\\n        temp = self.head.next\\n        self.removeNode(temp)\\n\\n        return temp\\n\\n    def removeNode(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self.size -= 1\\n        # del node\\n\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.d = collections.defaultdict(DLL)\\n        self.cache = dict()\\n        self.keyToLmap = dict()\\n        self.size = 0\\n        self.min_freq = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        self.updateFreq(key, self.cache[key][1])\\n        return self.cache[key][1]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.cap == 0:\\n            return\\n        if key not in self.cache:\\n            if self.size == self.cap:\\n                \"\"\"\\n                1. capacity is now full so we have to remove LFU.\\n                2. LFU number we have in min_freq so we have to remove from d[min_freq]\\n                3. First element from d[min_freq] will be removed.\\n                \"\"\"\\n                temp = self.d[self.min_freq].removeFromHead()\\n                del self.cache[temp.key]\\n                del self.keyToLmap[temp.key]\\n            temp = self.d[1].insertAtTail(key, value)\\n            self.keyToLmap[key] = temp\\n            self.min_freq = 1\\n            self.cache[key] = (1, value)\\n            if self.size < self.cap: self.size += 1\\n        else:\\n            self.updateFreq(key, value)\\n\\n    def updateFreq(self, key, value):\\n        \"\"\"\\n        Update Freq works in following way:\\n            1. Retrieve freq and value of key\\n            2. From keyToLmap dict get address of linkedlist of key\\n            3. Remove key value from current freq.\\n            4. Append key to freq+1 list.\\n        :param value:\\n        :param key:\\n        :return:\\n        \"\"\"\\n        prevFreq, _ = self.cache[key]\\n        currFreq = prevFreq + 1\\n        self.d[prevFreq].removeNode(self.keyToLmap[key])\\n        self.keyToLmap[key] = self.d[currFreq].insertAtTail(key, value)\\n        if self.d[self.min_freq].size == 0:\\n            self.min_freq += 1\\n        self.cache[key] = (currFreq, value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069541,
                "title": "java-o-1-one-hashmap-99-runtime-88-space-complexity",
                "content": "Simple concept:\\nStoring a LinkedList of Keys `KeyNode` inside a LinkedList of Frequencies `FreqNode`\\n`FreqNode` acts as frequency buckets that holds all Key/Value pairs that have that frequency. \\n\\nWhen updating a Key/Value pair:\\n1. Use `map.get(key)` to retrieve the `KeyNode`  \\n2. Remove the `KeyNode` from the `FreqNode` parent \\n3. Move it to the `freq+1` node (ie. the `parent.next` node), OR create a new node if `parent.next.freq` > `freq+1` \\n\\n````\\n+---+      +---+      +---+      +---+      \"FreqNode\"\\n| 0 | ---> | 1 | ---> | 3 | ---> | 6 |      Frequency Buckets\\n+---+      +---+      +---+      +---+      \\n             |          |          |\\n           +---+      +---+      +---+      \"KeyNode\"\\n           |1,1|      |2,2|      |5,5|      Key/Value Pairs\\n\\t\\t   +---+      +---+      +---+\\t    Ordered from Most Recently Used (Top) to Least Recently Used (Bottom)\\n             |          |                   Adding [6,6] would remove the Lest Frequent and Least Recent node [3,3]\\n           +---+      +---+\\n           |3,3|      |4,4|\\n\\t\\t   +---+      +---+\\n````\\nIf get(2) was called:\\n````\\n+---+      +---+      +---+      +---+      +---+ \\n| 0 | ---> | 1 | ---> | 3 | ---> | 4 | ---> | 6 |   \\n+---+      +---+      +---+      +---+      +---+      \\n             |          |          |          |\\n           +---+      +---+      +---+      +---+ \\n           |1,1|      |4,4|      |2,2|      |5,5|\\n\\t\\t   +---+      +---+      +---+      +---+ \\n             |          \\n           +---+ \\n           |3,3| \\n\\t\\t   +---+ \\n````\\nIf get(4) was called: (Note that [4,4] was used most recently, so it\\'s placed at the beginning of its respective Freq LinkedList)\\n````\\n+---+      +---+      +---+      +---+ \\n| 0 | ---> | 1 | ---> | 4 | ---> | 6 | \\n+---+      +---+      +---+      +---+      \\n             |          |          |\\n           +---+      +---+      +---+    \\n           |1,1|      |4,4|      |5,5| \\n\\t\\t   +---+      +---+      +---+\\t\\n             |          |               \\n           +---+      +---+\\n           |3,3|      |2,2|\\n\\t\\t   +---+      +---+\\n````\\n```\\nclass KeyNode {\\n    int val, key;\\n    KeyNode next, prev;\\n    FreqNode parent;\\n\\t\\n    public KeyNode(int key, int val, FreqNode parent) {\\n        this.key = key;\\n        this.val = val;\\n        this.parent = parent;\\n    }\\n}\\n\\nclass FreqNode {\\n    int freq;\\n    KeyNode start, end;\\n    FreqNode next, prev;\\n    \\n    public FreqNode(int freq) {\\n        this.freq = freq;\\n        this.start = new KeyNode(-1, -1, null);\\n        this.end = new KeyNode(-1, -1, null);\\n        this.start.next = end;\\n        this.end.prev = start;\\n    }\\n    \\n    public void add(KeyNode node) {\\n        KeyNode head = this.start.next;\\n        head.prev = node;\\n        node.next = head;\\n        \\n        start.next = node;\\n        node.prev = start; \\n    }\\n    \\n    public void remove(KeyNode node) {\\n        if (isEmpty()) {\\n            return;\\n        }\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public boolean isEmpty() {\\n        return start.next == end;\\n    }\\n}\\n\\nclass LFUCache {\\n    HashMap<Integer, KeyNode> map = new HashMap<>();\\n    int size, capacity;\\n    FreqNode start, end;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.size = 0;\\n        map = new HashMap<>();\\n        start = new FreqNode(0);\\n        end = new FreqNode(Integer.MAX_VALUE);\\n        start.next = end;     \\n    }\\n    \\n    public int get(int key) {\\n \\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        KeyNode curr = map.get(key);\\n        updateFreq(curr);\\n        return curr.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if (capacity == 0) {\\n            return;\\n        }\\n        \\n\\t\\tKeyNode curr = null;\\n        \\n        if (map.containsKey(key)) {\\n            curr = map.get(key);\\n            curr.val = value;\\n        } else if (size < capacity) {\\n            curr = new KeyNode(key, value, start);\\n            start.add(curr);\\n            ++size;\\n        } else {\\n            curr = new KeyNode(key, value, start);\\n            start.add(curr);\\n            FreqNode removeParent = start.next;\\n            map.remove(removeParent.end.prev.key);\\n            removeParent.end.prev = removeParent.end.prev.prev;\\n            removeParent.end.prev.next = removeParent.end;\\n        }\\n        \\n        map.put(key, curr);\\n        updateFreq(curr);\\n    }\\n    \\n    private void updateFreq(KeyNode node) {\\n        \\n        FreqNode parent = node.parent;\\n\\n        if (parent.next.freq > parent.freq+1) {\\n            FreqNode nextParent = new FreqNode(parent.freq+1);\\n            nextParent.next = parent.next;\\n            parent.next = nextParent;\\n            nextParent.prev = parent;\\n            nextParent.next.prev = nextParent;\\n        } \\n        \\n        parent.remove(node);\\n        parent.next.add(node);    \\n        node.parent = parent.next;\\n    \\n        //removes parent from freq buckets\\n        if (parent != start && parent != end && parent.isEmpty()) {\\n            parent.next.prev = parent.prev;\\n            parent.prev.next = parent.next;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "````\\n+---+      +---+      +---+      +---+      \"FreqNode\"\\n| 0 | ---> | 1 | ---> | 3 | ---> | 6 |      Frequency Buckets\\n+---+      +---+      +---+      +---+      \\n             |          |          |\\n           +---+      +---+      +---+      \"KeyNode\"\\n           |1,1|      |2,2|      |5,5|      Key/Value Pairs\\n\\t\\t   +---+      +---+      +---+\\t    Ordered from Most Recently Used (Top) to Least Recently Used (Bottom)\\n             |          |                   Adding [6,6] would remove the Lest Frequent and Least Recent node [3,3]\\n           +---+      +---+\\n           |3,3|      |4,4|\\n\\t\\t   +---+      +---+\\n```\n````\\n+---+      +---+      +---+      +---+      +---+ \\n| 0 | ---> | 1 | ---> | 3 | ---> | 4 | ---> | 6 |   \\n+---+      +---+      +---+      +---+      +---+      \\n             |          |          |          |\\n           +---+      +---+      +---+      +---+ \\n           |1,1|      |4,4|      |2,2|      |5,5|\\n\\t\\t   +---+      +---+      +---+      +---+ \\n             |          \\n           +---+ \\n           |3,3| \\n\\t\\t   +---+ \\n```\n````\\n+---+      +---+      +---+      +---+ \\n| 0 | ---> | 1 | ---> | 4 | ---> | 6 | \\n+---+      +---+      +---+      +---+      \\n             |          |          |\\n           +---+      +---+      +---+    \\n           |1,1|      |4,4|      |5,5| \\n\\t\\t   +---+      +---+      +---+\\t\\n             |          |               \\n           +---+      +---+\\n           |3,3|      |2,2|\\n\\t\\t   +---+      +---+\\n```\n```\\nclass KeyNode {\\n    int val, key;\\n    KeyNode next, prev;\\n    FreqNode parent;\\n\\t\\n    public KeyNode(int key, int val, FreqNode parent) {\\n        this.key = key;\\n        this.val = val;\\n        this.parent = parent;\\n    }\\n}\\n\\nclass FreqNode {\\n    int freq;\\n    KeyNode start, end;\\n    FreqNode next, prev;\\n    \\n    public FreqNode(int freq) {\\n        this.freq = freq;\\n        this.start = new KeyNode(-1, -1, null);\\n        this.end = new KeyNode(-1, -1, null);\\n        this.start.next = end;\\n        this.end.prev = start;\\n    }\\n    \\n    public void add(KeyNode node) {\\n        KeyNode head = this.start.next;\\n        head.prev = node;\\n        node.next = head;\\n        \\n        start.next = node;\\n        node.prev = start; \\n    }\\n    \\n    public void remove(KeyNode node) {\\n        if (isEmpty()) {\\n            return;\\n        }\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public boolean isEmpty() {\\n        return start.next == end;\\n    }\\n}\\n\\nclass LFUCache {\\n    HashMap<Integer, KeyNode> map = new HashMap<>();\\n    int size, capacity;\\n    FreqNode start, end;\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.size = 0;\\n        map = new HashMap<>();\\n        start = new FreqNode(0);\\n        end = new FreqNode(Integer.MAX_VALUE);\\n        start.next = end;     \\n    }\\n    \\n    public int get(int key) {\\n \\n        if (capacity == 0) {\\n            return -1;\\n        }\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        KeyNode curr = map.get(key);\\n        updateFreq(curr);\\n        return curr.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if (capacity == 0) {\\n            return;\\n        }\\n        \\n\\t\\tKeyNode curr = null;\\n        \\n        if (map.containsKey(key)) {\\n            curr = map.get(key);\\n            curr.val = value;\\n        } else if (size < capacity) {\\n            curr = new KeyNode(key, value, start);\\n            start.add(curr);\\n            ++size;\\n        } else {\\n            curr = new KeyNode(key, value, start);\\n            start.add(curr);\\n            FreqNode removeParent = start.next;\\n            map.remove(removeParent.end.prev.key);\\n            removeParent.end.prev = removeParent.end.prev.prev;\\n            removeParent.end.prev.next = removeParent.end;\\n        }\\n        \\n        map.put(key, curr);\\n        updateFreq(curr);\\n    }\\n    \\n    private void updateFreq(KeyNode node) {\\n        \\n        FreqNode parent = node.parent;\\n\\n        if (parent.next.freq > parent.freq+1) {\\n            FreqNode nextParent = new FreqNode(parent.freq+1);\\n            nextParent.next = parent.next;\\n            parent.next = nextParent;\\n            nextParent.prev = parent;\\n            nextParent.next.prev = nextParent;\\n        } \\n        \\n        parent.remove(node);\\n        parent.next.add(node);    \\n        node.parent = parent.next;\\n    \\n        //removes parent from freq buckets\\n        if (parent != start && parent != end && parent.isEmpty()) {\\n            parent.next.prev = parent.prev;\\n            parent.prev.next = parent.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950492,
                "title": "c-simplest-and-readable-solution-with-comments",
                "content": "```\\nclass LFUCache {\\n    \\npublic:\\n    #define pii pair<int,int>\\n    #define v first\\n    #define freq second\\n\\t\\n\\t\\n    unordered_map<int,list<int>> lfuCache; //map to get the list of elements using their freq\\n    unordered_map<int,pii> getParams;       // map to get the value and freq using key\\n    unordered_map<int,list<int>:: iterator> getIt;  // map to get the the iterator using key\\n    int size;\\n    int capacity;\\n    int minFreq;\\n    LFUCache(int capacity) {\\n        this->capacity=capacity;\\n        size=0;\\n        minFreq=INT_MAX;\\n    }\\n    int get(int key) {\\n        if(capacity!=0 && getParams.find(key)!=getParams.end()){\\n            int value=getParams[key].v;\\n            int f=getParams[key].freq;\\n            auto it=getIt[key];\\n            lfuCache[f].erase(it);     //erase this element from its current_freq to store it on current_freq+1 \\n            if(lfuCache[f].size()==0 && minFreq==f){\\n                minFreq=f+1;          //keep track if  no elements with minFreq are left\\n            }\\n            \\n            getParams[key].freq=f+1;\\n            lfuCache[f+1].push_front(key);\\n            it=lfuCache[f+1].begin();\\n            getIt[key]=it;\\n            return value;\\n        }else\\n            return -1;\\n    }\\n    void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(getParams.find(key)==getParams.end()){\\n            if(size==capacity){\\n                auto it=lfuCache[minFreq].end();\\n                it--;                              //to get the least recently used item \\n                \\n                int element=*(it);\\n                getParams.erase(element);\\n                getIt.erase(element);               //erase it to make room for the new entry\\n                lfuCache[minFreq].pop_back();\\n                if(lfuCache[minFreq].size()==0){\\n                    minFreq=1;                       \\n                }\\n                size--;\\n            }\\n            lfuCache[1].push_front(key);\\n            getParams[key]={value,1};\\n            getIt[key]=lfuCache[1].begin();\\n            minFreq=min(minFreq,1);\\n            size++;\\n        }else{\\n            int f=getParams[key].freq;\\n            auto it=getIt[key];\\n            lfuCache[f].erase(it);\\n            if(lfuCache[f].size()==0 && minFreq==f){\\n                minFreq=f+1;\\n            }\\n            getParams[key]={value,f+1};\\n            lfuCache[f+1].push_front(key);\\n            it=lfuCache[f+1].begin();\\n            getIt[key]=it;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    \\npublic:\\n    #define pii pair<int,int>\\n    #define v first\\n    #define freq second\\n\\t\\n\\t\\n    unordered_map<int,list<int>> lfuCache; //map to get the list of elements using their freq\\n    unordered_map<int,pii> getParams;       // map to get the value and freq using key\\n    unordered_map<int,list<int>:: iterator> getIt;  // map to get the the iterator using key\\n    int size;\\n    int capacity;\\n    int minFreq;\\n    LFUCache(int capacity) {\\n        this->capacity=capacity;\\n        size=0;\\n        minFreq=INT_MAX;\\n    }\\n    int get(int key) {\\n        if(capacity!=0 && getParams.find(key)!=getParams.end()){\\n            int value=getParams[key].v;\\n            int f=getParams[key].freq;\\n            auto it=getIt[key];\\n            lfuCache[f].erase(it);     //erase this element from its current_freq to store it on current_freq+1 \\n            if(lfuCache[f].size()==0 && minFreq==f){\\n                minFreq=f+1;          //keep track if  no elements with minFreq are left\\n            }\\n            \\n            getParams[key].freq=f+1;\\n            lfuCache[f+1].push_front(key);\\n            it=lfuCache[f+1].begin();\\n            getIt[key]=it;\\n            return value;\\n        }else\\n            return -1;\\n    }\\n    void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(getParams.find(key)==getParams.end()){\\n            if(size==capacity){\\n                auto it=lfuCache[minFreq].end();\\n                it--;                              //to get the least recently used item \\n                \\n                int element=*(it);\\n                getParams.erase(element);\\n                getIt.erase(element);               //erase it to make room for the new entry\\n                lfuCache[minFreq].pop_back();\\n                if(lfuCache[minFreq].size()==0){\\n                    minFreq=1;                       \\n                }\\n                size--;\\n            }\\n            lfuCache[1].push_front(key);\\n            getParams[key]={value,1};\\n            getIt[key]=lfuCache[1].begin();\\n            minFreq=min(minFreq,1);\\n            size++;\\n        }else{\\n            int f=getParams[key].freq;\\n            auto it=getIt[key];\\n            lfuCache[f].erase(it);\\n            if(lfuCache[f].size()==0 && minFreq==f){\\n                minFreq=f+1;\\n            }\\n            getParams[key]={value,f+1};\\n            lfuCache[f+1].push_front(key);\\n            it=lfuCache[f+1].begin();\\n            getIt[key]=it;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894722,
                "title": "java-lru-based-solution-time-o-1-space-o-n-comments",
                "content": "```\\nclass LFUCache {\\n    ListNode head; //like in LRU\\n    ListNode tail; //like in LRU\\n    Map<Integer, Integer>map; //contains actual keys and values\\n    Map<Integer, Integer>elemToFreq; // key -> \"frequency for this key\"\\n    Map<Integer, ListNode>nodes; // \"frequency from elemToFreq\" -> ListNode\\n    int capacity;\\n        \\n    public LFUCache(int capacity) {\\n        nodes = new HashMap<>();\\n        elemToFreq = new HashMap<>();\\n        map = new HashMap<>();\\n        head = new ListNode(0);\\n        tail = new ListNode(0);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (map.get(key)!=null){\\n            incrFreq(key); //increment frequency for this key, update value in our maps and list of nodes\\n            return map.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity>0){\\n        //find and remove least frequent key from all maps and \\n\\t\\t//list of nodes (if only this key has definite frequency)\\n\\t\\tif (map.size()==capacity && map.get(key)==null) removeLF();\\n\\t\\t//look at it as if it\\'s a call of get() but with \\'map\\' update\\n        if (map.containsKey(key)){\\n            map.put(key, value);\\n            incrFreq(key);\\n        } else {\\n            map.put(key,value);\\n\\t\\t\\t//adding key and frequency \\'1\\' to our maps and list of nodes\\n            addNew(key);\\n        }\\n        }\\n    }\\n    \\n    public void incrFreq(int key){\\n\\t\\t//find frequency and listnode for this key\\n        int freq = elemToFreq.get(key);\\n        ListNode old = nodes.get(freq);\\n\\t\\t//remove key from listnode\\n        old.keys.remove(key);\\n\\t\\t//find new frequency for this key (always incremented)\\n        int newFreq = freq+1;\\n\\t\\t\\n\\t\\t//update maps and list of nodes with new frequency\\n        elemToFreq.put(key, newFreq);\\n        \\n        if (nodes.get(newFreq)!=null){\\n            nodes.get(newFreq).keys.add(key);\\n        } else {\\n            ListNode node = new ListNode(newFreq);\\n            node.keys.add(key);\\n            node.next = old.next;\\n            node.prev = old;\\n            old.next.prev = node;\\n            old.next = node;\\n            nodes.put(newFreq, node);\\n        }\\n\\t\\t//don\\'t forget to delete listnode with previous frequency if only this key had such frequency\\n        if (old.keys.isEmpty()){\\n            nodes.remove(freq);\\n            old.next.prev = old.prev;\\n            old.prev.next = old.next;\\n        }\\n        \\n        \\n    }\\n    \\n    public void addNew(int key){\\n        elemToFreq.put(key,1);\\n\\t\\t//add key to existing listnode with frequency=1 or create new listnode\\n        if (nodes.get(1)==null){\\n            ListNode node = new ListNode(1);\\n            node.keys.add(key);\\n            head.next.prev = node;\\n            node.next = head.next;\\n            head.next = node;\\n            node.prev = head;\\n            nodes.put(1, node);\\n        }\\n        else {\\n            nodes.get(1).keys.add(key);\\n        }\\n    }\\n    \\n    public void removeLF(){\\n\\t//find the first listnode => it will contain the least frequently used key\\n        ListNode lf = head.next;\\n        Iterator<Integer> it =  lf.keys.iterator();\\n        int toDelete = it.next();\\n        lf.keys.remove(toDelete);\\n        map.remove(toDelete);\\n        elemToFreq.remove(toDelete);\\n        if (head.next.keys.size()==0){\\n            nodes.remove(lf.freq);\\n            head.next = lf.next;\\n            lf.next.prev = head;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\nclass ListNode{\\n    int freq;\\n    LinkedHashSet<Integer>keys; //contains all the keys with frequency \\'freq\\'\\n    ListNode prev;\\n    ListNode next;\\n    public ListNode(int freq){\\n        this.freq=freq;\\n        keys = new LinkedHashSet<>(); //to keep order of adding keys\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    ListNode head; //like in LRU\\n    ListNode tail; //like in LRU\\n    Map<Integer, Integer>map; //contains actual keys and values\\n    Map<Integer, Integer>elemToFreq; // key -> \"frequency for this key\"\\n    Map<Integer, ListNode>nodes; // \"frequency from elemToFreq\" -> ListNode\\n    int capacity;\\n        \\n    public LFUCache(int capacity) {\\n        nodes = new HashMap<>();\\n        elemToFreq = new HashMap<>();\\n        map = new HashMap<>();\\n        head = new ListNode(0);\\n        tail = new ListNode(0);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (map.get(key)!=null){\\n            incrFreq(key); //increment frequency for this key, update value in our maps and list of nodes\\n            return map.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity>0){\\n        //find and remove least frequent key from all maps and \\n\\t\\t//list of nodes (if only this key has definite frequency)\\n\\t\\tif (map.size()==capacity && map.get(key)==null) removeLF();\\n\\t\\t//look at it as if it\\'s a call of get() but with \\'map\\' update\\n        if (map.containsKey(key)){\\n            map.put(key, value);\\n            incrFreq(key);\\n        } else {\\n            map.put(key,value);\\n\\t\\t\\t//adding key and frequency \\'1\\' to our maps and list of nodes\\n            addNew(key);\\n        }\\n        }\\n    }\\n    \\n    public void incrFreq(int key){\\n\\t\\t//find frequency and listnode for this key\\n        int freq = elemToFreq.get(key);\\n        ListNode old = nodes.get(freq);\\n\\t\\t//remove key from listnode\\n        old.keys.remove(key);\\n\\t\\t//find new frequency for this key (always incremented)\\n        int newFreq = freq+1;\\n\\t\\t\\n\\t\\t//update maps and list of nodes with new frequency\\n        elemToFreq.put(key, newFreq);\\n        \\n        if (nodes.get(newFreq)!=null){\\n            nodes.get(newFreq).keys.add(key);\\n        } else {\\n            ListNode node = new ListNode(newFreq);\\n            node.keys.add(key);\\n            node.next = old.next;\\n            node.prev = old;\\n            old.next.prev = node;\\n            old.next = node;\\n            nodes.put(newFreq, node);\\n        }\\n\\t\\t//don\\'t forget to delete listnode with previous frequency if only this key had such frequency\\n        if (old.keys.isEmpty()){\\n            nodes.remove(freq);\\n            old.next.prev = old.prev;\\n            old.prev.next = old.next;\\n        }\\n        \\n        \\n    }\\n    \\n    public void addNew(int key){\\n        elemToFreq.put(key,1);\\n\\t\\t//add key to existing listnode with frequency=1 or create new listnode\\n        if (nodes.get(1)==null){\\n            ListNode node = new ListNode(1);\\n            node.keys.add(key);\\n            head.next.prev = node;\\n            node.next = head.next;\\n            head.next = node;\\n            node.prev = head;\\n            nodes.put(1, node);\\n        }\\n        else {\\n            nodes.get(1).keys.add(key);\\n        }\\n    }\\n    \\n    public void removeLF(){\\n\\t//find the first listnode => it will contain the least frequently used key\\n        ListNode lf = head.next;\\n        Iterator<Integer> it =  lf.keys.iterator();\\n        int toDelete = it.next();\\n        lf.keys.remove(toDelete);\\n        map.remove(toDelete);\\n        elemToFreq.remove(toDelete);\\n        if (head.next.keys.size()==0){\\n            nodes.remove(lf.freq);\\n            head.next = lf.next;\\n            lf.next.prev = head;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\nclass ListNode{\\n    int freq;\\n    LinkedHashSet<Integer>keys; //contains all the keys with frequency \\'freq\\'\\n    ListNode prev;\\n    ListNode next;\\n    public ListNode(int freq){\\n        this.freq=freq;\\n        keys = new LinkedHashSet<>(); //to keep order of adding keys\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802867,
                "title": "swift-simple-sweet-100",
                "content": "```\\nclass ListNode {\\n    let key: Int\\n    var value: Int\\n    var freq: Int = 1\\n    var prev: ListNode? = nil\\n    var next: ListNode? = nil\\n    \\n    init(_ key: Int, _ value: Int) {\\n        self.key = key\\n        self.value = value\\n    }\\n}\\n\\nclass FreqList {\\n    // \"dummy\" stay between the tail and the head: ....tail -> dummy -> head.....\\n    // head is the LRU, tail is the most recently used\\n    let dummy: ListNode\\n    var size = 0\\n    \\n    init() {\\n        dummy = ListNode(-1, -1)\\n        dummy.prev = dummy\\n        dummy.next = dummy\\n    }\\n    \\n    func append(_ node: ListNode) { // add to the tail (most recently used)\\n        node.prev = dummy.prev\\n        node.prev!.next = node\\n        node.next = dummy\\n        dummy.prev = node\\n        \\n        size += 1\\n    }\\n    \\n    func remove(_ node: ListNode) {\\n        node.next!.prev = node.prev\\n        node.prev!.next = node.next\\n        \\n        size -= 1\\n    }\\n    \\n    func popLast() -> ListNode { // remove the head (LRU) and return it\\n        let head = dummy.next!\\n        remove(head)\\n        return head\\n    }\\n}\\n\\nclass LFUCache {\\n    var keyToNode = [Int: ListNode]()\\n    var freqToList = [Int: FreqList]()\\n    var size = 0\\n    var minFreq = 0\\n    let capacity: Int\\n    \\n    init(_ capacity: Int) {\\n        self.capacity = capacity\\n    }\\n    \\n    // get: return keyToNode[key], update node\\n    func get(_ key: Int) -> Int {\\n        if let node = keyToNode[key] {\\n            update(node)\\n            return node.value\\n        } else {\\n            return -1\\n        }\\n    }\\n    \\n    // put: if there exist \"node\", update it\\n    // else, check capacity, if full, remove head (LRU)\\n    // then, add the new node\\n    func put(_ key: Int, _ value: Int) {\\n        if capacity == 0 { return }\\n        \\n        if let node = keyToNode[key] {\\n            node.value = value\\n            update(node)\\n        } else {\\n            if size == capacity { // full\\n                let lruNode = freqToList[minFreq]!.popLast()\\n                keyToNode[lruNode.key] = nil\\n                size -= 1\\n            } \\n            \\n            let newNode = ListNode(key, value)\\n            keyToNode[key] = newNode\\n\\n            if freqToList[1] == nil {\\n                freqToList[1] = FreqList()\\n            }\\n            freqToList[1]!.append(newNode)\\n            \\n            size += 1\\n            minFreq = 1\\n        }\\n    }\\n    \\n    \\n    // update: increase freq, remove node from oldFreq\\'s list, add it to new list\\n    // if oldFreq\\'s list is empty, minReq is now this newFreq\\n    func update(_ node: ListNode) {\\n        let oldFreq = node.freq\\n        let newFreq = oldFreq + 1\\n        \\n        freqToList[oldFreq]!.remove(node)\\n        if minFreq == oldFreq && freqToList[oldFreq]!.size == 0 {\\n            minFreq = newFreq\\n        }\\n        \\n        node.freq = newFreq\\n        \\n        if freqToList[newFreq] == nil {\\n            freqToList[newFreq] = FreqList()\\n        }\\n        freqToList[newFreq]!.append(node)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode {\\n    let key: Int\\n    var value: Int\\n    var freq: Int = 1\\n    var prev: ListNode? = nil\\n    var next: ListNode? = nil\\n    \\n    init(_ key: Int, _ value: Int) {\\n        self.key = key\\n        self.value = value\\n    }\\n}\\n\\nclass FreqList {\\n    // \"dummy\" stay between the tail and the head: ....tail -> dummy -> head.....\\n    // head is the LRU, tail is the most recently used\\n    let dummy: ListNode\\n    var size = 0\\n    \\n    init() {\\n        dummy = ListNode(-1, -1)\\n        dummy.prev = dummy\\n        dummy.next = dummy\\n    }\\n    \\n    func append(_ node: ListNode) { // add to the tail (most recently used)\\n        node.prev = dummy.prev\\n        node.prev!.next = node\\n        node.next = dummy\\n        dummy.prev = node\\n        \\n        size += 1\\n    }\\n    \\n    func remove(_ node: ListNode) {\\n        node.next!.prev = node.prev\\n        node.prev!.next = node.next\\n        \\n        size -= 1\\n    }\\n    \\n    func popLast() -> ListNode { // remove the head (LRU) and return it\\n        let head = dummy.next!\\n        remove(head)\\n        return head\\n    }\\n}\\n\\nclass LFUCache {\\n    var keyToNode = [Int: ListNode]()\\n    var freqToList = [Int: FreqList]()\\n    var size = 0\\n    var minFreq = 0\\n    let capacity: Int\\n    \\n    init(_ capacity: Int) {\\n        self.capacity = capacity\\n    }\\n    \\n    // get: return keyToNode[key], update node\\n    func get(_ key: Int) -> Int {\\n        if let node = keyToNode[key] {\\n            update(node)\\n            return node.value\\n        } else {\\n            return -1\\n        }\\n    }\\n    \\n    // put: if there exist \"node\", update it\\n    // else, check capacity, if full, remove head (LRU)\\n    // then, add the new node\\n    func put(_ key: Int, _ value: Int) {\\n        if capacity == 0 { return }\\n        \\n        if let node = keyToNode[key] {\\n            node.value = value\\n            update(node)\\n        } else {\\n            if size == capacity { // full\\n                let lruNode = freqToList[minFreq]!.popLast()\\n                keyToNode[lruNode.key] = nil\\n                size -= 1\\n            } \\n            \\n            let newNode = ListNode(key, value)\\n            keyToNode[key] = newNode\\n\\n            if freqToList[1] == nil {\\n                freqToList[1] = FreqList()\\n            }\\n            freqToList[1]!.append(newNode)\\n            \\n            size += 1\\n            minFreq = 1\\n        }\\n    }\\n    \\n    \\n    // update: increase freq, remove node from oldFreq\\'s list, add it to new list\\n    // if oldFreq\\'s list is empty, minReq is now this newFreq\\n    func update(_ node: ListNode) {\\n        let oldFreq = node.freq\\n        let newFreq = oldFreq + 1\\n        \\n        freqToList[oldFreq]!.remove(node)\\n        if minFreq == oldFreq && freqToList[oldFreq]!.size == 0 {\\n            minFreq = newFreq\\n        }\\n        \\n        node.freq = newFreq\\n        \\n        if freqToList[newFreq] == nil {\\n            freqToList[newFreq] = FreqList()\\n        }\\n        freqToList[newFreq]!.append(node)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530128,
                "title": "c-o-1-get-o-1-put-beats-100-in-space-and-time-no-built-in-frameworks-ds-etc",
                "content": "Below code is self-explanatory as it appears with needed inline comments. It is a barebone C code accomplishing O(1) get O(1) put - with no built-in framework used to store and retrieve the data or to maintain LFU cache. It took considerable attempts to get everything finally working with top speed and minimum space. But, I feel it\\'s totally worth it.\\n\\nCheers\\n\\n```\\n#define MAX_CACHE_ITEMS 3192\\n#define MAX_FREQ 128\\n\\ntypedef struct LFUCache LFUCache;\\ntypedef struct LFUCache {   // Cache entry\\n    int freq;\\n    int val;\\n    bool valid;\\n    LFUCache *prev;\\n    LFUCache *next;\\n} LFUCache;\\n\\nstruct freq_m {             // Freq-list data\\n    LFUCache *head;\\n    LFUCache *tail;\\n};\\n\\nstruct cache_data {         // Main data\\n    int capacity;\\n    int size;\\n    int lfreq_index;        // Indexes freq-lists\\n    LFUCache *cache;        // Cache entries\\n    struct freq_m *fm;      // Freq-lists\\n};\\n\\ninline void *cache_alloc(int capacity);\\ninline void cache_dealloc(void *cache);\\ninline void refresh_cache(LFUCache *item, struct cache_data *cdata, bool new_entry);\\n\\nLFUCache* lFUCacheCreate(int capacity) {\\n    return cache_alloc(capacity);\\n}\\n\\nint lFUCacheGet(LFUCache* obj, int key) {\\n    struct cache_data *cdata = (void *)obj;\\n    LFUCache *item = &cdata->cache[key];\\n    if (cdata->capacity <= 0 || !item->valid)\\n        return -1;\\n    refresh_cache(item, cdata, false);\\n    return item->val;\\n}\\n\\nvoid lFUCachePut(LFUCache* obj, int key, int value) {\\n    struct cache_data *cdata = (void *)obj;\\n    LFUCache *item = &cdata->cache[key];\\n    if (cdata->capacity <= 0 || key >= MAX_CACHE_ITEMS)\\n        return;\\n    refresh_cache(item, cdata, !item->valid);\\n    item->val = value; \\n}\\n\\nvoid lFUCacheFree(LFUCache* obj) {\\n    cache_dealloc(obj);\\n}\\n\\n// Sets up cache\\ninline void *cache_alloc(int capacity)\\n{\\n    if (capacity > MAX_CACHE_ITEMS)\\n        return NULL;\\n    struct cache_data *cdata = calloc(1, sizeof *cdata);\\n    cdata->capacity = capacity;\\n    cdata->cache = calloc(1, sizeof(LFUCache [MAX_CACHE_ITEMS]));\\n    cdata->fm = calloc(1, sizeof(struct freq_m [MAX_FREQ]));\\n    return cdata;\\n}\\n\\n// Relinquishes cache\\ninline void cache_dealloc(void *cache)\\n{\\n    struct cache_data *cdata = cache;\\n    free(cdata->cache), \\n    free(cdata->fm);\\n    free(cdata);\\n}\\n\\n// Removes item from current freq-list\\ninline void fix_node(LFUCache *item)\\n{\\n    LFUCache **prev = &item->prev, **next = &item->next;\\n    *prev ? (*prev)->next = *next : 0;\\n    *next ? (*next)->prev = *prev : 0;\\n} \\n\\n// Fixes current freq-list\\ninline void fix_chead_tail_lfreq(LFUCache *item, struct cache_data *cdata)\\n{\\n    struct freq_m *fm = &cdata->fm[item->freq];\\n    LFUCache **head = &fm->head, **tail = &fm->tail;\\n    item == *head ? *head = item->next : 0;\\n    item == *tail ? *tail = item->prev : 0;\\n    item->freq == cdata->lfreq_index && !fm->head ? cdata->lfreq_index++ : 0;\\n}\\n\\n// Adds to front of next freq-list\\ninline void fix_nhead_tail(LFUCache *item, struct cache_data *cdata)\\n{                \\n    struct freq_m *fm = &cdata->fm[++item->freq];\\n    item->prev = NULL;                                      \\n    item->next = fm->head;                                    \\n    fm->head = fm->head ? fm->head->prev = item : (fm->tail = item);         \\n}\\n\\n// Evicts least-used entry from least freq-list\\ninline void evict_lfreq_node(struct cache_data *cdata)                             \\n{   \\n    struct freq_m *fm = &cdata->fm[cdata->lfreq_index]; \\n    LFUCache *lu = fm->tail;                         \\n    lu->prev ? lu->prev->next = NULL : 0;     \\n    lu->freq = 0;\\n    lu->valid = false;\\n    !(fm->tail = lu->prev) ? fm->head = NULL : 0;    \\n    lu->prev = lu->next = NULL;    \\n}\\n\\n// Maintains cache\\ninline void refresh_cache(LFUCache *item, struct cache_data *cdata, bool new_entry)\\n{\\n    if (new_entry)\\n        if (cdata->size == cdata->capacity)\\n            evict_lfreq_node(cdata); // Evict least-used entry from least freq-list\\n        else\\n            cdata->size++;        \\n    else {\\n        fix_node(item); // Remove from current freq-list\\n        fix_chead_tail_lfreq(item, cdata); // Fix current freq-list\\n    }\\n    fix_nhead_tail(item, cdata); // Add to front of next freq-list  \\n    if (!cdata->lfreq_index || cdata->lfreq_index > item->freq)\\n        cdata->lfreq_index = item->freq; \\n    item->valid = true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_CACHE_ITEMS 3192\\n#define MAX_FREQ 128\\n\\ntypedef struct LFUCache LFUCache;\\ntypedef struct LFUCache {   // Cache entry\\n    int freq;\\n    int val;\\n    bool valid;\\n    LFUCache *prev;\\n    LFUCache *next;\\n} LFUCache;\\n\\nstruct freq_m {             // Freq-list data\\n    LFUCache *head;\\n    LFUCache *tail;\\n};\\n\\nstruct cache_data {         // Main data\\n    int capacity;\\n    int size;\\n    int lfreq_index;        // Indexes freq-lists\\n    LFUCache *cache;        // Cache entries\\n    struct freq_m *fm;      // Freq-lists\\n};\\n\\ninline void *cache_alloc(int capacity);\\ninline void cache_dealloc(void *cache);\\ninline void refresh_cache(LFUCache *item, struct cache_data *cdata, bool new_entry);\\n\\nLFUCache* lFUCacheCreate(int capacity) {\\n    return cache_alloc(capacity);\\n}\\n\\nint lFUCacheGet(LFUCache* obj, int key) {\\n    struct cache_data *cdata = (void *)obj;\\n    LFUCache *item = &cdata->cache[key];\\n    if (cdata->capacity <= 0 || !item->valid)\\n        return -1;\\n    refresh_cache(item, cdata, false);\\n    return item->val;\\n}\\n\\nvoid lFUCachePut(LFUCache* obj, int key, int value) {\\n    struct cache_data *cdata = (void *)obj;\\n    LFUCache *item = &cdata->cache[key];\\n    if (cdata->capacity <= 0 || key >= MAX_CACHE_ITEMS)\\n        return;\\n    refresh_cache(item, cdata, !item->valid);\\n    item->val = value; \\n}\\n\\nvoid lFUCacheFree(LFUCache* obj) {\\n    cache_dealloc(obj);\\n}\\n\\n// Sets up cache\\ninline void *cache_alloc(int capacity)\\n{\\n    if (capacity > MAX_CACHE_ITEMS)\\n        return NULL;\\n    struct cache_data *cdata = calloc(1, sizeof *cdata);\\n    cdata->capacity = capacity;\\n    cdata->cache = calloc(1, sizeof(LFUCache [MAX_CACHE_ITEMS]));\\n    cdata->fm = calloc(1, sizeof(struct freq_m [MAX_FREQ]));\\n    return cdata;\\n}\\n\\n// Relinquishes cache\\ninline void cache_dealloc(void *cache)\\n{\\n    struct cache_data *cdata = cache;\\n    free(cdata->cache), \\n    free(cdata->fm);\\n    free(cdata);\\n}\\n\\n// Removes item from current freq-list\\ninline void fix_node(LFUCache *item)\\n{\\n    LFUCache **prev = &item->prev, **next = &item->next;\\n    *prev ? (*prev)->next = *next : 0;\\n    *next ? (*next)->prev = *prev : 0;\\n} \\n\\n// Fixes current freq-list\\ninline void fix_chead_tail_lfreq(LFUCache *item, struct cache_data *cdata)\\n{\\n    struct freq_m *fm = &cdata->fm[item->freq];\\n    LFUCache **head = &fm->head, **tail = &fm->tail;\\n    item == *head ? *head = item->next : 0;\\n    item == *tail ? *tail = item->prev : 0;\\n    item->freq == cdata->lfreq_index && !fm->head ? cdata->lfreq_index++ : 0;\\n}\\n\\n// Adds to front of next freq-list\\ninline void fix_nhead_tail(LFUCache *item, struct cache_data *cdata)\\n{                \\n    struct freq_m *fm = &cdata->fm[++item->freq];\\n    item->prev = NULL;                                      \\n    item->next = fm->head;                                    \\n    fm->head = fm->head ? fm->head->prev = item : (fm->tail = item);         \\n}\\n\\n// Evicts least-used entry from least freq-list\\ninline void evict_lfreq_node(struct cache_data *cdata)                             \\n{   \\n    struct freq_m *fm = &cdata->fm[cdata->lfreq_index]; \\n    LFUCache *lu = fm->tail;                         \\n    lu->prev ? lu->prev->next = NULL : 0;     \\n    lu->freq = 0;\\n    lu->valid = false;\\n    !(fm->tail = lu->prev) ? fm->head = NULL : 0;    \\n    lu->prev = lu->next = NULL;    \\n}\\n\\n// Maintains cache\\ninline void refresh_cache(LFUCache *item, struct cache_data *cdata, bool new_entry)\\n{\\n    if (new_entry)\\n        if (cdata->size == cdata->capacity)\\n            evict_lfreq_node(cdata); // Evict least-used entry from least freq-list\\n        else\\n            cdata->size++;        \\n    else {\\n        fix_node(item); // Remove from current freq-list\\n        fix_chead_tail_lfreq(item, cdata); // Fix current freq-list\\n    }\\n    fix_nhead_tail(item, cdata); // Add to front of next freq-list  \\n    if (!cdata->lfreq_index || cdata->lfreq_index > item->freq)\\n        cdata->lfreq_index = item->freq; \\n    item->valid = true;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 442088,
                "title": "java-solution",
                "content": "```\\nclass LFUCache {\\n    private int capacity;\\n    private int min;\\n    private Map<Integer, Integer> keyToVal;\\n    private Map<Integer, Integer> keyToCount;\\n    private Map<Integer, LinkedHashSet<Integer>> countToLRUKeys;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.min = -1;\\n        keyToVal = new HashMap<>();\\n        keyToCount = new HashMap<>();\\n        countToLRUKeys = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToVal.containsKey(key)) {\\n            return -1;\\n        }\\n        int count = keyToCount.get(key);\\n        countToLRUKeys.get(count).remove(key);\\n        if (min == count && countToLRUKeys.get(count).size() == 0) {\\n            min++;\\n        }\\n        putCount(key, count + 1);\\n        return keyToVal.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity <= 0) {\\n            return;\\n        }\\n        if (keyToVal.containsKey(key)) {\\n            keyToVal.put(key, value);\\n            int count = keyToCount.get(key);\\n            countToLRUKeys.get(count).remove(key);\\n            if (min == count && countToLRUKeys.get(count).size() == 0) {\\n                min++;\\n            }\\n            putCount(key, count + 1);\\n            return;\\n        }\\n        if (keyToVal.size() >= capacity) {\\n            evict(countToLRUKeys.get(min).iterator().next());\\n        }\\n        min = 1;\\n        putCount(key, 1);\\n        keyToVal.put(key, value);\\n    }\\n    \\n    //helper functions\\n    private void evict(int key) {\\n        //evict from the keyToVal map:\\n        keyToVal.remove(key);\\n        countToLRUKeys.get(min).remove(key);\\n    }\\n    private void putCount(int key, int count) {\\n        keyToCount.put(key, count);\\n        if (!countToLRUKeys.containsKey(count)) {\\n            countToLRUKeys.put(count, new LinkedHashSet<Integer>());\\n        }\\n        countToLRUKeys.get(count).add(key);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    private int capacity;\\n    private int min;\\n    private Map<Integer, Integer> keyToVal;\\n    private Map<Integer, Integer> keyToCount;\\n    private Map<Integer, LinkedHashSet<Integer>> countToLRUKeys;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.min = -1;\\n        keyToVal = new HashMap<>();\\n        keyToCount = new HashMap<>();\\n        countToLRUKeys = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToVal.containsKey(key)) {\\n            return -1;\\n        }\\n        int count = keyToCount.get(key);\\n        countToLRUKeys.get(count).remove(key);\\n        if (min == count && countToLRUKeys.get(count).size() == 0) {\\n            min++;\\n        }\\n        putCount(key, count + 1);\\n        return keyToVal.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity <= 0) {\\n            return;\\n        }\\n        if (keyToVal.containsKey(key)) {\\n            keyToVal.put(key, value);\\n            int count = keyToCount.get(key);\\n            countToLRUKeys.get(count).remove(key);\\n            if (min == count && countToLRUKeys.get(count).size() == 0) {\\n                min++;\\n            }\\n            putCount(key, count + 1);\\n            return;\\n        }\\n        if (keyToVal.size() >= capacity) {\\n            evict(countToLRUKeys.get(min).iterator().next());\\n        }\\n        min = 1;\\n        putCount(key, 1);\\n        keyToVal.put(key, value);\\n    }\\n    \\n    //helper functions\\n    private void evict(int key) {\\n        //evict from the keyToVal map:\\n        keyToVal.remove(key);\\n        countToLRUKeys.get(min).remove(key);\\n    }\\n    private void putCount(int key, int count) {\\n        keyToCount.put(key, count);\\n        if (!countToLRUKeys.containsKey(count)) {\\n            countToLRUKeys.put(count, new LinkedHashSet<Integer>());\\n        }\\n        countToLRUKeys.get(count).add(key);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436958,
                "title": "very-easy-to-read-c-solution-using-3-hashmap",
                "content": "```\\n\\nclass LFUCache {\\npublic:\\n    int capacity, lfu = 0;\\n    \\n    unordered_map<int, pair<int, int>>          key_val_freq;   // key to {value,freq}\\n    unordered_map<int, list<int>>               freq_key;       // freq to key list \\n    unordered_map<int, list<int>::iterator>     key_freq_iter;  // key to list iterator;\\n    \\n    LFUCache(int capacity) : capacity(capacity) {\\n    }\\n    \\n    int get(int key) {\\n        if (!key_val_freq.count(key)) {\\n            return -1;\\n        }\\n        updateLFU(key);\\n        return key_val_freq[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!capacity) {\\n            return;\\n        }\\n        \\n        if (key_val_freq.size() == capacity && key_val_freq.count(key) == 0)\\n            evict();\\n            \\n        if (key_val_freq.count(key)) {\\n            key_val_freq[key].first = value;\\n            updateLFU(key);\\n        } else {\\n            key_val_freq[key] = {value, 1};\\n            freq_key[1].push_back(key);\\n\\n            key_freq_iter[key] = --freq_key[1].end();  // store the position of the key in freq_key list !!!    \\n            lfu = 1;\\n        }\\n    }\\n    \\n    \\n    void updateLFU(int key) {        \\n        int freq = key_val_freq[key].second;\\n        \\n        key_val_freq[key].second++;             // update freq for the key\\n        auto iter = key_freq_iter[key];\\n\\n        freq_key[freq].erase(iter);\\n        freq_key[freq + 1].push_back(key);\\n        \\n        key_freq_iter[key] = --freq_key[freq + 1].end();\\n        \\n        if (freq_key[lfu].empty()) {\\n            lfu++;\\n        }\\n    }\\n    \\n    void evict() {\\n        int key = freq_key[lfu].front();\\n        freq_key[lfu].pop_front();\\n        \\n        key_val_freq.erase(key);\\n        key_freq_iter.erase(key);\\n    }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass LFUCache {\\npublic:\\n    int capacity, lfu = 0;\\n    \\n    unordered_map<int, pair<int, int>>          key_val_freq;   // key to {value,freq}\\n    unordered_map<int, list<int>>               freq_key;       // freq to key list \\n    unordered_map<int, list<int>::iterator>     key_freq_iter;  // key to list iterator;\\n    \\n    LFUCache(int capacity) : capacity(capacity) {\\n    }\\n    \\n    int get(int key) {\\n        if (!key_val_freq.count(key)) {\\n            return -1;\\n        }\\n        updateLFU(key);\\n        return key_val_freq[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!capacity) {\\n            return;\\n        }\\n        \\n        if (key_val_freq.size() == capacity && key_val_freq.count(key) == 0)\\n            evict();\\n            \\n        if (key_val_freq.count(key)) {\\n            key_val_freq[key].first = value;\\n            updateLFU(key);\\n        } else {\\n            key_val_freq[key] = {value, 1};\\n            freq_key[1].push_back(key);\\n\\n            key_freq_iter[key] = --freq_key[1].end();  // store the position of the key in freq_key list !!!    \\n            lfu = 1;\\n        }\\n    }\\n    \\n    \\n    void updateLFU(int key) {        \\n        int freq = key_val_freq[key].second;\\n        \\n        key_val_freq[key].second++;             // update freq for the key\\n        auto iter = key_freq_iter[key];\\n\\n        freq_key[freq].erase(iter);\\n        freq_key[freq + 1].push_back(key);\\n        \\n        key_freq_iter[key] = --freq_key[freq + 1].end();\\n        \\n        if (freq_key[lfu].empty()) {\\n            lfu++;\\n        }\\n    }\\n    \\n    void evict() {\\n        int key = freq_key[lfu].front();\\n        freq_key[lfu].pop_front();\\n        \\n        key_val_freq.erase(key);\\n        key_freq_iter.erase(key);\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361079,
                "title": "java-o-1-using-hashmap-and-linkedhashset-with-detailed-explanation",
                "content": "Credits: http://zxi.mytechroad.com/blog/hashtable/leetcode-460-lfu-cache/\\n![image](https://assets.leetcode.com/users/jinliutrojan/image_1566102572.png)\\n\\n```\\nclass LFUCache {\\n    /**\\n        Since we have get/put, we obviously need a hashmap. However, we need to evict least frequent used item so we need to keep the frequency information. \\n\\t\\tLike LRU, we create a self-dine node structure that has : key, value, freq\\n        Also, we need to keep capacity and min_freq as global variable. So that we can use min_freq to evict entry.\\n        We can use another hashmap<Integer, LinkedHashSet<Node>> to store freq -> [list of Node that has the same freq].\\n        get(key): If key doesn\\'t exist, return -1. Otherwise, get the node and call update(node). Return node.value\\n        put(key,value): If capacity <= 0, return. If key already existed, call update(node) and update its value. \\n\\t\\tOtherwise, we create a new entry for the key and put the new node(freq=1) into the cacheMap. \\n\\t\\tNow if cacheMap>capacity, we need to get the least frequent list of nodes from freqMap and delete the first node from list.\\n\\t\\tAlso delete it from cacheMap. In the end, reset minFreq = 1.\\n        update(node):First get the node.freq\\'s list from freqMap. Delete this node from list. If list is empty and node.freq=minFreq. This means minFreq list is empty. \\n\\t\\tNow we need to minFreq++. After this, We add 1 to node\\'s freq, then put it back to freqMap to the new freq bucket.\\n    */\\n    class Node{\\n        int key;\\n        int value;\\n        int freq;\\n        public Node(int key, int value, int freq){\\n            this.key = key;\\n            this.value = value;\\n            this.freq = freq;\\n        }\\n    }\\n    private int CAPACITY;\\n    private int minFreq;\\n    private HashMap<Integer, Node> cacheMap;\\n    private HashMap<Integer, LinkedHashSet<Node>> freqMap;\\n    public LFUCache(int capacity) {\\n        this.CAPACITY = capacity;\\n        this.minFreq = 1;\\n        this.cacheMap = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!cacheMap.containsKey(key))\\n            return -1;\\n        Node node = cacheMap.get(key);\\n        update(node);\\n        return node.value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(CAPACITY <= 0)\\n            return;\\n        if(cacheMap.containsKey(key)){\\n            Node node = cacheMap.get(key);\\n            update(node);\\n            node.value = value;\\n        }\\n        else{\\n            Node newNode = new Node(key, value, 1);\\n            cacheMap.put(key, newNode);\\n            if(!freqMap.containsKey(1))\\n                freqMap.put(1, new LinkedHashSet<Node>());\\n            freqMap.get(1).add(newNode);\\n            if(cacheMap.size() > CAPACITY){\\n                LinkedHashSet<Node> toBeEvictedList = freqMap.get(minFreq);\\n                Node toBeEvictedNode = toBeEvictedList.iterator().next();\\n                toBeEvictedList.remove(toBeEvictedNode);\\n                cacheMap.remove(toBeEvictedNode.key);\\n            }\\n            minFreq = 1;\\n        }\\n    }\\n    private void update(Node node){\\n        LinkedHashSet<Node> prevFreqNodeSet = freqMap.get(node.freq);\\n        prevFreqNodeSet.remove(node);\\n        if(prevFreqNodeSet.isEmpty() && node.freq == minFreq)\\n            minFreq++;\\n        node.freq++;\\n        if(!freqMap.containsKey(node.freq))\\n            freqMap.put(node.freq, new LinkedHashSet<Node>());\\n        freqMap.get(node.freq).add(node);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n    /**\\n        Since we have get/put, we obviously need a hashmap. However, we need to evict least frequent used item so we need to keep the frequency information. \\n\\t\\tLike LRU, we create a self-dine node structure that has : key, value, freq\\n        Also, we need to keep capacity and min_freq as global variable. So that we can use min_freq to evict entry.\\n        We can use another hashmap<Integer, LinkedHashSet<Node>> to store freq -> [list of Node that has the same freq].\\n        get(key): If key doesn\\'t exist, return -1. Otherwise, get the node and call update(node). Return node.value\\n        put(key,value): If capacity <= 0, return. If key already existed, call update(node) and update its value. \\n\\t\\tOtherwise, we create a new entry for the key and put the new node(freq=1) into the cacheMap. \\n\\t\\tNow if cacheMap>capacity, we need to get the least frequent list of nodes from freqMap and delete the first node from list.\\n\\t\\tAlso delete it from cacheMap. In the end, reset minFreq = 1.\\n        update(node):First get the node.freq\\'s list from freqMap. Delete this node from list. If list is empty and node.freq=minFreq. This means minFreq list is empty. \\n\\t\\tNow we need to minFreq++. After this, We add 1 to node\\'s freq, then put it back to freqMap to the new freq bucket.\\n    */\\n    class Node{\\n        int key;\\n        int value;\\n        int freq;\\n        public Node(int key, int value, int freq){\\n            this.key = key;\\n            this.value = value;\\n            this.freq = freq;\\n        }\\n    }\\n    private int CAPACITY;\\n    private int minFreq;\\n    private HashMap<Integer, Node> cacheMap;\\n    private HashMap<Integer, LinkedHashSet<Node>> freqMap;\\n    public LFUCache(int capacity) {\\n        this.CAPACITY = capacity;\\n        this.minFreq = 1;\\n        this.cacheMap = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!cacheMap.containsKey(key))\\n            return -1;\\n        Node node = cacheMap.get(key);\\n        update(node);\\n        return node.value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(CAPACITY <= 0)\\n            return;\\n        if(cacheMap.containsKey(key)){\\n            Node node = cacheMap.get(key);\\n            update(node);\\n            node.value = value;\\n        }\\n        else{\\n            Node newNode = new Node(key, value, 1);\\n            cacheMap.put(key, newNode);\\n            if(!freqMap.containsKey(1))\\n                freqMap.put(1, new LinkedHashSet<Node>());\\n            freqMap.get(1).add(newNode);\\n            if(cacheMap.size() > CAPACITY){\\n                LinkedHashSet<Node> toBeEvictedList = freqMap.get(minFreq);\\n                Node toBeEvictedNode = toBeEvictedList.iterator().next();\\n                toBeEvictedList.remove(toBeEvictedNode);\\n                cacheMap.remove(toBeEvictedNode.key);\\n            }\\n            minFreq = 1;\\n        }\\n    }\\n    private void update(Node node){\\n        LinkedHashSet<Node> prevFreqNodeSet = freqMap.get(node.freq);\\n        prevFreqNodeSet.remove(node);\\n        if(prevFreqNodeSet.isEmpty() && node.freq == minFreq)\\n            minFreq++;\\n        node.freq++;\\n        if(!freqMap.containsKey(node.freq))\\n            freqMap.put(node.freq, new LinkedHashSet<Node>());\\n        freqMap.get(node.freq).add(node);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200375,
                "title": "105ms-java-with-explanations",
                "content": "We wanted to figure out\\n- value of a key\\n- current frequency of a key\\n- least frequently used keys which is least recently used\\nAssuming there are several keys with the same frequency, we add them to an ordered collection (by insertion order) when we access them. The earliest inserted, i.e., the first one should be the least recently used. So when we reach capacity, we can remove the first one of the least frequently used keys collection.\\n\\nPlease never forget to remove frequency if no keys share this frequency. \\n```\\n    private static Map<Integer, Integer> keyToFreq;\\n    private static Map<Integer, Integer> keyToValue;\\n    private static TreeMap<Integer, LinkedHashSet<Integer>> freqToKeys;\\n    private static int capacity;\\n    \\n    public LFUCache(int capacity) {\\n        keyToFreq = new HashMap<>();\\n        keyToValue = new HashMap<>();\\n        freqToKeys = new TreeMap<>();\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToValue.containsKey(key))\\n            return -1;\\n        \\n        updateExistingFreq(key);\\n        \\n        return keyToValue.get(key);\\n    }\\n    \\n    private static void updateExistingFreq(int key) {\\n        int prevFreq = keyToFreq.get(key);\\n        int curFreq = prevFreq + 1;\\n        keyToFreq.put(key, curFreq);\\n        \\n        freqToKeys.get(prevFreq).remove(key);\\n        if (freqToKeys.get(prevFreq).isEmpty())\\n            freqToKeys.remove(prevFreq);\\n        freqToKeys.putIfAbsent(curFreq, new LinkedHashSet<>());\\n        freqToKeys.get(curFreq).add(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        // Corner case.\\n        if (capacity == 0)\\n            return;\\n        \\n        // If key is present already.\\n        if (keyToValue.containsKey(key)) {\\n            updateExistingFreq(key);\\n            keyToValue.put(key, value);\\n            return;\\n        }\\n        \\n        // If reach capacity.\\n        if (capacity == keyToValue.size()) {\\n            invalidate();\\n        }\\n        \\n        keyToValue.put(key, value);\\n        keyToFreq.put(key, 1);\\n        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());\\n        freqToKeys.get(1).add(key);\\n    }\\n    \\n    private static void invalidate() {\\n        int minFreq = freqToKeys.firstKey();\\n        // Remove the least recently used with the minimum frequency..\\n        int keyToRemove = -1;        \\n        Iterator<Integer> iter =freqToKeys.get(minFreq).iterator();\\n        if (iter.hasNext()) {\\n            keyToRemove = iter.next();\\n            iter.remove();\\n        }\\n        if (!iter.hasNext()) \\n            freqToKeys.remove(minFreq);\\n            \\n        keyToValue.remove(keyToRemove);\\n        keyToFreq.remove(keyToRemove);\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    private static Map<Integer, Integer> keyToFreq;\\n    private static Map<Integer, Integer> keyToValue;\\n    private static TreeMap<Integer, LinkedHashSet<Integer>> freqToKeys;\\n    private static int capacity;\\n    \\n    public LFUCache(int capacity) {\\n        keyToFreq = new HashMap<>();\\n        keyToValue = new HashMap<>();\\n        freqToKeys = new TreeMap<>();\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!keyToValue.containsKey(key))\\n            return -1;\\n        \\n        updateExistingFreq(key);\\n        \\n        return keyToValue.get(key);\\n    }\\n    \\n    private static void updateExistingFreq(int key) {\\n        int prevFreq = keyToFreq.get(key);\\n        int curFreq = prevFreq + 1;\\n        keyToFreq.put(key, curFreq);\\n        \\n        freqToKeys.get(prevFreq).remove(key);\\n        if (freqToKeys.get(prevFreq).isEmpty())\\n            freqToKeys.remove(prevFreq);\\n        freqToKeys.putIfAbsent(curFreq, new LinkedHashSet<>());\\n        freqToKeys.get(curFreq).add(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        // Corner case.\\n        if (capacity == 0)\\n            return;\\n        \\n        // If key is present already.\\n        if (keyToValue.containsKey(key)) {\\n            updateExistingFreq(key);\\n            keyToValue.put(key, value);\\n            return;\\n        }\\n        \\n        // If reach capacity.\\n        if (capacity == keyToValue.size()) {\\n            invalidate();\\n        }\\n        \\n        keyToValue.put(key, value);\\n        keyToFreq.put(key, 1);\\n        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());\\n        freqToKeys.get(1).add(key);\\n    }\\n    \\n    private static void invalidate() {\\n        int minFreq = freqToKeys.firstKey();\\n        // Remove the least recently used with the minimum frequency..\\n        int keyToRemove = -1;        \\n        Iterator<Integer> iter =freqToKeys.get(minFreq).iterator();\\n        if (iter.hasNext()) {\\n            keyToRemove = iter.next();\\n            iter.remove();\\n        }\\n        if (!iter.hasNext()) \\n            freqToKeys.remove(minFreq);\\n            \\n        keyToValue.remove(keyToRemove);\\n        keyToFreq.remove(keyToRemove);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541988,
                "title": "460-lfu-cache",
                "content": "class LFUCache {\\nprivate:\\n    unordered_map<int, int> key_val;\\n    unordered_map<int, int> key_use;\\n    unordered_map<int, deque<int>> uses;\\n    int min_uses;\\n    int capacity;\\n\\n    // Remove stale values from the uses[min_uses] deque\\n    void refreshCache() {\\n        while (!uses[min_uses].empty()) {\\n            int tmp_key = uses[min_uses].front();\\n            // Found a non-stale value, so refreshing done\\n            if (key_use[tmp_key] == min_uses) break;\\n\\n            // This is a stale value - remove it from the deque\\n            uses[min_uses].pop_front();\\n\\n            // uses[min_uses] was populated only by stale values, so remove it\\n            if (uses[min_uses].empty()) {\\n                uses.erase(min_uses);\\n                // Find the next candidate min_uses\\n                while (!uses.count(min_uses)) ++min_uses;\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int capacity): min_uses(INT_MAX), capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // Key doesn\\'t exist in cache\\n        if (!key_val.count(key)) return -1;\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        return key_val[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0) return;\\n\\n        // Prune the cache if at capacity and inserting a new value\\n        if (key_val.size() == capacity && !key_val.count(key)) {\\n            refreshCache();\\n\\n            // Finished removing all stale values from the cache\\n            // We now know this value must be valid. Erase the value\\n            // With the minimum number of uses that was used last\\n            int to_remove = uses[min_uses].front();\\n            uses[min_uses].pop_front();\\n            key_val.erase(to_remove);\\n            key_use.erase(to_remove);\\n        }\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        // If the number of uses of this newly insert key is a new minimum, update\\n        min_uses = min(min_uses, key_use[key]);\\n\\n        key_val[key] = value;\\n    }\\n};``",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "class LFUCache {\\nprivate:\\n    unordered_map<int, int> key_val;\\n    unordered_map<int, int> key_use;\\n    unordered_map<int, deque<int>> uses;\\n    int min_uses;\\n    int capacity;\\n\\n    // Remove stale values from the uses[min_uses] deque\\n    void refreshCache() {\\n        while (!uses[min_uses].empty()) {\\n            int tmp_key = uses[min_uses].front();\\n            // Found a non-stale value, so refreshing done\\n            if (key_use[tmp_key] == min_uses) break;\\n\\n            // This is a stale value - remove it from the deque\\n            uses[min_uses].pop_front();\\n\\n            // uses[min_uses] was populated only by stale values, so remove it\\n            if (uses[min_uses].empty()) {\\n                uses.erase(min_uses);\\n                // Find the next candidate min_uses\\n                while (!uses.count(min_uses)) ++min_uses;\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int capacity): min_uses(INT_MAX), capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // Key doesn\\'t exist in cache\\n        if (!key_val.count(key)) return -1;\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        return key_val[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0) return;\\n\\n        // Prune the cache if at capacity and inserting a new value\\n        if (key_val.size() == capacity && !key_val.count(key)) {\\n            refreshCache();\\n\\n            // Finished removing all stale values from the cache\\n            // We now know this value must be valid. Erase the value\\n            // With the minimum number of uses that was used last\\n            int to_remove = uses[min_uses].front();\\n            uses[min_uses].pop_front();\\n            key_val.erase(to_remove);\\n            key_use.erase(to_remove);\\n        }\\n\\n        ++key_use[key];\\n        uses[key_use[key]].push_back(key);\\n\\n        // If the number of uses of this newly insert key is a new minimum, update\\n        min_uses = min(min_uses, key_use[key]);\\n\\n        key_val[key] = value;\\n    }\\n};``",
                "codeTag": "Java"
            },
            {
                "id": 3337846,
                "title": "easy-to-undetstand-java-solution-with-comments-two-maps-node",
                "content": "```\\nclass LFUCache {\\n    class Node{\\n        int val;\\n        int key;\\n        int count;\\n    }\\n    \\n    int minCount;\\n    int cap;\\n    Map<Integer, Node> m; // k: key, v: node\\n    Map<Integer, LinkedHashSet<Node>> countToNodes; // k: count, v: a linked hashset of all nodes that their keys are equal to count\\n    \\n    public LFUCache(int capacity) {\\n        minCount = 1;\\n        cap = capacity;\\n        countToNodes = new HashMap<>();\\n        m = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!m.containsKey(key)){\\n            return -1;\\n        } \\n        Node cur = m.get(key);\\n        // remove key from current count (since we will inc count)\\n        countToNodes.get(cur.count).remove(cur); \\n        if (cur.count == minCount && countToNodes.get(cur.count).size() == 0){\\n            minCount++; // nothing in the current minCount bucket\\n        }\\n        cur.count++;\\n        \\n        if(!countToNodes.containsKey(cur.count)){ // a new count\\n            countToNodes.put(cur.count, new LinkedHashSet<>()); \\n        }\\n        countToNodes.get(cur.count).add(cur);\\n        return m.get(key).val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            m.get(key).val = value;\\n            get(key); // update key\\'s count\\n            return;\\n        } \\n        \\n        if (m.size() >= cap){\\n            Node nodeToRemove = countToNodes.get(minCount).iterator().next();\\n            countToNodes.get(minCount).remove(nodeToRemove);\\n            m.remove(nodeToRemove.key);\\n        }\\n        \\n        minCount = 1;\\n        Node cur = new Node();\\n        cur.val = value;\\n        cur.count = minCount;\\n        cur.key = key;\\n        m.put(key, cur);\\n        if(!countToNodes.containsKey(cur.count)){\\n            countToNodes.put(cur.count, new LinkedHashSet<>());\\n        }\\n        countToNodes.get(cur.count).add(cur);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    class Node{\\n        int val;\\n        int key;\\n        int count;\\n    }\\n    \\n    int minCount;\\n    int cap;\\n    Map<Integer, Node> m; // k: key, v: node\\n    Map<Integer, LinkedHashSet<Node>> countToNodes; // k: count, v: a linked hashset of all nodes that their keys are equal to count\\n    \\n    public LFUCache(int capacity) {\\n        minCount = 1;\\n        cap = capacity;\\n        countToNodes = new HashMap<>();\\n        m = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!m.containsKey(key)){\\n            return -1;\\n        } \\n        Node cur = m.get(key);\\n        // remove key from current count (since we will inc count)\\n        countToNodes.get(cur.count).remove(cur); \\n        if (cur.count == minCount && countToNodes.get(cur.count).size() == 0){\\n            minCount++; // nothing in the current minCount bucket\\n        }\\n        cur.count++;\\n        \\n        if(!countToNodes.containsKey(cur.count)){ // a new count\\n            countToNodes.put(cur.count, new LinkedHashSet<>()); \\n        }\\n        countToNodes.get(cur.count).add(cur);\\n        return m.get(key).val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            m.get(key).val = value;\\n            get(key); // update key\\'s count\\n            return;\\n        } \\n        \\n        if (m.size() >= cap){\\n            Node nodeToRemove = countToNodes.get(minCount).iterator().next();\\n            countToNodes.get(minCount).remove(nodeToRemove);\\n            m.remove(nodeToRemove.key);\\n        }\\n        \\n        minCount = 1;\\n        Node cur = new Node();\\n        cur.val = value;\\n        cur.count = minCount;\\n        cur.key = key;\\n        m.put(key, cur);\\n        if(!countToNodes.containsKey(cur.count)){\\n            countToNodes.put(cur.count, new LinkedHashSet<>());\\n        }\\n        countToNodes.get(cur.count).add(cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118399,
                "title": "java-detailed-solution",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n*It is highly recommended to solve the problem **[146. LRU Cache](https://leetcode.com/problems/lru-cache/description/)** before attempting this problem.*  \\n\\n---\\n\\n\\u2714\\uFE0F ***Video links to this solution are attached at the end of the post.*** \\u2714\\uFE0F\\n\\n---\\n\\nJust Like the problem **LRU Cache**, we are going to use a HashMap and a Doubly linked list, but this doubly linked list will be contained inside another hashmap.\\n\\nThis new hashmap will store the **frequencies** (or the number of times a key/node has been used), which will have **doubly linkedlists** mapped  to themselves. These doubly linkedlists are going to contain the nodes which have been used *frequency* number of times (because multiple nodes can have the same frequency or the number of times they\\'ve been used). \\n\\nThe nodes will be in the order same as in LRU cache problem (Most frequent will be placed right next to head, least frequent will be at the last, right before tail). \\n\\nWhenever we use a key/node, we increase the key\\'s (or node\\'s) frequency and put it in the list mapped to the new frequency. In the list, it\\'ll be put right next to head, because it is the most recently used key/node.\\n\\nWhenever we are at capacity (size limit exceeded), we will remove the node which has the least frequency (that will be given by the list mapped to the minimum frequency). So for that we will globally maintain a variable which will keep track of the minimum frequency a node has been used for. In case multiple nodes has the same minimum frequency, we will remove the one which is the least recently used (LRU), which will be present right before the tail of the list mapped to the minimum frequency.\\n\\nWe will create separate Node class and Doubly linkedlist class to serve our purpose.\\n\\n---\\n### Code:\\n``` java []\\nclass LFUCache {\\n    // map to store what keys we have, along with its node\\n    private Map<Integer, Node> cache;\\n    // map to store the nodes (in a doubly linked list) \\n    // mapped to the number of times (frequency) they\\'ve been used\\n    private Map<Integer, List> freqMap;\\n    // globally storing the assigned capacity, current cache size \\n    // and the minimum frequency so far that ad node has been used for\\n    private int capacity, currSize, minFreq;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFreq = 0;\\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = cache.get(key);\\n        if (node == null) {  // if not present\\n            return -1;       // return -1\\n        }\\n        updateNode(node);    // frequency increases\\n        return node.value;   // return the value\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) {    // if capacity is 0, can\\'t add any key \\n            return;            \\n        }\\n        // if key is already present\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key); // get that node\\n            node.value = value;         // update the value with new value\\n            updateNode(node);    // this node now becomes most recently used, so update it\\n        } else {\\n            currSize++;\\n            // evict the LFU node, if multiple exists, remove the LRU\\n            if (currSize > capacity) {  \\n                // get the LFU list\\n                List minFreqList = freqMap.get(minFreq);\\n                // Remove the LRU from it, if multiple exists\\n                // the LRU node is the 2nd last node in the list, so remove the key from cache\\n                Node LRU_Node = minFreqList.tail.prev;\\n                cache.remove(LRU_Node.key);\\n                // now remove the node itself from the list\\n                minFreqList.removeFromList(LRU_Node);\\n                currSize--;     // we are ready to accomodate now\\n            }\\n\\n            // as a new key has been passed, it\\'s frequency will be 1 \\n            // So mininum frequency will be reset to 1\\n            minFreq = 1;\\n            Node newNode = new Node(key, value);    // create a new node for this new key\\n            // we will add it to list of frequency 1, if frequency 1 exists in freqMap\\n            List minFreqList = freqMap.getOrDefault(1, new List());\\n            minFreqList.addToList(newNode);\\n            freqMap.put(1, minFreqList);    // put this list back to freqMap\\n            cache.put(key, newNode);        // also put it in cache\\n        }\\n    }\\n\\n    private void updateNode(Node node) {\\n        int currFreq = node.freq;       // get node\\'s current frequency\\n        List currList = freqMap.get(currFreq);  // get the list of that particular frequency\\n        currList.removeFromList(node);  // remove this node from that list as the frequency has changed\\n\\n        // in case this node\\'s frequnecy is minimum frequency \\n        // and it was the only node the in list of its frequency\\n        // minimum frequency will increment by 1\\n        if (currFreq == minFreq && currList.size == 0) {\\n            minFreq++;  \\n        }\\n\\n        node.freq++;    // node\\'s frequency increments\\n        // we will get the list (if exists) of this frequency\\n        List newList = freqMap.getOrDefault(node.freq, new List());\\n        newList.addToList(node);            // add the node to that list\\n        freqMap.put(node.freq, newList);    // and put the list back to the freqMap\\n    }\\n\\n    // Node class\\n    private class Node {\\n        int key, value, freq; // freq is the number of times this node has been used for\\n        Node next, prev;      // next and previous nodes\\n        // constructor\\n        private Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            this.freq = 1;    // when we create a new node, its frequency is 1\\n        }\\n    }\\n\\n    // Doubly Linked List class\\n    private class List {\\n        int size;           // to store the size of the list\\n        Node head, tail;    // head and tail nodes\\n        // constructor\\n        private List() {\\n            this.size = 0;\\n            this.head = new Node(0, 0);\\n            this.tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        // method to add new node to the list\\n        private void addToList(Node node) {\\n            Node headNext = head.next;\\n            head.next = node;\\n            node.next = headNext;\\n            headNext.prev = node;\\n            node.prev = head;\\n            size++;     // size increments when a new node is added\\n        }\\n\\n        // method to remove a node from the list\\n        private void removeFromList(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;     // size decrements when a node is removed\\n        }\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass LFUCache {\\n    private Map<Integer, Node> cache;\\n    private Map<Integer, List> freqMap;\\n    private int capacity, currSize, minFreq;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFreq = 0;\\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = cache.get(key);\\n        if (node == null) {  \\n            return -1;       \\n        }\\n        updateNode(node);    \\n        return node.value;  \\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) {    \\n            return;            \\n        }\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key);\\n            node.value = value;         \\n            updateNode(node);    \\n        } else {\\n            currSize++;\\n            if (currSize > capacity) {  \\n                List minFreqList = freqMap.get(minFreq); \\n                Node LRU_Node = minFreqList.tail.prev;\\n                cache.remove(LRU_Node.key);\\n                minFreqList.removeFromList(LRU_Node);\\n                currSize--;     \\n            }\\n\\n            minFreq = 1;\\n            Node newNode = new Node(key, value);    \\n            List minFreqList = freqMap.getOrDefault(1, new List());\\n\\n            minFreqList.addToList(newNode);\\n            freqMap.put(1, minFreqList);    \\n            cache.put(key, newNode);        \\n        }\\n    }\\n\\n    private void updateNode(Node node) {\\n        int currFreq = node.freq;       \\n        List currList = freqMap.get(currFreq);  \\n        currList.removeFromList(node);\\n\\n        if (currFreq == minFreq && currList.size == 0) {\\n            minFreq++;  \\n        }\\n\\n        node.freq++;   \\n        List newList = freqMap.getOrDefault(node.freq, new List());\\n        newList.addToList(node);            \\n        freqMap.put(node.freq, newList);   \\n    }\\n\\n    private class Node {\\n        int key, value, freq;\\n        Node next, prev;\\n        private Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            this.freq = 1; \\n        }\\n    }\\n\\n    private class List {\\n        int size;\\n        Node head, tail;\\n        private List() {\\n            this.size = 0;\\n            this.head = new Node(0, 0);\\n            this.tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        private void addToList(Node node) {\\n            Node headNext = head.next;\\n            head.next = node;\\n            node.next = headNext;\\n            headNext.prev = node;\\n            node.prev = head;\\n            size++;   \\n        }\\n\\n        private void removeFromList(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;    \\n        }\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(1)$$\\n### Space complexity: $$O(n)$$\\n---\\n**Watch these two videos serailly to understand the approach and the solution properly:**\\n\\n***[Link to first video](https://www.youtube.com/watch?v=0PSB9y8ehbk&t=27s)***\\n***[Link to second video](https://www.youtube.com/watch?v=mzqHlAW7jeE)***",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "``` java []\\nclass LFUCache {\\n    // map to store what keys we have, along with its node\\n    private Map<Integer, Node> cache;\\n    // map to store the nodes (in a doubly linked list) \\n    // mapped to the number of times (frequency) they\\'ve been used\\n    private Map<Integer, List> freqMap;\\n    // globally storing the assigned capacity, current cache size \\n    // and the minimum frequency so far that ad node has been used for\\n    private int capacity, currSize, minFreq;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFreq = 0;\\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = cache.get(key);\\n        if (node == null) {  // if not present\\n            return -1;       // return -1\\n        }\\n        updateNode(node);    // frequency increases\\n        return node.value;   // return the value\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) {    // if capacity is 0, can\\'t add any key \\n            return;            \\n        }\\n        // if key is already present\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key); // get that node\\n            node.value = value;         // update the value with new value\\n            updateNode(node);    // this node now becomes most recently used, so update it\\n        } else {\\n            currSize++;\\n            // evict the LFU node, if multiple exists, remove the LRU\\n            if (currSize > capacity) {  \\n                // get the LFU list\\n                List minFreqList = freqMap.get(minFreq);\\n                // Remove the LRU from it, if multiple exists\\n                // the LRU node is the 2nd last node in the list, so remove the key from cache\\n                Node LRU_Node = minFreqList.tail.prev;\\n                cache.remove(LRU_Node.key);\\n                // now remove the node itself from the list\\n                minFreqList.removeFromList(LRU_Node);\\n                currSize--;     // we are ready to accomodate now\\n            }\\n\\n            // as a new key has been passed, it\\'s frequency will be 1 \\n            // So mininum frequency will be reset to 1\\n            minFreq = 1;\\n            Node newNode = new Node(key, value);    // create a new node for this new key\\n            // we will add it to list of frequency 1, if frequency 1 exists in freqMap\\n            List minFreqList = freqMap.getOrDefault(1, new List());\\n            minFreqList.addToList(newNode);\\n            freqMap.put(1, minFreqList);    // put this list back to freqMap\\n            cache.put(key, newNode);        // also put it in cache\\n        }\\n    }\\n\\n    private void updateNode(Node node) {\\n        int currFreq = node.freq;       // get node\\'s current frequency\\n        List currList = freqMap.get(currFreq);  // get the list of that particular frequency\\n        currList.removeFromList(node);  // remove this node from that list as the frequency has changed\\n\\n        // in case this node\\'s frequnecy is minimum frequency \\n        // and it was the only node the in list of its frequency\\n        // minimum frequency will increment by 1\\n        if (currFreq == minFreq && currList.size == 0) {\\n            minFreq++;  \\n        }\\n\\n        node.freq++;    // node\\'s frequency increments\\n        // we will get the list (if exists) of this frequency\\n        List newList = freqMap.getOrDefault(node.freq, new List());\\n        newList.addToList(node);            // add the node to that list\\n        freqMap.put(node.freq, newList);    // and put the list back to the freqMap\\n    }\\n\\n    // Node class\\n    private class Node {\\n        int key, value, freq; // freq is the number of times this node has been used for\\n        Node next, prev;      // next and previous nodes\\n        // constructor\\n        private Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            this.freq = 1;    // when we create a new node, its frequency is 1\\n        }\\n    }\\n\\n    // Doubly Linked List class\\n    private class List {\\n        int size;           // to store the size of the list\\n        Node head, tail;    // head and tail nodes\\n        // constructor\\n        private List() {\\n            this.size = 0;\\n            this.head = new Node(0, 0);\\n            this.tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        // method to add new node to the list\\n        private void addToList(Node node) {\\n            Node headNext = head.next;\\n            head.next = node;\\n            node.next = headNext;\\n            headNext.prev = node;\\n            node.prev = head;\\n            size++;     // size increments when a new node is added\\n        }\\n\\n        // method to remove a node from the list\\n        private void removeFromList(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;     // size decrements when a node is removed\\n        }\\n    }\\n}\\n```\n``` java []\\nclass LFUCache {\\n    private Map<Integer, Node> cache;\\n    private Map<Integer, List> freqMap;\\n    private int capacity, currSize, minFreq;\\n\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFreq = 0;\\n        this.cache = new HashMap<>();\\n        this.freqMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        Node node = cache.get(key);\\n        if (node == null) {  \\n            return -1;       \\n        }\\n        updateNode(node);    \\n        return node.value;  \\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) {    \\n            return;            \\n        }\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key);\\n            node.value = value;         \\n            updateNode(node);    \\n        } else {\\n            currSize++;\\n            if (currSize > capacity) {  \\n                List minFreqList = freqMap.get(minFreq); \\n                Node LRU_Node = minFreqList.tail.prev;\\n                cache.remove(LRU_Node.key);\\n                minFreqList.removeFromList(LRU_Node);\\n                currSize--;     \\n            }\\n\\n            minFreq = 1;\\n            Node newNode = new Node(key, value);    \\n            List minFreqList = freqMap.getOrDefault(1, new List());\\n\\n            minFreqList.addToList(newNode);\\n            freqMap.put(1, minFreqList);    \\n            cache.put(key, newNode);        \\n        }\\n    }\\n\\n    private void updateNode(Node node) {\\n        int currFreq = node.freq;       \\n        List currList = freqMap.get(currFreq);  \\n        currList.removeFromList(node);\\n\\n        if (currFreq == minFreq && currList.size == 0) {\\n            minFreq++;  \\n        }\\n\\n        node.freq++;   \\n        List newList = freqMap.getOrDefault(node.freq, new List());\\n        newList.addToList(node);            \\n        freqMap.put(node.freq, newList);   \\n    }\\n\\n    private class Node {\\n        int key, value, freq;\\n        Node next, prev;\\n        private Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            this.freq = 1; \\n        }\\n    }\\n\\n    private class List {\\n        int size;\\n        Node head, tail;\\n        private List() {\\n            this.size = 0;\\n            this.head = new Node(0, 0);\\n            this.tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        private void addToList(Node node) {\\n            Node headNext = head.next;\\n            head.next = node;\\n            node.next = headNext;\\n            headNext.prev = node;\\n            node.prev = head;\\n            size++;   \\n        }\\n\\n        private void removeFromList(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115041,
                "title": "rust-nested-linkedlists-no-unsafe-no-unwrap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to some of the other solutions here. The idea is that you have a linked list node for each frequency count, These link to another linked list to track recency.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI create a LinkedList struct. Next references are kept with Rc. Previous references are kept with Weak. This is to ensure that the LinkedList is fully cleaned up when the next reference is dropped. This avoids circular references in my DataStructure. Insert and delete are implemented here to be used by both the Frequency list and the KeyValue lists.\\n\\nThe KeyValueNode is used to store the key, value and a Weak referencce to the cost node it is accociated with. This reference allows us to quickly determine which frequency node we are associated with.\\n\\nThe per frequency PerFreqList maintains a head and tail. When a node is updated it gets added to the tail of the relevant Frequency List. We can then used the reference to the head to evict a node.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::rc::{Rc, Weak};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\n\\nstruct LinkedList<T> {\\n    prev: Option<Weak<RefCell<LinkedList<T>>>>,\\n    next: Option<Rc<RefCell<LinkedList<T>>>>,\\n    val: T\\n}\\n\\nimpl<T> LinkedList<T> {\\n    pub fn new(val: T) -> Rc<RefCell<Self>> {\\n        Rc::new(\\n            RefCell::new(\\n                Self {\\n                    prev: None,\\n                    next: None,\\n                    val: val\\n                }\\n            )\\n        )\\n    }\\n    fn insert_after(node: Rc<RefCell<LinkedList<T>>>, to_add: Rc<RefCell<LinkedList<T>>>) {\\n        let mut old_next = node.borrow_mut().next.take();\\n        to_add.borrow_mut().prev = Some(Rc::downgrade(&node));\\n        if let Some(on) = old_next.as_mut() {\\n            on.borrow_mut().prev = Some(Rc::downgrade(&to_add));\\n        }\\n        to_add.borrow_mut().next = old_next;\\n        node.borrow_mut().next = Some(to_add);\\n    }\\n    fn delete_node(node: Rc<RefCell<LinkedList<T>>>) -> Rc<RefCell<LinkedList<T>>> {\\n        let next = node.borrow_mut().next.take();\\n        let prev = node.borrow_mut().prev.take();\\n        if let Some(next_node) = next.as_ref() {\\n            next_node.borrow_mut().prev = prev.clone();\\n        }\\n        if let Some(prev_node_weak) = prev {\\n            if let Some(prev_node) = prev_node_weak.upgrade() {\\n                prev_node.borrow_mut().next = next;\\n            }\\n        }\\n        node\\n    }\\n}\\nstruct KeyValueNode<K, V> {\\n    key: K,\\n    value: V,\\n    freq_ref: Option<\\n        Weak<\\n            RefCell<LinkedList<PerFreqList<K, V>>>\\n        >\\n    >\\n}\\n\\n\\nimpl<K, V> KeyValueNode<K, V> {\\n    fn new(key: K, value: V) -> Self {\\n        Self {\\n            key: key,\\n            value: value,\\n            freq_ref: None\\n        }\\n    }\\n}\\n\\nstruct PerFreqList<K, V> {\\n    freq: usize,\\n    head: Rc<RefCell<LinkedList<KeyValueNode<K,V>>>>,\\n    tail: Rc<RefCell<LinkedList<KeyValueNode<K,V>>>>,\\n    size: usize,\\n}\\n\\nimpl<K: Default,V: Default> PerFreqList<K,V> {\\n    fn new(freq: usize) -> Self {\\n        let mut head = LinkedList::new(KeyValueNode::new(K::default(), V::default()));\\n        let mut tail = LinkedList::new(KeyValueNode::new(K::default(), V::default()));\\n        let weak = Rc::downgrade(&head);\\n        head.borrow_mut().next = Some(tail.clone());\\n        tail.borrow_mut().prev = Some(weak);\\n        Self {\\n            freq: freq,\\n            head: head,\\n            tail: tail,\\n            size: 0\\n        }\\n    }\\n    fn insert_node(&mut self, node: Rc<RefCell<LinkedList<KeyValueNode<K, V>>>>) {\\n        LinkedList::insert_after(self.head.clone(), node);\\n        self.size += 1;\\n    }\\n    fn evict_node(&mut self) -> Result<Rc<RefCell<LinkedList<KeyValueNode<K, V>>>>,()> {\\n        let prev = self.tail.borrow().prev.clone();\\n        if self.size == 0 {\\n            return Err(())\\n        }\\n        match prev.and_then(|p| p.upgrade()) {\\n            Some(node) => {\\n                LinkedList::delete_node(node.clone());\\n                self.size -= 1;\\n                Ok(node)\\n            },\\n            _ => Err(())\\n        }\\n    }\\n}\\n\\nstruct LFUCache {\\n    capacity: usize,\\n    size: usize,\\n    freq_list: Rc<RefCell<LinkedList<PerFreqList<i32,i32>>>>,\\n    map: HashMap<i32, Rc<RefCell<LinkedList<KeyValueNode<i32, i32>>>>>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LFUCache {\\n\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            capacity: (capacity as usize),\\n            size: 0,\\n            freq_list: LinkedList::new(PerFreqList::new(1)),\\n            map: HashMap::new(),\\n        }\\n    }\\n    \\n    fn get(&mut self, key: i32) -> i32 {\\n        if let Some(node) = self.map.get(&key) {\\n            let result = node.borrow().val.value;\\n            self.update_node(node.clone());\\n            result\\n        } else {\\n            -1\\n        }\\n    }\\n    \\n    fn put(&mut self, key: i32, value: i32) {\\n        if self.capacity == 0 {\\n            return\\n        }\\n\\n        if let Some(node) = self.map.get(&key) {\\n            // Update\\n            node.borrow_mut().val.value = value;\\n            self.update_node(node.clone());\\n        } else {\\n            if self.size == self.capacity {\\n                self.evict_node();\\n            }\\n            self.insert_node(key, value);\\n        }\\n    }\\n\\n    fn evict_node(&mut self) -> Result<(),()> {\\n        let to_evict = if self.freq_list.borrow().val.size > 0 {\\n            self.freq_list.clone()\\n        } else {\\n            match self.freq_list.borrow().next.as_ref() {\\n                Some(node) => node.clone(),\\n                _ => return Err(())\\n            }\\n        };\\n        if to_evict.borrow().val.size == 0 {\\n            return Err(());\\n        }\\n        let node = to_evict.borrow_mut().val.evict_node()?;\\n        self.map.remove(&node.borrow().val.key);\\n        self.size -= 1;\\n\\n        if to_evict.borrow().val.size == 0 && to_evict.borrow().val.freq != 1 {\\n            LinkedList::delete_node(to_evict);\\n        }\\n        Ok(())\\n    }\\n\\n    fn insert_node(&mut self, key: i32, value: i32) {\\n        let node = LinkedList::new(KeyValueNode::new(key, value));\\n        self.map.insert(key, node.clone());\\n        self.size += 1;\\n        self.freq_list.borrow_mut().val.insert_node(node.clone());\\n        let weak = Rc::downgrade(&self.freq_list);\\n        node.borrow_mut().val.freq_ref = Some(weak);\\n    }\\n\\n    fn update_node(&mut self, node: Rc<RefCell<LinkedList<KeyValueNode<i32, i32>>>>) {\\n        LinkedList::delete_node(node.clone());\\n        \\n        let old_freq_node_ref = node.borrow_mut().val.freq_ref.take();\\n        if let Some(old_freq_node) = old_freq_node_ref.and_then(|n|n.upgrade()) {\\n            // Leetcode rust version does not yet support let-else\\n            old_freq_node.borrow_mut().val.size -= 1;\\n            let next_freq = old_freq_node.borrow().val.freq + 1;\\n            let next_ref = old_freq_node.borrow().next.clone();\\n            let mut freq_node = match next_ref {\\n                Some(freq_node) if freq_node.borrow().val.freq == next_freq => {\\n                    freq_node\\n                },\\n                _ => {\\n                    let mut freq_node = LinkedList::new(PerFreqList::new(next_freq));\\n                    LinkedList::insert_after(old_freq_node.clone(), freq_node.clone());\\n                    freq_node\\n                }\\n            };\\n            \\n            freq_node.borrow_mut().val.insert_node(node.clone());\\n            let weak = Rc::downgrade(&freq_node);\\n            node.borrow_mut().val.freq_ref = Some(weak);\\n\\n            if old_freq_node.borrow().val.size == 0 && old_freq_node.borrow().val.freq != 1 {\\n                LinkedList::delete_node(old_freq_node);\\n            }\\n        }\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Doubly-Linked List"
                ],
                "code": "```\\nuse std::rc::{Rc, Weak};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\n\\nstruct LinkedList<T> {\\n    prev: Option<Weak<RefCell<LinkedList<T>>>>,\\n    next: Option<Rc<RefCell<LinkedList<T>>>>,\\n    val: T\\n}\\n\\nimpl<T> LinkedList<T> {\\n    pub fn new(val: T) -> Rc<RefCell<Self>> {\\n        Rc::new(\\n            RefCell::new(\\n                Self {\\n                    prev: None,\\n                    next: None,\\n                    val: val\\n                }\\n            )\\n        )\\n    }\\n    fn insert_after(node: Rc<RefCell<LinkedList<T>>>, to_add: Rc<RefCell<LinkedList<T>>>) {\\n        let mut old_next = node.borrow_mut().next.take();\\n        to_add.borrow_mut().prev = Some(Rc::downgrade(&node));\\n        if let Some(on) = old_next.as_mut() {\\n            on.borrow_mut().prev = Some(Rc::downgrade(&to_add));\\n        }\\n        to_add.borrow_mut().next = old_next;\\n        node.borrow_mut().next = Some(to_add);\\n    }\\n    fn delete_node(node: Rc<RefCell<LinkedList<T>>>) -> Rc<RefCell<LinkedList<T>>> {\\n        let next = node.borrow_mut().next.take();\\n        let prev = node.borrow_mut().prev.take();\\n        if let Some(next_node) = next.as_ref() {\\n            next_node.borrow_mut().prev = prev.clone();\\n        }\\n        if let Some(prev_node_weak) = prev {\\n            if let Some(prev_node) = prev_node_weak.upgrade() {\\n                prev_node.borrow_mut().next = next;\\n            }\\n        }\\n        node\\n    }\\n}\\nstruct KeyValueNode<K, V> {\\n    key: K,\\n    value: V,\\n    freq_ref: Option<\\n        Weak<\\n            RefCell<LinkedList<PerFreqList<K, V>>>\\n        >\\n    >\\n}\\n\\n\\nimpl<K, V> KeyValueNode<K, V> {\\n    fn new(key: K, value: V) -> Self {\\n        Self {\\n            key: key,\\n            value: value,\\n            freq_ref: None\\n        }\\n    }\\n}\\n\\nstruct PerFreqList<K, V> {\\n    freq: usize,\\n    head: Rc<RefCell<LinkedList<KeyValueNode<K,V>>>>,\\n    tail: Rc<RefCell<LinkedList<KeyValueNode<K,V>>>>,\\n    size: usize,\\n}\\n\\nimpl<K: Default,V: Default> PerFreqList<K,V> {\\n    fn new(freq: usize) -> Self {\\n        let mut head = LinkedList::new(KeyValueNode::new(K::default(), V::default()));\\n        let mut tail = LinkedList::new(KeyValueNode::new(K::default(), V::default()));\\n        let weak = Rc::downgrade(&head);\\n        head.borrow_mut().next = Some(tail.clone());\\n        tail.borrow_mut().prev = Some(weak);\\n        Self {\\n            freq: freq,\\n            head: head,\\n            tail: tail,\\n            size: 0\\n        }\\n    }\\n    fn insert_node(&mut self, node: Rc<RefCell<LinkedList<KeyValueNode<K, V>>>>) {\\n        LinkedList::insert_after(self.head.clone(), node);\\n        self.size += 1;\\n    }\\n    fn evict_node(&mut self) -> Result<Rc<RefCell<LinkedList<KeyValueNode<K, V>>>>,()> {\\n        let prev = self.tail.borrow().prev.clone();\\n        if self.size == 0 {\\n            return Err(())\\n        }\\n        match prev.and_then(|p| p.upgrade()) {\\n            Some(node) => {\\n                LinkedList::delete_node(node.clone());\\n                self.size -= 1;\\n                Ok(node)\\n            },\\n            _ => Err(())\\n        }\\n    }\\n}\\n\\nstruct LFUCache {\\n    capacity: usize,\\n    size: usize,\\n    freq_list: Rc<RefCell<LinkedList<PerFreqList<i32,i32>>>>,\\n    map: HashMap<i32, Rc<RefCell<LinkedList<KeyValueNode<i32, i32>>>>>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LFUCache {\\n\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            capacity: (capacity as usize),\\n            size: 0,\\n            freq_list: LinkedList::new(PerFreqList::new(1)),\\n            map: HashMap::new(),\\n        }\\n    }\\n    \\n    fn get(&mut self, key: i32) -> i32 {\\n        if let Some(node) = self.map.get(&key) {\\n            let result = node.borrow().val.value;\\n            self.update_node(node.clone());\\n            result\\n        } else {\\n            -1\\n        }\\n    }\\n    \\n    fn put(&mut self, key: i32, value: i32) {\\n        if self.capacity == 0 {\\n            return\\n        }\\n\\n        if let Some(node) = self.map.get(&key) {\\n            // Update\\n            node.borrow_mut().val.value = value;\\n            self.update_node(node.clone());\\n        } else {\\n            if self.size == self.capacity {\\n                self.evict_node();\\n            }\\n            self.insert_node(key, value);\\n        }\\n    }\\n\\n    fn evict_node(&mut self) -> Result<(),()> {\\n        let to_evict = if self.freq_list.borrow().val.size > 0 {\\n            self.freq_list.clone()\\n        } else {\\n            match self.freq_list.borrow().next.as_ref() {\\n                Some(node) => node.clone(),\\n                _ => return Err(())\\n            }\\n        };\\n        if to_evict.borrow().val.size == 0 {\\n            return Err(());\\n        }\\n        let node = to_evict.borrow_mut().val.evict_node()?;\\n        self.map.remove(&node.borrow().val.key);\\n        self.size -= 1;\\n\\n        if to_evict.borrow().val.size == 0 && to_evict.borrow().val.freq != 1 {\\n            LinkedList::delete_node(to_evict);\\n        }\\n        Ok(())\\n    }\\n\\n    fn insert_node(&mut self, key: i32, value: i32) {\\n        let node = LinkedList::new(KeyValueNode::new(key, value));\\n        self.map.insert(key, node.clone());\\n        self.size += 1;\\n        self.freq_list.borrow_mut().val.insert_node(node.clone());\\n        let weak = Rc::downgrade(&self.freq_list);\\n        node.borrow_mut().val.freq_ref = Some(weak);\\n    }\\n\\n    fn update_node(&mut self, node: Rc<RefCell<LinkedList<KeyValueNode<i32, i32>>>>) {\\n        LinkedList::delete_node(node.clone());\\n        \\n        let old_freq_node_ref = node.borrow_mut().val.freq_ref.take();\\n        if let Some(old_freq_node) = old_freq_node_ref.and_then(|n|n.upgrade()) {\\n            // Leetcode rust version does not yet support let-else\\n            old_freq_node.borrow_mut().val.size -= 1;\\n            let next_freq = old_freq_node.borrow().val.freq + 1;\\n            let next_ref = old_freq_node.borrow().next.clone();\\n            let mut freq_node = match next_ref {\\n                Some(freq_node) if freq_node.borrow().val.freq == next_freq => {\\n                    freq_node\\n                },\\n                _ => {\\n                    let mut freq_node = LinkedList::new(PerFreqList::new(next_freq));\\n                    LinkedList::insert_after(old_freq_node.clone(), freq_node.clone());\\n                    freq_node\\n                }\\n            };\\n            \\n            freq_node.borrow_mut().val.insert_node(node.clone());\\n            let weak = Rc::downgrade(&freq_node);\\n            node.borrow_mut().val.freq_ref = Some(weak);\\n\\n            if old_freq_node.borrow().val.size == 0 && old_freq_node.borrow().val.freq != 1 {\\n                LinkedList::delete_node(old_freq_node);\\n            }\\n        }\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3113378,
                "title": "video-explanation-easiest-solution-using-hashmap-beats-91",
                "content": "# Approach\\nhttps://youtu.be/Cu6TL9xkcsA\\n\\n# Code\\n```\\nfrom collections import defaultdict, OrderedDict\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {} # key -> (freq, val)\\n        self.frequencies = defaultdict(OrderedDict)\\n        self.minf = 0\\n        self.capacity = capacity\\n\\n    def insert(self, key, frequency, value):\\n        self.cache[key] = (frequency, value)\\n        self.frequencies[frequency][key] = value\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n\\n        frequency, value = self.cache[key] # a -> 2, 1 ==> 2: []\\n        del self.frequencies[frequency][key]\\n        if self.minf == frequency and not self.frequencies[frequency]:\\n            self.minf += 1\\n        self.insert(key, frequency+1, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return\\n        if key in self.cache:\\n            self.get(key)\\n            self.cache[key] = (self.cache[key][0], value)\\n            return\\n        if self.capacity == len(self.cache):\\n            k, v = self.frequencies[self.minf].popitem(last=False)\\n            del self.cache[k]\\n        self.minf = 1\\n        self.insert(key, 1, value)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\nfrom collections import defaultdict, OrderedDict\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {} # key -> (freq, val)\\n        self.frequencies = defaultdict(OrderedDict)\\n        self.minf = 0\\n        self.capacity = capacity\\n\\n    def insert(self, key, frequency, value):\\n        self.cache[key] = (frequency, value)\\n        self.frequencies[frequency][key] = value\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n\\n        frequency, value = self.cache[key] # a -> 2, 1 ==> 2: []\\n        del self.frequencies[frequency][key]\\n        if self.minf == frequency and not self.frequencies[frequency]:\\n            self.minf += 1\\n        self.insert(key, frequency+1, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity <= 0:\\n            return\\n        if key in self.cache:\\n            self.get(key)\\n            self.cache[key] = (self.cache[key][0], value)\\n            return\\n        if self.capacity == len(self.cache):\\n            k, v = self.frequencies[self.minf].popitem(last=False)\\n            del self.cache[k]\\n        self.minf = 1\\n        self.insert(key, 1, value)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113308,
                "title": "rust-hashmap-btreeset",
                "content": "```rust\\nuse std::collections::{BTreeSet, HashMap};\\n\\n#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone)]\\nstruct CacheEntry {\\n    count: usize,\\n    used_time: usize,\\n    key: i32,\\n    value: i32,\\n}\\n\\nstruct LFUCache {\\n    queue: BTreeSet<CacheEntry>,\\n    cache: HashMap<i32, CacheEntry>,\\n    capacity: usize,\\n    time: usize,\\n}\\n\\nimpl LFUCache {\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            queue: BTreeSet::new(),\\n            cache: HashMap::new(),\\n            capacity: capacity as usize,\\n            time: 0,\\n        }\\n    }\\n\\n    fn get(&mut self, key: i32) -> i32 {\\n        self.time += 1;\\n        if let Some(entry) = self.cache.get_mut(&key) {\\n            self.queue.remove(entry);\\n            entry.used_time = self.time;\\n            entry.count += 1;\\n            self.queue.insert(entry.clone());\\n            return entry.value;\\n        }\\n        -1\\n    }\\n\\n    fn put(&mut self, key: i32, value: i32) {\\n        self.time += 1;\\n        if self.capacity == 0 {\\n            return;\\n        }\\n        if let Some(entry) = self.cache.get_mut(&key) {\\n            self.queue.remove(entry);\\n            entry.used_time = self.time;\\n            entry.count += 1;\\n            entry.value = value;\\n            self.queue.insert(entry.clone());\\n        } else {\\n            if self.cache.len() >= self.capacity {\\n                let entry = self.queue.iter().next().unwrap().clone();\\n                self.cache.remove(&entry.key);\\n                self.queue.remove(&entry);\\n            }\\n            let entry = CacheEntry {\\n                key,\\n                value,\\n                count: 1,\\n                used_time: self.time,\\n            };\\n            self.cache.entry(key).or_insert(entry.clone());\\n            self.queue.insert(entry);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::{BTreeSet, HashMap};\\n\\n#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone)]\\nstruct CacheEntry {\\n    count: usize,\\n    used_time: usize,\\n    key: i32,\\n    value: i32,\\n}\\n\\nstruct LFUCache {\\n    queue: BTreeSet<CacheEntry>,\\n    cache: HashMap<i32, CacheEntry>,\\n    capacity: usize,\\n    time: usize,\\n}\\n\\nimpl LFUCache {\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            queue: BTreeSet::new(),\\n            cache: HashMap::new(),\\n            capacity: capacity as usize,\\n            time: 0,\\n        }\\n    }\\n\\n    fn get(&mut self, key: i32) -> i32 {\\n        self.time += 1;\\n        if let Some(entry) = self.cache.get_mut(&key) {\\n            self.queue.remove(entry);\\n            entry.used_time = self.time;\\n            entry.count += 1;\\n            self.queue.insert(entry.clone());\\n            return entry.value;\\n        }\\n        -1\\n    }\\n\\n    fn put(&mut self, key: i32, value: i32) {\\n        self.time += 1;\\n        if self.capacity == 0 {\\n            return;\\n        }\\n        if let Some(entry) = self.cache.get_mut(&key) {\\n            self.queue.remove(entry);\\n            entry.used_time = self.time;\\n            entry.count += 1;\\n            entry.value = value;\\n            self.queue.insert(entry.clone());\\n        } else {\\n            if self.cache.len() >= self.capacity {\\n                let entry = self.queue.iter().next().unwrap().clone();\\n                self.cache.remove(&entry.key);\\n                self.queue.remove(&entry);\\n            }\\n            let entry = CacheEntry {\\n                key,\\n                value,\\n                count: 1,\\n                used_time: self.time,\\n            };\\n            self.cache.entry(key).or_insert(entry.clone());\\n            self.queue.insert(entry);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3113050,
                "title": "0-1-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        this -> capacity = capacity;\\n        size = 0;\\n    }\\n    \\n    int get(int key) {\\n        if (values.find(key) == values.end()) {\\n            return -1;\\n        }\\n        update(key);\\n        return values[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!capacity) {\\n            return;\\n        }\\n        if (values.find(key) != values.end()) {\\n            values[key].first = value;\\n            update(key);\\n        } else {\\n            if (size == capacity) {\\n                int evict = keys[lfu].front();\\n                keys[lfu].pop_front();\\n                values.erase(evict);\\n                iters.erase(evict);\\n            } else {\\n                size++;\\n            }\\n            values[key] = {value, 1};\\n            keys[1].push_back(key);\\n            iters[key] = --keys[1].end();\\n            lfu = 1;\\n        }\\n    }\\nprivate:\\n    int capacity, size, lfu = 0;\\n    unordered_map<int, list<int>> keys;\\n    unordered_map<int, pair<int, int>> values;\\n    unordered_map<int, list<int>::iterator> iters;\\n    \\n    void update(int key) {\\n        int freq = values[key].second;\\n        auto iter = iters[key];\\n        values[key].second++;\\n        keys[freq].erase(iter);\\n        keys[freq + 1].push_back(key);\\n        iters[key] = --keys[freq + 1].end();\\n        if (keys[lfu].empty()) {\\n            lfu++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    LFUCache(int capacity) {\\n        this -> capacity = capacity;\\n        size = 0;\\n    }\\n    \\n    int get(int key) {\\n        if (values.find(key) == values.end()) {\\n            return -1;\\n        }\\n        update(key);\\n        return values[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!capacity) {\\n            return;\\n        }\\n        if (values.find(key) != values.end()) {\\n            values[key].first = value;\\n            update(key);\\n        } else {\\n            if (size == capacity) {\\n                int evict = keys[lfu].front();\\n                keys[lfu].pop_front();\\n                values.erase(evict);\\n                iters.erase(evict);\\n            } else {\\n                size++;\\n            }\\n            values[key] = {value, 1};\\n            keys[1].push_back(key);\\n            iters[key] = --keys[1].end();\\n            lfu = 1;\\n        }\\n    }\\nprivate:\\n    int capacity, size, lfu = 0;\\n    unordered_map<int, list<int>> keys;\\n    unordered_map<int, pair<int, int>> values;\\n    unordered_map<int, list<int>::iterator> iters;\\n    \\n    void update(int key) {\\n        int freq = values[key].second;\\n        auto iter = iters[key];\\n        values[key].second++;\\n        keys[freq].erase(iter);\\n        keys[freq + 1].push_back(key);\\n        iters[key] = --keys[freq + 1].end();\\n        if (keys[lfu].empty()) {\\n            lfu++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113010,
                "title": "c-o-1-with-2-hashmaps-easy-with-comments",
                "content": "# Idea\\n\\n- This problem is easier to understand once you have solved [LRU Cache](https://leetcode.com/problems/lru-cache/ ). \\n- Another problem that will help but not as crucial is [Maximum Frequency Stack](https://leetcode.com/problems/maximum-frequency-stack/).\\n- We will have a LRU cache (implemented with a doubly linked list) for each frequency so all we need to do is map the keys properly. \\n- As long as we keep track of the minimum frequency both functions will be constant time.\\n# Code\\n```\\nclass LFUCache {\\nprivate: \\n    // For obtaining value\\n    unordered_map<int, pair<int, int>> keyToVal; // Key to {value, frequency}\\n\\n    // For dealing with LFU and LRU\\n    unordered_map<int, list<int>> freqToKeys; // Frequency to keys\\n    \\n    int size;\\n    int keys;\\n    int minFreq;\\n\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        keys = 0;\\n        minFreq = 1;\\n    }\\n    \\n    int get(int key) {\\n        if (keyToVal.find(key) == keyToVal.end()){\\n            return -1;\\n        }\\n        // Remove from previous frequency\\n        int prevFreq = keyToVal[key].second++; // Set new frequency\\n        freqToKeys[prevFreq].remove(key);\\n\\n        // If it was minimum frequency and only key in list\\n        if (prevFreq == minFreq && freqToKeys[prevFreq].empty()){ \\n            minFreq++;\\n        }\\n\\n        // Add to front for most recently used\\n        freqToKeys[prevFreq+1].push_front(key);\\n        return keyToVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // For edge case so we do not try to remove a 0 capacity cache\\n        if (size == 0){ \\n            return;\\n        }\\n\\n        // We can use \\'get\\' to check if key already exists and to increment frequency\\n        if (get(key) != -1){ \\n            keyToVal[key].first = value;\\n            return;\\n        }\\n\\n        if (size == keys){\\n            // Must remove LFU + LRU key\\n            keyToVal.erase(freqToKeys[minFreq].back()); \\n            freqToKeys[minFreq].pop_back(); \\n            keys--;\\n        }\\n\\n        keys++;\\n        minFreq = 1; // Min freq is always 1 after inserting new key\\n        keyToVal[key] = {value, 1};\\n        freqToKeys[minFreq].push_front(key);\\n    }\\n};\\n\\n```\\n\\n**Please upvote if this helped! :)**\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass LFUCache {\\nprivate: \\n    // For obtaining value\\n    unordered_map<int, pair<int, int>> keyToVal; // Key to {value, frequency}\\n\\n    // For dealing with LFU and LRU\\n    unordered_map<int, list<int>> freqToKeys; // Frequency to keys\\n    \\n    int size;\\n    int keys;\\n    int minFreq;\\n\\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        keys = 0;\\n        minFreq = 1;\\n    }\\n    \\n    int get(int key) {\\n        if (keyToVal.find(key) == keyToVal.end()){\\n            return -1;\\n        }\\n        // Remove from previous frequency\\n        int prevFreq = keyToVal[key].second++; // Set new frequency\\n        freqToKeys[prevFreq].remove(key);\\n\\n        // If it was minimum frequency and only key in list\\n        if (prevFreq == minFreq && freqToKeys[prevFreq].empty()){ \\n            minFreq++;\\n        }\\n\\n        // Add to front for most recently used\\n        freqToKeys[prevFreq+1].push_front(key);\\n        return keyToVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // For edge case so we do not try to remove a 0 capacity cache\\n        if (size == 0){ \\n            return;\\n        }\\n\\n        // We can use \\'get\\' to check if key already exists and to increment frequency\\n        if (get(key) != -1){ \\n            keyToVal[key].first = value;\\n            return;\\n        }\\n\\n        if (size == keys){\\n            // Must remove LFU + LRU key\\n            keyToVal.erase(freqToKeys[minFreq].back()); \\n            freqToKeys[minFreq].pop_back(); \\n            keys--;\\n        }\\n\\n        keys++;\\n        minFreq = 1; // Min freq is always 1 after inserting new key\\n        keyToVal[key] = {value, 1};\\n        freqToKeys[minFreq].push_front(key);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112554,
                "title": "easiest-solution-o-n-set-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am using one map and set, set will keep track of frequency and counter.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare 4 member\\n1. unordere_map, key-> {val, frequecy, counter}\\n2. set, {frequecy, counter, key}\\n3. cap, max capacity of set\\n4. counter, will start from 0\\n\\nNow for Get function, \\n~ we first check if it\\'s in map, if not return -1;\\n~ if present, then increase frequncy and update counter, by removing prevoius values from map\\n\\nNow fro put function,\\n~ we first check if key, present in map, if present, then will update value, frequncy and counter same as Get function method\\n~if key not present, then will check if set is full, then will delete first element of set, because set holding freq as 0 index, counter 1\\nso if freq same, min counter at beginging, after deleting will insert new key\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnlogc, where n is no. of keys, c is swt max capacity, because using set\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), n is no. of keys\\n\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    set<vector<int>> s;\\n    int cap;\\n    int counter;\\n    \\n    LFUCache(int capacity) {\\n        cap = capacity;\\n        counter=0;\\n    }\\n    \\n    int get(int key) {\\n        if(cap==0)\\n            return -1;\\n        counter++;\\n        if(mp.find(key)==mp.end())\\n            return -1;\\n\\n        int val = mp[key][0];\\n        int fre = mp[key][1];\\n        int coun = mp[key][2];\\n\\n        auto it = s.find({fre, coun, key});\\n\\n        s.erase(it);\\n\\n        mp[key] = {val, fre+1, counter};\\n        s.insert({fre+1, counter, key});\\n\\n        return val;        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0)\\n            return;\\n\\n        counter++;\\n        if(mp.find(key)!=mp.end())\\n        {\\n            int val = value;\\n            int fre = mp[key][1];\\n            int coun = mp[key][2];\\n            auto it = s.find({fre, coun, key});\\n            s.erase(it);\\n\\n            mp[key] = {val, fre+1, counter};\\n            s.insert({fre+1, counter, key});\\n        }\\n        else\\n        {\\n            if(s.size()>=cap)\\n            {\\n                vector<int> it = *s.begin();\\n                int key1 = it[2];\\n                cout<<key1<<endl;\\n                mp.erase(key1);\\n                s.erase(s.begin());\\n            }\\n\\n            mp[key] = {value, 1, counter};\\n            s.insert({1, counter, key});\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    set<vector<int>> s;\\n    int cap;\\n    int counter;\\n    \\n    LFUCache(int capacity) {\\n        cap = capacity;\\n        counter=0;\\n    }\\n    \\n    int get(int key) {\\n        if(cap==0)\\n            return -1;\\n        counter++;\\n        if(mp.find(key)==mp.end())\\n            return -1;\\n\\n        int val = mp[key][0];\\n        int fre = mp[key][1];\\n        int coun = mp[key][2];\\n\\n        auto it = s.find({fre, coun, key});\\n\\n        s.erase(it);\\n\\n        mp[key] = {val, fre+1, counter};\\n        s.insert({fre+1, counter, key});\\n\\n        return val;        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap==0)\\n            return;\\n\\n        counter++;\\n        if(mp.find(key)!=mp.end())\\n        {\\n            int val = value;\\n            int fre = mp[key][1];\\n            int coun = mp[key][2];\\n            auto it = s.find({fre, coun, key});\\n            s.erase(it);\\n\\n            mp[key] = {val, fre+1, counter};\\n            s.insert({fre+1, counter, key});\\n        }\\n        else\\n        {\\n            if(s.size()>=cap)\\n            {\\n                vector<int> it = *s.begin();\\n                int key1 = it[2];\\n                cout<<key1<<endl;\\n                mp.erase(key1);\\n                s.erase(s.begin());\\n            }\\n\\n            mp[key] = {value, 1, counter};\\n            s.insert({1, counter, key});\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3111707,
                "title": "well-commented-c-solution-t-100-s-98",
                "content": "# Code\\nPlease like if this helped you!\\n```\\nclass LFUCache {\\n    unordered_map<int,pair<int,int>> cache; // map[key] = {value,count}\\n    vector<deque<int>> counter; // one deque per count\\n    int max_size, num_elements;\\n\\n    void increment_element(int key) {\\n        // increment cache counter\\n        cache[key].second++;\\n        // increase size of counter if necessary\\n        while (counter.size() <= cache[key].second)\\n            counter.push_back(deque<int>());\\n        // add a new element into the appropriate deque\\n        counter[cache[key].second].push_back(key);\\n    }\\n\\n    void remove_LFU_element() {\\n        bool success = false;\\n        // start from the front of the counter\\n        for (int i = 0; i < counter.size() && !success; i++) {\\n            // start at the front of each deque\\n            while (!counter[i].empty() && !success) {\\n                // if this count is valid, delete the entry in the cache\\n                if (cache[counter[i].front()].second == i) {\\n                    success = true;\\n                    cache.erase(counter[i].front());\\n                    num_elements--;\\n                }\\n                counter[i].pop_front(); // delete invalid and 1st valid\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int c) {\\n        max_size = c;\\n        num_elements = 0;\\n        counter = {{}};\\n    }\\n\\n    int get(int key) {\\n        // if not found, return -1\\n        if (cache.find(key) == cache.end())\\n            return -1;\\n        // count use\\n        increment_element(key);\\n        // return the value\\n        return cache[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // protect against capacity = 0\\n        if (max_size == 0) return;\\n        // if key exists\\n        if (cache.find(key) != cache.end()) {\\n            cache[key].first = value;\\n            increment_element(key);\\n            return;\\n        }\\n        // if at capacity\\n        if (num_elements == max_size)\\n            remove_LFU_element();\\n        // add the new key\\n        cache[key] = make_pair(value,0);\\n        counter[0].push_back(key);\\n        num_elements++;\\n    }\\n};\\n```\\n\\nPlease like if this helped you!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    unordered_map<int,pair<int,int>> cache; // map[key] = {value,count}\\n    vector<deque<int>> counter; // one deque per count\\n    int max_size, num_elements;\\n\\n    void increment_element(int key) {\\n        // increment cache counter\\n        cache[key].second++;\\n        // increase size of counter if necessary\\n        while (counter.size() <= cache[key].second)\\n            counter.push_back(deque<int>());\\n        // add a new element into the appropriate deque\\n        counter[cache[key].second].push_back(key);\\n    }\\n\\n    void remove_LFU_element() {\\n        bool success = false;\\n        // start from the front of the counter\\n        for (int i = 0; i < counter.size() && !success; i++) {\\n            // start at the front of each deque\\n            while (!counter[i].empty() && !success) {\\n                // if this count is valid, delete the entry in the cache\\n                if (cache[counter[i].front()].second == i) {\\n                    success = true;\\n                    cache.erase(counter[i].front());\\n                    num_elements--;\\n                }\\n                counter[i].pop_front(); // delete invalid and 1st valid\\n            }\\n        }\\n    }\\n\\npublic:\\n    LFUCache(int c) {\\n        max_size = c;\\n        num_elements = 0;\\n        counter = {{}};\\n    }\\n\\n    int get(int key) {\\n        // if not found, return -1\\n        if (cache.find(key) == cache.end())\\n            return -1;\\n        // count use\\n        increment_element(key);\\n        // return the value\\n        return cache[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // protect against capacity = 0\\n        if (max_size == 0) return;\\n        // if key exists\\n        if (cache.find(key) != cache.end()) {\\n            cache[key].first = value;\\n            increment_element(key);\\n            return;\\n        }\\n        // if at capacity\\n        if (num_elements == max_size)\\n            remove_LFU_element();\\n        // add the new key\\n        cache[key] = make_pair(value,0);\\n        counter[0].push_back(key);\\n        num_elements++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111639,
                "title": "hashtable-c-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n1. Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node {\\n  int key;\\n  int value;\\n  int freq;\\n  list<int>::const_iterator it;\\n};\\n\\nclass LFUCache {\\n public:\\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\\n\\n  int get(int key) {\\n    if (!keyToNode.count(key))\\n      return -1;\\n\\n    Node& node = keyToNode[key];\\n    touch(node);\\n    return node.value;\\n  }\\n\\n  void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToNode.count(key)) {\\n      Node& node = keyToNode[key];\\n      node.value = value;\\n      touch(node);\\n      return;\\n    }\\n\\n    if (keyToNode.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      const int keyToEvict = freqToList[minFreq].back();\\n      freqToList[minFreq].pop_back();\\n      keyToNode.erase(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    freqToList[1].push_front(key);\\n    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};\\n  }\\n\\n private:\\n  int capacity;\\n  int minFreq;\\n  unordered_map<int, Node> keyToNode;\\n  unordered_map<int, list<int>> freqToList;\\n\\n  void touch(Node& node) {\\n    // Update the node\\'s frequency\\n    const int prevFreq = node.freq;\\n    const int newFreq = ++node.freq;\\n\\n    // Remove the iterator from prevFreq\\'s list\\n    freqToList[prevFreq].erase(node.it);\\n    if (freqToList[prevFreq].empty()) {\\n      freqToList.erase(prevFreq);\\n      // Update minFreq if needed\\n      if (prevFreq == minFreq)\\n        ++minFreq;\\n    }\\n\\n    // Insert the key to the front of newFreq\\'s list\\n    freqToList[newFreq].push_front(node.key);\\n    node.it = cbegin(freqToList[newFreq]);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n  int key;\\n  int value;\\n  int freq;\\n  list<int>::const_iterator it;\\n};\\n\\nclass LFUCache {\\n public:\\n  LFUCache(int capacity) : capacity(capacity), minFreq(0) {}\\n\\n  int get(int key) {\\n    if (!keyToNode.count(key))\\n      return -1;\\n\\n    Node& node = keyToNode[key];\\n    touch(node);\\n    return node.value;\\n  }\\n\\n  void put(int key, int value) {\\n    if (capacity == 0)\\n      return;\\n    if (keyToNode.count(key)) {\\n      Node& node = keyToNode[key];\\n      node.value = value;\\n      touch(node);\\n      return;\\n    }\\n\\n    if (keyToNode.size() == capacity) {\\n      // Evict LRU key from the minFreq list\\n      const int keyToEvict = freqToList[minFreq].back();\\n      freqToList[minFreq].pop_back();\\n      keyToNode.erase(keyToEvict);\\n    }\\n\\n    minFreq = 1;\\n    freqToList[1].push_front(key);\\n    keyToNode[key] = {key, value, 1, cbegin(freqToList[1])};\\n  }\\n\\n private:\\n  int capacity;\\n  int minFreq;\\n  unordered_map<int, Node> keyToNode;\\n  unordered_map<int, list<int>> freqToList;\\n\\n  void touch(Node& node) {\\n    // Update the node\\'s frequency\\n    const int prevFreq = node.freq;\\n    const int newFreq = ++node.freq;\\n\\n    // Remove the iterator from prevFreq\\'s list\\n    freqToList[prevFreq].erase(node.it);\\n    if (freqToList[prevFreq].empty()) {\\n      freqToList.erase(prevFreq);\\n      // Update minFreq if needed\\n      if (prevFreq == minFreq)\\n        ++minFreq;\\n    }\\n\\n    // Insert the key to the front of newFreq\\'s list\\n    freqToList[newFreq].push_front(node.key);\\n    node.it = cbegin(freqToList[newFreq]);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111552,
                "title": "python-3-solution",
                "content": "\\n\\n# Code\\n```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.freq_to_key = defaultdict(lambda : OrderedDict())\\n        self.key_to_freq = defaultdict(int)\\n        self.min_freq = 1\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key_to_freq:\\n            return -1\\n        freq = self.key_to_freq[key]\\n        self.key_to_freq[key] = freq + 1\\n        value = self.freq_to_key[freq][key]\\n        del self.freq_to_key[freq][key]\\n        self.freq_to_key[freq+1][key] = value\\n        if self.min_freq == freq and not self.freq_to_key[freq]:\\n            self.min_freq += 1\\n        return value\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.key_to_freq:\\n            self.get(key)\\n            self.freq_to_key[self.key_to_freq[key]][key] = value\\n        else:\\n            self.capacity -= 1\\n            self.key_to_freq[key] = 1\\n            self.freq_to_key[1][key] = value\\n            if self.capacity < 0:\\n                self.capacity += 1\\n                k, v = self.freq_to_key[self.min_freq].popitem(False)\\n                del self.key_to_freq[k]\\n            self.min_freq = 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.freq_to_key = defaultdict(lambda : OrderedDict())\\n        self.key_to_freq = defaultdict(int)\\n        self.min_freq = 1\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.key_to_freq:\\n            return -1\\n        freq = self.key_to_freq[key]\\n        self.key_to_freq[key] = freq + 1\\n        value = self.freq_to_key[freq][key]\\n        del self.freq_to_key[freq][key]\\n        self.freq_to_key[freq+1][key] = value\\n        if self.min_freq == freq and not self.freq_to_key[freq]:\\n            self.min_freq += 1\\n        return value\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.key_to_freq:\\n            self.get(key)\\n            self.freq_to_key[self.key_to_freq[key]][key] = value\\n        else:\\n            self.capacity -= 1\\n            self.key_to_freq[key] = 1\\n            self.freq_to_key[1][key] = value\\n            if self.capacity < 0:\\n                self.capacity += 1\\n                k, v = self.freq_to_key[self.min_freq].popitem(False)\\n                del self.key_to_freq[k]\\n            self.min_freq = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111529,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LFUCache {\\n    int capacity;\\n    int minFreq;\\n    unordered_map<int,pair<int,int>> keyVal;\\n    unordered_map<int,list<int>> freqList;\\n    unordered_map<int,list<int>::iterator> pos;\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n        minFreq = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyVal.find(key) == keyVal.end())\\n            return -1;\\n        freqList[keyVal[key].second].erase(pos[key]);\\n        keyVal[key].second++;\\n        freqList[keyVal[key].second].push_back(key);\\n        pos[key] = --freqList[keyVal[key].second].end();\\n        if(freqList[minFreq].empty())\\n            minFreq++;\\n        return keyVal[key].first;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!capacity)\\n            return;\\n        if(keyVal.find(key) != keyVal.end()) {\\n            keyVal[key].first = value;\\n            freqList[keyVal[key].second].erase(pos[key]);\\n            keyVal[key].second++;\\n            freqList[keyVal[key].second].push_back(key);\\n            pos[key] = --freqList[keyVal[key].second].end();\\n            if(freqList[minFreq].empty())\\n                minFreq++;\\n            return;\\n        }\\n        if(keyVal.size() == capacity) {\\n            int delKey = freqList[minFreq].front();\\n            keyVal.erase(delKey);\\n            pos.erase(delKey);\\n            freqList[minFreq].pop_front();\\n        }\\n        keyVal[key] = {value,1};\\n        freqList[1].push_back(key);\\n        pos[key] = --freqList[1].end();\\n        minFreq = 1;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111479,
                "title": "c-hashmaps-and-linkedlist",
                "content": "# Intuition & Approach\\nhttps://youtu.be/uyaOlNOTUA8\\n\\n# Code\\n```\\nclass LFUCache {\\n    int capacity, minFreq;\\n\\n    struct Element {\\n        int value, fr;\\n        list<int>::iterator it;\\n    };\\n\\n    unordered_map<int, Element> cache;\\n    unordered_map<int, list<int> > freq;\\n\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n    }\\n\\n    int get(int key) {\\n        if (!cache.count(key)) return -1;\\n        \\n        freq[cache[key].fr].erase(cache[key].it);\\n\\n        cache[key].fr++;\\n        freq[cache[key].fr].push_back(key);\\n        cache[key].it = prev(freq[ cache[key].fr].end());\\n\\n        minFreq += freq[minFreq].empty();\\n\\n        return cache[key].value;\\n    }\\n\\n    void put(int key, int value) {\\n        if (!capacity) return;\\n\\n        if (get(key) != -1) {\\n            cache[key].value = value;\\n            return;\\n        }\\n\\n        if (cache.size() == capacity){\\n            cache.erase(freq[minFreq].front());\\n            freq[minFreq].pop_front();\\n        }\\n\\n        freq[1].push_back(key);\\n        cache[key] = {value, 1, prev(freq[1].end())};\\n        minFreq = 1;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    int capacity, minFreq;\\n\\n    struct Element {\\n        int value, fr;\\n        list<int>::iterator it;\\n    };\\n\\n    unordered_map<int, Element> cache;\\n    unordered_map<int, list<int> > freq;\\n\\npublic:\\n    LFUCache(int capacity) {\\n        this->capacity = capacity;\\n    }\\n\\n    int get(int key) {\\n        if (!cache.count(key)) return -1;\\n        \\n        freq[cache[key].fr].erase(cache[key].it);\\n\\n        cache[key].fr++;\\n        freq[cache[key].fr].push_back(key);\\n        cache[key].it = prev(freq[ cache[key].fr].end());\\n\\n        minFreq += freq[minFreq].empty();\\n\\n        return cache[key].value;\\n    }\\n\\n    void put(int key, int value) {\\n        if (!capacity) return;\\n\\n        if (get(key) != -1) {\\n            cache[key].value = value;\\n            return;\\n        }\\n\\n        if (cache.size() == capacity){\\n            cache.erase(freq[minFreq].front());\\n            freq[minFreq].pop_front();\\n        }\\n\\n        freq[1].push_back(key);\\n        cache[key] = {value, 1, prev(freq[1].end())};\\n        minFreq = 1;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111421,
                "title": "python3-solution",
                "content": "\\n```\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.freq = 1\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict() \\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:return -1\\n        node = self.cache[key]\\n\\n        self.update(node, node.val)\\n        return node.val\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n        if key not in self.cache: \\n            if len(self.cache) >= self.capacity:\\n                k, v = self.usage[self.LF].popitem(last=False)\\n                self.cache.pop(k)\\n            node = ListNode(key, value)\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            self.LF = 1\\n        else: \\n            node = self.cache[key]\\n            node.val = value\\n            self.update(node, value)\\n            \\n            \\n    def update(self, node, newVal):\\n        k, f = node.key, node.freq\\n        self.usage[f].pop(k)\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.freq = 1\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict() \\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:return -1\\n        node = self.cache[key]\\n\\n        self.update(node, node.val)\\n        return node.val\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n        if key not in self.cache: \\n            if len(self.cache) >= self.capacity:\\n                k, v = self.usage[self.LF].popitem(last=False)\\n                self.cache.pop(k)\\n            node = ListNode(key, value)\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            self.LF = 1\\n        else: \\n            node = self.cache[key]\\n            node.val = value\\n            self.update(node, value)\\n            \\n            \\n    def update(self, node, newVal):\\n        k, f = node.key, node.freq\\n        self.usage[f].pop(k)\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009996,
                "title": "easy-java-solution-hashmap-and-dll",
                "content": "<!--# Intuition\\n Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!--Describe your approach to solving the problem. -->\\nfor, get(key) -->\\ngets the value of the key if exists, else -1;\\n\\nfor, put(key, value) -->\\ncondition 1: updates the value of the key if present, else inserts the key directly.\\ncondition 2: when cache is full -->\\ncase i : if cache is full, removes the LFU guy\\ncase ii : if cache is full, but exists multiple LFU guys (or a tie exists), then remove the LRU one and then add new node.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n<!--\\n- Space complexity:\\n Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LFUCache {\\n\\n    final int capacity;  //total capacity of LFU Cache\\n    int currSize;   //curr size of LFU Cache\\n    int minFrequency;    //minimum freq of the entire LFU Cache\\n    Map<Integer, DLLNode> cache;    //HashMap containing key to node mapping, storing all nodes by their keys\\n    Map<Integer, DoubleLinkedList> frequencyMap;    //HashMap containing key to LL mapping, storing all DLL by their frequencies\\n\\n\\n    public LFUCache(int capacity) \\n    {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n    //getting node value by key, and then updating node frequency and relocating that node \\n    public int get(int key) \\n    {\\n        DLLNode currNode = cache.get(key);\\n        if(currNode == null)\\n        {\\n            return -1;\\n        }\\n        updateNode(currNode);\\n        return currNode.val;\\n    }\\n\\n    /* adding new node into LFU cache and DLL -->\\n        1. if LFU has input key, update node value and node pos in list\\n        2. if LFU cache does not have input key,\\n            a) if LFU cache does not have enough space --> remove the LRU node in min frequency list and then add new node\\n            b) if LFU cache have enough space, add new node directly\\n    */\\n    \\n    public void put(int key, int value) \\n    {\\n        //always check for the cache capacity\\n        if(capacity == 0)\\n        {\\n            return;\\n        }\\n\\n        if(cache.containsKey(key))\\n        {\\n            DLLNode currNode = cache.get(key);\\n            currNode.val = value;\\n            updateNode(currNode);\\n        }\\n        else\\n        {\\n            currSize++;\\n            if(currSize > capacity)\\n            {\\n                //getting minimum freq list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                currSize--;\\n            }\\n            //changing min frequency back to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            //getting the list with frequency 1, and adding new node into the list, and into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode currNode)\\n    {\\n        int currFreq = currNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(currFreq);\\n        curList.removeNode(currNode);\\n\\n        //if current list(last list ) which has lowest frequency and current node is the only node in that list , remove the entire list and then increase min frequency value by 1\\n        if (currFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        currNode.frequency++;\\n        //adding current node to another list has current frequency + 1,\\n        //if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(currNode.frequency, new DoubleLinkedList());\\n        newList.addNode(currNode);\\n        frequencyMap.put(currNode.frequency, newList);\\n\\n\\n\\n    }\\n\\n    class DLLNode \\n    {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) \\n        {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    class DoubleLinkedList \\n    {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() \\n        {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        //adding new node into head of list and increasing list size by 1 \\n        public void addNode(DLLNode currNode) {\\n            DLLNode nextNode = head.next;\\n            currNode.next = nextNode;\\n            currNode.prev = head;\\n            head.next = currNode;\\n            nextNode.prev = currNode;\\n            listSize++;\\n        }\\n\\n        //removing input node and decreasing list size by 1\\n        public void removeNode(DLLNode currNode) {\\n            DLLNode prevNode = currNode.prev;\\n            DLLNode nextNode = currNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n\\n    final int capacity;  //total capacity of LFU Cache\\n    int currSize;   //curr size of LFU Cache\\n    int minFrequency;    //minimum freq of the entire LFU Cache\\n    Map<Integer, DLLNode> cache;    //HashMap containing key to node mapping, storing all nodes by their keys\\n    Map<Integer, DoubleLinkedList> frequencyMap;    //HashMap containing key to LL mapping, storing all DLL by their frequencies\\n\\n\\n    public LFUCache(int capacity) \\n    {\\n        this.capacity = capacity;\\n        this.currSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n    //getting node value by key, and then updating node frequency and relocating that node \\n    public int get(int key) \\n    {\\n        DLLNode currNode = cache.get(key);\\n        if(currNode == null)\\n        {\\n            return -1;\\n        }\\n        updateNode(currNode);\\n        return currNode.val;\\n    }\\n\\n    /* adding new node into LFU cache and DLL -->\\n        1. if LFU has input key, update node value and node pos in list\\n        2. if LFU cache does not have input key,\\n            a) if LFU cache does not have enough space --> remove the LRU node in min frequency list and then add new node\\n            b) if LFU cache have enough space, add new node directly\\n    */\\n    \\n    public void put(int key, int value) \\n    {\\n        //always check for the cache capacity\\n        if(capacity == 0)\\n        {\\n            return;\\n        }\\n\\n        if(cache.containsKey(key))\\n        {\\n            DLLNode currNode = cache.get(key);\\n            currNode.val = value;\\n            updateNode(currNode);\\n        }\\n        else\\n        {\\n            currSize++;\\n            if(currSize > capacity)\\n            {\\n                //getting minimum freq list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                currSize--;\\n            }\\n            //changing min frequency back to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            //getting the list with frequency 1, and adding new node into the list, and into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode currNode)\\n    {\\n        int currFreq = currNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(currFreq);\\n        curList.removeNode(currNode);\\n\\n        //if current list(last list ) which has lowest frequency and current node is the only node in that list , remove the entire list and then increase min frequency value by 1\\n        if (currFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        currNode.frequency++;\\n        //adding current node to another list has current frequency + 1,\\n        //if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(currNode.frequency, new DoubleLinkedList());\\n        newList.addNode(currNode);\\n        frequencyMap.put(currNode.frequency, newList);\\n\\n\\n\\n    }\\n\\n    class DLLNode \\n    {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) \\n        {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    class DoubleLinkedList \\n    {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() \\n        {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        //adding new node into head of list and increasing list size by 1 \\n        public void addNode(DLLNode currNode) {\\n            DLLNode nextNode = head.next;\\n            currNode.next = nextNode;\\n            currNode.prev = head;\\n            head.next = currNode;\\n            nextNode.prev = currNode;\\n            listSize++;\\n        }\\n\\n        //removing input node and decreasing list size by 1\\n        public void removeNode(DLLNode currNode) {\\n            DLLNode prevNode = currNode.prev;\\n            DLLNode nextNode = currNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730107,
                "title": "js-only-two-maps",
                "content": "```js\\nvar LFUCache = function(capacity) {\\n  this.minCount = 0;\\n  this.keyValues = new Map();\\n  this.countKeys = new Map();\\n  this.capacity = capacity;\\n};\\n\\nLFUCache.prototype.incrementCount = function(key, newValue = undefined) {\\n  \\n  let { value, count } = this.keyValues.get(key);\\n  if (newValue) value = newValue;\\n  this.keyValues.set(key, { value, count: count + 1 });\\n  \\n  const set = this.countKeys.get(count);\\n  set.delete(key);\\n\\n  if (set.size === 0) {\\n    this.countKeys.delete(count);\\n    if (this.minCount === count) this.minCount += 1;\\n  } else {\\n    this.countKeys.set(count, set); \\n  }\\n\\n  this.countKeys.set(count + 1, (this.countKeys.get(count + 1) || new Set()).add(key));\\n  \\n  return value;\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n  if (!this.keyValues.has(key)) return -1;\\n  return this.incrementCount(key);\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if (this.capacity === 0) return;\\n  \\n  if (this.keyValues.has(key)) {\\n    this.incrementCount(key, value);\\n    return;\\n  }\\n    \\n  if (this.keyValues.size === this.capacity) {\\n    \\n    const set = this.countKeys.get(this.minCount);\\n    const keyToDelete = set.values().next().value;\\n    set.delete(keyToDelete);\\n    \\n    if (set.size === 0) {\\n      this.countKeys.delete(this.minCount);\\n    } else {\\n      this.countKeys.set(this.minCount, set); \\n    }\\n\\n    this.keyValues.delete(keyToDelete);\\n  }\\n\\n  const count = 1;\\n  this.keyValues.set(key, { value, count });\\n  this.countKeys.set(count, (this.countKeys.get(count) || new Set()).add(key));\\n  this.minCount = count;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar LFUCache = function(capacity) {\\n  this.minCount = 0;\\n  this.keyValues = new Map();\\n  this.countKeys = new Map();\\n  this.capacity = capacity;\\n};\\n\\nLFUCache.prototype.incrementCount = function(key, newValue = undefined) {\\n  \\n  let { value, count } = this.keyValues.get(key);\\n  if (newValue) value = newValue;\\n  this.keyValues.set(key, { value, count: count + 1 });\\n  \\n  const set = this.countKeys.get(count);\\n  set.delete(key);\\n\\n  if (set.size === 0) {\\n    this.countKeys.delete(count);\\n    if (this.minCount === count) this.minCount += 1;\\n  } else {\\n    this.countKeys.set(count, set); \\n  }\\n\\n  this.countKeys.set(count + 1, (this.countKeys.get(count + 1) || new Set()).add(key));\\n  \\n  return value;\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.get = function(key) {\\n  if (!this.keyValues.has(key)) return -1;\\n  return this.incrementCount(key);\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if (this.capacity === 0) return;\\n  \\n  if (this.keyValues.has(key)) {\\n    this.incrementCount(key, value);\\n    return;\\n  }\\n    \\n  if (this.keyValues.size === this.capacity) {\\n    \\n    const set = this.countKeys.get(this.minCount);\\n    const keyToDelete = set.values().next().value;\\n    set.delete(keyToDelete);\\n    \\n    if (set.size === 0) {\\n      this.countKeys.delete(this.minCount);\\n    } else {\\n      this.countKeys.set(this.minCount, set); \\n    }\\n\\n    this.keyValues.delete(keyToDelete);\\n  }\\n\\n  const count = 1;\\n  this.keyValues.set(key, { value, count });\\n  this.countKeys.set(count, (this.countKeys.get(count) || new Set()).add(key));\\n  this.minCount = count;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366143,
                "title": "python-dll-hashmap-oops-concepts-implementation",
                "content": "```\\nclass Node:\\n    \\n    def __init__(self, key, val, cnt=1, nxxt=None, prev=None):\\n        self.key = key\\n        self.val = val\\n        self.cnt = cnt\\n        self.nxxt = nxxt\\n        self.prev = prev\\n        \\n        \\nclass NodeList(Node):\\n    \\n    def __init__(self):\\n        self.head = Node(0,0)\\n        self.tail = Node(0,0)\\n        self.head.nxxt = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n        \\n        \\n    def addFront(self, node):\\n        temp = self.head.nxxt\\n        self.head.nxxt = node\\n        node.prev = self.head\\n        node.nxxt = temp\\n        temp.prev = node\\n        \\n        self.size += 1\\n        \\n        \\n    def removeNode(self, node):\\n        delprev = node.prev\\n        delnxxt = node.nxxt\\n        delprev.nxxt = delnxxt\\n        delnxxt.prev = delprev\\n        \\n        self.size -= 1\\n        \\n\\nclass LFUCache(NodeList):\\n\\n    def __init__(self, capacity: int):\\n        self.keyNode = {}\\n        self.freqNodeList = {}\\n        self.maxSizeCache = capacity\\n        self.currSize = 0\\n        self.minFreq = 0\\n        \\n        \\n    def updateFreqNodeList(self, node):\\n        del self.keyNode[node.key]\\n        nodelist = self.freqNodeList[node.cnt]\\n        nodelist.removeNode(node)\\n        \\n        if node.cnt == self.minFreq and self.freqNodeList[node.cnt].size == 0:\\n            self.minFreq += 1\\n            \\n        if (node.cnt+1) in self.freqNodeList:\\n            nextHigherFreqNodeList = self.freqNodeList[node.cnt+1]\\n        else:\\n            nextHigherFreqNodeList = NodeList()\\n            \\n        node.cnt += 1\\n        nextHigherFreqNodeList.addFront(node)\\n        \\n        self.freqNodeList[node.cnt] = nextHigherFreqNodeList\\n        self.keyNode[node.key] = node\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.keyNode:\\n            node = self.keyNode[key]\\n            ans = node.val\\n            self.updateFreqNodeList(node)\\n            \\n            return ans\\n        \\n        else:\\n            return -1\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.maxSizeCache == 0:\\n            return\\n        \\n        if key in self.keyNode:\\n            node = self.keyNode[key]\\n            node.val = value\\n            self.updateFreqNodeList(node)\\n            return\\n        \\n        else:\\n            if self.currSize == self.maxSizeCache:\\n                nodelist = self.freqNodeList[self.minFreq]\\n                del self.keyNode[nodelist.tail.prev.key]\\n                nodelist.removeNode(nodelist.tail.prev)\\n                self.currSize -= 1\\n                \\n            self.currSize += 1\\n            self.minFreq = 1\\n            \\n            if self.minFreq in self.freqNodeList:\\n                nodelist = self.freqNodeList[self.minFreq]\\n            else:\\n                nodelist = NodeList()\\n                \\n            node = Node(key, value)\\n            nodelist.addFront(node)\\n            \\n            self.keyNode[key] = node\\n            self.freqNodeList[self.minFreq] = nodelist\\n        \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node:\\n    \\n    def __init__(self, key, val, cnt=1, nxxt=None, prev=None):\\n        self.key = key\\n        self.val = val\\n        self.cnt = cnt\\n        self.nxxt = nxxt\\n        self.prev = prev\\n        \\n        \\nclass NodeList(Node):\\n    \\n    def __init__(self):\\n        self.head = Node(0,0)\\n        self.tail = Node(0,0)\\n        self.head.nxxt = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n        \\n        \\n    def addFront(self, node):\\n        temp = self.head.nxxt\\n        self.head.nxxt = node\\n        node.prev = self.head\\n        node.nxxt = temp\\n        temp.prev = node\\n        \\n        self.size += 1\\n        \\n        \\n    def removeNode(self, node):\\n        delprev = node.prev\\n        delnxxt = node.nxxt\\n        delprev.nxxt = delnxxt\\n        delnxxt.prev = delprev\\n        \\n        self.size -= 1\\n        \\n\\nclass LFUCache(NodeList):\\n\\n    def __init__(self, capacity: int):\\n        self.keyNode = {}\\n        self.freqNodeList = {}\\n        self.maxSizeCache = capacity\\n        self.currSize = 0\\n        self.minFreq = 0\\n        \\n        \\n    def updateFreqNodeList(self, node):\\n        del self.keyNode[node.key]\\n        nodelist = self.freqNodeList[node.cnt]\\n        nodelist.removeNode(node)\\n        \\n        if node.cnt == self.minFreq and self.freqNodeList[node.cnt].size == 0:\\n            self.minFreq += 1\\n            \\n        if (node.cnt+1) in self.freqNodeList:\\n            nextHigherFreqNodeList = self.freqNodeList[node.cnt+1]\\n        else:\\n            nextHigherFreqNodeList = NodeList()\\n            \\n        node.cnt += 1\\n        nextHigherFreqNodeList.addFront(node)\\n        \\n        self.freqNodeList[node.cnt] = nextHigherFreqNodeList\\n        self.keyNode[node.key] = node\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.keyNode:\\n            node = self.keyNode[key]\\n            ans = node.val\\n            self.updateFreqNodeList(node)\\n            \\n            return ans\\n        \\n        else:\\n            return -1\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.maxSizeCache == 0:\\n            return\\n        \\n        if key in self.keyNode:\\n            node = self.keyNode[key]\\n            node.val = value\\n            self.updateFreqNodeList(node)\\n            return\\n        \\n        else:\\n            if self.currSize == self.maxSizeCache:\\n                nodelist = self.freqNodeList[self.minFreq]\\n                del self.keyNode[nodelist.tail.prev.key]\\n                nodelist.removeNode(nodelist.tail.prev)\\n                self.currSize -= 1\\n                \\n            self.currSize += 1\\n            self.minFreq = 1\\n            \\n            if self.minFreq in self.freqNodeList:\\n                nodelist = self.freqNodeList[self.minFreq]\\n            else:\\n                nodelist = NodeList()\\n                \\n            node = Node(key, value)\\n            nodelist.addFront(node)\\n            \\n            self.keyNode[key] = node\\n            self.freqNodeList[self.minFreq] = nodelist\\n        \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349568,
                "title": "python-two-hashmap-and-two-variables",
                "content": "**This is an implementation of the solution provided  by the most upvoted post** [**here**](http://leetcode.com/problems/lfu-cache/discuss/207673/Python-concise-solution-**detailed**-explanation%3A-Two-dict-%2B-Doubly-linked-list).\\n\\n**Solution**:\\n    Store (key,value) pairs in two hashmap. The first hashmap will map keys to their frequencies and the second hashmap will map frequencies to an ordered hashmap of (key,value) pairs. Ordered hashmap is important here because it will store the most recently used (key,value) pairs at the back. Also, we will keep track of the minimum frequency such that we can find and remove the least frequently used (key,value) pair in O(1).\\n\\n Get: Check if a key exists. If yes, increment its frequency in the keyToFreq hashmap and move it one frequency up in the freqToKey hashmap. Update the minimum frequency if it is necessary. \\n\\nPut: Check if a key exists. \\nIf yes, increment its frequency in the keyToFreq hashmap, move it one frequency up in the freqToKey hashmap, and update the value. Update the minimum frequency if it is neccessary.\\n        \\nElse, add the key and set its frequency as 1 in the keyToFreq hashmap and add such (key,value) pair to its corresponding frequency in the freqToKey hashmap. If we exceed the capacity, using the minimum frequency and find the first (key,value) pairs at such frequency in the keyToFreq hashmap and remove it from both hashmap. Set the minimum frequency to 1. \\n\\n**Complexity**:\\n    Time: O(1)\\n    Space: O(capacity)\\n```\\nfrom collections import OrderedDict, defaultdict\\n\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n\\n        # Initialize the capacity\\n        self.capacity = capacity\\n\\n        # Initialize the hashmap to map freq -> ordered hashmap of (key,value) pairs.\\n        self.freqToKey = defaultdict(OrderedDict)\\n\\n        # Initialize the hashmap to map key -> freq\\n        self.keyToFreq = defaultdict()\\n\\n        # Initialize the minimum frequency to 1 \\n        self.minFreq = 1\\n\\n    def get(self, key: int) -> int:\\n\\n        # If the key doesn\\'t exist, return -1\\n        if key not in self.keyToFreq:\\n            return -1\\n\\n        # Move (key,value) pair one frequency up\\n        self.freqToKey[self.keyToFreq[key] + 1][key] = self.freqToKey[self.keyToFreq[key]].pop(key)\\n\\n        # If the minimum frequency is the same as the freq of the current key and there isn\\'t any more (key,value) pair after moved such key 1 frequency up, increment the minimum frequency by 1 \\n        if (\\n            self.minFreq == self.keyToFreq[key]\\n            and len(self.freqToKey[self.keyToFreq[key]]) == 0\\n        ):\\n            self.minFreq = self.keyToFreq[key] + 1\\n\\n        # Increment the frequency of the current key in the keyToFreq hashmap by 1\\n        self.keyToFreq[key] += 1\\n\\n        # Return the value\\n        return self.freqToKey[self.keyToFreq[key]][key]\\n\\n    def put(self, key: int, value: int) -> None:\\n\\n        # If the key exists,\\n        if key in self.keyToFreq:\\n\\n            # Move (key,value) pair one frequency up and update its value\\n            self.freqToKey[self.keyToFreq[key]].pop(key)\\n            self.freqToKey[self.keyToFreq[key] + 1][key] = value\\n\\n            # If the minimum frequency is the same as the freq of the current key and there isn\\'t any more (key,value) pair after moved such key 1 frequency up, increment the minimum frequency by 1 \\n            if (\\n                self.minFreq == self.keyToFreq[key]\\n                and len(self.freqToKey[self.keyToFreq[key]]) == 0\\n            ):\\n                self.minFreq = self.keyToFreq[key] + 1\\n\\n            # Increment the frequency of the current key in the keyToFreq hashmap by 1\\n            self.keyToFreq[key] += 1\\n\\n        # Elif the key doesn\\'t exist,\\n        else:\\n\\n            # Add it to the keyToFreq hashmap\\n            self.keyToFreq[key] = 1\\n\\n            # Add the (key,value) pair to the freqToKey hashmap\\n            self.freqToKey[self.keyToFreq[key]][key] = value\\n\\n            # Decrement the capacity by 1\\n            self.capacity -= 1\\n\\n            # If we run out of capacity\\n            if self.capacity < 0:\\n\\n                # Remove the first (key,value) pair at the minimum frequency from both hashmaps \\n                key, value = self.freqToKey[self.minFreq].popitem(last=False)\\n                self.keyToFreq.pop(key)\\n\\n                # Increment the capacity\\n                self.capacity +=1\\n\\n            # Set the minimum frequency to 1\\n            self.minFreq = 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import OrderedDict, defaultdict\\n\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n\\n        # Initialize the capacity\\n        self.capacity = capacity\\n\\n        # Initialize the hashmap to map freq -> ordered hashmap of (key,value) pairs.\\n        self.freqToKey = defaultdict(OrderedDict)\\n\\n        # Initialize the hashmap to map key -> freq\\n        self.keyToFreq = defaultdict()\\n\\n        # Initialize the minimum frequency to 1 \\n        self.minFreq = 1\\n\\n    def get(self, key: int) -> int:\\n\\n        # If the key doesn\\'t exist, return -1\\n        if key not in self.keyToFreq:\\n            return -1\\n\\n        # Move (key,value) pair one frequency up\\n        self.freqToKey[self.keyToFreq[key] + 1][key] = self.freqToKey[self.keyToFreq[key]].pop(key)\\n\\n        # If the minimum frequency is the same as the freq of the current key and there isn\\'t any more (key,value) pair after moved such key 1 frequency up, increment the minimum frequency by 1 \\n        if (\\n            self.minFreq == self.keyToFreq[key]\\n            and len(self.freqToKey[self.keyToFreq[key]]) == 0\\n        ):\\n            self.minFreq = self.keyToFreq[key] + 1\\n\\n        # Increment the frequency of the current key in the keyToFreq hashmap by 1\\n        self.keyToFreq[key] += 1\\n\\n        # Return the value\\n        return self.freqToKey[self.keyToFreq[key]][key]\\n\\n    def put(self, key: int, value: int) -> None:\\n\\n        # If the key exists,\\n        if key in self.keyToFreq:\\n\\n            # Move (key,value) pair one frequency up and update its value\\n            self.freqToKey[self.keyToFreq[key]].pop(key)\\n            self.freqToKey[self.keyToFreq[key] + 1][key] = value\\n\\n            # If the minimum frequency is the same as the freq of the current key and there isn\\'t any more (key,value) pair after moved such key 1 frequency up, increment the minimum frequency by 1 \\n            if (\\n                self.minFreq == self.keyToFreq[key]\\n                and len(self.freqToKey[self.keyToFreq[key]]) == 0\\n            ):\\n                self.minFreq = self.keyToFreq[key] + 1\\n\\n            # Increment the frequency of the current key in the keyToFreq hashmap by 1\\n            self.keyToFreq[key] += 1\\n\\n        # Elif the key doesn\\'t exist,\\n        else:\\n\\n            # Add it to the keyToFreq hashmap\\n            self.keyToFreq[key] = 1\\n\\n            # Add the (key,value) pair to the freqToKey hashmap\\n            self.freqToKey[self.keyToFreq[key]][key] = value\\n\\n            # Decrement the capacity by 1\\n            self.capacity -= 1\\n\\n            # If we run out of capacity\\n            if self.capacity < 0:\\n\\n                # Remove the first (key,value) pair at the minimum frequency from both hashmaps \\n                key, value = self.freqToKey[self.minFreq].popitem(last=False)\\n                self.keyToFreq.pop(key)\\n\\n                # Increment the capacity\\n                self.capacity +=1\\n\\n            # Set the minimum frequency to 1\\n            self.minFreq = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106818,
                "title": "c-dll-map-list",
                "content": "My solution is inspired by Striver\\'s Solution Video \\n\\nUsing Unordered Map & Doubly Linked List\\nTime Complexity : O(1)\\nSpace Complexity : O(N)\\n\\nstruct Node{\\n    int cnt, val, key;\\n    Node* next;\\n    Node* prev;\\n    \\n    Node(int _key, int _val){\\n        key = _key;\\n        val = _val;\\n        cnt = 1;\\n    }\\n};\\n\\nstruct List{\\n    int size;\\n    Node* head;\\n    Node* tail;\\n    \\n    List(){\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head->next = tail;\\n        tail->prev = head;\\n        size = 0;\\n    }\\n    \\n    void addNodeIntoList(Node* node){\\n        Node* temp = head->next;\\n        \\n        node->next = temp;\\n        node->prev = head;\\n        \\n        head->next = node;\\n        temp->prev = node;\\n        \\n        size++;\\n    }\\n    \\n    void removeNodeFromList(Node* delnode){        \\n        Node* delprev = delnode->prev;\\n        Node* delnext = delnode->next;\\n        \\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n        \\n        size--; \\n    }    \\n};\\n\\nclass LFUCache {\\nprivate:\\n    int minFreqInMap, size, curSize;\\n    \\n    // frequency, list for that frequency\\n    unordered_map<int, List*> mapFreqList;\\n    \\n    // key, nodeAddress\\n    unordered_map<int, Node*> keyNodeMap;\\n    \\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        curSize = 0;\\n        minFreqInMap = 0;\\n    }\\n    \\n    void updateFreqOfNodeIntoFreqListMap(Node* node){\\n        keyNodeMap.erase(node->key);\\n        mapFreqList[node->cnt]->removeNodeFromList(node);\\n        \\n        if(node->cnt == minFreqInMap && mapFreqList[node->cnt]->size == 0){\\n            minFreqInMap++;\\n        }\\n        \\n        List* list = new List();\\n        if(mapFreqList[node->cnt + 1]){\\n            list = mapFreqList[node->cnt + 1];\\n        }\\n        \\n        node->cnt += 1;\\n        list->addNodeIntoList(node);\\n        mapFreqList[node->cnt] = list;\\n        keyNodeMap[node->key] = node;\\n    }\\n    \\n    int get(int key) {        \\n        if(keyNodeMap[key]){\\n            Node* node = keyNodeMap[key];\\n            int value = node->val;\\n            updateFreqOfNodeIntoFreqListMap(node);\\n            return value;\\n        }        \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        // edge case\\n        if(size == 0) return;\\n        \\n        if(keyNodeMap[key]){\\n            Node* node = keyNodeMap[key];\\n            node->val = value;\\n            updateFreqOfNodeIntoFreqListMap(node);\\n        }\\n        else{\\n            if(size == curSize){\\n                List* list = mapFreqList[minFreqInMap];\\n                keyNodeMap.erase(list->tail->prev->key);\\n                mapFreqList[minFreqInMap]->removeNodeFromList(list->tail->prev);\\n                curSize--;\\n            }\\n            \\n            curSize++;\\n            minFreqInMap = 1;\\n            \\n            List* list = new List();\\n            if(mapFreqList[minFreqInMap]){\\n                list = mapFreqList[minFreqInMap];\\n            }\\n            \\n            Node* node = new Node(key, value);\\n            list->addNodeIntoList(node);\\n            mapFreqList[minFreqInMap] = list;\\n            \\n            keyNodeMap[key] = node;\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "My solution is inspired by Striver\\'s Solution Video \\n\\nUsing Unordered Map & Doubly Linked List\\nTime Complexity : O(1)\\nSpace Complexity : O(N)\\n\\nstruct Node{\\n    int cnt, val, key;\\n    Node* next;\\n    Node* prev;\\n    \\n    Node(int _key, int _val){\\n        key = _key;\\n        val = _val;\\n        cnt = 1;\\n    }\\n};\\n\\nstruct List{\\n    int size;\\n    Node* head;\\n    Node* tail;\\n    \\n    List(){\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head->next = tail;\\n        tail->prev = head;\\n        size = 0;\\n    }\\n    \\n    void addNodeIntoList(Node* node){\\n        Node* temp = head->next;\\n        \\n        node->next = temp;\\n        node->prev = head;\\n        \\n        head->next = node;\\n        temp->prev = node;\\n        \\n        size++;\\n    }\\n    \\n    void removeNodeFromList(Node* delnode){        \\n        Node* delprev = delnode->prev;\\n        Node* delnext = delnode->next;\\n        \\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n        \\n        size--; \\n    }    \\n};\\n\\nclass LFUCache {\\nprivate:\\n    int minFreqInMap, size, curSize;\\n    \\n    // frequency, list for that frequency\\n    unordered_map<int, List*> mapFreqList;\\n    \\n    // key, nodeAddress\\n    unordered_map<int, Node*> keyNodeMap;\\n    \\npublic:\\n    LFUCache(int capacity) {\\n        size = capacity;\\n        curSize = 0;\\n        minFreqInMap = 0;\\n    }\\n    \\n    void updateFreqOfNodeIntoFreqListMap(Node* node){\\n        keyNodeMap.erase(node->key);\\n        mapFreqList[node->cnt]->removeNodeFromList(node);\\n        \\n        if(node->cnt == minFreqInMap && mapFreqList[node->cnt]->size == 0){\\n            minFreqInMap++;\\n        }\\n        \\n        List* list = new List();\\n        if(mapFreqList[node->cnt + 1]){\\n            list = mapFreqList[node->cnt + 1];\\n        }\\n        \\n        node->cnt += 1;\\n        list->addNodeIntoList(node);\\n        mapFreqList[node->cnt] = list;\\n        keyNodeMap[node->key] = node;\\n    }\\n    \\n    int get(int key) {        \\n        if(keyNodeMap[key]){\\n            Node* node = keyNodeMap[key];\\n            int value = node->val;\\n            updateFreqOfNodeIntoFreqListMap(node);\\n            return value;\\n        }        \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        // edge case\\n        if(size == 0) return;\\n        \\n        if(keyNodeMap[key]){\\n            Node* node = keyNodeMap[key];\\n            node->val = value;\\n            updateFreqOfNodeIntoFreqListMap(node);\\n        }\\n        else{\\n            if(size == curSize){\\n                List* list = mapFreqList[minFreqInMap];\\n                keyNodeMap.erase(list->tail->prev->key);\\n                mapFreqList[minFreqInMap]->removeNodeFromList(list->tail->prev);\\n                curSize--;\\n            }\\n            \\n            curSize++;\\n            minFreqInMap = 1;\\n            \\n            List* list = new List();\\n            if(mapFreqList[minFreqInMap]){\\n                list = mapFreqList[minFreqInMap];\\n            }\\n            \\n            Node* node = new Node(key, value);\\n            list->addNodeIntoList(node);\\n            mapFreqList[minFreqInMap] = list;\\n            \\n            keyNodeMap[key] = node;\\n        }\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1976554,
                "title": "java-runtime-66-ms-faster-than-88-58-of-java-online-submissions-time-o-1",
                "content": "```\\nimport java.util.HashMap;\\n\\n\\npublic class LFUCache {\\n\\tHashMap<Integer, Node> valMap;\\n\\tHashMap<Integer, LinkedList> freqMap;\\n\\tint minFreq;\\n\\tint capacity;\\n\\t\\n\\t\\n\\tpublic LFUCache(int capacity) {\\n\\t\\tthis.valMap = new HashMap<>();\\n\\t\\tthis.freqMap = new HashMap<>();\\n\\t\\tthis.minFreq = 0;\\n\\t\\tthis.capacity = capacity;\\n\\t}\\n\\t\\n\\tpublic int get(int key) {\\n\\t\\tNode curr = valMap.get(key);\\n\\t\\tif(curr == null) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tupdateNode(curr);\\n\\t\\treturn curr.val;\\n\\t}\\n\\t\\n\\tpublic void put(int key, int val) {\\n\\t\\tif(capacity == 0) return;\\n\\t\\t\\n\\t\\tif(valMap.containsKey(key)) {\\n\\t\\t\\tvalMap.get(key).val = val;\\n\\t\\t\\tupdateNode(valMap.get(key));\\n\\t\\t\\t\\n\\t\\t}else {\\n\\t\\t\\tif(valMap.size() == capacity) {\\n\\t\\t\\t\\tLinkedList list = freqMap.get(minFreq);\\n\\t\\t\\t\\tvalMap.remove(list.tail.prev.key);\\n\\t\\t\\t\\tlist.removeNode(list.tail.prev);\\n\\t\\t\\t}\\n\\t\\t\\tminFreq = 1;\\n\\t\\t\\tNode node = new Node(key, val);\\n\\t\\t\\tLinkedList list = freqMap.getOrDefault(1, new LinkedList());\\n\\t\\t\\tlist.addNode(node);\\n\\t\\t\\tfreqMap.put(1, list);\\n\\t\\t\\tvalMap.put(key, node);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate void updateNode(Node n) {\\n\\t\\tLinkedList list = freqMap.get(n.freq);\\n\\t\\tlist.removeNode(n);\\n\\t\\tif(n.freq  == minFreq && list.size == 0) {\\n\\t\\t\\tminFreq++;\\n\\t\\t}\\n\\t\\tn.freq++;\\n\\t\\tLinkedList newList = freqMap.getOrDefault(n.freq, new LinkedList());\\n\\t\\tnewList.addNode(n);\\n\\t\\tfreqMap.put(n.freq, newList);\\n\\t}\\n\\t\\n\\t\\n\\tprivate class Node{\\n\\t\\tNode next;\\n\\t\\tNode prev;\\n\\t\\tint key;\\n\\t\\tint val;\\n\\t\\tint freq;\\n\\t\\t\\n\\t\\tNode(){}\\n\\t\\tNode(int key, int val){\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.next = null;\\n\\t\\t\\tthis.prev = null;\\n\\t\\t\\tthis.freq = 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate class LinkedList{\\n\\t\\tNode head;\\n\\t\\tNode tail;\\n\\t\\tint size;\\n\\t\\tpublic LinkedList() {\\n\\t\\t\\thead = new Node();\\n\\t\\t\\ttail = new Node();\\n\\t\\t\\thead.next = tail;\\n\\t\\t\\ttail.prev = head;\\n\\t\\t\\tsize = 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic void addNode(Node n) {\\n\\t\\t\\tn.next = head.next;\\n\\t\\t\\thead.next.prev = n;\\n\\t\\t\\thead.next = n;\\n\\t\\t\\tn.prev = head;\\n\\t\\t\\tsize++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic void removeNode(Node n) {\\n\\t\\t\\tn.prev.next  = n.next;\\n\\t\\t\\tn.next.prev = n.prev;\\n\\t\\t\\tsize--;\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\n\\npublic class LFUCache {\\n\\tHashMap<Integer, Node> valMap;\\n\\tHashMap<Integer, LinkedList> freqMap;\\n\\tint minFreq;\\n\\tint capacity;\\n\\t\\n\\t\\n\\tpublic LFUCache(int capacity) {\\n\\t\\tthis.valMap = new HashMap<>();\\n\\t\\tthis.freqMap = new HashMap<>();\\n\\t\\tthis.minFreq = 0;\\n\\t\\tthis.capacity = capacity;\\n\\t}\\n\\t\\n\\tpublic int get(int key) {\\n\\t\\tNode curr = valMap.get(key);\\n\\t\\tif(curr == null) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tupdateNode(curr);\\n\\t\\treturn curr.val;\\n\\t}\\n\\t\\n\\tpublic void put(int key, int val) {\\n\\t\\tif(capacity == 0) return;\\n\\t\\t\\n\\t\\tif(valMap.containsKey(key)) {\\n\\t\\t\\tvalMap.get(key).val = val;\\n\\t\\t\\tupdateNode(valMap.get(key));\\n\\t\\t\\t\\n\\t\\t}else {\\n\\t\\t\\tif(valMap.size() == capacity) {\\n\\t\\t\\t\\tLinkedList list = freqMap.get(minFreq);\\n\\t\\t\\t\\tvalMap.remove(list.tail.prev.key);\\n\\t\\t\\t\\tlist.removeNode(list.tail.prev);\\n\\t\\t\\t}\\n\\t\\t\\tminFreq = 1;\\n\\t\\t\\tNode node = new Node(key, val);\\n\\t\\t\\tLinkedList list = freqMap.getOrDefault(1, new LinkedList());\\n\\t\\t\\tlist.addNode(node);\\n\\t\\t\\tfreqMap.put(1, list);\\n\\t\\t\\tvalMap.put(key, node);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate void updateNode(Node n) {\\n\\t\\tLinkedList list = freqMap.get(n.freq);\\n\\t\\tlist.removeNode(n);\\n\\t\\tif(n.freq  == minFreq && list.size == 0) {\\n\\t\\t\\tminFreq++;\\n\\t\\t}\\n\\t\\tn.freq++;\\n\\t\\tLinkedList newList = freqMap.getOrDefault(n.freq, new LinkedList());\\n\\t\\tnewList.addNode(n);\\n\\t\\tfreqMap.put(n.freq, newList);\\n\\t}\\n\\t\\n\\t\\n\\tprivate class Node{\\n\\t\\tNode next;\\n\\t\\tNode prev;\\n\\t\\tint key;\\n\\t\\tint val;\\n\\t\\tint freq;\\n\\t\\t\\n\\t\\tNode(){}\\n\\t\\tNode(int key, int val){\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.next = null;\\n\\t\\t\\tthis.prev = null;\\n\\t\\t\\tthis.freq = 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate class LinkedList{\\n\\t\\tNode head;\\n\\t\\tNode tail;\\n\\t\\tint size;\\n\\t\\tpublic LinkedList() {\\n\\t\\t\\thead = new Node();\\n\\t\\t\\ttail = new Node();\\n\\t\\t\\thead.next = tail;\\n\\t\\t\\ttail.prev = head;\\n\\t\\t\\tsize = 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic void addNode(Node n) {\\n\\t\\t\\tn.next = head.next;\\n\\t\\t\\thead.next.prev = n;\\n\\t\\t\\thead.next = n;\\n\\t\\t\\tn.prev = head;\\n\\t\\t\\tsize++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic void removeNode(Node n) {\\n\\t\\t\\tn.prev.next  = n.next;\\n\\t\\t\\tn.next.prev = n.prev;\\n\\t\\t\\tsize--;\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840982,
                "title": "python3-sortedlist-solution",
                "content": "The idea is intuitive, sort by frequency first and then by time. Each time we call add or get method we increment LFU.time by 1. This approach is very similar to https://leetcode.com/problems/lru-cache/. Instead of linkedlist, here we can use sortedlist to search for the node we want to delete.\\n```\\nfrom sortedcontainers import SortedList\\nclass Node:\\n    def __init__(self,key,val,freq=1,time=0):\\n        self.key=key\\n        self.val=val\\n        self.freq=freq\\n        self.time=time\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.heap=SortedList(key=lambda x:(-x.freq,-x.time))\\n        self.node_map={}\\n        self.cap=capacity\\n        self.time=0\\n    \\n    def add(self,node):\\n        self.heap.add(node)\\n        self.node_map[node.key]=node\\n        \\n    def remove(self,node):\\n        self.node_map.pop(node.key)\\n        self.heap.remove(node)\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.node_map:\\n            return -1\\n            \\n        else:\\n            node=self.node_map[key]\\n            self.remove(node)\\n            node.freq+=1\\n            node.time=self.time\\n            self.add(node)\\n            self.time+=1\\n            return node.val\\n\\n    def put(self, key: int, value: int) -> None:\\n        old_freq=0\\n        if self.cap==0:\\n            return\\n        if key not in self.node_map and len(self.node_map)>=self.cap:\\n            pop_node=self.heap[-1]\\n            self.remove(pop_node)\\n        if key in self.node_map:\\n            old_node=self.node_map[key]\\n            old_freq=old_node.freq\\n            self.remove(old_node)\\n        node=Node(key,value,1+old_freq,self.time)\\n        self.time+=1\\n        self.add(node)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Node:\\n    def __init__(self,key,val,freq=1,time=0):\\n        self.key=key\\n        self.val=val\\n        self.freq=freq\\n        self.time=time\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.heap=SortedList(key=lambda x:(-x.freq,-x.time))\\n        self.node_map={}\\n        self.cap=capacity\\n        self.time=0\\n    \\n    def add(self,node):\\n        self.heap.add(node)\\n        self.node_map[node.key]=node\\n        \\n    def remove(self,node):\\n        self.node_map.pop(node.key)\\n        self.heap.remove(node)\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.node_map:\\n            return -1\\n            \\n        else:\\n            node=self.node_map[key]\\n            self.remove(node)\\n            node.freq+=1\\n            node.time=self.time\\n            self.add(node)\\n            self.time+=1\\n            return node.val\\n\\n    def put(self, key: int, value: int) -> None:\\n        old_freq=0\\n        if self.cap==0:\\n            return\\n        if key not in self.node_map and len(self.node_map)>=self.cap:\\n            pop_node=self.heap[-1]\\n            self.remove(pop_node)\\n        if key in self.node_map:\\n            old_node=self.node_map[key]\\n            old_freq=old_node.freq\\n            self.remove(old_node)\\n        node=Node(key,value,1+old_freq,self.time)\\n        self.time+=1\\n        self.add(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836052,
                "title": "java-linkedhashset-solution",
                "content": "```\\nclass LFUCache {\\n    private Map<Integer, Integer> keyToVal;\\n    private Map<Integer, Integer> keyToFreq;\\n    private Map<Integer, LinkedHashSet<Integer>> freqToKeys;\\n    private int minFreq;\\n    private int cap;\\n    \\n    public LFUCache(int capacity) {\\n        this.cap = capacity;\\n        \\n        keyToVal = new HashMap<>();\\n        keyToFreq = new HashMap<>();\\n        freqToKeys = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!keyToVal.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        increaseFreq(key);\\n        \\n        return keyToVal.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(this.cap <= 0) {\\n            return;\\n        }\\n        \\n        if(keyToVal.containsKey(key)) {\\n            keyToVal.put(key, value);\\n            increaseFreq(key);\\n            return;\\n        }\\n               \\n        if(keyToVal.size() >= this.cap) {\\n            removeMinFreqKey();\\n        }\\n        \\n        keyToVal.put(key, value);\\n        keyToFreq.put(key, 1);\\n        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());\\n        freqToKeys.get(1).add(key);\\n        \\n        this.minFreq = 1;\\n    } \\n    \\n    private void increaseFreq(int key) {\\n        int freq = keyToFreq.get(key);\\n        keyToFreq.put(key, freq + 1);\\n        \\n        freqToKeys.get(freq).remove(key);\\n        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n        freqToKeys.get(freq + 1).add(key);\\n        \\n        if (freq == this.minFreq && freqToKeys.get(freq).isEmpty()) {\\n            this.minFreq++;\\n        }\\n    }\\n    \\n    private void removeMinFreqKey() {\\n        LinkedHashSet<Integer> set = freqToKeys.get(this.minFreq);\\n        \\n        int keyToDelete = set.iterator().next();\\n        \\n        set.remove(keyToDelete);\\n        \\n        keyToVal.remove(keyToDelete);\\n        keyToFreq.remove(keyToDelete);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n    private Map<Integer, Integer> keyToVal;\\n    private Map<Integer, Integer> keyToFreq;\\n    private Map<Integer, LinkedHashSet<Integer>> freqToKeys;\\n    private int minFreq;\\n    private int cap;\\n    \\n    public LFUCache(int capacity) {\\n        this.cap = capacity;\\n        \\n        keyToVal = new HashMap<>();\\n        keyToFreq = new HashMap<>();\\n        freqToKeys = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!keyToVal.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        increaseFreq(key);\\n        \\n        return keyToVal.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(this.cap <= 0) {\\n            return;\\n        }\\n        \\n        if(keyToVal.containsKey(key)) {\\n            keyToVal.put(key, value);\\n            increaseFreq(key);\\n            return;\\n        }\\n               \\n        if(keyToVal.size() >= this.cap) {\\n            removeMinFreqKey();\\n        }\\n        \\n        keyToVal.put(key, value);\\n        keyToFreq.put(key, 1);\\n        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());\\n        freqToKeys.get(1).add(key);\\n        \\n        this.minFreq = 1;\\n    } \\n    \\n    private void increaseFreq(int key) {\\n        int freq = keyToFreq.get(key);\\n        keyToFreq.put(key, freq + 1);\\n        \\n        freqToKeys.get(freq).remove(key);\\n        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n        freqToKeys.get(freq + 1).add(key);\\n        \\n        if (freq == this.minFreq && freqToKeys.get(freq).isEmpty()) {\\n            this.minFreq++;\\n        }\\n    }\\n    \\n    private void removeMinFreqKey() {\\n        LinkedHashSet<Integer> set = freqToKeys.get(this.minFreq);\\n        \\n        int keyToDelete = set.iterator().next();\\n        \\n        set.remove(keyToDelete);\\n        \\n        keyToVal.remove(keyToDelete);\\n        keyToFreq.remove(keyToDelete);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651415,
                "title": "java-simple-solution-using-3-hashmap-with-comments",
                "content": "```\\nclass LFUCache {\\n    //key - val map\\n    Map<Integer, Integer> kvMap = new HashMap<>();\\n\\t//key - freq map\\n    Map<Integer, Integer> kfMap = new HashMap<>();\\n\\t//freq - keyList map\\n    Map<Integer, List<Integer>> fkMap = new HashMap<>();\\n    int min = 1;\\n    int cap;\\n\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if(!kvMap.containsKey(key)) return -1;\\n        //update freq\\n        updateFreq(key);\\n        return kvMap.get(key);\\n    }\\n    public void updateFreq(int key){\\n        int count = kfMap.get(key);\\n        kfMap.put(key, count + 1);//increasing the count by 1\\n\\n        //remove the key from the key list if origin frequency \\n        fkMap.get(count).remove(Integer.valueOf(key));\\n\\t\\t//put the key into the end of new list\\n        fkMap.putIfAbsent(count + 1, new ArrayList<>());\\n        fkMap.get(count + 1).add(key);\\n            \\n//if prev count is min and there\\'s no more key in that list, means new min = count + 1\\n        //update min if needed\\n        if(min == count && fkMap.get(count).isEmpty()) \\n            min = count + 1;\\n    }\\n    public void evict(){\\n        //find the key to delete\\n        int k = fkMap.get(min).get(0); //if there\\'s multiple, the head of list is the LRU\\n            \\n        kvMap.remove(k);\\n        kfMap.remove(k);\\n        fkMap.get(min).remove(0);\\n    }\\n    \\n    public void put(int key, int val) {\\n        if(!kvMap.containsKey(key)){\\n            kvMap.put(key, val);\\n            kfMap.put(key, 1);\\n            fkMap.putIfAbsent(1, new ArrayList<>());\\n            fkMap.get(1).add(key);\\n\\t\\t\\t//do evict before updating min\\n            while(kvMap.size() > cap){\\n                evict();\\n            }\\n            min = 1;\\n        }else{\\n            kvMap.put(key, val);\\n            updateFreq(key);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    //key - val map\\n    Map<Integer, Integer> kvMap = new HashMap<>();\\n\\t//key - freq map\\n    Map<Integer, Integer> kfMap = new HashMap<>();\\n\\t//freq - keyList map\\n    Map<Integer, List<Integer>> fkMap = new HashMap<>();\\n    int min = 1;\\n    int cap;\\n\\n    public LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if(!kvMap.containsKey(key)) return -1;\\n        //update freq\\n        updateFreq(key);\\n        return kvMap.get(key);\\n    }\\n    public void updateFreq(int key){\\n        int count = kfMap.get(key);\\n        kfMap.put(key, count + 1);//increasing the count by 1\\n\\n        //remove the key from the key list if origin frequency \\n        fkMap.get(count).remove(Integer.valueOf(key));\\n\\t\\t//put the key into the end of new list\\n        fkMap.putIfAbsent(count + 1, new ArrayList<>());\\n        fkMap.get(count + 1).add(key);\\n            \\n//if prev count is min and there\\'s no more key in that list, means new min = count + 1\\n        //update min if needed\\n        if(min == count && fkMap.get(count).isEmpty()) \\n            min = count + 1;\\n    }\\n    public void evict(){\\n        //find the key to delete\\n        int k = fkMap.get(min).get(0); //if there\\'s multiple, the head of list is the LRU\\n            \\n        kvMap.remove(k);\\n        kfMap.remove(k);\\n        fkMap.get(min).remove(0);\\n    }\\n    \\n    public void put(int key, int val) {\\n        if(!kvMap.containsKey(key)){\\n            kvMap.put(key, val);\\n            kfMap.put(key, 1);\\n            fkMap.putIfAbsent(1, new ArrayList<>());\\n            fkMap.get(1).add(key);\\n\\t\\t\\t//do evict before updating min\\n            while(kvMap.size() > cap){\\n                evict();\\n            }\\n            min = 1;\\n        }else{\\n            kvMap.put(key, val);\\n            updateFreq(key);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449558,
                "title": "js-using-two-hashmaps-and-dll-672ms-100",
                "content": "```\\nclass DLLNode {\\n    constructor(key, val, freq) {\\n        this.key = key;\\n        this.val = val;\\n        this.freq = freq;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n\\nclass DLL {\\n    constructor() {\\n        this.head = null;\\n        this.tail = null;\\n    }\\n    addNode(node) {\\n        if(!this.head) {\\n            this.head = node;\\n            this.tail = node;\\n        } else {\\n            this.tail.next = node;\\n            node.prev = this.tail;\\n            this.tail = this.tail.next;\\n        }\\n    }\\n    removeNode(node) {\\n        if(node === this.head && this.head.next) {\\n            this.head = this.head.next;\\n            this.head.prev = null;\\n        } else if(node === this.head) {\\n            this.head = null;\\n            this.tail = null;\\n        } else if(node === this.tail) {\\n            this.tail = this.tail.prev;\\n            this.tail.next = null;\\n        } else {\\n            if(node.prev) {\\n                node.prev.next = node.next;    \\n            }\\n            if(node.next) {\\n                node.next.prev = node.prev;    \\n            }\\n        }\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    isEmpty() {\\n        return this.head === null;\\n    }\\n}\\n\\nclass LFUCache {\\n    constructor(capacity) { // O(1)\\n        this.size = capacity;    // total size\\n        this.capacity = capacity;    // current size\\n        this.keyMap = new Map();    // key to node mapping\\n        this.freqMap = new Map();  // freq to DLL of nodes mapping\\n        this.minFreq = 1;         // keeps track of the min freq of a key in the cache\\n    }\\n    get = function(key) {    // O(1)\\n\\t\\t// if size is 0 or key is not present in the cache, return -1\\n        if(!this.size || !this.keyMap.has(key)) {\\n            return -1;\\n        }\\n        const keyNode = this.keyMap.get(key);\\n        const newFreq = keyNode.freq + 1;\\n        \\n        // remove node from curr-freq mapped DLL\\n        this.freqMap.get(keyNode.freq).removeNode(keyNode);\\n        if(this.freqMap.get(keyNode.freq).isEmpty()) {\\n            this.freqMap.delete(keyNode.freq);\\n            if(this.minFreq === keyNode.freq) {    // update the min-freq if there are no keys with that freq\\n                this.minFreq = newFreq;\\n            }\\n        }\\n        keyNode.freq = newFreq;    // update the freq of the key\\n\\n        // add node to the new freq mapped DLL\\n        const vals = this.freqMap.has(newFreq) ? this.freqMap.get(newFreq) : new DLL();\\n        vals.addNode(keyNode);\\n        this.freqMap.set(newFreq, vals);\\n        return keyNode.val;\\n    }\\n    put = function(key, value) {\\n        if(!this.size) {     // if the cache size is 0, return\\n            return;\\n        }\\n        if(this.keyMap.has(key)) {    // cache already has key, need to update the value\\n            this.keyMap.get(key).val = value;\\n            this.get(key);    // this will handle updating the freq and the maps\\n            return;\\n        } else if(this.capacity === 0) {    // if the cache is full, need to evict the least frequently used key\\n            this.evictLFU();\\n        }\\n        const node = new DLLNode(key, value, 1);    // create a new node and add to the maps\\n        if(!this.freqMap.has(1)) {\\n            this.freqMap.set(1, new DLL());\\n        }\\n        this.keyMap.set(key, node);\\n        this.freqMap.get(1).addNode(node);\\n        this.minFreq = 1;\\n        --this.capacity;\\n    }\\n    evictLFU = function() {\\n\\t\\t// remove the nodes from the head and add to the tail - DLL\\n\\t\\t// the first node with the min-freq will be least recently used\\n        const list = this.freqMap.get(this.minFreq);\\n        const node = list.head;\\n\\n\\t\\t// updating the maps\\n        this.keyMap.delete(node.key);\\n        list.removeNode(node);        \\n        if(list.isEmpty()) {\\n            this.freqMap.delete(this.minFreq);\\n        }\\n        ++this.capacity;    // removed from the cache, so capacity got freed up\\n    }\\n}\\n```\\nTime Complexity = O(1) for each operation\\nSpace Complexity = O(n) [HashMaps, DLL]",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass DLLNode {\\n    constructor(key, val, freq) {\\n        this.key = key;\\n        this.val = val;\\n        this.freq = freq;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n\\nclass DLL {\\n    constructor() {\\n        this.head = null;\\n        this.tail = null;\\n    }\\n    addNode(node) {\\n        if(!this.head) {\\n            this.head = node;\\n            this.tail = node;\\n        } else {\\n            this.tail.next = node;\\n            node.prev = this.tail;\\n            this.tail = this.tail.next;\\n        }\\n    }\\n    removeNode(node) {\\n        if(node === this.head && this.head.next) {\\n            this.head = this.head.next;\\n            this.head.prev = null;\\n        } else if(node === this.head) {\\n            this.head = null;\\n            this.tail = null;\\n        } else if(node === this.tail) {\\n            this.tail = this.tail.prev;\\n            this.tail.next = null;\\n        } else {\\n            if(node.prev) {\\n                node.prev.next = node.next;    \\n            }\\n            if(node.next) {\\n                node.next.prev = node.prev;    \\n            }\\n        }\\n        node.next = null;\\n        node.prev = null;\\n    }\\n    isEmpty() {\\n        return this.head === null;\\n    }\\n}\\n\\nclass LFUCache {\\n    constructor(capacity) { // O(1)\\n        this.size = capacity;    // total size\\n        this.capacity = capacity;    // current size\\n        this.keyMap = new Map();    // key to node mapping\\n        this.freqMap = new Map();  // freq to DLL of nodes mapping\\n        this.minFreq = 1;         // keeps track of the min freq of a key in the cache\\n    }\\n    get = function(key) {    // O(1)\\n\\t\\t// if size is 0 or key is not present in the cache, return -1\\n        if(!this.size || !this.keyMap.has(key)) {\\n            return -1;\\n        }\\n        const keyNode = this.keyMap.get(key);\\n        const newFreq = keyNode.freq + 1;\\n        \\n        // remove node from curr-freq mapped DLL\\n        this.freqMap.get(keyNode.freq).removeNode(keyNode);\\n        if(this.freqMap.get(keyNode.freq).isEmpty()) {\\n            this.freqMap.delete(keyNode.freq);\\n            if(this.minFreq === keyNode.freq) {    // update the min-freq if there are no keys with that freq\\n                this.minFreq = newFreq;\\n            }\\n        }\\n        keyNode.freq = newFreq;    // update the freq of the key\\n\\n        // add node to the new freq mapped DLL\\n        const vals = this.freqMap.has(newFreq) ? this.freqMap.get(newFreq) : new DLL();\\n        vals.addNode(keyNode);\\n        this.freqMap.set(newFreq, vals);\\n        return keyNode.val;\\n    }\\n    put = function(key, value) {\\n        if(!this.size) {     // if the cache size is 0, return\\n            return;\\n        }\\n        if(this.keyMap.has(key)) {    // cache already has key, need to update the value\\n            this.keyMap.get(key).val = value;\\n            this.get(key);    // this will handle updating the freq and the maps\\n            return;\\n        } else if(this.capacity === 0) {    // if the cache is full, need to evict the least frequently used key\\n            this.evictLFU();\\n        }\\n        const node = new DLLNode(key, value, 1);    // create a new node and add to the maps\\n        if(!this.freqMap.has(1)) {\\n            this.freqMap.set(1, new DLL());\\n        }\\n        this.keyMap.set(key, node);\\n        this.freqMap.get(1).addNode(node);\\n        this.minFreq = 1;\\n        --this.capacity;\\n    }\\n    evictLFU = function() {\\n\\t\\t// remove the nodes from the head and add to the tail - DLL\\n\\t\\t// the first node with the min-freq will be least recently used\\n        const list = this.freqMap.get(this.minFreq);\\n        const node = list.head;\\n\\n\\t\\t// updating the maps\\n        this.keyMap.delete(node.key);\\n        list.removeNode(node);        \\n        if(list.isEmpty()) {\\n            this.freqMap.delete(this.minFreq);\\n        }\\n        ++this.capacity;    // removed from the cache, so capacity got freed up\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443507,
                "title": "c-3-hash-map-solution-o-1-tc-o-n-sc-very-easy-100-line-solution",
                "content": "Solution with 3 hash maps;\\nO(1) time complexity\\nO(n) space complexity\\n\\n```\\nclass LFUCache {\\npublic:\\n    unordered_map<int,pair<int,int>> ktp;\\n    unordered_map<int,list<int>> ftl;\\n    unordered_map<int,list<int>::iterator> ktli;\\n    int c;\\n    int min_freq;\\n    // deque\\n    \\n    LFUCache(int capacity) {\\n        c = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(c == 0) return -1;\\n        \\n        if(ktp.find(key) == ktp.end()) return -1;\\n        \\n            // 1. changing values\\n            ktp[key].second++;\\n            \\n            // 2. deleting old frequency frequency\\n            int cf = ktp[key].second;\\n            ftl[cf-1].erase(ktli[key]);\\n            if(ftl[cf-1].empty()) \\n                ftl.erase(cf-1);\\n            ktli.erase(key);\\n            \\n            // 3. updating if min_freq\\n            if( min_freq == cf - 1 && ftl.find(cf-1) == ftl.end() ){\\n                min_freq++;\\n            }\\n            \\n            \\n            // 4. inserting new frequency\\n            ftl[cf].push_back(key);\\n            ktli[key] = (--ftl[cf].end());\\n        \\n        return ktp[key].first;\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        if(c== 0) return;\\n        if(ktp.find(key) != ktp.end()){\\n            // already present\\n            \\n            // 1. changing values\\n            ktp[key].first = value;\\n            ktp[key].second++;\\n            \\n            // 2. deleting old frequency frequency\\n            int cf = ktp[key].second;\\n            ftl[cf-1].erase(ktli[key]);\\n            if(ftl[cf-1].empty()) \\n                ftl.erase(cf-1);\\n            ktli.erase(key);\\n            \\n            // 3. updating if min_freq\\n            if( min_freq == cf - 1 && ftl.find(cf-1) == ftl.end() ){\\n                min_freq++;\\n            }\\n            \\n            \\n            // 4. inserting new frequency\\n            ftl[cf].push_back(key);\\n           ktli[key] = (--ftl[cf].end());\\n            \\n            \\n            \\n        }\\n        else{\\n            // not present\\n            \\n            \\n            // if full capacity\\n            if(ktp.size() == c){\\n                int delete_key = ftl[min_freq].front();\\n                ftl[min_freq].pop_front();\\n                \\n                if(ftl[min_freq].empty()) \\n                    ftl.erase(min_freq);\\n                \\n                ktp.erase(delete_key);\\n                ktli.erase(delete_key);\\n            }\\n            int cf = 1;\\n            \\n            ktp[key] = {value , 1};\\n            ftl[cf].push_back(key);\\n            ktli[key] = (--ftl[cf].end());\\n            \\n            min_freq = 1;\\n        }\\n        \\n        \\n    }\\n};\\n\\n\\n```\\n\\n**Here before ranjan**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    unordered_map<int,pair<int,int>> ktp;\\n    unordered_map<int,list<int>> ftl;\\n    unordered_map<int,list<int>::iterator> ktli;\\n    int c;\\n    int min_freq;\\n    // deque\\n    \\n    LFUCache(int capacity) {\\n        c = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(c == 0) return -1;\\n        \\n        if(ktp.find(key) == ktp.end()) return -1;\\n        \\n            // 1. changing values\\n            ktp[key].second++;\\n            \\n            // 2. deleting old frequency frequency\\n            int cf = ktp[key].second;\\n            ftl[cf-1].erase(ktli[key]);\\n            if(ftl[cf-1].empty()) \\n                ftl.erase(cf-1);\\n            ktli.erase(key);\\n            \\n            // 3. updating if min_freq\\n            if( min_freq == cf - 1 && ftl.find(cf-1) == ftl.end() ){\\n                min_freq++;\\n            }\\n            \\n            \\n            // 4. inserting new frequency\\n            ftl[cf].push_back(key);\\n            ktli[key] = (--ftl[cf].end());\\n        \\n        return ktp[key].first;\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        if(c== 0) return;\\n        if(ktp.find(key) != ktp.end()){\\n            // already present\\n            \\n            // 1. changing values\\n            ktp[key].first = value;\\n            ktp[key].second++;\\n            \\n            // 2. deleting old frequency frequency\\n            int cf = ktp[key].second;\\n            ftl[cf-1].erase(ktli[key]);\\n            if(ftl[cf-1].empty()) \\n                ftl.erase(cf-1);\\n            ktli.erase(key);\\n            \\n            // 3. updating if min_freq\\n            if( min_freq == cf - 1 && ftl.find(cf-1) == ftl.end() ){\\n                min_freq++;\\n            }\\n            \\n            \\n            // 4. inserting new frequency\\n            ftl[cf].push_back(key);\\n           ktli[key] = (--ftl[cf].end());\\n            \\n            \\n            \\n        }\\n        else{\\n            // not present\\n            \\n            \\n            // if full capacity\\n            if(ktp.size() == c){\\n                int delete_key = ftl[min_freq].front();\\n                ftl[min_freq].pop_front();\\n                \\n                if(ftl[min_freq].empty()) \\n                    ftl.erase(min_freq);\\n                \\n                ktp.erase(delete_key);\\n                ktli.erase(delete_key);\\n            }\\n            int cf = 1;\\n            \\n            ktp[key] = {value , 1};\\n            ftl[cf].push_back(key);\\n            ktli[key] = (--ftl[cf].end());\\n            \\n            min_freq = 1;\\n        }\\n        \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234090,
                "title": "easy-java-o-1-solution-with-detailed-explanation",
                "content": "We maintain 3 hashmaps:\\n1. keyValMap - This will store the exact key-value pair.\\n2. frequencyMapStartNode - This will store the head of the linked list (Deque) for each frequency.\\n3. frequencyMapEndNode  - This will store the last node of the linked list (Deque) for each frequency.\\n\\nOur core logic is that, we maintain a Deque for each frequency. Here frequency means, the number of time a key is accessed (put + get). So if 2 elements have been accessed 4 times, then we maintain an entry in frequencyMapStartNode, which is something like {2: DummyStartNode-> Element1 - > Element 2- > DummyLastNode} by keeping the head of the list in our map. Similarly, we keep the last node of this list in our frequencyMapEndNode {2: DummyEndNode}. We store it for fast operations as shown in the code.\\n\\n1. Get() - > We check whether we have a key- value pair in the keyValMap or not. If we have it, then we fetch the corresponding node from it and increment its counter. Now, since the frequency of this key has increased, we need to update rest of the 2 map explained above. We check whether or not we have Deque for the new counter. If not, we create a new Deque using our helper function (getNewListHead()). Once we have the list, whether newly created or already existing, we add this node to the start of this Deque. We do this so that whenever we want to delete any node from the list, we delete the last node, as it will the one which was used least recently.\\n\\n2. Put() -> In this case we check, whether or not we are adding a new key or updating an old one. In case of addition, we check for it\\'s current size and if it has already reached it\\'s capacity, we remove the least recently used node/key. We do this by traversing our frequency map and finding a Deque having minimum frequency. We delete the last node from that list. Now we are can simple add the new Node.\\n\\n\\n```\\n\\nclass LFUCache {\\n\\n    class Node{\\n        int val;\\n        int counter;\\n        int key;\\n        \\n        Node prev;\\n        Node next;\\n    }\\n    \\n    int capacity;\\n    int currCt = 0;\\n    Map<Integer, Node> keyValMap = new HashMap<>();\\n    Map<Integer, Node> frequencyMapStartNode = new HashMap<>();\\n    Map<Integer, Node> frequencyMapEndNode = new HashMap<>();\\n    \\n    Node dummy = new Node();\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    private void removeNode(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private void addNode(Node head, Node node){\\n        head.next.prev = node;\\n        node.prev = head;\\n        node.next = head.next;\\n        head.next = node;\\n    }\\n    \\n    private Node createNewList(){\\n        Node head = new Node();\\n        Node end = new Node();\\n        \\n        head.next = end;\\n        end.prev = head;\\n        \\n        head.prev = end.next = null;\\n        return head;\\n    }\\n\\n    private Node getNewListHead(int val){\\n        Node newFrequenctList = frequencyMapStartNode.get(val);\\n        if(newFrequenctList == null){\\n            newFrequenctList = createNewList();\\n            frequencyMapStartNode.put(val, newFrequenctList);\\n            frequencyMapEndNode.put(val, newFrequenctList.next);\\n        }\\n        return newFrequenctList;\\n    }\\n    \\n    public int get(int key) {\\n        Node temp = keyValMap.getOrDefault(key, dummy);\\n        if(temp != dummy){\\n            temp.counter++;\\n            removeNode(temp);\\n            Node newFrequenctList = getNewListHead(temp.counter);\\n            addNode(newFrequenctList, temp);\\n            return temp.val;\\n        }else{\\n            return -1;\\n        }\\n    }\\n    \\n\\n    public void put(int key, int value) {\\n        if(capacity == 0){\\n            return;\\n        }\\n        Node temp = keyValMap.getOrDefault(key, dummy);\\n        boolean updated = false;\\n        if(currCt == capacity && temp == dummy){\\n            for(Integer freq: frequencyMapStartNode.keySet()){\\n                Node startNode = frequencyMapStartNode.get(freq);\\n                Node endNode = frequencyMapEndNode.get(freq);\\n                if(startNode.next != endNode){\\n                    keyValMap.remove(endNode.prev.key);\\n                    removeNode(endNode.prev);\\n                    updated = true;\\n                    break;\\n                }\\n            }\\n  \\n        }else{\\n            currCt++;\\n        }\\n        \\n        if(temp != dummy){\\n            currCt--;\\n            temp.counter++;\\n            temp.val = value;\\n            temp.key = key;\\n            removeNode(temp);\\n            Node newFrequenctList = getNewListHead(temp.counter);\\n            addNode(newFrequenctList, temp);\\n            keyValMap.put(key, temp);\\n            return;\\n        }\\n\\n        temp = new Node();\\n        temp.val = value;\\n        temp.key = key;\\n        temp.counter = 1;\\n        Node newFrequenctList = getNewListHead(temp.counter);\\n        addNode(newFrequenctList, temp);\\n        keyValMap.put(key, temp);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */",
                "solutionTags": [],
                "code": "We maintain 3 hashmaps:\\n1. keyValMap - This will store the exact key-value pair.\\n2. frequencyMapStartNode - This will store the head of the linked list (Deque) for each frequency.\\n3. frequencyMapEndNode  - This will store the last node of the linked list (Deque) for each frequency.\\n\\nOur core logic is that, we maintain a Deque for each frequency. Here frequency means, the number of time a key is accessed (put + get). So if 2 elements have been accessed 4 times, then we maintain an entry in frequencyMapStartNode, which is something like {2: DummyStartNode-> Element1 - > Element 2- > DummyLastNode} by keeping the head of the list in our map. Similarly, we keep the last node of this list in our frequencyMapEndNode {2: DummyEndNode}. We store it for fast operations as shown in the code.\\n\\n1. Get() - > We check whether we have a key- value pair in the keyValMap or not. If we have it, then we fetch the corresponding node from it and increment its counter. Now, since the frequency of this key has increased, we need to update rest of the 2 map explained above. We check whether or not we have Deque for the new counter. If not, we create a new Deque using our helper function (getNewListHead()). Once we have the list, whether newly created or already existing, we add this node to the start of this Deque. We do this so that whenever we want to delete any node from the list, we delete the last node, as it will the one which was used least recently.\\n\\n2. Put() -> In this case we check, whether or not we are adding a new key or updating an old one. In case of addition, we check for it\\'s current size and if it has already reached it\\'s capacity, we remove the least recently used node/key. We do this by traversing our frequency map and finding a Deque having minimum frequency. We delete the last node from that list. Now we are can simple add the new Node.\\n\\n\\n```\\n\\nclass LFUCache {\\n\\n    class Node{\\n        int val;\\n        int counter;\\n        int key;\\n        \\n        Node prev;\\n        Node next;\\n    }\\n    \\n    int capacity;\\n    int currCt = 0;\\n    Map<Integer, Node> keyValMap = new HashMap<>();\\n    Map<Integer, Node> frequencyMapStartNode = new HashMap<>();\\n    Map<Integer, Node> frequencyMapEndNode = new HashMap<>();\\n    \\n    Node dummy = new Node();\\n    \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    private void removeNode(Node node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private void addNode(Node head, Node node){\\n        head.next.prev = node;\\n        node.prev = head;\\n        node.next = head.next;\\n        head.next = node;\\n    }\\n    \\n    private Node createNewList(){\\n        Node head = new Node();\\n        Node end = new Node();\\n        \\n        head.next = end;\\n        end.prev = head;\\n        \\n        head.prev = end.next = null;\\n        return head;\\n    }\\n\\n    private Node getNewListHead(int val){\\n        Node newFrequenctList = frequencyMapStartNode.get(val);\\n        if(newFrequenctList == null){\\n            newFrequenctList = createNewList();\\n            frequencyMapStartNode.put(val, newFrequenctList);\\n            frequencyMapEndNode.put(val, newFrequenctList.next);\\n        }\\n        return newFrequenctList;\\n    }\\n    \\n    public int get(int key) {\\n        Node temp = keyValMap.getOrDefault(key, dummy);\\n        if(temp != dummy){\\n            temp.counter++;\\n            removeNode(temp);\\n            Node newFrequenctList = getNewListHead(temp.counter);\\n            addNode(newFrequenctList, temp);\\n            return temp.val;\\n        }else{\\n            return -1;\\n        }\\n    }\\n    \\n\\n    public void put(int key, int value) {\\n        if(capacity == 0){\\n            return;\\n        }\\n        Node temp = keyValMap.getOrDefault(key, dummy);\\n        boolean updated = false;\\n        if(currCt == capacity && temp == dummy){\\n            for(Integer freq: frequencyMapStartNode.keySet()){\\n                Node startNode = frequencyMapStartNode.get(freq);\\n                Node endNode = frequencyMapEndNode.get(freq);\\n                if(startNode.next != endNode){\\n                    keyValMap.remove(endNode.prev.key);\\n                    removeNode(endNode.prev);\\n                    updated = true;\\n                    break;\\n                }\\n            }\\n  \\n        }else{\\n            currCt++;\\n        }\\n        \\n        if(temp != dummy){\\n            currCt--;\\n            temp.counter++;\\n            temp.val = value;\\n            temp.key = key;\\n            removeNode(temp);\\n            Node newFrequenctList = getNewListHead(temp.counter);\\n            addNode(newFrequenctList, temp);\\n            keyValMap.put(key, temp);\\n            return;\\n        }\\n\\n        temp = new Node();\\n        temp.val = value;\\n        temp.key = key;\\n        temp.counter = 1;\\n        Node newFrequenctList = getNewListHead(temp.counter);\\n        addNode(newFrequenctList, temp);\\n        keyValMap.put(key, temp);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1060210,
                "title": "java-solution-with-o-1",
                "content": "```\\nclass node{\\n    int key;\\n    node pre,next;\\n    node(int key,node l,node r){\\n        this.key = key;\\n        pre = l;\\n        next = r;\\n    }\\n}\\nclass linkedList{\\n    node head,tail;\\n    linkedList(){\\n        head = null;\\n        tail= null;\\n    }\\n    linkedList(int key){\\n        head = new node(key,null,null);\\n        tail = head;\\n    }\\n    linkedList(node a){\\n        head = a;\\n        tail = head;\\n    }\\n    node remove(node x){\\n        if(x.pre!=null)\\n            x.pre.next = x.next;\\n        else    head = x.next;\\n        if(x.next!=null)\\n            x.next.pre = x.pre;\\n        else\\n            tail = tail.pre;\\n        x.pre = null;\\n        x.next = null;\\n        if(head==x){\\n            head = null;\\n            tail = null;\\n        }\\n        return x;\\n    }\\n    node addToRecent(node x){\\n        if(head==null){\\n            head = x;\\n            tail = head;\\n            return x;\\n        }\\n        tail.next = x;\\n        x.pre = tail;\\n        tail = tail.next;\\n        return x;\\n    }\\n    node removeFirst(){\\n        if(head==null){\\n            System.out.println(\"head is null...\");\\n        }\\n        node x = head;\\n        head = head.next;\\n        x.next = null;\\n        if(head==null)  return x;\\n        head.pre = null;\\n        return x;\\n    }\\n}\\nclass LFUCache {\\n    public HashMap<Integer,Integer> cache;\\n    public HashMap<Integer,Integer> count;\\n    public HashMap<Integer,HashMap<Integer,node>> map;\\n    public HashMap<Integer,linkedList> map_list;\\n    int minCount;\\n    int maxCap;\\n    public LFUCache(int capacity) {\\n        this.maxCap = capacity;\\n        cache = new HashMap<>();\\n        count = new HashMap<>();\\n        map = new HashMap<>();\\n        map_list = new HashMap<>();\\n        minCount=Integer.MAX_VALUE;\\n    }\\n    public void increament(int key){\\n        int temp = count.getOrDefault(key,0);\\n        count.put(key,temp+1);\\n        \\n        HashMap<Integer,node> s = map.get(temp);\\n        linkedList sl = map_list.get(temp);\\n        node tempNode =null;\\n        if(s!=null){    \\n            tempNode = s.remove(key);\\n            sl.remove(tempNode);\\n            if(s.isEmpty()){\\n                if(minCount==temp)\\n                    minCount = temp+1;\\n                map.remove(temp);\\n                map_list.remove(temp);\\n            }\\n        }\\n        s = map.getOrDefault(temp+1,new HashMap<>());\\n        if(tempNode==null)\\n            tempNode = new node(key,null,null);    \\n        s.put(key,tempNode);\\n        map.put(temp+1,s);\\n        \\n        \\n        sl = map_list.getOrDefault(temp+1,new linkedList());\\n        sl.addToRecent(tempNode);\\n        map_list.put(temp+1,sl);\\n        \\n        minCount = Math.min(minCount,temp+1);\\n    }\\n    public void deleteLF(){\\n        HashMap<Integer,node> s = map.get(minCount);\\n        if(s==null) System.out.println(\"Never happen\");\\n        linkedList sl = map_list.get(minCount);\\n        \\n        node tempNode = sl.removeFirst();\\n        s.remove(tempNode.key);\\n        if(s.isEmpty()){\\n            map.remove(minCount);\\n            map_list.remove(minCount);\\n        }\\n        \\n        count.remove(tempNode.key);\\n        cache.remove(tempNode.key);\\n        \\n    }\\n    public int get(int key) {\\n        if(cache.containsKey(key)){\\n            increament(key);\\n            return cache.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(maxCap==0)   return;\\n        if(!cache.containsKey(key) && cache.size()==maxCap){\\n            deleteLF();\\n        }\\n        cache.put(key,value);\\n        increament(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass node{\\n    int key;\\n    node pre,next;\\n    node(int key,node l,node r){\\n        this.key = key;\\n        pre = l;\\n        next = r;\\n    }\\n}\\nclass linkedList{\\n    node head,tail;\\n    linkedList(){\\n        head = null;\\n        tail= null;\\n    }\\n    linkedList(int key){\\n        head = new node(key,null,null);\\n        tail = head;\\n    }\\n    linkedList(node a){\\n        head = a;\\n        tail = head;\\n    }\\n    node remove(node x){\\n        if(x.pre!=null)\\n            x.pre.next = x.next;\\n        else    head = x.next;\\n        if(x.next!=null)\\n            x.next.pre = x.pre;\\n        else\\n            tail = tail.pre;\\n        x.pre = null;\\n        x.next = null;\\n        if(head==x){\\n            head = null;\\n            tail = null;\\n        }\\n        return x;\\n    }\\n    node addToRecent(node x){\\n        if(head==null){\\n            head = x;\\n            tail = head;\\n            return x;\\n        }\\n        tail.next = x;\\n        x.pre = tail;\\n        tail = tail.next;\\n        return x;\\n    }\\n    node removeFirst(){\\n        if(head==null){\\n            System.out.println(\"head is null...\");\\n        }\\n        node x = head;\\n        head = head.next;\\n        x.next = null;\\n        if(head==null)  return x;\\n        head.pre = null;\\n        return x;\\n    }\\n}\\nclass LFUCache {\\n    public HashMap<Integer,Integer> cache;\\n    public HashMap<Integer,Integer> count;\\n    public HashMap<Integer,HashMap<Integer,node>> map;\\n    public HashMap<Integer,linkedList> map_list;\\n    int minCount;\\n    int maxCap;\\n    public LFUCache(int capacity) {\\n        this.maxCap = capacity;\\n        cache = new HashMap<>();\\n        count = new HashMap<>();\\n        map = new HashMap<>();\\n        map_list = new HashMap<>();\\n        minCount=Integer.MAX_VALUE;\\n    }\\n    public void increament(int key){\\n        int temp = count.getOrDefault(key,0);\\n        count.put(key,temp+1);\\n        \\n        HashMap<Integer,node> s = map.get(temp);\\n        linkedList sl = map_list.get(temp);\\n        node tempNode =null;\\n        if(s!=null){    \\n            tempNode = s.remove(key);\\n            sl.remove(tempNode);\\n            if(s.isEmpty()){\\n                if(minCount==temp)\\n                    minCount = temp+1;\\n                map.remove(temp);\\n                map_list.remove(temp);\\n            }\\n        }\\n        s = map.getOrDefault(temp+1,new HashMap<>());\\n        if(tempNode==null)\\n            tempNode = new node(key,null,null);    \\n        s.put(key,tempNode);\\n        map.put(temp+1,s);\\n        \\n        \\n        sl = map_list.getOrDefault(temp+1,new linkedList());\\n        sl.addToRecent(tempNode);\\n        map_list.put(temp+1,sl);\\n        \\n        minCount = Math.min(minCount,temp+1);\\n    }\\n    public void deleteLF(){\\n        HashMap<Integer,node> s = map.get(minCount);\\n        if(s==null) System.out.println(\"Never happen\");\\n        linkedList sl = map_list.get(minCount);\\n        \\n        node tempNode = sl.removeFirst();\\n        s.remove(tempNode.key);\\n        if(s.isEmpty()){\\n            map.remove(minCount);\\n            map_list.remove(minCount);\\n        }\\n        \\n        count.remove(tempNode.key);\\n        cache.remove(tempNode.key);\\n        \\n    }\\n    public int get(int key) {\\n        if(cache.containsKey(key)){\\n            increament(key);\\n            return cache.get(key);\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(maxCap==0)   return;\\n        if(!cache.containsKey(key) && cache.size()==maxCap){\\n            deleteLF();\\n        }\\n        cache.put(key,value);\\n        increament(key);\\n        \\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048382,
                "title": "java-using-linkedhashmap-hashmap-and-set",
                "content": "Step 1.  you have to understand and be able to implement LRU cache (https://leetcode.com/problems/lru-cache/) using LinkedHashMap. \\n\\nStep 2. You need another Map to maintain frequency count. make sure to remove from the map when ejecting an element from the LinkedHashMap\\n\\nStep 3. have a HashSet to capture equal frequency entries.\\n\\nThe rest is easy \\n\\n\\tclass LFUCache {\\n\\t\\tint capacity;\\n\\t\\tMap<Integer, Integer> countMap;\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\tSet<Integer> set;\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tcountMap = new HashMap<Integer, Integer>();\\n\\t\\t\\tmap = new LinkedHashMap<Integer, Integer>(capacity);\\n\\t\\t}\\n\\n\\t\\tprivate int getKeyToRemove(){\\n\\t\\t\\tint lFUKey = Integer.MIN_VALUE;\\n\\t\\t\\tint minValue = Integer.MAX_VALUE;\\n\\t\\t\\tset = new HashSet<Integer>();\\n\\n\\t\\t\\tfor(int key : countMap.keySet()){\\n\\t\\t\\t\\tif(countMap.get(key) < minValue){\\n\\t\\t\\t\\t\\tminValue = countMap.get(key);\\n\\t\\t\\t\\t\\tlFUKey = key;\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int key : countMap.keySet()){ //check for equal Frequency.\\n\\t\\t\\t\\tif(countMap.get(key) == countMap.get(lFUKey)){\\n\\t\\t\\t\\t\\tset.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn lFUKey;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tint value = -1;\\n\\t\\t\\tif(map.containsKey(key)){\\n\\t\\t\\t\\tvalue = map.get(key);\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tcountMap.put(key, countMap.get(key) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;    \\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif(map.size() == capacity && !map.containsKey(key)){\\n\\t\\t\\t\\tint keyToRemove = getKeyToRemove();\\n\\t\\t\\t\\tif(set.size() == 1){\\n\\t\\t\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\t\\t\\tcountMap.remove(keyToRemove);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int mapKey : map.keySet()){\\n\\t\\t\\t\\t\\t\\tif(set.contains(mapKey)){\\n\\t\\t\\t\\t\\t\\t\\tmap.remove(mapKey);\\n\\t\\t\\t\\t\\t\\t\\tcountMap.remove(mapKey);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(map.containsKey(key)){\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(map.size() < capacity){\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tcountMap.put(key, countMap.getOrDefault(key, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "Step 1.  you have to understand and be able to implement LRU cache (https://leetcode.com/problems/lru-cache/) using LinkedHashMap. \\n\\nStep 2. You need another Map to maintain frequency count. make sure to remove from the map when ejecting an element from the LinkedHashMap\\n\\nStep 3. have a HashSet to capture equal frequency entries.\\n\\nThe rest is easy \\n\\n\\tclass LFUCache {\\n\\t\\tint capacity;\\n\\t\\tMap<Integer, Integer> countMap;\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\tSet<Integer> set;\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tcountMap = new HashMap<Integer, Integer>();\\n\\t\\t\\tmap = new LinkedHashMap<Integer, Integer>(capacity);\\n\\t\\t}\\n\\n\\t\\tprivate int getKeyToRemove(){\\n\\t\\t\\tint lFUKey = Integer.MIN_VALUE;\\n\\t\\t\\tint minValue = Integer.MAX_VALUE;\\n\\t\\t\\tset = new HashSet<Integer>();\\n\\n\\t\\t\\tfor(int key : countMap.keySet()){\\n\\t\\t\\t\\tif(countMap.get(key) < minValue){\\n\\t\\t\\t\\t\\tminValue = countMap.get(key);\\n\\t\\t\\t\\t\\tlFUKey = key;\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int key : countMap.keySet()){ //check for equal Frequency.\\n\\t\\t\\t\\tif(countMap.get(key) == countMap.get(lFUKey)){\\n\\t\\t\\t\\t\\tset.add(key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn lFUKey;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tint value = -1;\\n\\t\\t\\tif(map.containsKey(key)){\\n\\t\\t\\t\\tvalue = map.get(key);\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tcountMap.put(key, countMap.get(key) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;    \\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif(map.size() == capacity && !map.containsKey(key)){\\n\\t\\t\\t\\tint keyToRemove = getKeyToRemove();\\n\\t\\t\\t\\tif(set.size() == 1){\\n\\t\\t\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\t\\t\\tcountMap.remove(keyToRemove);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int mapKey : map.keySet()){\\n\\t\\t\\t\\t\\t\\tif(set.contains(mapKey)){\\n\\t\\t\\t\\t\\t\\t\\tmap.remove(mapKey);\\n\\t\\t\\t\\t\\t\\t\\tcountMap.remove(mapKey);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if(map.containsKey(key)){\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(map.size() < capacity){\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tcountMap.put(key, countMap.getOrDefault(key, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 870362,
                "title": "python-dll",
                "content": "~~~python\\nclass Node:\\n    def __init__(self, key=None, val=None, next=None, prev=None):\\n        self.val = val\\n        self.key = key\\n        self.freq = 1\\n        self.next = next\\n        self.prev = prev\\n    \\nclass DLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self._size = 0\\n        \\n    @property\\n    def size(self):\\n        return self._size\\n\\n    def insert(self, node):\\n        node.next = self.tail\\n        node.prev = self.tail.prev\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n        self._size += 1\\n    \\n    def pop(self, node=None):\\n        if not node:\\n            node = self.head.next\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        self._size -= 1\\n        return node\\n    \\n    def move_to_tail(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        self.insert(node)\\n        \\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self._min_freq = 0\\n        self.cache = {}\\n        self.capacity = capacity\\n        self.freq = defaultdict(DLinkedList)\\n        \\n    def _update(self, node):\\n        f = node.freq\\n        self.freq[f].pop(node)\\n        if f == self._min_freq and self.freq[f].size == 0:\\n            self._min_freq = f+1\\n        node.freq += 1\\n        self.freq[node.freq].insert(node)\\n    \\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._update(node)\\n            return node.val\\n        else:\\n            return -1\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return;\\n        \\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._update(node)\\n            node.val = value\\n        else:\\n            if len(self.cache) >= self.capacity:\\n                node = self.freq[self._min_freq].pop()\\n                del self.cache[node.key]\\n            node = Node(key=key, val=value)\\n            self.cache[key] = node\\n            self._min_freq = 1\\n            self.freq[1].insert(node)    \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n\\n~~~",
                "solutionTags": [],
                "code": "~~~python\\nclass Node:\\n    def __init__(self, key=None, val=None, next=None, prev=None):\\n        self.val = val\\n        self.key = key\\n        self.freq = 1\\n        self.next = next\\n        self.prev = prev\\n    \\nclass DLinkedList:\\n    def __init__(self):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self._size = 0\\n        \\n    @property\\n    def size(self):\\n        return self._size\\n\\n    def insert(self, node):\\n        node.next = self.tail\\n        node.prev = self.tail.prev\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n        self._size += 1\\n    \\n    def pop(self, node=None):\\n        if not node:\\n            node = self.head.next\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        self._size -= 1\\n        return node\\n    \\n    def move_to_tail(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        self.insert(node)\\n        \\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self._min_freq = 0\\n        self.cache = {}\\n        self.capacity = capacity\\n        self.freq = defaultdict(DLinkedList)\\n        \\n    def _update(self, node):\\n        f = node.freq\\n        self.freq[f].pop(node)\\n        if f == self._min_freq and self.freq[f].size == 0:\\n            self._min_freq = f+1\\n        node.freq += 1\\n        self.freq[node.freq].insert(node)\\n    \\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._update(node)\\n            return node.val\\n        else:\\n            return -1\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return;\\n        \\n        if key in self.cache:\\n            node = self.cache[key]\\n            self._update(node)\\n            node.val = value\\n        else:\\n            if len(self.cache) >= self.capacity:\\n                node = self.freq[self._min_freq].pop()\\n                del self.cache[node.key]\\n            node = Node(key=key, val=value)\\n            self.cache[key] = node\\n            self._min_freq = 1\\n            self.freq[1].insert(node)    \\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 841231,
                "title": "go-doubly-linked-list",
                "content": "```\\ntype LFUCache struct {\\n\\tnodes map[int]*list.Element\\n\\tlists map[int]*list.List\\n\\tcapacity int\\n\\tmin int\\n}\\n\\ntype node struct {\\n\\tkey int\\n\\tvalue int\\n\\tfreq int\\n}\\n\\nfunc Constructor(capacity int) LFUCache {\\n\\treturn LFUCache{nodes: make(map[int]*list.Element),\\n\\t\\t\\t\\t\\tlists: make(map[int]*list.List),\\n\\t\\t\\t\\t\\tcapacity: capacity,\\n\\t\\t\\t\\t\\tmin: 0,\\n\\t}\\n}\\n\\n\\nfunc (this *LFUCache) Get(key int) int {\\n\\tv, ok := this.nodes[key]\\n\\tif !ok {\\n\\t\\treturn -1\\n\\t}\\n\\tn := v.Value.(*node)\\n\\tthis.lists[n.freq].Remove(v)\\n\\tn.freq++\\n\\tif _, ok := this.lists[n.freq]; !ok {\\n\\t\\tthis.lists[n.freq] = list.New()\\n\\t}\\n\\tnewlist := this.lists[n.freq]\\n    newnode := newlist.PushBack(n)\\n    this.nodes[key] = newnode\\n\\tif n.freq - 1 == this.min && this.lists[n.freq - 1].Len() == 0 {\\n\\t\\tthis.min++\\n\\t}\\n\\treturn n.value\\n}\\n\\n\\nfunc (this *LFUCache) Put(key int, value int)  {\\n\\tif this.capacity == 0 {\\n\\t\\treturn\\n\\t}\\n\\n\\tif v, ok := this.nodes[key]; ok {\\n\\t\\tn := v.Value.(*node)\\n\\t\\tn.value = value\\n\\t\\tthis.Get(key)\\n\\t\\treturn\\n\\t}\\n\\n\\tif this.capacity == len(this.nodes) {\\n\\t\\tlist := this.lists[this.min]\\n\\t\\tfrontNode := list.Front()\\n\\t\\tdelete(this.nodes, frontNode.Value.(*node).key)\\n\\t\\tlist.Remove(frontNode)\\n\\t}\\n\\n\\tthis.min = 1\\n\\tn := &node{key: key,\\n\\t\\t\\tvalue: value,\\n\\t\\t\\tfreq: 1,\\n\\t}\\n\\n\\tif _, ok := this.lists[1]; !ok {\\n\\t\\tthis.lists[1] = list.New()\\n\\t}\\n\\n\\tlist1 := this.lists[1]\\n\\tnewnode := list1.PushBack(n)\\n\\tthis.nodes[key] = newnode\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype LFUCache struct {\\n\\tnodes map[int]*list.Element\\n\\tlists map[int]*list.List\\n\\tcapacity int\\n\\tmin int\\n}\\n\\ntype node struct {\\n\\tkey int\\n\\tvalue int\\n\\tfreq int\\n}\\n\\nfunc Constructor(capacity int) LFUCache {\\n\\treturn LFUCache{nodes: make(map[int]*list.Element),\\n\\t\\t\\t\\t\\tlists: make(map[int]*list.List),\\n\\t\\t\\t\\t\\tcapacity: capacity,\\n\\t\\t\\t\\t\\tmin: 0,\\n\\t}\\n}\\n\\n\\nfunc (this *LFUCache) Get(key int) int {\\n\\tv, ok := this.nodes[key]\\n\\tif !ok {\\n\\t\\treturn -1\\n\\t}\\n\\tn := v.Value.(*node)\\n\\tthis.lists[n.freq].Remove(v)\\n\\tn.freq++\\n\\tif _, ok := this.lists[n.freq]; !ok {\\n\\t\\tthis.lists[n.freq] = list.New()\\n\\t}\\n\\tnewlist := this.lists[n.freq]\\n    newnode := newlist.PushBack(n)\\n    this.nodes[key] = newnode\\n\\tif n.freq - 1 == this.min && this.lists[n.freq - 1].Len() == 0 {\\n\\t\\tthis.min++\\n\\t}\\n\\treturn n.value\\n}\\n\\n\\nfunc (this *LFUCache) Put(key int, value int)  {\\n\\tif this.capacity == 0 {\\n\\t\\treturn\\n\\t}\\n\\n\\tif v, ok := this.nodes[key]; ok {\\n\\t\\tn := v.Value.(*node)\\n\\t\\tn.value = value\\n\\t\\tthis.Get(key)\\n\\t\\treturn\\n\\t}\\n\\n\\tif this.capacity == len(this.nodes) {\\n\\t\\tlist := this.lists[this.min]\\n\\t\\tfrontNode := list.Front()\\n\\t\\tdelete(this.nodes, frontNode.Value.(*node).key)\\n\\t\\tlist.Remove(frontNode)\\n\\t}\\n\\n\\tthis.min = 1\\n\\tn := &node{key: key,\\n\\t\\t\\tvalue: value,\\n\\t\\t\\tfreq: 1,\\n\\t}\\n\\n\\tif _, ok := this.lists[1]; !ok {\\n\\t\\tthis.lists[1] = list.New()\\n\\t}\\n\\n\\tlist1 := this.lists[1]\\n\\tnewnode := list1.PushBack(n)\\n\\tthis.nodes[key] = newnode\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776799,
                "title": "python-solution-beat-95-with-comments-ordereddict-dict",
                "content": "The basic idea is, using OrderedDict to save the frequency data:\\n```python\\nself.freq[f][k]= v     ## the node(key=k, val=v) now has frequency f\\n```\\nThen the internal order of` self.freq[f]` refers to the usage order of the keys, i.e. the first one would always be the least recently used key. It actually create a LRU for each frequency (see [146. LRU Cache](https://leetcode.com/problems/lru-cache/)). \\nThe rest work should be way easier now. \\n\\n```python\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.freq = 1\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict() \\n        ## usage[f][k]=v : frequency = f, key = k, v = value \\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        ## current least frequenct usage\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache: return -1\\n        node = self.cache[key]\\n        ## update the frequency\\n        self.update(node, node.val)\\n        return node.val\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n        if key not in self.cache: \\n            if len(self.cache) >= self.capacity:\\n                ## pop the node with current least freuenct usage (FIFO)\\n                k, v = self.usage[self.LF].popitem(last=False)\\n                self.cache.pop(k)\\n            node = ListNode(key, value)\\n            ## save the new node into cache and usage map\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            ## reset current LF to 1\\n            self.LF = 1\\n        else: \\n            ## update the vaLue of existing key \\n            node = self.cache[key]\\n            node.val = value\\n            ## update the frequency\\n            self.update(node, value)\\n            \\n            \\n    def update(self, node, newVal):\\n        k, f = node.key, node.freq\\n        ## delete from the former frequency (f)\\n        self.usage[f].pop(k)\\n        ## if the former frequency is the LFU and it become empty\\n        ## the new frequency (f+1) become new LFU\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        ## push to the new frequency (f+1)\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n        \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nself.freq[f][k]= v     ## the node(key=k, val=v) now has frequency f\\n```\n```python\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.val = value\\n        self.freq = 1\\n        \\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict() \\n        ## usage[f][k]=v : frequency = f, key = k, v = value \\n        self.usage = collections.defaultdict(collections.OrderedDict)\\n        ## current least frequenct usage\\n        self.LF = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache: return -1\\n        node = self.cache[key]\\n        ## update the frequency\\n        self.update(node, node.val)\\n        return node.val\\n        \\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0: return\\n        if key not in self.cache: \\n            if len(self.cache) >= self.capacity:\\n                ## pop the node with current least freuenct usage (FIFO)\\n                k, v = self.usage[self.LF].popitem(last=False)\\n                self.cache.pop(k)\\n            node = ListNode(key, value)\\n            ## save the new node into cache and usage map\\n            self.cache[key] = node\\n            self.usage[1][key] = value\\n            ## reset current LF to 1\\n            self.LF = 1\\n        else: \\n            ## update the vaLue of existing key \\n            node = self.cache[key]\\n            node.val = value\\n            ## update the frequency\\n            self.update(node, value)\\n            \\n            \\n    def update(self, node, newVal):\\n        k, f = node.key, node.freq\\n        ## delete from the former frequency (f)\\n        self.usage[f].pop(k)\\n        ## if the former frequency is the LFU and it become empty\\n        ## the new frequency (f+1) become new LFU\\n        if not self.usage[f] and self.LF == f:\\n            self.LF += 1\\n        ## push to the new frequency (f+1)\\n        self.usage[f+1][k] = newVal\\n        node.freq += 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 749658,
                "title": "java-linkedhashmap-o-1",
                "content": "\\n```\\nclass LFUCache {\\n    \\n    private int minFrequency = Integer.MAX_VALUE;\\n    private int capacity = 0;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    private Map<Integer, Node> cache2 = new HashMap<>();\\n    // Use LinkedHashMap as value here to track the insertion (least-recently-used) order.\\n    private Map<Integer, LinkedHashMap<Integer, Node>> frequencyMap2 = new HashMap<>();\\n    \\n    public int get(int key) {\\n        Node node = cache2.get(key);\\n        if(node == null) return -1;\\n        \\n        updateNode(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity <= 0) return;\\n        Node node = cache2.get(key);\\n        if(node == null){\\n            node = new Node(key, value, 0);\\n        }\\n        node.val = value;\\n        updateNode(node);\\n    }\\n    private void updateNode(Node node){\\n        int freq = node.frequency;\\n        node.frequency++;\\n        // It\\'s a new node.    \\n        if(freq == 0){\\n            if(cache2.size() == capacity){\\n                Map<Integer, Node> nodes = frequencyMap2.get(minFrequency);\\n                Iterator<Integer> it = nodes.keySet().iterator();\\n                int k = it.next();\\n                // Remove the least frequently and recently used key-value.\\n                it.remove();\\n                if(nodes.isEmpty()) frequencyMap2.remove(minFrequency);\\n                cache2.remove(k);\\n            }\\n            minFrequency = 1;\\n            cache2.put(node.key, node);\\n        }else{\\n            Map<Integer, Node> nodes = frequencyMap2.get(freq);\\n            nodes.remove(node.key);\\n            if(nodes.isEmpty()){\\n                frequencyMap2.remove(freq);\\n                if(freq == minFrequency){\\n                    minFrequency++;\\n                }\\n            }   \\n        }\\n        frequencyMap2.compute(node.frequency, (k,v) ->{\\n            if(v == null){\\n                v = new LinkedHashMap<>();\\n            }\\n            // Re-insert the node into the LinkedHashMap to track the least-recently-used order.\\n            v.remove(node.key);\\n            v.put(node.key, node);\\n            return v;\\n        });\\n    }\\n    static class Node{\\n        private int key;\\n        private int val;\\n        private int frequency;\\n        Node(int key, int val, int frequency){\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = frequency;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    \\n    private int minFrequency = Integer.MAX_VALUE;\\n    private int capacity = 0;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    private Map<Integer, Node> cache2 = new HashMap<>();\\n    // Use LinkedHashMap as value here to track the insertion (least-recently-used) order.\\n    private Map<Integer, LinkedHashMap<Integer, Node>> frequencyMap2 = new HashMap<>();\\n    \\n    public int get(int key) {\\n        Node node = cache2.get(key);\\n        if(node == null) return -1;\\n        \\n        updateNode(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity <= 0) return;\\n        Node node = cache2.get(key);\\n        if(node == null){\\n            node = new Node(key, value, 0);\\n        }\\n        node.val = value;\\n        updateNode(node);\\n    }\\n    private void updateNode(Node node){\\n        int freq = node.frequency;\\n        node.frequency++;\\n        // It\\'s a new node.    \\n        if(freq == 0){\\n            if(cache2.size() == capacity){\\n                Map<Integer, Node> nodes = frequencyMap2.get(minFrequency);\\n                Iterator<Integer> it = nodes.keySet().iterator();\\n                int k = it.next();\\n                // Remove the least frequently and recently used key-value.\\n                it.remove();\\n                if(nodes.isEmpty()) frequencyMap2.remove(minFrequency);\\n                cache2.remove(k);\\n            }\\n            minFrequency = 1;\\n            cache2.put(node.key, node);\\n        }else{\\n            Map<Integer, Node> nodes = frequencyMap2.get(freq);\\n            nodes.remove(node.key);\\n            if(nodes.isEmpty()){\\n                frequencyMap2.remove(freq);\\n                if(freq == minFrequency){\\n                    minFrequency++;\\n                }\\n            }   \\n        }\\n        frequencyMap2.compute(node.frequency, (k,v) ->{\\n            if(v == null){\\n                v = new LinkedHashMap<>();\\n            }\\n            // Re-insert the node into the LinkedHashMap to track the least-recently-used order.\\n            v.remove(node.key);\\n            v.put(node.key, node);\\n            return v;\\n        });\\n    }\\n    static class Node{\\n        private int key;\\n        private int val;\\n        private int frequency;\\n        Node(int key, int val, int frequency){\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = frequency;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726530,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis problem is extremley hard and in my opinion, in order to solve it in an interview setting, you would at least need to have seen this problem before. This problem was inspired by the solutions posted in https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList. Take a look at LRU cache as well, since you are expcted to return the LRU entry if there is a tie in frequencies.\\n\\n\\n### Solution\\n```\\n    private int capacity;\\n    private int size;\\n    private int minFrequency;\\n    private Map<Integer, Node> cache;\\n    private Map<Integer, DLL> frequencyMap;\\n    \\n    public LFUCache(int capacity) {\\n        this.size = 0;\\n        this.capacity = capacity;\\n        this.minFrequency = 0;\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!cache.containsKey(key)) return -1;\\n        else {\\n            int val = cache.get(key).value;\\n            updateNode(cache.get(key));\\n            return val;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (cache.containsKey(key)) {\\n            Node n = cache.get(key);\\n            n.value = value;\\n            updateNode(n);\\n        } else {\\n            size++;\\n            if (size > capacity) {\\n                // get minimum frequency list\\n                DLL minFreqList = frequencyMap.get(minFrequency);\\n                Node deleteNode = minFreqList.removeTail();\\n                cache.remove(deleteNode.key);\\n                size--;\\n            }\\n            minFrequency = 1;\\n            Node newNode = new Node(key, value);\\n\\n            DLL curList = frequencyMap.getOrDefault(1, new DLL());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n    \\n    private void updateNode(Node node) {\\n        DLL list = frequencyMap.get(node.freq);\\n        list.removeNode(node);\\n        if (node.freq == minFrequency && list.size == 0) {\\n            minFrequency++;\\n        }\\n        node.freq++;\\n        if (!frequencyMap.containsKey(node.freq)) {\\n            frequencyMap.put(node.freq, new DLL());\\n        }\\n        frequencyMap.get(node.freq).addNode(node);\\n    }\\n    \\n    private static class Node {\\n        int key, value, freq;\\n        Node prev, next;\\n        \\n        public Node() { }\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.value = val;\\n            this.freq = 1;\\n        }\\n    }\\n    \\n    private static class DLL {\\n        Node head;\\n        Node tail;\\n        int size;\\n        \\n        public DLL() {\\n            this.head = new Node();\\n            this.tail = new Node();\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n        \\n        public void addNode(Node node) {\\n            Node after = head.next;\\n            after.prev = node;\\n            node.next = after;\\n            head.next = node;\\n            node.prev = head;\\n            size++;\\n        }\\n        \\n        public void removeNode(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;\\n        }\\n\\n        /** remove tail node **/\\n        public Node removeTail() {\\n            // DO NOT FORGET to check list size\\n            if (size > 0) {\\n                Node tailNode = tail.prev;\\n                removeNode(tailNode);\\n                return tailNode;\\n            }\\n            return null;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int capacity;\\n    private int size;\\n    private int minFrequency;\\n    private Map<Integer, Node> cache;\\n    private Map<Integer, DLL> frequencyMap;\\n    \\n    public LFUCache(int capacity) {\\n        this.size = 0;\\n        this.capacity = capacity;\\n        this.minFrequency = 0;\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!cache.containsKey(key)) return -1;\\n        else {\\n            int val = cache.get(key).value;\\n            updateNode(cache.get(key));\\n            return val;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (cache.containsKey(key)) {\\n            Node n = cache.get(key);\\n            n.value = value;\\n            updateNode(n);\\n        } else {\\n            size++;\\n            if (size > capacity) {\\n                // get minimum frequency list\\n                DLL minFreqList = frequencyMap.get(minFrequency);\\n                Node deleteNode = minFreqList.removeTail();\\n                cache.remove(deleteNode.key);\\n                size--;\\n            }\\n            minFrequency = 1;\\n            Node newNode = new Node(key, value);\\n\\n            DLL curList = frequencyMap.getOrDefault(1, new DLL());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n    \\n    private void updateNode(Node node) {\\n        DLL list = frequencyMap.get(node.freq);\\n        list.removeNode(node);\\n        if (node.freq == minFrequency && list.size == 0) {\\n            minFrequency++;\\n        }\\n        node.freq++;\\n        if (!frequencyMap.containsKey(node.freq)) {\\n            frequencyMap.put(node.freq, new DLL());\\n        }\\n        frequencyMap.get(node.freq).addNode(node);\\n    }\\n    \\n    private static class Node {\\n        int key, value, freq;\\n        Node prev, next;\\n        \\n        public Node() { }\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.value = val;\\n            this.freq = 1;\\n        }\\n    }\\n    \\n    private static class DLL {\\n        Node head;\\n        Node tail;\\n        int size;\\n        \\n        public DLL() {\\n            this.head = new Node();\\n            this.tail = new Node();\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n        \\n        public void addNode(Node node) {\\n            Node after = head.next;\\n            after.prev = node;\\n            node.next = after;\\n            head.next = node;\\n            node.prev = head;\\n            size++;\\n        }\\n        \\n        public void removeNode(Node node) {\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n            size--;\\n        }\\n\\n        /** remove tail node **/\\n        public Node removeTail() {\\n            // DO NOT FORGET to check list size\\n            if (size > 0) {\\n                Node tailNode = tail.prev;\\n                removeNode(tailNode);\\n                return tailNode;\\n            }\\n            return null;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676378,
                "title": "short-and-clean-java-solution-using-two-hashmap-and-linkedhashset",
                "content": "Map<Integer, Integer> map matches each key with its value\\nMap<Integer, Integer> keyToFreq matches each key with its frequency\\nTreeMap<Integer, LinkedHashSet<Integer>> allFreqs matches each frequency(>=1) with all the keys that have this frequency(keep insertion order by using LinkedHashSet)\\n\\nIf you think LinkedHashSet is too fancy, we can use LinkedList too. \\nBut it will be slower because remove(Object o) is O(n), while LinkedHashSet have constant time for remove.\\n\\n```\\nclass LFUCache {\\n\\t\\tprivate Map<Integer, Integer> map;\\n\\t\\tprivate Map<Integer, Integer> keyToFreq;\\n\\t\\tprivate TreeMap<Integer, LinkedHashSet<Integer>> allFreqs;\\n\\t\\tprivate int capacity;\\n\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tkeyToFreq = new HashMap<>();\\n\\t\\t\\tallFreqs = new TreeMap<>();\\n\\t\\t}\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tif (!map.containsKey(key)) return -1;\\n\\t\\t\\tupdate(key);\\n\\t\\t\\treturn map.get(key);\\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif (capacity == 0) return;\\n\\n\\t\\t\\tif (map.containsKey(key)) {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (map.size() == capacity) evict();\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tkeyToFreq.put(key, 1);\\n\\t\\t\\t\\tallFreqs.putIfAbsent(1, new LinkedHashSet<>());\\n\\t\\t\\t\\tallFreqs.get(1).add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tprivate void update(int key) {\\n\\t\\t\\tint freq = keyToFreq.get(key);\\n\\t\\t\\tkeyToFreq.put(key, freq + 1);\\n\\n\\t\\t\\tallFreqs.get(freq).remove(key);\\n\\t\\t\\tif (allFreqs.get(freq).isEmpty()) {\\n\\t\\t\\t\\tallFreqs.remove(freq);\\n\\t\\t\\t}\\n\\t\\t\\tallFreqs.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n\\t\\t\\tallFreqs.get(freq + 1).add(key);\\n\\t\\t}\\n\\t\\t\\n\\t\\tprivate void evict() {\\n\\t\\t\\tint minFreq = allFreqs.firstKey();\\n\\t\\t\\tIterator<Integer> iter = allFreqs.get(minFreq).iterator();\\n\\t\\t\\tint keyToRemove = iter.next();\\n\\t\\t\\titer.remove();\\n\\n\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\tkeyToFreq.remove(keyToRemove);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n\\n\\nUsing LinkedList instead of LinkedHashSet\\n```\\nclass LFUCache {\\n\\t\\tprivate Map<Integer, Integer> map;\\n\\t\\tprivate Map<Integer, Integer> keyToFreq;\\n\\t\\tprivate TreeMap<Integer, LinkedList<Integer>> allFreqs;\\n\\t\\tprivate int capacity;\\n\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tkeyToFreq = new HashMap<>();\\n\\t\\t\\tallFreqs = new TreeMap<>();\\n\\t\\t}\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tif (!map.containsKey(key)) return -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\treturn map.get(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif (capacity == 0) return;\\n\\n\\t\\t\\tif (map.containsKey(key)) {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (map.size() == capacity) evict();\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tkeyToFreq.put(key, 1);\\n\\t\\t\\t\\tallFreqs.putIfAbsent(1, new LinkedList<>());\\n\\t\\t\\t\\tallFreqs.get(1).add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tprivate void update(int key) {\\n\\t\\t\\tint freq = keyToFreq.get(key);\\n\\t\\t\\tkeyToFreq.put(key, freq + 1);\\n\\n\\t\\t\\tallFreqs.get(freq).remove((Integer) key);\\n\\t\\t\\tif (allFreqs.get(freq).isEmpty()) {\\n\\t\\t\\t\\tallFreqs.remove(freq);\\n\\t\\t\\t}\\n\\t\\t\\tallFreqs.putIfAbsent(freq + 1, new LinkedList<>());\\n\\t\\t\\tallFreqs.get(freq + 1).add(key);\\n\\t\\t}\\n\\n\\t\\tprivate void evict() {\\n\\t\\t\\tint minFreq = allFreqs.firstKey();\\n\\t\\t\\tint keyToRemove = allFreqs.get(minFreq).pollFirst();\\n\\n\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\tkeyToFreq.remove(keyToRemove);\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n\\t\\tprivate Map<Integer, Integer> map;\\n\\t\\tprivate Map<Integer, Integer> keyToFreq;\\n\\t\\tprivate TreeMap<Integer, LinkedHashSet<Integer>> allFreqs;\\n\\t\\tprivate int capacity;\\n\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tkeyToFreq = new HashMap<>();\\n\\t\\t\\tallFreqs = new TreeMap<>();\\n\\t\\t}\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tif (!map.containsKey(key)) return -1;\\n\\t\\t\\tupdate(key);\\n\\t\\t\\treturn map.get(key);\\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif (capacity == 0) return;\\n\\n\\t\\t\\tif (map.containsKey(key)) {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (map.size() == capacity) evict();\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tkeyToFreq.put(key, 1);\\n\\t\\t\\t\\tallFreqs.putIfAbsent(1, new LinkedHashSet<>());\\n\\t\\t\\t\\tallFreqs.get(1).add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tprivate void update(int key) {\\n\\t\\t\\tint freq = keyToFreq.get(key);\\n\\t\\t\\tkeyToFreq.put(key, freq + 1);\\n\\n\\t\\t\\tallFreqs.get(freq).remove(key);\\n\\t\\t\\tif (allFreqs.get(freq).isEmpty()) {\\n\\t\\t\\t\\tallFreqs.remove(freq);\\n\\t\\t\\t}\\n\\t\\t\\tallFreqs.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n\\t\\t\\tallFreqs.get(freq + 1).add(key);\\n\\t\\t}\\n\\t\\t\\n\\t\\tprivate void evict() {\\n\\t\\t\\tint minFreq = allFreqs.firstKey();\\n\\t\\t\\tIterator<Integer> iter = allFreqs.get(minFreq).iterator();\\n\\t\\t\\tint keyToRemove = iter.next();\\n\\t\\t\\titer.remove();\\n\\n\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\tkeyToFreq.remove(keyToRemove);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\nclass LFUCache {\\n\\t\\tprivate Map<Integer, Integer> map;\\n\\t\\tprivate Map<Integer, Integer> keyToFreq;\\n\\t\\tprivate TreeMap<Integer, LinkedList<Integer>> allFreqs;\\n\\t\\tprivate int capacity;\\n\\n\\t\\tpublic LFUCache(int capacity) {\\n\\t\\t\\tthis.capacity = capacity;\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tkeyToFreq = new HashMap<>();\\n\\t\\t\\tallFreqs = new TreeMap<>();\\n\\t\\t}\\n\\n\\t\\tpublic int get(int key) {\\n\\t\\t\\tif (!map.containsKey(key)) return -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\treturn map.get(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void put(int key, int value) {\\n\\t\\t\\tif (capacity == 0) return;\\n\\n\\t\\t\\tif (map.containsKey(key)) {\\n\\t\\t\\t\\tupdate(key);\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (map.size() == capacity) evict();\\n\\t\\t\\t\\tmap.put(key, value);\\n\\t\\t\\t\\tkeyToFreq.put(key, 1);\\n\\t\\t\\t\\tallFreqs.putIfAbsent(1, new LinkedList<>());\\n\\t\\t\\t\\tallFreqs.get(1).add(key);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tprivate void update(int key) {\\n\\t\\t\\tint freq = keyToFreq.get(key);\\n\\t\\t\\tkeyToFreq.put(key, freq + 1);\\n\\n\\t\\t\\tallFreqs.get(freq).remove((Integer) key);\\n\\t\\t\\tif (allFreqs.get(freq).isEmpty()) {\\n\\t\\t\\t\\tallFreqs.remove(freq);\\n\\t\\t\\t}\\n\\t\\t\\tallFreqs.putIfAbsent(freq + 1, new LinkedList<>());\\n\\t\\t\\tallFreqs.get(freq + 1).add(key);\\n\\t\\t}\\n\\n\\t\\tprivate void evict() {\\n\\t\\t\\tint minFreq = allFreqs.firstKey();\\n\\t\\t\\tint keyToRemove = allFreqs.get(minFreq).pollFirst();\\n\\n\\t\\t\\tmap.remove(keyToRemove);\\n\\t\\t\\tkeyToFreq.remove(keyToRemove);\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580078,
                "title": "go-solution-using-hashmap-and-golang-implementation-of-a-doubly-linked-list",
                "content": "```\\ntype LFUCache struct {\\n\\tcap     int\\n\\tmin     int\\n\\tcache   map[int]*list.Element\\n\\tbuckets map[int]*list.List\\n}\\n\\ntype LFUCacheElement struct {\\n\\tKey         int\\n\\tVal         int\\n\\tFrequency   int\\n}\\n\\nfunc Constructor(capacity int) LFUCache {\\n\\tbuckets := make(map[int]*list.List)\\n\\tbuckets[1] = list.New()\\n\\tnewCache := LFUCache{\\n\\t\\tcap: capacity,\\n\\t\\tmin: 1,\\n\\t\\tcache: make(map[int]*list.Element),\\n\\t\\tbuckets: buckets,\\n\\t}\\n\\treturn newCache\\n}\\n\\nfunc (lfc *LFUCache) Get(key int) int {\\n\\te, ok := lfc.cache[key]\\n\\tif ok {\\n\\t\\tlfuCacheElement := e.Value.(*LFUCacheElement)\\n\\t\\toldBucket := lfc.buckets[lfuCacheElement.Frequency]\\n\\t\\toldBucket.Remove(e)\\n\\t\\tif lfuCacheElement.Frequency == lfc.min && oldBucket.Len() == 0 {\\n\\t\\t\\tlfc.min++\\n\\t\\t}\\n\\t\\tlfuCacheElement.Frequency++\\n\\t\\tnewBucket, ok := lfc.buckets[lfuCacheElement.Frequency]\\n\\t\\tif !ok {\\n\\t\\t\\tnewBucket = list.New()\\n\\t\\t\\tlfc.buckets[lfuCacheElement.Frequency] = newBucket\\n\\t\\t}\\n        lfc.cache[key] = newBucket.PushFront(lfuCacheElement)\\n        return lfuCacheElement.Val\\n\\t} else {\\n\\t\\treturn -1\\n\\t}\\n}\\n\\nfunc (lfc *LFUCache) Put(key int, value int)  {\\n\\te, ok := lfc.cache[key]\\n\\tif ok {\\n\\t\\tlfuCacheElement := e.Value.(*LFUCacheElement)\\n\\t\\tlfuCacheElement.Val = value\\n\\t\\tlfc.Get(key)\\n\\t} else {\\n        newLfuCacheElement := LFUCacheElement{Key: key, Val: value, Frequency: 1}\\n        newElement := lfc.buckets[1].PushFront(&newLfuCacheElement)\\n\\t\\tlfc.cache[key] = newElement\\n        if len(lfc.cache) > lfc.cap {\\n\\t\\t\\tlfBucket := lfc.buckets[lfc.min]\\n\\t\\t\\tlrElement := lfBucket.Back()\\n\\t\\t\\tlfBucket.Remove(lrElement)\\n\\t\\t\\tlfuCacheElement := lrElement.Value.(*LFUCacheElement)\\n\\t\\t\\tdelete(lfc.cache, lfuCacheElement.Key)\\n\\t\\t}\\n        lfc.min = 1\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype LFUCache struct {\\n\\tcap     int\\n\\tmin     int\\n\\tcache   map[int]*list.Element\\n\\tbuckets map[int]*list.List\\n}\\n\\ntype LFUCacheElement struct {\\n\\tKey         int\\n\\tVal         int\\n\\tFrequency   int\\n}\\n\\nfunc Constructor(capacity int) LFUCache {\\n\\tbuckets := make(map[int]*list.List)\\n\\tbuckets[1] = list.New()\\n\\tnewCache := LFUCache{\\n\\t\\tcap: capacity,\\n\\t\\tmin: 1,\\n\\t\\tcache: make(map[int]*list.Element),\\n\\t\\tbuckets: buckets,\\n\\t}\\n\\treturn newCache\\n}\\n\\nfunc (lfc *LFUCache) Get(key int) int {\\n\\te, ok := lfc.cache[key]\\n\\tif ok {\\n\\t\\tlfuCacheElement := e.Value.(*LFUCacheElement)\\n\\t\\toldBucket := lfc.buckets[lfuCacheElement.Frequency]\\n\\t\\toldBucket.Remove(e)\\n\\t\\tif lfuCacheElement.Frequency == lfc.min && oldBucket.Len() == 0 {\\n\\t\\t\\tlfc.min++\\n\\t\\t}\\n\\t\\tlfuCacheElement.Frequency++\\n\\t\\tnewBucket, ok := lfc.buckets[lfuCacheElement.Frequency]\\n\\t\\tif !ok {\\n\\t\\t\\tnewBucket = list.New()\\n\\t\\t\\tlfc.buckets[lfuCacheElement.Frequency] = newBucket\\n\\t\\t}\\n        lfc.cache[key] = newBucket.PushFront(lfuCacheElement)\\n        return lfuCacheElement.Val\\n\\t} else {\\n\\t\\treturn -1\\n\\t}\\n}\\n\\nfunc (lfc *LFUCache) Put(key int, value int)  {\\n\\te, ok := lfc.cache[key]\\n\\tif ok {\\n\\t\\tlfuCacheElement := e.Value.(*LFUCacheElement)\\n\\t\\tlfuCacheElement.Val = value\\n\\t\\tlfc.Get(key)\\n\\t} else {\\n        newLfuCacheElement := LFUCacheElement{Key: key, Val: value, Frequency: 1}\\n        newElement := lfc.buckets[1].PushFront(&newLfuCacheElement)\\n\\t\\tlfc.cache[key] = newElement\\n        if len(lfc.cache) > lfc.cap {\\n\\t\\t\\tlfBucket := lfc.buckets[lfc.min]\\n\\t\\t\\tlrElement := lfBucket.Back()\\n\\t\\t\\tlfBucket.Remove(lrElement)\\n\\t\\t\\tlfuCacheElement := lrElement.Value.(*LFUCacheElement)\\n\\t\\t\\tdelete(lfc.cache, lfuCacheElement.Key)\\n\\t\\t}\\n        lfc.min = 1\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487700,
                "title": "neat-java-code-with-video-explanation-chinese-english",
                "content": "# English\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/su3E22YwLB4\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Chinese\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7ec329ahpdk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Code\\n```\\nclass LFUCache {\\n    class Node {\\n        int key, val;\\n        int cnt;\\n        Node prev, next;\\n        public Node(int k, int v) {\\n            key = k;\\n            val = v;\\n            cnt = 1;\\n        }\\n    }\\n    \\n    class DLList {\\n        Node head, tail;\\n        int len;\\n        public DLList() {\\n            head = new Node(0, 0);\\n            tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n            len = 0;\\n        }\\n        \\n        public void addHead(Node node) {\\n            Node next = head.next;\\n            head.next = node;\\n            node.prev = head;\\n            node.next = next;\\n            next.prev = node;\\n            map.put(node.key, node);\\n            len++;\\n        }\\n        \\n        public void remove(Node node) {\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            prev.next = next;\\n            next.prev = prev;\\n            len--;\\n            map.remove(node.key);\\n        }\\n        \\n        public void removeTail() {\\n            Node prevTail = tail.prev;\\n            remove(prevTail);\\n        }\\n    }\\n    \\n    Map<Integer, Node> map;\\n    Map<Integer, DLList> freq;\\n    int size, capacity;\\n    int maxFreq;\\n    public LFUCache(int capacity) {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n        this.capacity = capacity;\\n        size = 0;\\n        maxFreq = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if (map.get(key) == null) return -1;\\n        \\n        Node node = map.get(key);\\n        int prevFreq = node.cnt;\\n        DLList prevList = freq.get(prevFreq);\\n        prevList.remove(node);\\n        \\n        int curFreq = prevFreq + 1;\\n        maxFreq = Math.max(maxFreq, curFreq);\\n        DLList curList = freq.getOrDefault(curFreq, new DLList());\\n        node.cnt++;\\n        curList.addHead(node);\\n        \\n        freq.put(prevFreq, prevList);\\n        freq.put(curFreq, curList);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (map.get(key) != null) {\\n            map.get(key).val = value;\\n            get(key);\\n            return;\\n        }\\n        \\n        Node node = new Node(key, value);\\n        DLList curList = freq.getOrDefault(1, new DLList());\\n        curList.addHead(node);\\n        size++;\\n        \\n        if (size > capacity) {\\n            if (curList.len > 1) {\\n                curList.removeTail();\\n            } else {\\n                for (int i = 2; i <= maxFreq; i++) {\\n                    if (freq.get(i) != null && freq.get(i).len > 0) {\\n                        freq.get(i).removeTail();\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            size--;\\n        }\\n        \\n        freq.put(1, curList);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\n    class Node {\\n        int key, val;\\n        int cnt;\\n        Node prev, next;\\n        public Node(int k, int v) {\\n            key = k;\\n            val = v;\\n            cnt = 1;\\n        }\\n    }\\n    \\n    class DLList {\\n        Node head, tail;\\n        int len;\\n        public DLList() {\\n            head = new Node(0, 0);\\n            tail = new Node(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n            len = 0;\\n        }\\n        \\n        public void addHead(Node node) {\\n            Node next = head.next;\\n            head.next = node;\\n            node.prev = head;\\n            node.next = next;\\n            next.prev = node;\\n            map.put(node.key, node);\\n            len++;\\n        }\\n        \\n        public void remove(Node node) {\\n            Node prev = node.prev;\\n            Node next = node.next;\\n            prev.next = next;\\n            next.prev = prev;\\n            len--;\\n            map.remove(node.key);\\n        }\\n        \\n        public void removeTail() {\\n            Node prevTail = tail.prev;\\n            remove(prevTail);\\n        }\\n    }\\n    \\n    Map<Integer, Node> map;\\n    Map<Integer, DLList> freq;\\n    int size, capacity;\\n    int maxFreq;\\n    public LFUCache(int capacity) {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n        this.capacity = capacity;\\n        size = 0;\\n        maxFreq = 0;\\n    }\\n    \\n    public int get(int key) {\\n        if (map.get(key) == null) return -1;\\n        \\n        Node node = map.get(key);\\n        int prevFreq = node.cnt;\\n        DLList prevList = freq.get(prevFreq);\\n        prevList.remove(node);\\n        \\n        int curFreq = prevFreq + 1;\\n        maxFreq = Math.max(maxFreq, curFreq);\\n        DLList curList = freq.getOrDefault(curFreq, new DLList());\\n        node.cnt++;\\n        curList.addHead(node);\\n        \\n        freq.put(prevFreq, prevList);\\n        freq.put(curFreq, curList);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (map.get(key) != null) {\\n            map.get(key).val = value;\\n            get(key);\\n            return;\\n        }\\n        \\n        Node node = new Node(key, value);\\n        DLList curList = freq.getOrDefault(1, new DLList());\\n        curList.addHead(node);\\n        size++;\\n        \\n        if (size > capacity) {\\n            if (curList.len > 1) {\\n                curList.removeTail();\\n            } else {\\n                for (int i = 2; i <= maxFreq; i++) {\\n                    if (freq.get(i) != null && freq.get(i).len > 0) {\\n                        freq.get(i).removeTail();\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            size--;\\n        }\\n        \\n        freq.put(1, curList);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446180,
                "title": "c-2d-linked-list-method-2-hash-map-method",
                "content": "```\\nclass LFUCache {\\nprivate:\\n    // Create a 2D linked list, while the outer list represent the frequency,\\n    // the inner list stores the data that have this frequency.\\n    list<list<pair<int, int>>> l;\\n    unordered_map<int, list<list<pair<int, int>>>::iterator> mp1;\\n    unordered_map<int, list<pair<int, int>>::iterator> mp2;\\n    int cap = 0;\\n    int current = 0;\\npublic:\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n        l.push_back(list<pair<int, int>>());\\n    }\\n    \\n    int get(int key) {\\n        if (cap == 0) return -1;\\n        if (mp1.find(key) == mp1.end()) return -1;\\n        auto it_1 = mp1[key];\\n        auto it_2 = mp2[key];\\n        int val = it_2->second;\\n        auto it_1_new = it_1;\\n        ++it_1_new;\\n        if (it_1_new == l.end()) l.push_back(list<pair<int, int>>());\\n        it_1_new = it_1;\\n        ++it_1_new;\\n        it_1_new->push_front(*it_2);\\n        it_1->erase(it_2);\\n        mp1[key] = it_1_new;\\n        mp2[key] = it_1_new->begin();\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (cap == 0) return;\\n        if (mp1.find(key) == mp1.end()) {\\n            ++current;\\n            if (current > cap) {\\n                auto it = l.begin();\\n                for (it; it != l.end(); ++it){\\n                    if (it->size() != 0) break;\\n                } // for\\n                mp1.erase(it->back().first);\\n                mp2.erase(it->back().first);\\n                it->pop_back();\\n                --current;\\n            }\\n            l.begin()->push_front(make_pair(key, value));\\n            mp1[key] = l.begin();\\n            mp2[key] = l.begin()->begin();\\n        }\\n        else {\\n            auto it1 = mp1[key];\\n            auto it2 = mp2[key];\\n            auto it1_new = it1;\\n            ++it1_new;\\n            if (it1_new == l.end()) l.push_back(list<pair<int, int>>());\\n            it1_new = it1;\\n            ++it1_new;\\n            it1_new->push_front(make_pair(key, value));\\n            it1->erase(it2);\\n            mp1[key] = it1_new;\\n            mp2[key] = it1_new->begin();\\n        }\\n    }\\n};\\n```\\nActually, at first, I tried to use a vector of double linked lists. However, although I can pass majority of the test cases, at least one of them will cause heap overflow. Therefore, we need to use linked lists.\\nWhen I first encounter this question, it seems quite strange to me. But in fact, the basic idea of LFU is the same as LRU, i.e. use linked list to reduce the run time of push_front() and erase() to O(1).\\nI would say there are many points in the implemenation that can lead to errors. But once you can do it, you should practice LFU more, until you can write it in limited time and bug-free. (Maybe during an interview LOL)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LFUCache {\\nprivate:\\n    // Create a 2D linked list, while the outer list represent the frequency,\\n    // the inner list stores the data that have this frequency.\\n    list<list<pair<int, int>>> l;\\n    unordered_map<int, list<list<pair<int, int>>>::iterator> mp1;\\n    unordered_map<int, list<pair<int, int>>::iterator> mp2;\\n    int cap = 0;\\n    int current = 0;\\npublic:\\n    LFUCache(int capacity) {\\n        cap = capacity;\\n        l.push_back(list<pair<int, int>>());\\n    }\\n    \\n    int get(int key) {\\n        if (cap == 0) return -1;\\n        if (mp1.find(key) == mp1.end()) return -1;\\n        auto it_1 = mp1[key];\\n        auto it_2 = mp2[key];\\n        int val = it_2->second;\\n        auto it_1_new = it_1;\\n        ++it_1_new;\\n        if (it_1_new == l.end()) l.push_back(list<pair<int, int>>());\\n        it_1_new = it_1;\\n        ++it_1_new;\\n        it_1_new->push_front(*it_2);\\n        it_1->erase(it_2);\\n        mp1[key] = it_1_new;\\n        mp2[key] = it_1_new->begin();\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (cap == 0) return;\\n        if (mp1.find(key) == mp1.end()) {\\n            ++current;\\n            if (current > cap) {\\n                auto it = l.begin();\\n                for (it; it != l.end(); ++it){\\n                    if (it->size() != 0) break;\\n                } // for\\n                mp1.erase(it->back().first);\\n                mp2.erase(it->back().first);\\n                it->pop_back();\\n                --current;\\n            }\\n            l.begin()->push_front(make_pair(key, value));\\n            mp1[key] = l.begin();\\n            mp2[key] = l.begin()->begin();\\n        }\\n        else {\\n            auto it1 = mp1[key];\\n            auto it2 = mp2[key];\\n            auto it1_new = it1;\\n            ++it1_new;\\n            if (it1_new == l.end()) l.push_back(list<pair<int, int>>());\\n            it1_new = it1;\\n            ++it1_new;\\n            it1_new->push_front(make_pair(key, value));\\n            it1->erase(it2);\\n            mp1[key] = it1_new;\\n            mp2[key] = it1_new->begin();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253641,
                "title": "javascript-o-1-solution-using-nested-map-instead-of-doubly-linked-list",
                "content": "The idea is similar to the one using DoubleLinkedList, but here we leverage the fact that javascript `Map()` construct are actually ordered and you can use `Map.values().next().value` to easily get the first inserted item with `O(1)` time. Therefore we don\\'t have to maintain that DoubleLinkedList and keep track of which item is the oldest.\\n```\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n  this.keyMap = new Map();\\n  this.freqMap = new Map();\\n  this.size = capacity;\\n  this.minFreq = 1;\\n};\\nLFUCache.prototype.get = function(key){\\n  const result = this.getNode(key);\\n  return result ? result.value : -1;\\n};\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.getNode = function(key) {\\n  const node = this.keyMap.get(key);\\n  if(node){\\n    result = node.value;\\n    let freq = this.freqMap.get(node.freq);\\n    freq.delete(node.key);\\n    if(freq.size === 0){\\n      this.freqMap.delete(node.freq);\\n      if(this.minFreq === node.freq) this.minFreq++;\\n    }\\n    node.freq++;\\n    freq = this.freqMap.get(node.freq);\\n    if(freq){\\n      freq.set(node.key, node);\\n    }else{\\n      this.freqMap.set(node.freq, new Map([[node.key, node]]));\\n    }\\n  }\\n  return node;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if(this.size === 0) return;\\n  let node = this.getNode(key);\\n  if(node){\\n    node.value = value;\\n  }else{\\n    node = {key, value, freq: 1};\\n    if(this.keyMap.size === this.size){\\n      const minFreqMap = this.freqMap.get(this.minFreq);\\n      const oldNode = minFreqMap.values().next().value;\\n      minFreqMap.delete(oldNode.key);\\n      this.keyMap.delete(oldNode.key);\\n      if(minFreqMap.size === 0){\\n        this.freqMap.delete(oldNode.freq);\\n      }\\n    }\\n    const freqOne = this.freqMap.get(1);\\n    if(freqOne){\\n      freqOne.set(node.key, node);\\n    }else{\\n      this.freqMap.set(1, new Map([[node.key, node]]));\\n    }\\n    this.keyMap.set(node.key, node);\\n    this.minFreq = 1;\\n  }\\n};\\n\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LFUCache = function(capacity) {\\n  this.keyMap = new Map();\\n  this.freqMap = new Map();\\n  this.size = capacity;\\n  this.minFreq = 1;\\n};\\nLFUCache.prototype.get = function(key){\\n  const result = this.getNode(key);\\n  return result ? result.value : -1;\\n};\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLFUCache.prototype.getNode = function(key) {\\n  const node = this.keyMap.get(key);\\n  if(node){\\n    result = node.value;\\n    let freq = this.freqMap.get(node.freq);\\n    freq.delete(node.key);\\n    if(freq.size === 0){\\n      this.freqMap.delete(node.freq);\\n      if(this.minFreq === node.freq) this.minFreq++;\\n    }\\n    node.freq++;\\n    freq = this.freqMap.get(node.freq);\\n    if(freq){\\n      freq.set(node.key, node);\\n    }else{\\n      this.freqMap.set(node.freq, new Map([[node.key, node]]));\\n    }\\n  }\\n  return node;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLFUCache.prototype.put = function(key, value) {\\n  if(this.size === 0) return;\\n  let node = this.getNode(key);\\n  if(node){\\n    node.value = value;\\n  }else{\\n    node = {key, value, freq: 1};\\n    if(this.keyMap.size === this.size){\\n      const minFreqMap = this.freqMap.get(this.minFreq);\\n      const oldNode = minFreqMap.values().next().value;\\n      minFreqMap.delete(oldNode.key);\\n      this.keyMap.delete(oldNode.key);\\n      if(minFreqMap.size === 0){\\n        this.freqMap.delete(oldNode.freq);\\n      }\\n    }\\n    const freqOne = this.freqMap.get(1);\\n    if(freqOne){\\n      freqOne.set(node.key, node);\\n    }else{\\n      this.freqMap.set(1, new Map([[node.key, node]]));\\n    }\\n    this.keyMap.set(node.key, node);\\n    this.minFreq = 1;\\n  }\\n};\\n\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 243620,
                "title": "python-lfu-cache",
                "content": "```\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.table = {}\\n        self.freq_bins = {}\\n        self.min_freq = 0\\n        self.capacity = capacity\\n        self.count = 0\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.table:\\n            return -1\\n        \\n        val, freq = self.table[key]\\n        self.table[key] = (val, freq+1)\\n        \\n        freq_bin = self.freq_bins[freq]\\n        freq_bin.remove(key)\\n        \\n        # can be optimized if instead of a list,\\n        # we use an actual LRU cache from here:\\n        # https://leetcode.com/problems/lru-cache/\\n        next_freq_bin = self.freq_bins.get(freq+1, [])\\n        next_freq_bin.insert(0, key)\\n        self.freq_bins[freq+1] = next_freq_bin\\n        \\n        if len(freq_bin) == 0 and freq == self.min_freq:\\n            self.min_freq = freq+1\\n        \\n        return val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.table:\\n            val, freq = self.table[key]\\n            self.table[key] = (value, freq+1)\\n\\n            freq_bin = self.freq_bins[freq]\\n            freq_bin.remove(key)\\n\\n            next_freq_bin = self.freq_bins.get(freq+1, [])\\n            next_freq_bin.insert(0, key)\\n            self.freq_bins[freq+1] = next_freq_bin\\n\\n            if len(freq_bin) == 0 and freq == self.min_freq:\\n                self.min_freq = freq+1\\n\\n            return\\n        \\n        if self.count == self.capacity:\\n            freq_bin = self.freq_bins[self.min_freq]\\n            k = freq_bin.pop()\\n            del self.table[k]\\n            self.count -= 1\\n            \\n        self.table[key] = (value, 1)\\n        self.count += 1\\n        freq_bin = self.freq_bins.get(1, [])\\n        freq_bin.insert(0, key)\\n        self.freq_bins[1] = freq_bin\\n        self.min_freq = 1\\n        return\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.table = {}\\n        self.freq_bins = {}\\n        self.min_freq = 0\\n        self.capacity = capacity\\n        self.count = 0\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.table:\\n            return -1\\n        \\n        val, freq = self.table[key]\\n        self.table[key] = (val, freq+1)\\n        \\n        freq_bin = self.freq_bins[freq]\\n        freq_bin.remove(key)\\n        \\n        # can be optimized if instead of a list,\\n        # we use an actual LRU cache from here:\\n        # https://leetcode.com/problems/lru-cache/\\n        next_freq_bin = self.freq_bins.get(freq+1, [])\\n        next_freq_bin.insert(0, key)\\n        self.freq_bins[freq+1] = next_freq_bin\\n        \\n        if len(freq_bin) == 0 and freq == self.min_freq:\\n            self.min_freq = freq+1\\n        \\n        return val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if self.capacity == 0:\\n            return\\n        \\n        if key in self.table:\\n            val, freq = self.table[key]\\n            self.table[key] = (value, freq+1)\\n\\n            freq_bin = self.freq_bins[freq]\\n            freq_bin.remove(key)\\n\\n            next_freq_bin = self.freq_bins.get(freq+1, [])\\n            next_freq_bin.insert(0, key)\\n            self.freq_bins[freq+1] = next_freq_bin\\n\\n            if len(freq_bin) == 0 and freq == self.min_freq:\\n                self.min_freq = freq+1\\n\\n            return\\n        \\n        if self.count == self.capacity:\\n            freq_bin = self.freq_bins[self.min_freq]\\n            k = freq_bin.pop()\\n            del self.table[k]\\n            self.count -= 1\\n            \\n        self.table[key] = (value, 1)\\n        self.count += 1\\n        freq_bin = self.freq_bins.get(1, [])\\n        freq_bin.insert(0, key)\\n        self.freq_bins[1] = freq_bin\\n        self.min_freq = 1\\n        return\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212202,
                "title": "ac-swift-solution-100",
                "content": "Using the ideas from: [Java O(1) Solution Using Two HashMap and One DoubleLinkedList](https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList)\\n\\n```swift\\nclass LFUCache {\\n    var capacity: Int // cache capacity\\n    var count: Int // count of all nodes in the cache\\n    var min: Int // min reference count among all nodes in the cache\\n    var nodeMap: [Int: DLNode] // key: node\\n    var countMap: [Int: DLList] // count: double linked list\\n\\n    init(_ capacity: Int) {\\n        self.capacity = capacity\\n        self.count = 0\\n        self.min = Int.max\\n        self.nodeMap = [Int: DLNode]()\\n        self.countMap = [Int: DLList]()\\n    }\\n    \\n    func get(_ key: Int) -> Int {\\n        if let node = nodeMap[key] {\\n            updateNode(node)\\n            return node.value\\n        } else {\\n            return -1\\n        }\\n    }\\n    \\n    func put(_ key: Int, _ value: Int) {\\n        guard capacity > 0 else {\\n            return\\n        }\\n        if let node = nodeMap[key] {\\n            node.value = value\\n            updateNode(node)\\n        } else {\\n            // Compare capacity before addition because the new node is guaranteed to evict one of the old nodes.\\n            // And we don\\'t need to worry about min count because it will be set to 1 as later we are adding a new node.\\n            if count == capacity {\\n                if let minList = countMap[min] {\\n                    let removed = minList.removeLast()\\n                    nodeMap[removed.key] = nil\\n                    count -= 1\\n                }\\n            }\\n            let node = DLNode(key, value)\\n            nodeMap[key] = node\\n            if let firstList = countMap[1] {\\n                firstList.add(node)\\n            } else {\\n                countMap[1] = DLList(node)\\n            }\\n            count += 1\\n            min = 1\\n        }\\n    }\\n    \\n    private func updateNode(_ node: DLNode) {\\n        if let list = countMap[node.count] {\\n            list.remove(node)\\n            // If the list after removal is empty, we need to increment `min`.\\n            if node.count == min && list.isEmpty {\\n                min += 1\\n            }\\n            node.count += 1\\n            if let newList = countMap[node.count] {\\n                newList.add(node)\\n            } else {\\n                countMap[node.count] = DLList(node)\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * let obj = LFUCache(capacity)\\n * let ret_1: Int = obj.get(key)\\n * obj.put(key, value)\\n */\\n \\nclass DLNode {\\n    var key: Int\\n    var value: Int\\n    var count: Int\\n    var next: DLNode?\\n    var prev: DLNode?\\n    \\n    init(_ key: Int, _ value: Int) {\\n        self.key = key\\n        self.value = value\\n        self.count = 1\\n    }\\n}\\n\\nclass DLList {\\n    var head: DLNode\\n    var tail: DLNode\\n    \\n    var isEmpty: Bool {\\n        return head.next === tail && tail.prev === head\\n    }\\n    \\n    init(_ node: DLNode) {\\n        self.head = DLNode(0, 0)\\n        self.tail = DLNode(0, 0)\\n        self.head.next = node\\n        node.prev = self.head\\n        node.next = self.tail\\n        self.tail.prev = node\\n    }\\n    \\n    func add(_ node: DLNode) {\\n        node.prev = head\\n        node.next = head.next\\n        head.next?.prev = node\\n        head.next = node\\n    }\\n    \\n    func remove(_ node: DLNode) {\\n        node.prev?.next = node.next\\n        node.next?.prev = node.prev\\n    }\\n    \\n    func removeLast() -> DLNode {\\n        // This node must exist.\\n        let node = tail.prev!\\n        remove(node)\\n        return node\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass LFUCache {\\n    var capacity: Int // cache capacity\\n    var count: Int // count of all nodes in the cache\\n    var min: Int // min reference count among all nodes in the cache\\n    var nodeMap: [Int: DLNode] // key: node\\n    var countMap: [Int: DLList] // count: double linked list\\n\\n    init(_ capacity: Int) {\\n        self.capacity = capacity\\n        self.count = 0\\n        self.min = Int.max\\n        self.nodeMap = [Int: DLNode]()\\n        self.countMap = [Int: DLList]()\\n    }\\n    \\n    func get(_ key: Int) -> Int {\\n        if let node = nodeMap[key] {\\n            updateNode(node)\\n            return node.value\\n        } else {\\n            return -1\\n        }\\n    }\\n    \\n    func put(_ key: Int, _ value: Int) {\\n        guard capacity > 0 else {\\n            return\\n        }\\n        if let node = nodeMap[key] {\\n            node.value = value\\n            updateNode(node)\\n        } else {\\n            // Compare capacity before addition because the new node is guaranteed to evict one of the old nodes.\\n            // And we don\\'t need to worry about min count because it will be set to 1 as later we are adding a new node.\\n            if count == capacity {\\n                if let minList = countMap[min] {\\n                    let removed = minList.removeLast()\\n                    nodeMap[removed.key] = nil\\n                    count -= 1\\n                }\\n            }\\n            let node = DLNode(key, value)\\n            nodeMap[key] = node\\n            if let firstList = countMap[1] {\\n                firstList.add(node)\\n            } else {\\n                countMap[1] = DLList(node)\\n            }\\n            count += 1\\n            min = 1\\n        }\\n    }\\n    \\n    private func updateNode(_ node: DLNode) {\\n        if let list = countMap[node.count] {\\n            list.remove(node)\\n            // If the list after removal is empty, we need to increment `min`.\\n            if node.count == min && list.isEmpty {\\n                min += 1\\n            }\\n            node.count += 1\\n            if let newList = countMap[node.count] {\\n                newList.add(node)\\n            } else {\\n                countMap[node.count] = DLList(node)\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * let obj = LFUCache(capacity)\\n * let ret_1: Int = obj.get(key)\\n * obj.put(key, value)\\n */\\n \\nclass DLNode {\\n    var key: Int\\n    var value: Int\\n    var count: Int\\n    var next: DLNode?\\n    var prev: DLNode?\\n    \\n    init(_ key: Int, _ value: Int) {\\n        self.key = key\\n        self.value = value\\n        self.count = 1\\n    }\\n}\\n\\nclass DLList {\\n    var head: DLNode\\n    var tail: DLNode\\n    \\n    var isEmpty: Bool {\\n        return head.next === tail && tail.prev === head\\n    }\\n    \\n    init(_ node: DLNode) {\\n        self.head = DLNode(0, 0)\\n        self.tail = DLNode(0, 0)\\n        self.head.next = node\\n        node.prev = self.head\\n        node.next = self.tail\\n        self.tail.prev = node\\n    }\\n    \\n    func add(_ node: DLNode) {\\n        node.prev = head\\n        node.next = head.next\\n        head.next?.prev = node\\n        head.next = node\\n    }\\n    \\n    func remove(_ node: DLNode) {\\n        node.prev?.next = node.next\\n        node.next?.prev = node.prev\\n    }\\n    \\n    func removeLast() -> DLNode {\\n        // This node must exist.\\n        let node = tail.prev!\\n        remove(node)\\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193161,
                "title": "reuse-lru-to-implement-lfu-as-wrapper",
                "content": "Ignoring LRU Cache code, LFU cache code is easy to implement in 20 mins.\\nI have used my LRU cache LC problem solution, to implement LFU here. You can use yours!\\n\\nBasic idea is to maintain LRU for each frequency.\\nWhen we get() on LFU cache, if key exists, we move key from one LRU cache to another.\\nWhen we put() on LFU cache, \\ncase 1: Key exists: do get on **LFU** cache and update key\\'s value in LRU cache\\ncase 2: Key does NOT exists: if LRU cache for frequency 1 exists, put the key on that LRU cache, otherwise create one LRU cache for frequency 1 and put.\\n\\n```\\nstruct Node {\\n    int key, val;\\n    Node *next, *prev;\\n    Node(int k = -1, int v = -1) : key(k), val(v) { }\\n};\\n\\nclass LRUCache {\\nprivate:\\n    int capacity, size;\\n    Node *head, *tail;\\n    unordered_map<int, Node*> cache;\\n    \\n    void remove(Node *node) {\\n        node->prev->next = node->next;\\n        node->next->prev = node->prev;\\n        size--;\\n    }\\n    \\n    void addTail(Node *node) {\\n        tail->prev->next = node;\\n        node->prev = tail->prev;\\n        tail->prev = node;\\n        node->next = tail;\\n        ++size;\\n    }\\npublic:\\n    \\n    int evict() {\\n        Node *node = head->next;\\n        remove(node);\\n        int key = node->key;\\n        cache.erase(key);\\n        delete node;\\n        return key;\\n    }\\n    \\n    LRUCache(int capacity) : capacity(capacity), size(0) {\\n        head = new Node();\\n        tail = new Node();\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get_size() {\\n        return size;\\n    }\\n    \\n    int get(int key) {\\n        if (cache.find(key) == cache.end())\\n            return -1;\\n        if (tail->prev != cache[key]) {\\n            remove(cache[key]);\\n            addTail(cache[key]);\\n        }\\n        return cache[key]->val;\\n    }\\n    \\n    \\n    void put(int key, int value) {\\n        if (get(key) != -1) {\\n            // Key is in cache, and also it has been moved to tail\\n            cache[key]->val = value;\\n        } else {\\n            // key is NOT in cache\\n            Node *node = new Node(key, value);\\n            if (size == capacity) {\\n                // Reached full capcity, evict\\n                evict();\\n            }\\n            addTail(node);\\n            cache[key] = node;\\n        }\\n    }\\n    \\n    void remove(int key) {\\n        if(!cache.count(key))\\n            return;\\n        remove(cache[key]);\\n        delete cache[key];\\n        cache.erase(key);\\n    }\\n};\\n\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, LRUCache*> ftoLRU; // freq to LRU cache map;\\n    unordered_map<int, int>       ktof;   // key to freq\\n    int                           minFreq, size, capacity;\\n    \\n    void evict() {\\n        LRUCache *LRU = ftoLRU[minFreq];\\n        cout << \"minFreq:\" << minFreq << endl;\\n        int key = LRU->evict();\\n        if (!LRU->get_size()) {\\n            delete LRU;\\n            ftoLRU.erase(minFreq);\\n            minFreq = 1;\\n        }\\n        ktof.erase(key);\\n        size--;\\n    }\\n    \\npublic:\\n    LFUCache(int capacity) : capacity(capacity), size(0), minFreq(INT_MAX) {\\n        \\n    }\\n    \\n    int get(int key) {\\n        if (size == 0)\\n            return -1;\\n        \\n        int freq = ktof[key];\\n        if (!freq)\\n            return -1;\\n        \\n        LRUCache *oLRU = ftoLRU[freq];\\n        int val = oLRU->get(key);\\n        \\n        oLRU->remove(key);\\n        if (!oLRU->get_size()) {\\n            delete oLRU;\\n            ftoLRU.erase(freq);\\n            if (freq == minFreq)\\n                minFreq = freq + 1;\\n        }\\n        \\n        LRUCache *nLRU;\\n        freq++;\\n        nLRU = (ftoLRU.count(freq)) ? ftoLRU[freq] : new LRUCache(capacity);\\n        nLRU->put(key, val);\\n        ktof[key] = freq;\\n        ftoLRU[freq] = nLRU;\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0)\\n            return;\\n        \\n        int freq = ktof[key];\\n        \\n        if (freq) {\\n            get(key);\\n            LRUCache *LRU = ftoLRU[freq+1];\\n            LRU->put(key, value);\\n        } else {\\n            if (size == capacity) {\\n                evict();\\n            } \\n            freq = 1;\\n            minFreq = min(minFreq, freq);\\n            LRUCache *LRU = (ftoLRU.count(freq)) ? \\n                            ftoLRU[freq] : new LRUCache(capacity);\\n            ftoLRU[freq] = LRU;\\n            LRU->put(key, value);\\n            ktof[key] = freq;\\n            size++;\\n        }  \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int key, val;\\n    Node *next, *prev;\\n    Node(int k = -1, int v = -1) : key(k), val(v) { }\\n};\\n\\nclass LRUCache {\\nprivate:\\n    int capacity, size;\\n    Node *head, *tail;\\n    unordered_map<int, Node*> cache;\\n    \\n    void remove(Node *node) {\\n        node->prev->next = node->next;\\n        node->next->prev = node->prev;\\n        size--;\\n    }\\n    \\n    void addTail(Node *node) {\\n        tail->prev->next = node;\\n        node->prev = tail->prev;\\n        tail->prev = node;\\n        node->next = tail;\\n        ++size;\\n    }\\npublic:\\n    \\n    int evict() {\\n        Node *node = head->next;\\n        remove(node);\\n        int key = node->key;\\n        cache.erase(key);\\n        delete node;\\n        return key;\\n    }\\n    \\n    LRUCache(int capacity) : capacity(capacity), size(0) {\\n        head = new Node();\\n        tail = new Node();\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get_size() {\\n        return size;\\n    }\\n    \\n    int get(int key) {\\n        if (cache.find(key) == cache.end())\\n            return -1;\\n        if (tail->prev != cache[key]) {\\n            remove(cache[key]);\\n            addTail(cache[key]);\\n        }\\n        return cache[key]->val;\\n    }\\n    \\n    \\n    void put(int key, int value) {\\n        if (get(key) != -1) {\\n            // Key is in cache, and also it has been moved to tail\\n            cache[key]->val = value;\\n        } else {\\n            // key is NOT in cache\\n            Node *node = new Node(key, value);\\n            if (size == capacity) {\\n                // Reached full capcity, evict\\n                evict();\\n            }\\n            addTail(node);\\n            cache[key] = node;\\n        }\\n    }\\n    \\n    void remove(int key) {\\n        if(!cache.count(key))\\n            return;\\n        remove(cache[key]);\\n        delete cache[key];\\n        cache.erase(key);\\n    }\\n};\\n\\nclass LFUCache {\\nprivate:\\n    unordered_map<int, LRUCache*> ftoLRU; // freq to LRU cache map;\\n    unordered_map<int, int>       ktof;   // key to freq\\n    int                           minFreq, size, capacity;\\n    \\n    void evict() {\\n        LRUCache *LRU = ftoLRU[minFreq];\\n        cout << \"minFreq:\" << minFreq << endl;\\n        int key = LRU->evict();\\n        if (!LRU->get_size()) {\\n            delete LRU;\\n            ftoLRU.erase(minFreq);\\n            minFreq = 1;\\n        }\\n        ktof.erase(key);\\n        size--;\\n    }\\n    \\npublic:\\n    LFUCache(int capacity) : capacity(capacity), size(0), minFreq(INT_MAX) {\\n        \\n    }\\n    \\n    int get(int key) {\\n        if (size == 0)\\n            return -1;\\n        \\n        int freq = ktof[key];\\n        if (!freq)\\n            return -1;\\n        \\n        LRUCache *oLRU = ftoLRU[freq];\\n        int val = oLRU->get(key);\\n        \\n        oLRU->remove(key);\\n        if (!oLRU->get_size()) {\\n            delete oLRU;\\n            ftoLRU.erase(freq);\\n            if (freq == minFreq)\\n                minFreq = freq + 1;\\n        }\\n        \\n        LRUCache *nLRU;\\n        freq++;\\n        nLRU = (ftoLRU.count(freq)) ? ftoLRU[freq] : new LRUCache(capacity);\\n        nLRU->put(key, val);\\n        ktof[key] = freq;\\n        ftoLRU[freq] = nLRU;\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0)\\n            return;\\n        \\n        int freq = ktof[key];\\n        \\n        if (freq) {\\n            get(key);\\n            LRUCache *LRU = ftoLRU[freq+1];\\n            LRU->put(key, value);\\n        } else {\\n            if (size == capacity) {\\n                evict();\\n            } \\n            freq = 1;\\n            minFreq = min(minFreq, freq);\\n            LRUCache *LRU = (ftoLRU.count(freq)) ? \\n                            ftoLRU[freq] : new LRUCache(capacity);\\n            ftoLRU[freq] = LRU;\\n            LRU->put(key, value);\\n            ktof[key] = freq;\\n            size++;\\n        }  \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 169861,
                "title": "easy-to-write-java-o-1-solution-with-detailed-explanation",
                "content": "`O(1)` solution by using `HashMap` and `LinkedHashSet`, very easy to understand and write.\\nInspired by [this post](https://leetcode.com/problems/lfu-cache/discuss/94521/JAVA-O(1)-very-easy-solution-using-3-HashMaps-and-LinkedHashSet), and added comments for understanding.\\n```\\nclass LFUCache {\\n    // key : cache key\\n    // value : cache value\\n    Map<Integer, Integer> vals;\\n    // key : cache key\\n    // value : how many times the key is used\\n    Map<Integer, Integer> counts;\\n    // key : how many times the key is used\\n    // value : set of keys that have the same count\\n    // LinkedHashSet can add and remove in O(1), and will keep the entries in order, so iterator().next() can return the first added entry (the last used one)\\n    Map<Integer, LinkedHashSet<Integer>> lists;\\n    \\n    int capacity;\\n    // the minimum count that the keys are used, can be used to track the least frequently used key\\n    int minCount;\\n        \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.minCount = 0;\\n        this.vals = new HashMap<>();\\n        this.counts = new HashMap<>();\\n        this.lists = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        // the key does not exist\\n        if (!vals.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        // current count for this key\\n        int count = counts.get(key);\\n        // remove the current count for this key, and possibly update the minCount\\n        LinkedHashSet<Integer> set = lists.get(count);\\n        set.remove(key);\\n        if (set.size() == 0) {\\n            lists.remove(count);\\n            if (count == minCount) {\\n                minCount = count + 1;\\n            }\\n        }\\n        \\n        // update the new count for this key\\n        count++;\\n        counts.put(key, count);\\n        lists.computeIfAbsent(count, k -> new LinkedHashSet<>()).add(key);\\n        \\n        return vals.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        // we cannot save any key if the capacity is 0\\n        if (capacity == 0) {\\n            return;\\n        }\\n        // call get(key) here!!! Since updating the value for a key should also update its count.\\n        if (get(key) != -1) {\\n            vals.put(key, value);\\n            return;\\n        }\\n        \\n        // has reached to the capacity\\n        if (vals.size() == capacity) {\\n            // get and remove the least frequently used key\\n            // using LinkedHashSet can help us to get the least recently used key in O(1)\\n            LinkedHashSet<Integer> set = lists.get(minCount);\\n            int del = set.iterator().next();\\n            vals.remove(del);\\n            counts.remove(del);\\n            set.remove(del);\\n            if (set.size() == 0) {\\n                lists.remove(minCount);\\n            }\\n        }\\n        \\n        // add the key, note that a new key has count 1\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        lists.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);\\n        minCount = 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache {\\n    // key : cache key\\n    // value : cache value\\n    Map<Integer, Integer> vals;\\n    // key : cache key\\n    // value : how many times the key is used\\n    Map<Integer, Integer> counts;\\n    // key : how many times the key is used\\n    // value : set of keys that have the same count\\n    // LinkedHashSet can add and remove in O(1), and will keep the entries in order, so iterator().next() can return the first added entry (the last used one)\\n    Map<Integer, LinkedHashSet<Integer>> lists;\\n    \\n    int capacity;\\n    // the minimum count that the keys are used, can be used to track the least frequently used key\\n    int minCount;\\n        \\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.minCount = 0;\\n        this.vals = new HashMap<>();\\n        this.counts = new HashMap<>();\\n        this.lists = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        // the key does not exist\\n        if (!vals.containsKey(key)) {\\n            return -1;\\n        }\\n        \\n        // current count for this key\\n        int count = counts.get(key);\\n        // remove the current count for this key, and possibly update the minCount\\n        LinkedHashSet<Integer> set = lists.get(count);\\n        set.remove(key);\\n        if (set.size() == 0) {\\n            lists.remove(count);\\n            if (count == minCount) {\\n                minCount = count + 1;\\n            }\\n        }\\n        \\n        // update the new count for this key\\n        count++;\\n        counts.put(key, count);\\n        lists.computeIfAbsent(count, k -> new LinkedHashSet<>()).add(key);\\n        \\n        return vals.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        // we cannot save any key if the capacity is 0\\n        if (capacity == 0) {\\n            return;\\n        }\\n        // call get(key) here!!! Since updating the value for a key should also update its count.\\n        if (get(key) != -1) {\\n            vals.put(key, value);\\n            return;\\n        }\\n        \\n        // has reached to the capacity\\n        if (vals.size() == capacity) {\\n            // get and remove the least frequently used key\\n            // using LinkedHashSet can help us to get the least recently used key in O(1)\\n            LinkedHashSet<Integer> set = lists.get(minCount);\\n            int del = set.iterator().next();\\n            vals.remove(del);\\n            counts.remove(del);\\n            set.remove(del);\\n            if (set.size() == 0) {\\n                lists.remove(minCount);\\n            }\\n        }\\n        \\n        // add the key, note that a new key has count 1\\n        vals.put(key, value);\\n        counts.put(key, 1);\\n        lists.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);\\n        minCount = 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126602,
                "title": "two-hashmap-linkedhashset",
                "content": "Top answer needs three hashmap, we can use a class node to make it only need two hashmap:\\n\\n```\\nclass Node {\\n        int key, val, cnt;\\n        Node prev, next;\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            cnt = 1;\\n        }\\n    }\\n\\n\\npublic class LFUCache {\\n    int capacity, size, min;\\n    Map<Integer, Node> nodeMap;\\n    Map<Integer, LinkedHashSet<Integer>> countMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        nodeMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!nodeMap.containsKey(key)) return -1;\\n        Node node = nodeMap.get(key);\\n        update(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        Node node;\\n        if (nodeMap.containsKey(key)) {\\n            node = nodeMap.get(key);\\n            node.val = value;\\n            update(node);\\n        }\\n        else {\\n            node = new Node(key, value);\\n            nodeMap.put(key, node);\\n            if (size == capacity) {\\n                LinkedHashSet<Integer> set = countMap.get(min);\\n                int last = set.iterator().next();\\n                nodeMap.remove(last);\\n                set.remove(last);\\n                size--;\\n            }\\n            size++;\\n            min = 1;\\n            LinkedHashSet<Integer> newSet = countMap.getOrDefault(node.cnt, new LinkedHashSet<>());\\n            newSet.add(node.key);\\n            countMap.put(node.cnt, newSet);\\n        }\\n    }\\n    \\n    private void update(Node node) {\\n        LinkedHashSet<Integer> set = countMap.get(node.cnt);\\n        set.remove(node.key);\\n        if (node.cnt == min && set.size() == 0) min++; \\n        node.cnt++;\\n        LinkedHashSet<Integer> newSet = countMap.getOrDefault(node.cnt, new LinkedHashSet());\\n        newSet.add(node.key);\\n        countMap.put(node.cnt, newSet);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n        int key, val, cnt;\\n        Node prev, next;\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            cnt = 1;\\n        }\\n    }\\n\\n\\npublic class LFUCache {\\n    int capacity, size, min;\\n    Map<Integer, Node> nodeMap;\\n    Map<Integer, LinkedHashSet<Integer>> countMap;\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        nodeMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (!nodeMap.containsKey(key)) return -1;\\n        Node node = nodeMap.get(key);\\n        update(node);\\n        return node.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        Node node;\\n        if (nodeMap.containsKey(key)) {\\n            node = nodeMap.get(key);\\n            node.val = value;\\n            update(node);\\n        }\\n        else {\\n            node = new Node(key, value);\\n            nodeMap.put(key, node);\\n            if (size == capacity) {\\n                LinkedHashSet<Integer> set = countMap.get(min);\\n                int last = set.iterator().next();\\n                nodeMap.remove(last);\\n                set.remove(last);\\n                size--;\\n            }\\n            size++;\\n            min = 1;\\n            LinkedHashSet<Integer> newSet = countMap.getOrDefault(node.cnt, new LinkedHashSet<>());\\n            newSet.add(node.key);\\n            countMap.put(node.cnt, newSet);\\n        }\\n    }\\n    \\n    private void update(Node node) {\\n        LinkedHashSet<Integer> set = countMap.get(node.cnt);\\n        set.remove(node.key);\\n        if (node.cnt == min && set.size() == 0) min++; \\n        node.cnt++;\\n        LinkedHashSet<Integer> newSet = countMap.getOrDefault(node.cnt, new LinkedHashSet());\\n        newSet.add(node.key);\\n        countMap.put(node.cnt, newSet);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121881,
                "title": "clear-python-two-dictionary-with-doubly-linked-list-solution",
                "content": "```\\nclass Node(object):\\n    def __init__(self, k, v):\\n        self.prev = None\\n        self.next = None\\n        self.key = k\\n        self.val = v\\n        self.cnt = 1\\n\\nclass DoublyLinkedList(object):\\n    def __init__(self):\\n        self.head = Node(0, 0) # head is a dummy head node\\n        self.tail = Node(0, 0) # tail is a dummy tail node\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n\\n    def add_to_head(self, node):\\n        node.next = self.head.next\\n        self.head.next.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n        self.size += 1\\n\\n    def remove_tail(self):\\n        old_tail = self.tail.prev\\n        node = self.tail.prev\\n        node.prev.next = self.tail\\n        self.tail.prev = node.prev\\n        self.size -= 1\\n        return old_tail\\n\\n    def remove_node(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self.size -= 1\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.node_dict = {}\\n        self.freq_dict = collections.defaultdict(DoublyLinkedList)\\n        self.capacity = capacity\\n        self.size = 0\\n        self.min_freq = 0\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.node_dict:\\n            return -1\\n        else:\\n            node = self.node_dict[key]\\n            old_cnt = node.cnt\\n            node.cnt += 1\\n            self.freq_dict[old_cnt].remove_node(node)\\n            self.freq_dict[node.cnt].add_to_head(node)\\n            if old_cnt == self.min_freq and self.freq_dict[old_cnt].size == 0:\\n                self.min_freq += 1\\n            return node.val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.capacity <= 0:\\n            return\\n        if key not in self.node_dict:\\n            node = Node(key, value)\\n            self.node_dict[key] = node\\n            if self.size != self.capacity:\\n                self.freq_dict[1].add_to_head(node)\\n                self.size += 1\\n            else:\\n                old_tail = self.freq_dict[self.min_freq].remove_tail()\\n                self.node_dict.pop(old_tail.key)\\n                self.freq_dict[1].add_to_head(node)\\n            self.min_freq = 1\\n        else:\\n            node = self.node_dict[key]\\n            node.val = value\\n            old_cnt = node.cnt\\n            node.cnt += 1\\n            self.freq_dict[old_cnt].remove_node(node)\\n            self.freq_dict[node.cnt].add_to_head(node)\\n            if old_cnt == self.min_freq and self.freq_dict[old_cnt].size == 0:\\n                self.min_freq += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self, k, v):\\n        self.prev = None\\n        self.next = None\\n        self.key = k\\n        self.val = v\\n        self.cnt = 1\\n\\nclass DoublyLinkedList(object):\\n    def __init__(self):\\n        self.head = Node(0, 0) # head is a dummy head node\\n        self.tail = Node(0, 0) # tail is a dummy tail node\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.size = 0\\n\\n    def add_to_head(self, node):\\n        node.next = self.head.next\\n        self.head.next.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n        self.size += 1\\n\\n    def remove_tail(self):\\n        old_tail = self.tail.prev\\n        node = self.tail.prev\\n        node.prev.next = self.tail\\n        self.tail.prev = node.prev\\n        self.size -= 1\\n        return old_tail\\n\\n    def remove_node(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self.size -= 1\\n\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.node_dict = {}\\n        self.freq_dict = collections.defaultdict(DoublyLinkedList)\\n        self.capacity = capacity\\n        self.size = 0\\n        self.min_freq = 0\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.node_dict:\\n            return -1\\n        else:\\n            node = self.node_dict[key]\\n            old_cnt = node.cnt\\n            node.cnt += 1\\n            self.freq_dict[old_cnt].remove_node(node)\\n            self.freq_dict[node.cnt].add_to_head(node)\\n            if old_cnt == self.min_freq and self.freq_dict[old_cnt].size == 0:\\n                self.min_freq += 1\\n            return node.val\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.capacity <= 0:\\n            return\\n        if key not in self.node_dict:\\n            node = Node(key, value)\\n            self.node_dict[key] = node\\n            if self.size != self.capacity:\\n                self.freq_dict[1].add_to_head(node)\\n                self.size += 1\\n            else:\\n                old_tail = self.freq_dict[self.min_freq].remove_tail()\\n                self.node_dict.pop(old_tail.key)\\n                self.freq_dict[1].add_to_head(node)\\n            self.min_freq = 1\\n        else:\\n            node = self.node_dict[key]\\n            node.val = value\\n            old_cnt = node.cnt\\n            node.cnt += 1\\n            self.freq_dict[old_cnt].remove_node(node)\\n            self.freq_dict[node.cnt].add_to_head(node)\\n            if old_cnt == self.min_freq and self.freq_dict[old_cnt].size == 0:\\n                self.min_freq += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94525,
                "title": "concise-solution-with-frequency-bucket-with-comments",
                "content": "```cpp\\nclass LFUCache {\\n\\nprivate:\\n    int _cap;     // cache capacity\\n    int _minFreq; // min frequency\\n    unordered_map<int, list<int>> _f2klist;         // frequency -> key list\\n    unordered_map<int, list<int>::iterator> _k2pos; // key       -> iterator in key list\\n    unordered_map<int, pair<int, int>> _k2vf;       // key       -> (val, frequency)\\n    \\npublic:\\n    LFUCache(int capacity):_cap(capacity), _minFreq(0) { }\\n    \\n    int get(int key) \\n    {\\n        if (!_k2pos.count(key)) return -1;\\n        \\n        // increment existing key's frequency by 1\\n        int freq = _k2vf[key].second++;\\n        _f2klist[freq].erase(_k2pos[key]);\\n        _f2klist[freq+1].push_back(key);\\n        _k2pos[key] = --_f2klist[freq+1].end();\\n        \\n        // update min freq\\n        if (_f2klist[_minFreq].empty()) _f2klist.erase(_minFreq++);\\n        \\n        return _k2vf[key].first;\\n    }\\n    \\n    void put(int key, int value) \\n    {\\n        if (_cap <= 0) return;\\n        \\n        // update existing key's value\\n        if (get(key) != -1) {\\n            _k2vf[key].first = value;\\n            return;\\n        }\\n \\n        // evict oldest min freq key if reach capacity\\n        if (_k2vf.size() == _cap) { \\n            int k = _f2klist[_minFreq].front(); // key to evict\\n            _k2pos.erase(k);\\n            _k2vf.erase(k);\\n            _f2klist[_minFreq].pop_front();\\n            if (_f2klist[_minFreq].empty()) _f2klist.erase(_minFreq);\\n        }\\n        \\n        // insert new key with freq=1\\n        _k2vf[key] = {value, 1};\\n        _f2klist[_minFreq = 1].push_back(key);\\n        _k2pos[key] = --_f2klist[1].end();        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass LFUCache {\\n\\nprivate:\\n    int _cap;     // cache capacity\\n    int _minFreq; // min frequency\\n    unordered_map<int, list<int>> _f2klist;         // frequency -> key list\\n    unordered_map<int, list<int>::iterator> _k2pos; // key       -> iterator in key list\\n    unordered_map<int, pair<int, int>> _k2vf;       // key       -> (val, frequency)\\n    \\npublic:\\n    LFUCache(int capacity):_cap(capacity), _minFreq(0) { }\\n    \\n    int get(int key) \\n    {\\n        if (!_k2pos.count(key)) return -1;\\n        \\n        // increment existing key's frequency by 1\\n        int freq = _k2vf[key].second++;\\n        _f2klist[freq].erase(_k2pos[key]);\\n        _f2klist[freq+1].push_back(key);\\n        _k2pos[key] = --_f2klist[freq+1].end();\\n        \\n        // update min freq\\n        if (_f2klist[_minFreq].empty()) _f2klist.erase(_minFreq++);\\n        \\n        return _k2vf[key].first;\\n    }\\n    \\n    void put(int key, int value) \\n    {\\n        if (_cap <= 0) return;\\n        \\n        // update existing key's value\\n        if (get(key) != -1) {\\n            _k2vf[key].first = value;\\n            return;\\n        }\\n \\n        // evict oldest min freq key if reach capacity\\n        if (_k2vf.size() == _cap) { \\n            int k = _f2klist[_minFreq].front(); // key to evict\\n            _k2pos.erase(k);\\n            _k2vf.erase(k);\\n            _f2klist[_minFreq].pop_front();\\n            if (_f2klist[_minFreq].empty()) _f2klist.erase(_minFreq);\\n        }\\n        \\n        // insert new key with freq=1\\n        _k2vf[key] = {value, 1};\\n        _f2klist[_minFreq = 1].push_back(key);\\n        _k2pos[key] = --_f2klist[1].end();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94549,
                "title": "python-o-1-solution-using-two-dictionary-double-linked-list",
                "content": "Inspired by @xiyayan 's solution [here](https://discuss.leetcode.com/topic/73499/concise-python-o-1-beats-95-using-two-maps/8)\\n\\nSome notes:\\nkeymap = { key : node }\\nfremap = { fre : root }, root is circular linked list that connects to self at the beginning. Hence root.next is the head of the list (oldest node, to be removed) and root.prev is the last (newest, to be removed)\\n\\nIf it is LRU problem, we can remove fremap but only the double linked list.\\n\\n```\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.keymap = {}\\n        self.fremap = {}\\n        self.minfre = 1\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.keymap:\\n            return -1\\n        else:\\n            node = self.keymap[key]\\n            node.fre += 1\\n            self.ddRemove(node)\\n            if self.fremap[self.minfre].next is self.fremap[self.minfre]:\\n                self.minfre += 1\\n            root = self.fremap.setdefault(node.fre, DoubleListNode(None, None))\\n            self.ddAddToTail(node, root)\\n            return node.value\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0: return\\n        if key in self.keymap:\\n            self.keymap[key].value = value\\n            self.get(key)\\n        else:\\n            if len(self.keymap) == self.cap:\\n                root = self.fremap[self.minfre]\\n                keytbd = root.next.key\\n                self.ddRemove(root.next)\\n                del self.keymap[keytbd]\\n            node, self.minfre = DoubleListNode(key, value), 1\\n            root = self.fremap.setdefault(self.minfre, DoubleListNode(None, None))\\n            self.ddAddToTail(node, root)\\n            self.keymap[key] = node\\n\\n                \\n    def ddRemove(self, node):\\n        n1, n2 = node.prev, node.next\\n        n1.next, n2.prev = n2, n1\\n        node.prev, node.next = None, None\\n\\n        \\n    def ddAddToTail(self, node, tail):\\n        n1, n2 = tail.prev, tail\\n        node.prev, node.next = n1, n2\\n        n1.next, n2.prev = node, node\\n\\nclass DoubleListNode(object):\\n    def __init__(self, key, value):\\n        self.fre = 1\\n        self.key = key\\n        self.value = value\\n        self.prev = self\\n        self.next = self\\n```",
                "solutionTags": [],
                "code": "```\\nclass LFUCache(object):\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.keymap = {}\\n        self.fremap = {}\\n        self.minfre = 1\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.keymap:\\n            return -1\\n        else:\\n            node = self.keymap[key]\\n            node.fre += 1\\n            self.ddRemove(node)\\n            if self.fremap[self.minfre].next is self.fremap[self.minfre]:\\n                self.minfre += 1\\n            root = self.fremap.setdefault(node.fre, DoubleListNode(None, None))\\n            self.ddAddToTail(node, root)\\n            return node.value\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if self.cap == 0: return\\n        if key in self.keymap:\\n            self.keymap[key].value = value\\n            self.get(key)\\n        else:\\n            if len(self.keymap) == self.cap:\\n                root = self.fremap[self.minfre]\\n                keytbd = root.next.key\\n                self.ddRemove(root.next)\\n                del self.keymap[keytbd]\\n            node, self.minfre = DoubleListNode(key, value), 1\\n            root = self.fremap.setdefault(self.minfre, DoubleListNode(None, None))\\n            self.ddAddToTail(node, root)\\n            self.keymap[key] = node\\n\\n                \\n    def ddRemove(self, node):\\n        n1, n2 = node.prev, node.next\\n        n1.next, n2.prev = n2, n1\\n        node.prev, node.next = None, None\\n\\n        \\n    def ddAddToTail(self, node, tail):\\n        n1, n2 = tail.prev, tail\\n        node.prev, node.next = n1, n2\\n        n1.next, n2.prev = node, node\\n\\nclass DoubleListNode(object):\\n    def __init__(self, key, value):\\n        self.fre = 1\\n        self.key = key\\n        self.value = value\\n        self.prev = self\\n        self.next = self\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812959,
                "title": "c-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is similar to the LRU cache problem. The main difference is that we will need to keep a count variable with in the node to store the frequency of a key and a minimum count variable to store the minimum frequency. The minmum count should be updated whenever the frequency of the last element with that frequency is either changed, or when a new element is added.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use two hashmaps: keyNodeMap to keep track of key-node pairs, and countListMap for count-List pairs. \\n\\nThe Lists in countListMap will have a dummy head and a dummy tail, which will be used for adding new Nodes, checking if the List is empty, and deleting the last Nodes.\\n\\nWhen a new node is created, it will be inserted in the countListMap with count 1, and the minCount will be set to 1.\\n\\nWhen the frequency of a key changes, it is removed from the its current list and added into the List whose count = count+1. If such a list does not exist, it is created at that time.\\n\\nIn this method the same node is passed between different lists, instead of deleting a node and creating a new node with the same key, hence eliminating the need to create a new keyNode pair for each operation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n    class Node{\\n        public:\\n            int key;\\n            int val;\\n            int cnt;\\n            Node * next;\\n            Node * prev;\\n            Node(int key,int val)\\n            {\\n                this->key=key;\\n                this->val=val;\\n                this->cnt=1;\\n            }\\n    };\\n\\n    class List{\\n        public:\\n        Node * head;\\n        Node * tail;\\n        List()\\n        {\\n            head=new Node(-1,-1);\\n            tail= new Node(-1,-1);\\n            head->next=tail;\\n            tail->prev=head;\\n        }\\n    };\\n\\n    Node *head= new Node(-1,-1);\\n    Node *tail= new Node(-1,-1);\\n    int size;\\n    int minCount;\\n    unordered_map <int, Node*> keyNodeMap;\\n    unordered_map <int, List *> countListMap;\\n\\n    LFUCache(int capacity) {\\n        size=capacity;\\n    }\\n    void addNode(Node * head,Node * newnode)\\n    {\\n        Node * temp=head->next;\\n        head->next=newnode;\\n        newnode->prev=head;\\n\\n        temp->prev=newnode;\\n        newnode->next=temp;\\n    }\\n\\n    void deleteNode(Node * delnode)\\n    {\\n        Node *nextt=delnode->next;\\n        Node *prevv=delnode->prev;\\n        \\n        prevv->next=nextt;\\n        nextt->prev=prevv;\\n    }\\n    int get(int key) {\\n        if(keyNodeMap.find(key)==keyNodeMap.end())\\n            return -1;\\n        else\\n            {\\n                Node * resNode = keyNodeMap[key];\\n                deleteNode(resNode);\\n                if(resNode->cnt==minCount && countListMap[resNode->cnt]->head->next==countListMap[resNode->cnt]->tail )\\n                    minCount++;\\n                resNode->cnt++;\\n                if(countListMap.find(resNode->cnt)==countListMap.end())\\n                {   List * newList = new List;\\n                    countListMap[resNode->cnt]=newList;\\n                }\\n                addNode(countListMap[resNode->cnt]->head,resNode);\\n                return resNode->val;\\n            }\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        if(keyNodeMap.find(key)!=keyNodeMap.end())\\n        {\\n            keyNodeMap[key]->val=value;\\n            get(key);\\n        }\\n        else\\n        {\\n            if(keyNodeMap.size()==size)\\n            {   \\n                Node * delNode=countListMap[minCount]->tail->prev;\\n                keyNodeMap.erase(delNode->key);\\n                deleteNode(delNode);\\n            }\\n            Node * newNode = new Node(key,value);\\n            keyNodeMap[key]=newNode;\\n            if(countListMap.find(newNode->cnt)==countListMap.end())\\n                {   List * newList = new List;\\n                    countListMap[newNode->cnt]=newList;\\n                }\\n            addNode(countListMap[newNode->cnt]->head,newNode);\\n            minCount=1;\\n            \\n        }\\n    }\\n};\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    class Node{\\n        public:\\n            int key;\\n            int val;\\n            int cnt;\\n            Node * next;\\n            Node * prev;\\n            Node(int key,int val)\\n            {\\n                this->key=key;\\n                this->val=val;\\n                this->cnt=1;\\n            }\\n    };\\n\\n    class List{\\n        public:\\n        Node * head;\\n        Node * tail;\\n        List()\\n        {\\n            head=new Node(-1,-1);\\n            tail= new Node(-1,-1);\\n            head->next=tail;\\n            tail->prev=head;\\n        }\\n    };\\n\\n    Node *head= new Node(-1,-1);\\n    Node *tail= new Node(-1,-1);\\n    int size;\\n    int minCount;\\n    unordered_map <int, Node*> keyNodeMap;\\n    unordered_map <int, List *> countListMap;\\n\\n    LFUCache(int capacity) {\\n        size=capacity;\\n    }\\n    void addNode(Node * head,Node * newnode)\\n    {\\n        Node * temp=head->next;\\n        head->next=newnode;\\n        newnode->prev=head;\\n\\n        temp->prev=newnode;\\n        newnode->next=temp;\\n    }\\n\\n    void deleteNode(Node * delnode)\\n    {\\n        Node *nextt=delnode->next;\\n        Node *prevv=delnode->prev;\\n        \\n        prevv->next=nextt;\\n        nextt->prev=prevv;\\n    }\\n    int get(int key) {\\n        if(keyNodeMap.find(key)==keyNodeMap.end())\\n            return -1;\\n        else\\n            {\\n                Node * resNode = keyNodeMap[key];\\n                deleteNode(resNode);\\n                if(resNode->cnt==minCount && countListMap[resNode->cnt]->head->next==countListMap[resNode->cnt]->tail )\\n                    minCount++;\\n                resNode->cnt++;\\n                if(countListMap.find(resNode->cnt)==countListMap.end())\\n                {   List * newList = new List;\\n                    countListMap[resNode->cnt]=newList;\\n                }\\n                addNode(countListMap[resNode->cnt]->head,resNode);\\n                return resNode->val;\\n            }\\n\\n    }\\n    \\n    void put(int key, int value) {\\n        if(keyNodeMap.find(key)!=keyNodeMap.end())\\n        {\\n            keyNodeMap[key]->val=value;\\n            get(key);\\n        }\\n        else\\n        {\\n            if(keyNodeMap.size()==size)\\n            {   \\n                Node * delNode=countListMap[minCount]->tail->prev;\\n                keyNodeMap.erase(delNode->key);\\n                deleteNode(delNode);\\n            }\\n            Node * newNode = new Node(key,value);\\n            keyNodeMap[key]=newNode;\\n            if(countListMap.find(newNode->cnt)==countListMap.end())\\n                {   List * newList = new List;\\n                    countListMap[newNode->cnt]=newList;\\n                }\\n            addNode(countListMap[newNode->cnt]->head,newNode);\\n            minCount=1;\\n            \\n        }\\n    }\\n};\\n\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115527,
                "title": "python3-solution-using-linked-lists-and-hashmap",
                "content": "# Approach\\n![image.png](https://assets.leetcode.com/users/images/5d593896-937e-456e-bfe1-40795d275fcf_1675036397.7166142.png)\\nThis is how it looks like. We have \\'nested\\' linked lists. One linked list is used for frequency levels holding. Inner one is for holding nodes sorted by updating time. Also we have map for quick getting values by key.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Node:\\n\\n    def __init__(self, key, val, freq_node):\\n        self.key = key\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.freq_node = freq_node\\n\\n    def __str__(self):\\n        res = \\'\\'\\n        if self.right:\\n            res += str(self.right) + \\' => \\'\\n        res += str(self.key)\\n        return res\\n\\n\\nclass FreqNode:\\n\\n    def __init__(self):\\n        self.upper = None\\n        self.lower = None\\n        self.first_val_node = None\\n        self.last_val_node = None\\n\\n    def add_val(self, val_node):\\n        if self.first_val_node is None:\\n            self.first_val_node = val_node\\n            self.last_val_node = val_node\\n        else:\\n            self.first_val_node.left = val_node\\n            val_node.right = self.first_val_node\\n            self.first_val_node = val_node\\n\\n    def pop_last(self):\\n        if self.empty():\\n            return None\\n\\n        result = (self.last_val_node.key, self.last_val_node.val)\\n        if self.last_val_node.left is not None:\\n            self.last_val_node = self.last_val_node.left\\n            self.last_val_node.right = None\\n            return result\\n        else:\\n            self.last_val_node = None\\n            self.first_val_node = None\\n        return result\\n\\n    def pop_first(self):\\n        if self.empty():\\n            return None\\n\\n        result = (self.first_val_node.key, self.first_val_node.val)\\n        if self.first_val_node.right is not None:\\n            self.first_val_node = self.first_val_node.right\\n            self.first_val_node.left = None\\n            return result\\n        else:\\n            self.last_val_node = None\\n            self.first_val_node = None\\n        return result\\n\\n    def del_node(self, node):\\n        if self.first_val_node == node:\\n            self.pop_first()\\n        elif self.last_val_node == node:\\n            self.pop_last()\\n        else:\\n            node.left.right = node.right\\n            node.right.left = node.left\\n\\n    def empty(self):\\n        if self.first_val_node is None:\\n            return True\\n        return False\\n\\n    def __str__(self):\\n        return str(self.first_val_node)\\n\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.map = {}\\n        self.lower_freq = FreqNode()\\n        self.higher_freq = self.lower_freq\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.map:\\n            return -1\\n        node = self.map[key]\\n        self._update_node(node)\\n        return node.val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        if key not in self.map:\\n            if len(self.map) == self.capacity:\\n                freq_node = self.lower_freq\\n                while freq_node.empty():\\n                    freq_node = freq_node.upper\\n                del self.map[freq_node.pop_last()[0]]\\n            self.map[key] = Node(key, value, self.lower_freq)\\n            self.lower_freq.add_val(self.map[key])\\n        else:\\n            self.map[key].val = value\\n            self._update_node(self.map[key])\\n\\n    def _update_node(self, node):\\n        if node.freq_node is self.higher_freq:\\n            self.higher_freq.upper = FreqNode()\\n            self.higher_freq = self.higher_freq.upper\\n        node.freq_node.del_node(node)\\n        node.left = None\\n        node.right = None\\n        node.freq_node.upper.add_val(node)\\n        node.freq_node = node.freq_node.upper\\n\\n    def __str__(self):\\n        s = \\' *\\'\\n        freq = self.lower_freq\\n        rank = 0\\n        while freq:\\n            rank += 1\\n            s += \\'\\\\n| | \\\\n[\\' + str(rank) + \\']\\'\\n            if not freq.empty():\\n                s += \\' => \\' + str(freq)\\n            freq = freq.upper\\n        return s\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n\\n    def __init__(self, key, val, freq_node):\\n        self.key = key\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.freq_node = freq_node\\n\\n    def __str__(self):\\n        res = \\'\\'\\n        if self.right:\\n            res += str(self.right) + \\' => \\'\\n        res += str(self.key)\\n        return res\\n\\n\\nclass FreqNode:\\n\\n    def __init__(self):\\n        self.upper = None\\n        self.lower = None\\n        self.first_val_node = None\\n        self.last_val_node = None\\n\\n    def add_val(self, val_node):\\n        if self.first_val_node is None:\\n            self.first_val_node = val_node\\n            self.last_val_node = val_node\\n        else:\\n            self.first_val_node.left = val_node\\n            val_node.right = self.first_val_node\\n            self.first_val_node = val_node\\n\\n    def pop_last(self):\\n        if self.empty():\\n            return None\\n\\n        result = (self.last_val_node.key, self.last_val_node.val)\\n        if self.last_val_node.left is not None:\\n            self.last_val_node = self.last_val_node.left\\n            self.last_val_node.right = None\\n            return result\\n        else:\\n            self.last_val_node = None\\n            self.first_val_node = None\\n        return result\\n\\n    def pop_first(self):\\n        if self.empty():\\n            return None\\n\\n        result = (self.first_val_node.key, self.first_val_node.val)\\n        if self.first_val_node.right is not None:\\n            self.first_val_node = self.first_val_node.right\\n            self.first_val_node.left = None\\n            return result\\n        else:\\n            self.last_val_node = None\\n            self.first_val_node = None\\n        return result\\n\\n    def del_node(self, node):\\n        if self.first_val_node == node:\\n            self.pop_first()\\n        elif self.last_val_node == node:\\n            self.pop_last()\\n        else:\\n            node.left.right = node.right\\n            node.right.left = node.left\\n\\n    def empty(self):\\n        if self.first_val_node is None:\\n            return True\\n        return False\\n\\n    def __str__(self):\\n        return str(self.first_val_node)\\n\\n\\nclass LFUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.map = {}\\n        self.lower_freq = FreqNode()\\n        self.higher_freq = self.lower_freq\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.map:\\n            return -1\\n        node = self.map[key]\\n        self._update_node(node)\\n        return node.val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self.capacity == 0:\\n            return\\n        if key not in self.map:\\n            if len(self.map) == self.capacity:\\n                freq_node = self.lower_freq\\n                while freq_node.empty():\\n                    freq_node = freq_node.upper\\n                del self.map[freq_node.pop_last()[0]]\\n            self.map[key] = Node(key, value, self.lower_freq)\\n            self.lower_freq.add_val(self.map[key])\\n        else:\\n            self.map[key].val = value\\n            self._update_node(self.map[key])\\n\\n    def _update_node(self, node):\\n        if node.freq_node is self.higher_freq:\\n            self.higher_freq.upper = FreqNode()\\n            self.higher_freq = self.higher_freq.upper\\n        node.freq_node.del_node(node)\\n        node.left = None\\n        node.right = None\\n        node.freq_node.upper.add_val(node)\\n        node.freq_node = node.freq_node.upper\\n\\n    def __str__(self):\\n        s = \\' *\\'\\n        freq = self.lower_freq\\n        rank = 0\\n        while freq:\\n            rank += 1\\n            s += \\'\\\\n| | \\\\n[\\' + str(rank) + \\']\\'\\n            if not freq.empty():\\n                s += \\' => \\' + str(freq)\\n            freq = freq.upper\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115321,
                "title": "easy-clean-java-solution-without-dll-explanation-included",
                "content": "\\n\\n# Code\\n```\\nclass LFUCache {\\n    /**\\n     * Instead of using DLL we have used LinkedHashSet for the easier implementation.\\n     * Removal of an element from LinkedHashSet takes O(1)\\n     * Insertion of an element from LinkedHashSet takes O(1)\\n     * And also it preserves the insertion order, unlike hashset\\n     */\\n    private int capacity = 0;\\n\\n    private int minFreq = 0;\\n    /**\\n     * Stores key and its respective value\\n     */\\n    private HashMap<Integer, Integer> keyToValueMap;\\n    /**\\n     * Stores key and its respective freq\\n     */\\n    private HashMap<Integer, Integer> keyToFreqMap;\\n    /**\\n     * Stores freq and its associated values\\n     */\\n    private HashMap<Integer, LinkedHashSet<Integer>> freqToListMap;\\n\\n    public LFUCache(int capacity) {\\n        /**\\n         * Initialize all the instance variables here\\n         */\\n        this.capacity = capacity;\\n        minFreq = 0;\\n        keyToValueMap = new HashMap<>();\\n        keyToFreqMap = new HashMap<>();\\n        freqToListMap = new HashMap<>();\\n    }\\n\\n    public int get(int key) {\\n        /**\\n         * If the value is not in the keyToValueMap return -1\\n         */\\n        if (!keyToValueMap.containsKey(key)) return -1;\\n        /**\\n         * Get the current freq of the key\\n         */\\n        int currentFreq = keyToFreqMap.get(key);\\n        /**\\n         * Since we have to increase the freq remove the element from current freq list\\n         */\\n        freqToListMap.get(currentFreq).remove(key);\\n        /**\\n         * If all the elements from the min freq are removed, update the minFreq\\n         */\\n        if (currentFreq == minFreq && freqToListMap.get(currentFreq).isEmpty()) {\\n            minFreq++;\\n            freqToListMap.remove(currentFreq);\\n        }\\n        freqToListMap.putIfAbsent(currentFreq + 1, new LinkedHashSet<>());\\n        freqToListMap.get(currentFreq + 1).add(key);\\n        keyToFreqMap.put(key, currentFreq + 1);\\n        return keyToValueMap.get(key);\\n\\n    }\\n\\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (keyToValueMap.containsKey(key)) {\\n            keyToValueMap.put(key, value);\\n            get(key);\\n            return;\\n        }\\n\\n        /**\\n         * If the capacity is equal to keyToValueMap size\\n         */\\n        if (capacity == this.keyToValueMap.size()) {\\n            /**\\n             * Remove the LRU element from the list\\n             */\\n            if (freqToListMap.get(minFreq).iterator().hasNext()) {\\n                int valueToRemove = freqToListMap.get(minFreq).iterator().next();\\n                System.out.println();\\n                freqToListMap.get(minFreq).remove(valueToRemove);\\n                keyToValueMap.remove(valueToRemove);\\n                keyToFreqMap.remove(valueToRemove);\\n            }\\n\\n\\n        }\\n        minFreq = 1;\\n        freqToListMap.putIfAbsent(minFreq, new LinkedHashSet<>());\\n        freqToListMap.get(minFreq).add(key);\\n        keyToFreqMap.put(key, minFreq);\\n        keyToValueMap.put(key, value);\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/ada466e3-0549-4c3d-b417-f0b840882fc5_1675027752.1356936.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LFUCache {\\n    /**\\n     * Instead of using DLL we have used LinkedHashSet for the easier implementation.\\n     * Removal of an element from LinkedHashSet takes O(1)\\n     * Insertion of an element from LinkedHashSet takes O(1)\\n     * And also it preserves the insertion order, unlike hashset\\n     */\\n    private int capacity = 0;\\n\\n    private int minFreq = 0;\\n    /**\\n     * Stores key and its respective value\\n     */\\n    private HashMap<Integer, Integer> keyToValueMap;\\n    /**\\n     * Stores key and its respective freq\\n     */\\n    private HashMap<Integer, Integer> keyToFreqMap;\\n    /**\\n     * Stores freq and its associated values\\n     */\\n    private HashMap<Integer, LinkedHashSet<Integer>> freqToListMap;\\n\\n    public LFUCache(int capacity) {\\n        /**\\n         * Initialize all the instance variables here\\n         */\\n        this.capacity = capacity;\\n        minFreq = 0;\\n        keyToValueMap = new HashMap<>();\\n        keyToFreqMap = new HashMap<>();\\n        freqToListMap = new HashMap<>();\\n    }\\n\\n    public int get(int key) {\\n        /**\\n         * If the value is not in the keyToValueMap return -1\\n         */\\n        if (!keyToValueMap.containsKey(key)) return -1;\\n        /**\\n         * Get the current freq of the key\\n         */\\n        int currentFreq = keyToFreqMap.get(key);\\n        /**\\n         * Since we have to increase the freq remove the element from current freq list\\n         */\\n        freqToListMap.get(currentFreq).remove(key);\\n        /**\\n         * If all the elements from the min freq are removed, update the minFreq\\n         */\\n        if (currentFreq == minFreq && freqToListMap.get(currentFreq).isEmpty()) {\\n            minFreq++;\\n            freqToListMap.remove(currentFreq);\\n        }\\n        freqToListMap.putIfAbsent(currentFreq + 1, new LinkedHashSet<>());\\n        freqToListMap.get(currentFreq + 1).add(key);\\n        keyToFreqMap.put(key, currentFreq + 1);\\n        return keyToValueMap.get(key);\\n\\n    }\\n\\n    public void put(int key, int value) {\\n        if (capacity == 0) return;\\n        if (keyToValueMap.containsKey(key)) {\\n            keyToValueMap.put(key, value);\\n            get(key);\\n            return;\\n        }\\n\\n        /**\\n         * If the capacity is equal to keyToValueMap size\\n         */\\n        if (capacity == this.keyToValueMap.size()) {\\n            /**\\n             * Remove the LRU element from the list\\n             */\\n            if (freqToListMap.get(minFreq).iterator().hasNext()) {\\n                int valueToRemove = freqToListMap.get(minFreq).iterator().next();\\n                System.out.println();\\n                freqToListMap.get(minFreq).remove(valueToRemove);\\n                keyToValueMap.remove(valueToRemove);\\n                keyToFreqMap.remove(valueToRemove);\\n            }\\n\\n\\n        }\\n        minFreq = 1;\\n        freqToListMap.putIfAbsent(minFreq, new LinkedHashSet<>());\\n        freqToListMap.get(minFreq).add(key);\\n        keyToFreqMap.put(key, minFreq);\\n        keyToValueMap.put(key, value);\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115232,
                "title": "java-hashmap-of-linkedhashsets-o-1-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a HashMap to store the key -> {value, frequency} mapping. Use another HashMap which would have the frequency counts as keys and the associated cache keys as a set. Using a LinkedHashSet here would ensure that the order in which items are added to the set is maintained. In case of eviction and mulitple keys having the minimum frequency count, picking the first one from the LinkedHashSet would imply picking the least recently used one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LFUCache {\\n  int cap;\\n  int minFreq;\\n  Map<Integer, int[]> cache;\\n  Map<Integer, Set<Integer>> freqLists;\\n\\n  // Updates the value and frequency count in the cache.\\n  private void helper(int key, int val) {\\n    int[] a = cache.get(key);\\n    val = val == -1 ? a[0] : val;\\n    var freq = a[1];\\n\\n    cache.put(key, new int[] {val, freq + 1});\\n    freqLists.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n\\n    freqLists.get(freq + 1).add(key);\\n    freqLists.get(freq).remove(key);\\n    if (freqLists.get(freq).size() == 0) {\\n      freqLists.remove(freq);\\n      minFreq = minFreq == freq ? freq + 1 : minFreq;\\n    }\\n  }\\n\\n  public LFUCache(int capacity) {\\n    cap = capacity;\\n    minFreq = Integer.MAX_VALUE;\\n    cache = new HashMap<>();\\n    freqLists = new HashMap<>();\\n  }\\n  \\n  public int get(int key) {\\n    if (!cache.containsKey(key))\\n      return -1;\\n\\n    helper(key, -1);\\n    return cache.get(key)[0];\\n  }\\n  \\n  public void put(int key, int value) {\\n    if (!cache.containsKey(key)) {\\n      if (cap == 0) {\\n        // The cache is at capacity, find the LFU key and remove it.\\n        if (minFreq == Integer.MAX_VALUE) return;\\n\\n        var keyToRemove = freqLists.get(minFreq).iterator().next();\\n        cache.remove(keyToRemove);\\n        freqLists.get(minFreq).remove(keyToRemove);\\n\\n        if (freqLists.get(minFreq).size() == 0)\\n          freqLists.remove(minFreq);\\n        cap++;\\n      }\\n      // Add the new key to the cache.\\n      cache.put(key, new int[] {value, 1});\\n      minFreq = 1;\\n      \\n      freqLists.putIfAbsent(1, new LinkedHashSet<>());\\n      freqLists.get(1).add(key);\\n      cap--;\\n    } else {\\n      // Update the value of the exisiting key.\\n      helper(key, value);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass LFUCache {\\n  int cap;\\n  int minFreq;\\n  Map<Integer, int[]> cache;\\n  Map<Integer, Set<Integer>> freqLists;\\n\\n  // Updates the value and frequency count in the cache.\\n  private void helper(int key, int val) {\\n    int[] a = cache.get(key);\\n    val = val == -1 ? a[0] : val;\\n    var freq = a[1];\\n\\n    cache.put(key, new int[] {val, freq + 1});\\n    freqLists.putIfAbsent(freq + 1, new LinkedHashSet<>());\\n\\n    freqLists.get(freq + 1).add(key);\\n    freqLists.get(freq).remove(key);\\n    if (freqLists.get(freq).size() == 0) {\\n      freqLists.remove(freq);\\n      minFreq = minFreq == freq ? freq + 1 : minFreq;\\n    }\\n  }\\n\\n  public LFUCache(int capacity) {\\n    cap = capacity;\\n    minFreq = Integer.MAX_VALUE;\\n    cache = new HashMap<>();\\n    freqLists = new HashMap<>();\\n  }\\n  \\n  public int get(int key) {\\n    if (!cache.containsKey(key))\\n      return -1;\\n\\n    helper(key, -1);\\n    return cache.get(key)[0];\\n  }\\n  \\n  public void put(int key, int value) {\\n    if (!cache.containsKey(key)) {\\n      if (cap == 0) {\\n        // The cache is at capacity, find the LFU key and remove it.\\n        if (minFreq == Integer.MAX_VALUE) return;\\n\\n        var keyToRemove = freqLists.get(minFreq).iterator().next();\\n        cache.remove(keyToRemove);\\n        freqLists.get(minFreq).remove(keyToRemove);\\n\\n        if (freqLists.get(minFreq).size() == 0)\\n          freqLists.remove(minFreq);\\n        cap++;\\n      }\\n      // Add the new key to the cache.\\n      cache.put(key, new int[] {value, 1});\\n      minFreq = 1;\\n      \\n      freqLists.putIfAbsent(1, new LinkedHashSet<>());\\n      freqLists.get(1).add(key);\\n      cap--;\\n    } else {\\n      // Update the value of the exisiting key.\\n      helper(key, value);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113459,
                "title": "rust-with-rc-refcell-listnode",
                "content": "That\\'s a lot of code...\\n\\nUsing HashMap, a doubly linked list, and a vector of dummy nodes.\\n\\nThe dummy nodes will serve as positions to insert nodes when a node\\'s use counter increases.\\n\\nHere is an illustration of the data structure after running the following code.\\n```rust\\nlet mut obj = LFUCache::new(5);\\nobj.put(1, 1);\\nobj.put(2, 2);\\nobj.get(2);\\nobj.get(2);\\nobj.put(3, 3);\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d610dd8d-18ee-4c76-a9f4-49e3f371da88_1674995218.1716158.png)\\n\\n# Complexity\\n- get(): O(1)\\n- put(): Amortized O(1). When a least frequently used key have to be removed, the run time depends on the use count of the LFU key.\\n- Space complexity: O(n), where n is number of get() and put() calls.\\n# Code\\n```rust\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\ntype RcNode = Rc<RefCell<ListNode>>;\\ntype OptNode = Option<RcNode>;\\n\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub key: i32,\\n    pub val: i32,\\n    pub count: usize,\\n    pub prev: OptNode,\\n    pub next: OptNode,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    fn new(key: i32, val: i32, count: usize) -> Self {\\n        ListNode {\\n            key,\\n            val,\\n            count,\\n            prev: None,\\n            next: None,\\n        }\\n    }\\n\\n    fn new_rc(key: i32, val: i32, count: usize) -> RcNode {\\n        Rc::new(RefCell::new(ListNode::new(key, val, count)))\\n    }\\n\\n    fn link(before: &RcNode, after: &RcNode) {\\n        before.borrow_mut().next = Some(Rc::clone(after));\\n        after.borrow_mut().prev = Some(Rc::clone(before));\\n    }\\n\\n    fn insert(node: &RcNode, after: &RcNode) {\\n        let before = after.borrow_mut().prev.take().unwrap();\\n        Self::link(&before, node);\\n        Self::link(node, after);\\n    }\\n\\n    fn remove(node: &RcNode) {\\n        let before = node.borrow_mut().prev.take().unwrap();\\n        let after = node.borrow_mut().next.take().unwrap();\\n        Self::link(&before, &after);\\n    }\\n}\\n\\nstruct LFUCache {\\n    hash: HashMap<i32, RcNode>,\\n    dummies: Vec<RcNode>,\\n    capacity: i32,\\n    used: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LFUCache {\\n\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            dummies: vec![ListNode::new_rc(-1, -1, 0)],\\n            capacity,\\n            used: 0,\\n        }\\n    }\\n    \\n    fn get(&mut self, key: i32) -> i32 {\\n        match self.hash.get_mut(&key) {\\n            None => -1,\\n            Some(rc) => {\\n                let count = rc.borrow().count;\\n                let val = rc.borrow().val;\\n                ListNode::remove(rc);\\n                rc.borrow_mut().count += 1;\\n                let rc2 = Rc::clone(rc);\\n                self.insert(&rc2, count + 1);\\n                val\\n            }\\n        }\\n    }\\n    \\n    fn put(&mut self, key: i32, value: i32) {\\n        if self.capacity == 0 {\\n            return;\\n        }\\n        match self.hash.get_mut(&key) {\\n            None => {\\n                if self.used == self.capacity {\\n                    self.remove_LFU();\\n                }\\n                else {\\n                    self.used += 1;\\n                }\\n                let rc = ListNode::new_rc(key, value, 1);\\n                self.hash.insert(key, Rc::clone(&rc));\\n                self.insert(&rc, 1);\\n            }\\n            Some(rc) => {\\n                let count = rc.borrow().count;\\n                ListNode::remove(rc);\\n                rc.borrow_mut().val = value;\\n                rc.borrow_mut().count += 1;\\n                let rc2 = Rc::clone(rc);\\n                self.insert(&rc2, count + 1);\\n            }\\n        }\\n    }\\n\\n    fn insert(&mut self, rc: &RcNode, count: usize) {\\n        if self.dummies.len() == count {\\n            let dummy = ListNode::new_rc(-1, -1, count);\\n            let last = self.dummies.last().unwrap();\\n            ListNode::link(last, &dummy);\\n            self.dummies.push(dummy);\\n        }\\n        ListNode::insert(rc, &self.dummies[count]);\\n    }\\n\\n    fn remove_LFU(&mut self) {\\n        let mut rc = Rc::clone(&self.dummies[0]);\\n        while rc.borrow().val == -1 {\\n            let temp = Rc::clone(rc.borrow().next.as_ref().unwrap());\\n            rc = temp;\\n        }\\n        let key = rc.borrow().key;\\n        self.hash.remove(&key);\\n        ListNode::remove(&rc);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * let obj = LFUCache::new(capacity);\\n * let ret_1: i32 = obj.get(key);\\n * obj.put(key, value);\\n */\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```rust\\nlet mut obj = LFUCache::new(5);\\nobj.put(1, 1);\\nobj.put(2, 2);\\nobj.get(2);\\nobj.get(2);\\nobj.put(3, 3);\\n```\n```rust\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\ntype RcNode = Rc<RefCell<ListNode>>;\\ntype OptNode = Option<RcNode>;\\n\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub key: i32,\\n    pub val: i32,\\n    pub count: usize,\\n    pub prev: OptNode,\\n    pub next: OptNode,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    fn new(key: i32, val: i32, count: usize) -> Self {\\n        ListNode {\\n            key,\\n            val,\\n            count,\\n            prev: None,\\n            next: None,\\n        }\\n    }\\n\\n    fn new_rc(key: i32, val: i32, count: usize) -> RcNode {\\n        Rc::new(RefCell::new(ListNode::new(key, val, count)))\\n    }\\n\\n    fn link(before: &RcNode, after: &RcNode) {\\n        before.borrow_mut().next = Some(Rc::clone(after));\\n        after.borrow_mut().prev = Some(Rc::clone(before));\\n    }\\n\\n    fn insert(node: &RcNode, after: &RcNode) {\\n        let before = after.borrow_mut().prev.take().unwrap();\\n        Self::link(&before, node);\\n        Self::link(node, after);\\n    }\\n\\n    fn remove(node: &RcNode) {\\n        let before = node.borrow_mut().prev.take().unwrap();\\n        let after = node.borrow_mut().next.take().unwrap();\\n        Self::link(&before, &after);\\n    }\\n}\\n\\nstruct LFUCache {\\n    hash: HashMap<i32, RcNode>,\\n    dummies: Vec<RcNode>,\\n    capacity: i32,\\n    used: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LFUCache {\\n\\n    fn new(capacity: i32) -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            dummies: vec![ListNode::new_rc(-1, -1, 0)],\\n            capacity,\\n            used: 0,\\n        }\\n    }\\n    \\n    fn get(&mut self, key: i32) -> i32 {\\n        match self.hash.get_mut(&key) {\\n            None => -1,\\n            Some(rc) => {\\n                let count = rc.borrow().count;\\n                let val = rc.borrow().val;\\n                ListNode::remove(rc);\\n                rc.borrow_mut().count += 1;\\n                let rc2 = Rc::clone(rc);\\n                self.insert(&rc2, count + 1);\\n                val\\n            }\\n        }\\n    }\\n    \\n    fn put(&mut self, key: i32, value: i32) {\\n        if self.capacity == 0 {\\n            return;\\n        }\\n        match self.hash.get_mut(&key) {\\n            None => {\\n                if self.used == self.capacity {\\n                    self.remove_LFU();\\n                }\\n                else {\\n                    self.used += 1;\\n                }\\n                let rc = ListNode::new_rc(key, value, 1);\\n                self.hash.insert(key, Rc::clone(&rc));\\n                self.insert(&rc, 1);\\n            }\\n            Some(rc) => {\\n                let count = rc.borrow().count;\\n                ListNode::remove(rc);\\n                rc.borrow_mut().val = value;\\n                rc.borrow_mut().count += 1;\\n                let rc2 = Rc::clone(rc);\\n                self.insert(&rc2, count + 1);\\n            }\\n        }\\n    }\\n\\n    fn insert(&mut self, rc: &RcNode, count: usize) {\\n        if self.dummies.len() == count {\\n            let dummy = ListNode::new_rc(-1, -1, count);\\n            let last = self.dummies.last().unwrap();\\n            ListNode::link(last, &dummy);\\n            self.dummies.push(dummy);\\n        }\\n        ListNode::insert(rc, &self.dummies[count]);\\n    }\\n\\n    fn remove_LFU(&mut self) {\\n        let mut rc = Rc::clone(&self.dummies[0]);\\n        while rc.borrow().val == -1 {\\n            let temp = Rc::clone(rc.borrow().next.as_ref().unwrap());\\n            rc = temp;\\n        }\\n        let key = rc.borrow().key;\\n        self.hash.remove(&key);\\n        ListNode::remove(&rc);\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * let obj = LFUCache::new(capacity);\\n * let ret_1: i32 = obj.get(key);\\n * obj.put(key, value);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112929,
                "title": "c-most-intuitive-solution-on-leetcode",
                "content": "# Intuition\\nWe can use a map and a set, set will keep track of frequency and counter whereas map will do the mapping of key-> value.\\nSet should come as a part of intuition because we want a sorted data structure which can help find us the lFU or LRU element based on counter and frequency.\\n\\n# Approach\\n**Have 4 things initialised as public members**\\n\\n**unordered_map**, with format key-> {val, frequecy, counter}\\n**set**, with format {frequecy, counter, key}\\n**cap**, for max capacity of set\\n**counter**, will start from 0\\n\\nNow for Get function,\\n1. we first check if it\\'s in map, if not return -1;\\n2. if present, then increase frequncy and update counter, by removing prevoius values from map\\n\\nNow fro put function,\\n1. we first check if key, present in map, if present, then will update value, frequncy and counter same as Get function method\\n2. if key not present, then will check if set is full, then will delete first element of set, because set holding freq as 0 index, counter 1 (i.e set is sorted first on basis on frequency and then if frequency same then on basis of counter)\\nso if freq same, we shall min counter at beginning, delete it and then after deleting, we can insert new key into set.\\n\\n# Code\\n```\\nclass LFUCache {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    set<vector<int>> s;\\n    int cap;\\n    //Helps track the latest key on which operation is performed(use for least recently used key)\\n    int counter = 0;\\n    \\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(cap == 0 || mp.find(key) == mp.end())\\n            return -1;\\n\\n        counter++;\\n        int val = mp[key][0];\\n        int fre = mp[key][1];\\n        int cnt = mp[key][2];\\n        auto it = s.find({fre, cnt, key});\\n\\n        //delete the entry in set\\n        s.erase(it);\\n\\n        //update key with frequency in map and set\\n        mp[key] = {val, fre + 1, counter};\\n        s.insert({fre + 1, counter, key});\\n\\n        return val;        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap == 0)\\n            return;\\n\\n        counter++;\\n        //when key is present in Cache\\n        if(mp.find(key) != mp.end())\\n        {\\n            //if present in map, then for sure present in set\\n            int val = value;\\n            int fre = mp[key][1];\\n            int coun = mp[key][2];\\n            auto it = s.find({fre, coun, key});\\n            s.erase(it);\\n\\n            mp[key] = {val, fre + 1, counter};\\n            s.insert({fre + 1, counter, key});\\n        }\\n        //key aint present\\n        else\\n        {\\n            //capacity of cache is reached\\n            if(s.size() >= cap)\\n            {\\n                vector<int> it = *s.begin();\\n                int key1 = it[2];\\n                mp.erase(key1);\\n                s.erase(s.begin());\\n            }\\n\\n            mp[key] = {value, 1, counter};\\n            s.insert({1, counter, key});\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass LFUCache {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    set<vector<int>> s;\\n    int cap;\\n    //Helps track the latest key on which operation is performed(use for least recently used key)\\n    int counter = 0;\\n    \\n    LFUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(cap == 0 || mp.find(key) == mp.end())\\n            return -1;\\n\\n        counter++;\\n        int val = mp[key][0];\\n        int fre = mp[key][1];\\n        int cnt = mp[key][2];\\n        auto it = s.find({fre, cnt, key});\\n\\n        //delete the entry in set\\n        s.erase(it);\\n\\n        //update key with frequency in map and set\\n        mp[key] = {val, fre + 1, counter};\\n        s.insert({fre + 1, counter, key});\\n\\n        return val;        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(cap == 0)\\n            return;\\n\\n        counter++;\\n        //when key is present in Cache\\n        if(mp.find(key) != mp.end())\\n        {\\n            //if present in map, then for sure present in set\\n            int val = value;\\n            int fre = mp[key][1];\\n            int coun = mp[key][2];\\n            auto it = s.find({fre, coun, key});\\n            s.erase(it);\\n\\n            mp[key] = {val, fre + 1, counter};\\n            s.insert({fre + 1, counter, key});\\n        }\\n        //key aint present\\n        else\\n        {\\n            //capacity of cache is reached\\n            if(s.size() >= cap)\\n            {\\n                vector<int> it = *s.begin();\\n                int key1 = it[2];\\n                mp.erase(key1);\\n                s.erase(s.begin());\\n            }\\n\\n            mp[key] = {value, 1, counter};\\n            s.insert({1, counter, key});\\n        }\\n        \\n        return;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112803,
                "title": "clean-code-using-hashmap-linkedhashset",
                "content": "# Github with testcases\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/hard/design/LFUCache.kt\\n\\n# Code\\n```\\nclass LFUCache(private val capacity: Int) {\\n    private val keyValueStore = HashMap<Int, Int>()\\n    private val keyUsageCount = HashMap<Int, Int>()\\n    private val usageCountToKeysLookup = HashMap<Int, LinkedHashSet<Int>>()\\n    private var minUsageCount = 1\\n\\n    fun get(key: Int): Int {\\n        if (capacity == 0 || !keyValueStore.containsKey(key)) return -1\\n        updateKeyUsage(key)\\n        return keyValueStore[key]!!\\n    }\\n\\n    fun put(key: Int, value: Int) {\\n        if (capacity == 0) return\\n        if (keyValueStore.containsKey(key)) {\\n            updateKeyUsage(key)\\n            keyValueStore[key] = value\\n            return\\n        }\\n        if (keyValueStore.size == capacity) evictLeastFrequentlyUsed()\\n        addNewKeyValue(key, value)\\n    }\\n\\n    private fun evictLeastFrequentlyUsed() {\\n        val candidateKeys = usageCountToKeysLookup[minUsageCount]!!\\n        val evictedKey = candidateKeys.first()//lru\\n        candidateKeys.remove(evictedKey)\\n        keyValueStore.remove(evictedKey)\\n        keyUsageCount.remove(evictedKey)\\n    }\\n\\n    private fun updateKeyUsage(key: Int) {\\n        val prevCount = keyUsageCount[key]!!\\n        val nextCount = prevCount + 1\\n        val keys = usageCountToKeysLookup[prevCount]!!\\n        keys.remove(key)\\n        if (minUsageCount == prevCount && keys.isEmpty()) minUsageCount = nextCount\\n        keyUsageCount[key] = nextCount\\n        usageCountToKeysLookup.computeIfAbsent(nextCount) { LinkedHashSet() }.add(key)\\n    }\\n\\n    private fun addNewKeyValue(key: Int, value: Int) {\\n        minUsageCount = 1\\n        keyUsageCount[key] = 1\\n        usageCountToKeysLookup.computeIfAbsent(1) { LinkedHashSet() }.add(key)\\n        keyValueStore[key] = value\\n    }\\n\\n    fun printState() {\\n        println(\"keyValueStore: $keyValueStore,keyUsageCount: $keyUsageCount,usageCountToKeysLookup: $usageCountToKeysLookup,minCount: $minUsageCount\")\\n    }\\n}\\n```\\n\\n![upvote_meme.jpeg](https://assets.leetcode.com/users/images/423c55f3-e3b0-4f06-b3d2-9c0aff4c3f51_1674982444.2171352.jpeg)\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass LFUCache(private val capacity: Int) {\\n    private val keyValueStore = HashMap<Int, Int>()\\n    private val keyUsageCount = HashMap<Int, Int>()\\n    private val usageCountToKeysLookup = HashMap<Int, LinkedHashSet<Int>>()\\n    private var minUsageCount = 1\\n\\n    fun get(key: Int): Int {\\n        if (capacity == 0 || !keyValueStore.containsKey(key)) return -1\\n        updateKeyUsage(key)\\n        return keyValueStore[key]!!\\n    }\\n\\n    fun put(key: Int, value: Int) {\\n        if (capacity == 0) return\\n        if (keyValueStore.containsKey(key)) {\\n            updateKeyUsage(key)\\n            keyValueStore[key] = value\\n            return\\n        }\\n        if (keyValueStore.size == capacity) evictLeastFrequentlyUsed()\\n        addNewKeyValue(key, value)\\n    }\\n\\n    private fun evictLeastFrequentlyUsed() {\\n        val candidateKeys = usageCountToKeysLookup[minUsageCount]!!\\n        val evictedKey = candidateKeys.first()//lru\\n        candidateKeys.remove(evictedKey)\\n        keyValueStore.remove(evictedKey)\\n        keyUsageCount.remove(evictedKey)\\n    }\\n\\n    private fun updateKeyUsage(key: Int) {\\n        val prevCount = keyUsageCount[key]!!\\n        val nextCount = prevCount + 1\\n        val keys = usageCountToKeysLookup[prevCount]!!\\n        keys.remove(key)\\n        if (minUsageCount == prevCount && keys.isEmpty()) minUsageCount = nextCount\\n        keyUsageCount[key] = nextCount\\n        usageCountToKeysLookup.computeIfAbsent(nextCount) { LinkedHashSet() }.add(key)\\n    }\\n\\n    private fun addNewKeyValue(key: Int, value: Int) {\\n        minUsageCount = 1\\n        keyUsageCount[key] = 1\\n        usageCountToKeysLookup.computeIfAbsent(1) { LinkedHashSet() }.add(key)\\n        keyValueStore[key] = value\\n    }\\n\\n    fun printState() {\\n        println(\"keyValueStore: $keyValueStore,keyUsageCount: $keyUsageCount,usageCountToKeysLookup: $usageCountToKeysLookup,minCount: $minUsageCount\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112459,
                "title": "c-with-node-and-list-implementation-hashmap-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(1) for get and put operations\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nstruct Node {\\n    Node* next;\\n    Node* prev;\\n    int key;\\n    int value;\\n    int cnt;\\n    Node(int key_, int value_) {\\n        key = key_;\\n        value = value_;\\n        cnt = 1;\\n        prev = NULL;\\n        next = NULL;\\n    }\\n};\\n\\nstruct List {\\n    int size;\\n    Node* head;\\n    Node* tail;\\n\\n    List() {\\n       head = new Node(0,0);\\n       tail = new Node(0,0);\\n       head->next = tail;\\n       tail->prev = head;\\n       size = 0;\\n    }\\n\\n    void addFront(Node* node) {\\n        Node* temp = head->next;\\n        node->next = temp;\\n        temp->prev = node;\\n        node->prev = head;\\n        head->next = node;\\n        size++;\\n    }\\n\\n    void removeNode(Node* node) {\\n        Node* temp = node->next;\\n        temp->prev = node->prev;\\n        node->prev->next = temp;\\n        size--;\\n    }\\n};\\n\\nclass LFUCache {\\n    map<int,Node*> keynode;\\n    map<int,List*> freqList;\\n    int maxcapacity;\\n    int minfreq;\\n    int cursize;\\npublic:\\n    LFUCache(int capacity) {\\n        maxcapacity = capacity;\\n        minfreq = 0;\\n        cursize = 0;\\n    }\\n\\n    void updateFreqListMap(Node* node){\\n        keynode.erase(node->key);\\n        freqList[node->cnt]->removeNode(node);\\n        if(node->cnt == minfreq && freqList[node->cnt]->size == 0) {\\n            minfreq++;\\n        }\\n\\n        List* nexthigherfreqlist = new List();\\n        if(freqList.find(node->cnt+1) != freqList.end()) {\\n            nexthigherfreqlist = freqList[node->cnt + 1];\\n        }\\n\\n        node->cnt += 1;\\n        nexthigherfreqlist->addFront(node);\\n        freqList[node->cnt] = nexthigherfreqlist;\\n        keynode[node->key] = node;\\n    }\\n    \\n    int get(int key) {\\n        if(keynode.find(key) != keynode.end()) {\\n            Node* node = keynode[key];\\n            int val = node->value;\\n            updateFreqListMap(node);\\n            return val;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(maxcapacity == 0) {\\n            return;\\n        }\\n\\n        if(keynode.find(key) != keynode.end()) {\\n            Node* node = keynode[key];\\n            node->value = value;\\n            updateFreqListMap(node);\\n        }\\n        else {\\n            if(cursize == maxcapacity) {\\n                List* minfreqlist = freqList[minfreq];\\n                keynode.erase(minfreqlist->tail->prev->key);\\n                minfreqlist->removeNode(minfreqlist->tail->prev);\\n                freqList[minfreq] = minfreqlist;\\n                cursize--;\\n            }\\n\\n            cursize++;\\n            minfreq = 1;\\n            List* minfreqlist = new List();\\n            if(freqList.find(minfreq) != freqList.end()) {\\n                minfreqlist = freqList[minfreq];\\n            }\\n\\n            Node* node = new Node(key, value);\\n            minfreqlist->addFront(node);\\n            keynode[key] = node;\\n            freqList[minfreq] = minfreqlist;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n    Node* next;\\n    Node* prev;\\n    int key;\\n    int value;\\n    int cnt;\\n    Node(int key_, int value_) {\\n        key = key_;\\n        value = value_;\\n        cnt = 1;\\n        prev = NULL;\\n        next = NULL;\\n    }\\n};\\n\\nstruct List {\\n    int size;\\n    Node* head;\\n    Node* tail;\\n\\n    List() {\\n       head = new Node(0,0);\\n       tail = new Node(0,0);\\n       head->next = tail;\\n       tail->prev = head;\\n       size = 0;\\n    }\\n\\n    void addFront(Node* node) {\\n        Node* temp = head->next;\\n        node->next = temp;\\n        temp->prev = node;\\n        node->prev = head;\\n        head->next = node;\\n        size++;\\n    }\\n\\n    void removeNode(Node* node) {\\n        Node* temp = node->next;\\n        temp->prev = node->prev;\\n        node->prev->next = temp;\\n        size--;\\n    }\\n};\\n\\nclass LFUCache {\\n    map<int,Node*> keynode;\\n    map<int,List*> freqList;\\n    int maxcapacity;\\n    int minfreq;\\n    int cursize;\\npublic:\\n    LFUCache(int capacity) {\\n        maxcapacity = capacity;\\n        minfreq = 0;\\n        cursize = 0;\\n    }\\n\\n    void updateFreqListMap(Node* node){\\n        keynode.erase(node->key);\\n        freqList[node->cnt]->removeNode(node);\\n        if(node->cnt == minfreq && freqList[node->cnt]->size == 0) {\\n            minfreq++;\\n        }\\n\\n        List* nexthigherfreqlist = new List();\\n        if(freqList.find(node->cnt+1) != freqList.end()) {\\n            nexthigherfreqlist = freqList[node->cnt + 1];\\n        }\\n\\n        node->cnt += 1;\\n        nexthigherfreqlist->addFront(node);\\n        freqList[node->cnt] = nexthigherfreqlist;\\n        keynode[node->key] = node;\\n    }\\n    \\n    int get(int key) {\\n        if(keynode.find(key) != keynode.end()) {\\n            Node* node = keynode[key];\\n            int val = node->value;\\n            updateFreqListMap(node);\\n            return val;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(maxcapacity == 0) {\\n            return;\\n        }\\n\\n        if(keynode.find(key) != keynode.end()) {\\n            Node* node = keynode[key];\\n            node->value = value;\\n            updateFreqListMap(node);\\n        }\\n        else {\\n            if(cursize == maxcapacity) {\\n                List* minfreqlist = freqList[minfreq];\\n                keynode.erase(minfreqlist->tail->prev->key);\\n                minfreqlist->removeNode(minfreqlist->tail->prev);\\n                freqList[minfreq] = minfreqlist;\\n                cursize--;\\n            }\\n\\n            cursize++;\\n            minfreq = 1;\\n            List* minfreqlist = new List();\\n            if(freqList.find(minfreq) != freqList.end()) {\\n                minfreqlist = freqList[minfreq];\\n            }\\n\\n            Node* node = new Node(key, value);\\n            minfreqlist->addFront(node);\\n            keynode[key] = node;\\n            freqList[minfreq] = minfreqlist;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112071,
                "title": "java-c-python-explained-in-detail-constant-time-two-hashmap-s",
                "content": "# Intuition & Approach\\n\\nWe need to maintain all the keys, values and frequencies. Without invalidation (removing from the data structure when it reaches capacity), they can be maintained by a HashMap<Integer, Pair<Integer, Integer>>, keyed by the original key and valued by the frequency-value pair.\\n\\nWith the invalidation, we need to maintain the current minimum frequency and delete particular keys. Hence, we can group the keys with the same frequency together and maintain another HashMap<Integer, Set>, keyed by the frequency and valued by the set of keys that have the same frequency. This way, if we know the minimum frequency, we can access the potential keys to be deleted.\\n\\nAlso note that in the case of a tie, we\\'re required to find the least recently used key and invalidate it, hence we need to keep the frequencies ordered in the Set. Instead of using a TreeSet which adds an extra O(log(N))O(log(N))O(log(N)) time complexity, we can maintain the keys using a LinkedList so that it supports finding both an arbitrary key and the least recently used key in constant time. Fortunately, LinkedHashSet can do the job. Once a key is inserted/updated, we put it to the end of the LinkedHashSet so that we can invalidate the first key in the LinkedHashSet corresponding to the minimum frequency.\\n\\nThe original operations can be transformed into operations on the 2 HashMaps, keeping them in sync and maintaining the minimum frequency.\\n\\nSince C++ lacks LinkedHashSet, we have to use a workaround like maintaining a list of key and value pairs instead of the LinkedHashSet and keeping the iterator with the frequency in another unordered_map to keep this connection. The idea is similar but a little bit complicated. Another workaround would be to implement your own LRU cache with a doubly linked list.\\n\\nAlgorithm\\nTo make things simpler, assume we have 4 member variables:\\n\\nHashMap<Integer, Pair<Integer, Integer>> cache, keyed by the original key and valued by the frequency-value pair.\\nHashMap<Integer, LinkedListHashSet<Integer>> frequencies, keyed by frequency and valued by the set of keys that have the same frequency.\\nint minf, which is the minimum frequency at any given time.\\nint capacity, which is the capacity given in the input.\\nIt\\'s also convenient to have a private utility function insert to insert a key-value pair with a given frequency.\\n\\nvoid insert(int key, int frequency, int value)\\nInsert frequency-value pair into cache with the given key.\\nGet the LinkedHashSet corresponding to the given frequency (default to empty Set) and insert the given key.\\nint get(int key)\\nIf the given key is not in the cache, return -1, otherwise go to step 2.\\nGet the frequency and value from the cache.\\nGet the LinkedHashSet associated with frequency from frequencies and remove the given key from it, since the usage of the current key is increased by this function call.\\nIf minf == frequency and the above LinkedHashSet is empty, that means there are no more elements used minf times, so increase minf by 1.\\nCall insert(key, frequency + 1, value), since the current key\\'s usage has increased from this function call.\\nReturn value\\nvoid put(int key, int value)\\nIf capacity <= 0, exit.\\nIf the given key exists in cache, update the value in the original frequency-value (don\\'t call insert here), and then increment the frequency by using get(key). Exit the function.\\nIf cache.size() == capacity, get the first (least recently used) value in the LinkedHashSet corresponding to minf in frequencies, and remove it from cache and the LinkedHashSet.\\nIf we didn\\'t exit the function in step 2, it means that this element is a new one, so the minimum frequency cannot possibly be greater than one. Set minf to 1.\\nCall insert(key, 1, value)\\n\\n![memecat.jpeg](https://assets.leetcode.com/users/images/6551bb0f-2498-4a7b-8c39-0a3243a9c7fe_1674969971.2859943.jpeg)\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<K, V> {\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey() {\\n            return this.key;\\n        }\\n        public V getValue() {\\n            return this.value;\\n        }\\n    }\\n```\\n```\\n    class LFUCache {\\n        // key: original key, value: frequency and original value.\\n        private Map<Integer, Pair<Integer, Integer>> cache;\\n        // key: frequency, value: All keys that have the same frequency.\\n        private Map<Integer, LinkedHashSet<Integer>> frequencies;\\n        private int minf;\\n        private int capacity;\\n\\n        private void insert(int key, int frequency, int value) {\\n            cache.put(key, new Pair<>(frequency, value));\\n            frequencies.putIfAbsent(frequency, new LinkedHashSet<>());\\n            frequencies.get(frequency).add(key);\\n        }\\n\\n        public LFUCache(int capacity) {\\n            cache = new HashMap<>();\\n            frequencies = new HashMap<>();\\n            minf = 0;\\n            this.capacity = capacity;\\n        }\\n\\n        public int get(int key) {\\n            Pair<Integer, Integer> frequencyAndValue = cache.get(key);\\n            if (frequencyAndValue == null) {\\n                return -1;\\n            }\\n            final int frequency = frequencyAndValue.getKey();\\n            final Set<Integer> keys = frequencies.get(frequency);\\n            keys.remove(key);\\n            if (minf == frequency && keys.isEmpty()) {\\n                ++minf;\\n            }\\n            final int value = frequencyAndValue.getValue();\\n            insert(key, frequency + 1, value);\\n            return value;\\n        }\\n\\n        public void put(int key, int value) {\\n            if (capacity <= 0) {\\n                return;\\n            }\\n            Pair<Integer, Integer> frequencyAndValue = cache.get(key);\\n            if (frequencyAndValue != null) {\\n                cache.put(key, new Pair<>(frequencyAndValue.getKey(), value));\\n                get(key);\\n                return;\\n            }\\n            if (capacity == cache.size()) {\\n                final Set<Integer> keys = frequencies.get(minf);\\n                final int keyToDelete = keys.iterator().next();\\n                cache.remove(keyToDelete);\\n                keys.remove(keyToDelete);\\n            }\\n            minf = 1;\\n            insert(key, 1, value);\\n        }\\n    }\\n```\\n# C++\\n\\n```\\nclass LFUCache {\\n    // key: frequency, value: list of original key-value pairs that have the same frequency.\\n    unordered_map<int, list<pair<int, int>>> frequencies;\\n    // key: original key, value: pair of frequency and the iterator corresponding key int the\\n    // frequencies map\\'s list.\\n    unordered_map<int, pair<int, list<pair<int, int>>::iterator>> cache;\\n    int capacity;\\n    int minf;\\n\\n    void insert(int key, int frequency, int value) {\\n        frequencies[frequency].push_back({key, value});\\n        cache[key] = {frequency, --frequencies[frequency].end()};\\n    }\\n\\npublic:\\n    LFUCache(int capacity) : capacity(capacity), minf(0) {}\\n\\n    int get(int key) {\\n        const auto it = cache.find(key);\\n        if (it == cache.end()) {\\n            return -1;\\n        }\\n        const int f = it->second.first;\\n        const auto iter = it->second.second;\\n        const pair<int, int> kv = *iter;\\n        frequencies[f].erase(iter);\\n        if (frequencies[f].empty() && minf == f) {\\n            ++minf;\\n        }\\n        insert(key, f + 1, kv.second);\\n        return kv.second;\\n    }\\n\\n    void put(int key, int value) {\\n        if (capacity <= 0) {\\n            return;\\n        }\\n        const auto it = cache.find(key);\\n        if (it != cache.end()) {\\n            it->second.second->second = value;\\n            get(key);\\n            return;\\n        }\\n        if (capacity == cache.size()) {\\n            cache.erase(frequencies[minf].front().first);\\n            frequencies[minf].pop_front();\\n        }\\n        minf = 1;\\n        insert(key, 1, value);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```\\nclass Pair<K, V> {\\n        private K key;\\n        private V value;\\n\\n        public Pair(K key, V value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n\\n        public K getKey() {\\n            return this.key;\\n        }\\n        public V getValue() {\\n            return this.value;\\n        }\\n    }\\n```\n```\\n    class LFUCache {\\n        // key: original key, value: frequency and original value.\\n        private Map<Integer, Pair<Integer, Integer>> cache;\\n        // key: frequency, value: All keys that have the same frequency.\\n        private Map<Integer, LinkedHashSet<Integer>> frequencies;\\n        private int minf;\\n        private int capacity;\\n\\n        private void insert(int key, int frequency, int value) {\\n            cache.put(key, new Pair<>(frequency, value));\\n            frequencies.putIfAbsent(frequency, new LinkedHashSet<>());\\n            frequencies.get(frequency).add(key);\\n        }\\n\\n        public LFUCache(int capacity) {\\n            cache = new HashMap<>();\\n            frequencies = new HashMap<>();\\n            minf = 0;\\n            this.capacity = capacity;\\n        }\\n\\n        public int get(int key) {\\n            Pair<Integer, Integer> frequencyAndValue = cache.get(key);\\n            if (frequencyAndValue == null) {\\n                return -1;\\n            }\\n            final int frequency = frequencyAndValue.getKey();\\n            final Set<Integer> keys = frequencies.get(frequency);\\n            keys.remove(key);\\n            if (minf == frequency && keys.isEmpty()) {\\n                ++minf;\\n            }\\n            final int value = frequencyAndValue.getValue();\\n            insert(key, frequency + 1, value);\\n            return value;\\n        }\\n\\n        public void put(int key, int value) {\\n            if (capacity <= 0) {\\n                return;\\n            }\\n            Pair<Integer, Integer> frequencyAndValue = cache.get(key);\\n            if (frequencyAndValue != null) {\\n                cache.put(key, new Pair<>(frequencyAndValue.getKey(), value));\\n                get(key);\\n                return;\\n            }\\n            if (capacity == cache.size()) {\\n                final Set<Integer> keys = frequencies.get(minf);\\n                final int keyToDelete = keys.iterator().next();\\n                cache.remove(keyToDelete);\\n                keys.remove(keyToDelete);\\n            }\\n            minf = 1;\\n            insert(key, 1, value);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111929,
                "title": "simple-java-easy-solution-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n\\tint key;\\n\\tint val;\\n\\tNode next;\\n\\tNode prev;\\n\\tint freq=1;\\n\\tNode(int k,int v){\\n\\t\\tkey=k;\\n\\t\\tval=v;\\n\\t}\\n}\\nclass DoublyLinkedList{\\n\\tNode head;\\n\\tNode tail;\\n\\tDoublyLinkedList(){\\n\\t\\thead=new Node(-1,-1);\\n\\t\\ttail=new Node(-1,-1);\\n\\t\\thead.next=tail;\\n\\t\\ttail.prev=head;\\n\\t}\\n\\tvoid addNode(Node v){\\n\\t\\tNode next=head.next;\\n\\t\\thead.next=v;\\n\\t\\tv.prev=head;\\n\\t\\thead.next=v;\\n\\t\\tv.next=next;\\n\\t\\tnext.prev=v;\\n\\t}\\n\\tNode removeNode(){\\n\\t\\tNode node=tail.prev;\\n\\t\\tnode.prev.next=tail;\\n\\t\\ttail.prev=node.prev;\\n\\t\\treturn node;\\n\\t}\\n\\tNode removeNode(Node v){\\n\\t\\tNode prev=v.prev;\\n\\t\\tNode next=v.next;\\n\\t\\tprev.next=next;\\n\\t\\tnext.prev=prev;\\n\\t\\treturn v;\\n\\t}\\n\\tboolean isEmpty(){\\n\\t\\tif(head.next==tail)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n}\\nclass LFUCache {\\n    HashMap<Integer,DoublyLinkedList> freqList=new HashMap<Integer,DoublyLinkedList>();\\n\\tHashMap<Integer,Node> lfuCache =new HashMap<Integer,Node>(); \\n\\tint capacity;\\n\\tint minFreq;\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        minFreq=1;\\n    }\\n    public int get(int key) {\\n        if(lfuCache.get(key)==null)\\n        \\treturn -1;\\n       \\tNode v=lfuCache.get(key);\\n       \\tfreqList.get(v.freq).removeNode(v);\\n       \\tif(freqList.get(v.freq).isEmpty()){\\n       \\t\\tif(minFreq==v.freq){\\n                minFreq=v.freq+1;\\n            }\\n       \\t}\\n       \\tv.freq+=1;\\n       \\tif(freqList.get(v.freq)==null){\\n       \\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n       \\t\\td.addNode(v);\\n       \\t\\tfreqList.put(v.freq,d);\\n       \\t}\\n       \\telse{\\n       \\t\\tfreqList.get(v.freq).addNode(v);\\n       \\t}\\n       \\treturn v.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(lfuCache.get(key)!=null){\\n        \\tNode v=lfuCache.get(key);\\n        \\tfreqList.get(v.freq).removeNode(v);\\n        \\tif(freqList.get(v.freq).isEmpty()){\\n                if(minFreq==v.freq)\\n        \\t\\tminFreq=v.freq+1;\\n        \\t}\\n\\t       \\tv.freq+=1;\\n\\t       \\tif(freqList.get(v.freq)==null){\\n\\t       \\t\\t DoublyLinkedList d=new DoublyLinkedList();\\n\\t       \\t\\td.addNode(v);\\n\\t       \\t\\tfreqList.put(v.freq,d);\\n\\t       \\t}\\n\\t       \\telse{\\n\\t       \\t\\tfreqList.get(v.freq).addNode(v);\\n\\t       \\t}\\n\\t       \\tv.val=value;\\n\\t      }\\n\\t      else{\\n\\t     \\t\\tif(lfuCache.size()==capacity){\\n\\t     \\t\\t\\tNode v=freqList.get(minFreq).removeNode();\\n\\t     \\t\\t\\tlfuCache.remove(v.key);\\t\\t\\t\\n\\t     \\t\\t}\\n\\t     \\t\\tNode newNode = new Node(key,value);\\n\\t     \\t\\tlfuCache.put(key,newNode);\\n\\t     \\t\\tif(freqList.get(1)!=null){\\n\\t     \\t\\t\\tfreqList.get(1).addNode(newNode);\\n\\t     \\t\\t}\\n\\t     \\t\\telse{\\n\\t     \\t\\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n\\t     \\t\\t\\td.addNode(newNode);\\n\\t     \\t\\t\\tfreqList.put(1,d);\\n\\t     \\t\\t}\\n               minFreq=1;\\n\\t      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n\\tint key;\\n\\tint val;\\n\\tNode next;\\n\\tNode prev;\\n\\tint freq=1;\\n\\tNode(int k,int v){\\n\\t\\tkey=k;\\n\\t\\tval=v;\\n\\t}\\n}\\nclass DoublyLinkedList{\\n\\tNode head;\\n\\tNode tail;\\n\\tDoublyLinkedList(){\\n\\t\\thead=new Node(-1,-1);\\n\\t\\ttail=new Node(-1,-1);\\n\\t\\thead.next=tail;\\n\\t\\ttail.prev=head;\\n\\t}\\n\\tvoid addNode(Node v){\\n\\t\\tNode next=head.next;\\n\\t\\thead.next=v;\\n\\t\\tv.prev=head;\\n\\t\\thead.next=v;\\n\\t\\tv.next=next;\\n\\t\\tnext.prev=v;\\n\\t}\\n\\tNode removeNode(){\\n\\t\\tNode node=tail.prev;\\n\\t\\tnode.prev.next=tail;\\n\\t\\ttail.prev=node.prev;\\n\\t\\treturn node;\\n\\t}\\n\\tNode removeNode(Node v){\\n\\t\\tNode prev=v.prev;\\n\\t\\tNode next=v.next;\\n\\t\\tprev.next=next;\\n\\t\\tnext.prev=prev;\\n\\t\\treturn v;\\n\\t}\\n\\tboolean isEmpty(){\\n\\t\\tif(head.next==tail)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n}\\nclass LFUCache {\\n    HashMap<Integer,DoublyLinkedList> freqList=new HashMap<Integer,DoublyLinkedList>();\\n\\tHashMap<Integer,Node> lfuCache =new HashMap<Integer,Node>(); \\n\\tint capacity;\\n\\tint minFreq;\\n    public LFUCache(int capacity) {\\n        this.capacity=capacity;\\n        minFreq=1;\\n    }\\n    public int get(int key) {\\n        if(lfuCache.get(key)==null)\\n        \\treturn -1;\\n       \\tNode v=lfuCache.get(key);\\n       \\tfreqList.get(v.freq).removeNode(v);\\n       \\tif(freqList.get(v.freq).isEmpty()){\\n       \\t\\tif(minFreq==v.freq){\\n                minFreq=v.freq+1;\\n            }\\n       \\t}\\n       \\tv.freq+=1;\\n       \\tif(freqList.get(v.freq)==null){\\n       \\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n       \\t\\td.addNode(v);\\n       \\t\\tfreqList.put(v.freq,d);\\n       \\t}\\n       \\telse{\\n       \\t\\tfreqList.get(v.freq).addNode(v);\\n       \\t}\\n       \\treturn v.val;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(capacity==0)\\n            return;\\n        if(lfuCache.get(key)!=null){\\n        \\tNode v=lfuCache.get(key);\\n        \\tfreqList.get(v.freq).removeNode(v);\\n        \\tif(freqList.get(v.freq).isEmpty()){\\n                if(minFreq==v.freq)\\n        \\t\\tminFreq=v.freq+1;\\n        \\t}\\n\\t       \\tv.freq+=1;\\n\\t       \\tif(freqList.get(v.freq)==null){\\n\\t       \\t\\t DoublyLinkedList d=new DoublyLinkedList();\\n\\t       \\t\\td.addNode(v);\\n\\t       \\t\\tfreqList.put(v.freq,d);\\n\\t       \\t}\\n\\t       \\telse{\\n\\t       \\t\\tfreqList.get(v.freq).addNode(v);\\n\\t       \\t}\\n\\t       \\tv.val=value;\\n\\t      }\\n\\t      else{\\n\\t     \\t\\tif(lfuCache.size()==capacity){\\n\\t     \\t\\t\\tNode v=freqList.get(minFreq).removeNode();\\n\\t     \\t\\t\\tlfuCache.remove(v.key);\\t\\t\\t\\n\\t     \\t\\t}\\n\\t     \\t\\tNode newNode = new Node(key,value);\\n\\t     \\t\\tlfuCache.put(key,newNode);\\n\\t     \\t\\tif(freqList.get(1)!=null){\\n\\t     \\t\\t\\tfreqList.get(1).addNode(newNode);\\n\\t     \\t\\t}\\n\\t     \\t\\telse{\\n\\t     \\t\\t\\tDoublyLinkedList d=new DoublyLinkedList();\\n\\t     \\t\\t\\td.addNode(newNode);\\n\\t     \\t\\t\\tfreqList.put(1,d);\\n\\t     \\t\\t}\\n               minFreq=1;\\n\\t      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111554,
                "title": "c-easy-hashmaps-runs-9ms-beats-97-98",
                "content": "![images.jpeg](https://assets.leetcode.com/users/images/35f361d2-d3aa-4afa-b046-1262f71b681f_1674963808.8140721.jpeg)\\n> # Kindly Up-Vote Sir\\n\\n# Intuition\\nThe original operations can be transformed into operations on the 2 HashMaps, keeping them for sync and maintaining the minimum frequency.\\n\\nSince C++ lacks LinkedHashSet, we have to use a workaround like maintaining a list of key and value pairs instead of the LinkedHashSet and keeping the iterator with the frequency in another unordered_map to keep this connection. The idea is similar but a little bit complicated. Another workaround would be to implement your own LRU cache with a doubly linked list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- void insert(int key, int frequency, int value)\\n- Insert frequency-value pair into cache with the given key.\\n- Get the LinkedHashSet corresponding to the given frequency (default to empty Set) and insert the given key.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(1)\\n> - For each get operation, in the worst case, we query the frequencies and remove a key from the associated value which is a LinkedHashSet and call insert function once. All the operations have the constant time complexity based on the hash calculating for simple type\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n>- We can well as all the keys with frequencies in the 2 HashMaps (plus a LinkedHashSet), so there are at most $min(N, capacity) keys and values at any given time.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LFUCache \\n{\\npublic:\\n    priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n//get th prio pair queue with the vector and the greater pair\\n\\n    unordered_map<int,int>m;//unodermapping for m\\n    unordered_map<int,int>freq;//unodermapping for freq\\n\\n    int cap;//for cap\\n    int tar;//for tar\\n\\n    LFUCache(int capacity) \\n\\n\\n```\\nDriver Code\\n```\\n\\n    //driver code starts here\\n\\n    {\\n        cap=capacity;//define the capacity\\n    }\\n    \\n    int get(int key)\\n    {\\n        if(m.find(key)==m.end())return -1;\\n        put(key,m[key]);\\n        return m[key];\\n    }\\n    \\n    void put(int key, int value)\\n\\n    {\\n        if(cap==0)\\n        {\\n            return;\\n        }\\n        \\n        if(m.find(key)==m.end()&&m.size()==cap)\\n        {\\n            while(m.size()==cap)//decalare the cap size\\n            \\n            {\\n                auto x=pq.top();\\n                if(freq[x.second.second]==x.first)//for the first feq\\n                \\n                {\\n                    m.erase(x.second.second);//remove the 2nd m\\n                    freq.erase(x.second.second); // with freq \\n                }\\n\\n                pq.pop();\\n\\n            }\\n        }\\n        m[key]=value;\\n        //define the key balue for the var \\'m\\'\\n        freq[key]++;\\n\\n        pq.push({freq[key],{tar++,key}});\\n        //driver code ends here\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass LFUCache \\n{\\npublic:\\n    priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>pq;\\n//get th prio pair queue with the vector and the greater pair\\n\\n    unordered_map<int,int>m;//unodermapping for m\\n    unordered_map<int,int>freq;//unodermapping for freq\\n\\n    int cap;//for cap\\n    int tar;//for tar\\n\\n    LFUCache(int capacity) \\n\\n\\n```\n```\\n\\n    //driver code starts here\\n\\n    {\\n        cap=capacity;//define the capacity\\n    }\\n    \\n    int get(int key)\\n    {\\n        if(m.find(key)==m.end())return -1;\\n        put(key,m[key]);\\n        return m[key];\\n    }\\n    \\n    void put(int key, int value)\\n\\n    {\\n        if(cap==0)\\n        {\\n            return;\\n        }\\n        \\n        if(m.find(key)==m.end()&&m.size()==cap)\\n        {\\n            while(m.size()==cap)//decalare the cap size\\n            \\n            {\\n                auto x=pq.top();\\n                if(freq[x.second.second]==x.first)//for the first feq\\n                \\n                {\\n                    m.erase(x.second.second);//remove the 2nd m\\n                    freq.erase(x.second.second); // with freq \\n                }\\n\\n                pq.pop();\\n\\n            }\\n        }\\n        m[key]=value;\\n        //define the key balue for the var \\'m\\'\\n        freq[key]++;\\n\\n        pq.push({freq[key],{tar++,key}});\\n        //driver code ends here\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892022,
                "title": "o-1-two-hashmap-doublelinkedlist-clean-up-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo HashMap + DoubleLinkedList approach:\\n    - HashMap to store (key, DoubleNode(key, value, freq, ...)) pairs\\n    - HashMap to store (freq, DoubleLinkedList for keys with this freq) pairs\\n\\nAlso, let\\'s clean up empty DoubleLinkedLists and removed nodes.\\n\\n# Complexity\\n\\n## get method\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## put method\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        self.cache = {}\\n        self.freqs = defaultdict(DoubleLinkedList)\\n        self.capacity = capacity\\n        self.min_freq = 0\\n\\n    def get(self, key: int) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if key not in self.cache:\\n            return -1\\n        value = self.cache[key].value\\n        self.update(key, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.capacity == 0:\\n            return\\n        if key in self.cache:\\n            self.update(key, value)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                removed_key = self.freqs[self.min_freq].pop_back()\\n                if self.freqs[self.min_freq].is_empty:\\n                    del self.freqs[self.min_freq]\\n                del self.cache[removed_key]\\n            self.min_freq = 1\\n            self.freqs[self.min_freq].push_front(key, value, self.min_freq)\\n            self.cache[key] = self.freqs[self.min_freq].head\\n\\n    def update(self, key: int, value: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        node = self.cache[key]\\n        freq = node.freq\\n        self.freqs[freq + 1].push_front(key, value, freq + 1)\\n        self.cache[key] = self.freqs[freq + 1].head\\n        self.freqs[freq].remove_node(node)\\n        if (freq == self.min_freq) and self.freqs[freq].is_empty:\\n            self.min_freq += 1\\n        if self.freqs[freq].is_empty:\\n            del self.freqs[freq]\\n\\n\\n\\nclass DoubleNode:\\n    def __init__(self, key, value, freq=1, next=None, prev=None):\\n        self.key = key\\n        self.value = value\\n        self.freq = freq\\n        self.next = next\\n        self.prev = prev\\n\\n\\nclass DoubleLinkedList:\\n    def __init__(self) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        self.head = self.tail = None\\n        self.is_empty = True\\n\\n    def __emptied__(self) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        del self.head\\n        self.head = self.tail = None\\n        self.is_empty = True\\n\\n    def push_front(self, key: int, value: int, freq: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            self.head = self.tail = DoubleNode(key, value, freq)\\n            self.is_empty = False\\n        else:\\n            node = DoubleNode(key, value, freq, next=self.head)\\n            self.head.prev = node\\n            self.head = node\\n\\n    def pop_front(self) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            raise IndexError(\"LinkedList is empty!\")\\n        key = self.head.key\\n        if self.head == self.tail:\\n            self.__emptied__()\\n        else:\\n            next = self.head.next\\n            self.head.next = next.prev = None\\n            del self.head\\n            self.head = next\\n        return key\\n\\n    def pop_back(self) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            raise IndexError(\"LinkedList is empty!\")\\n        key = self.tail.key\\n        if self.head == self.tail:\\n            self.__emptied__()\\n        else:\\n            prev = self.tail.prev\\n            self.tail.prev = prev.next = None\\n            del self.tail\\n            self.tail = prev\\n        return key\\n\\n    def remove_node(self, node: DoubleNode) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty or (node is None):\\n            raise IndexError(\"LinkedList is empty or node is None!\")\\n        if node == self.head:\\n            self.pop_front()\\n        elif node == self.tail:\\n            self.pop_back()\\n        else:\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            node.prev = node.next = None\\n            del node\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        self.cache = {}\\n        self.freqs = defaultdict(DoubleLinkedList)\\n        self.capacity = capacity\\n        self.min_freq = 0\\n\\n    def get(self, key: int) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if key not in self.cache:\\n            return -1\\n        value = self.cache[key].value\\n        self.update(key, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.capacity == 0:\\n            return\\n        if key in self.cache:\\n            self.update(key, value)\\n        else:\\n            if len(self.cache) == self.capacity:\\n                removed_key = self.freqs[self.min_freq].pop_back()\\n                if self.freqs[self.min_freq].is_empty:\\n                    del self.freqs[self.min_freq]\\n                del self.cache[removed_key]\\n            self.min_freq = 1\\n            self.freqs[self.min_freq].push_front(key, value, self.min_freq)\\n            self.cache[key] = self.freqs[self.min_freq].head\\n\\n    def update(self, key: int, value: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        node = self.cache[key]\\n        freq = node.freq\\n        self.freqs[freq + 1].push_front(key, value, freq + 1)\\n        self.cache[key] = self.freqs[freq + 1].head\\n        self.freqs[freq].remove_node(node)\\n        if (freq == self.min_freq) and self.freqs[freq].is_empty:\\n            self.min_freq += 1\\n        if self.freqs[freq].is_empty:\\n            del self.freqs[freq]\\n\\n\\n\\nclass DoubleNode:\\n    def __init__(self, key, value, freq=1, next=None, prev=None):\\n        self.key = key\\n        self.value = value\\n        self.freq = freq\\n        self.next = next\\n        self.prev = prev\\n\\n\\nclass DoubleLinkedList:\\n    def __init__(self) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        self.head = self.tail = None\\n        self.is_empty = True\\n\\n    def __emptied__(self) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        del self.head\\n        self.head = self.tail = None\\n        self.is_empty = True\\n\\n    def push_front(self, key: int, value: int, freq: int) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            self.head = self.tail = DoubleNode(key, value, freq)\\n            self.is_empty = False\\n        else:\\n            node = DoubleNode(key, value, freq, next=self.head)\\n            self.head.prev = node\\n            self.head = node\\n\\n    def pop_front(self) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            raise IndexError(\"LinkedList is empty!\")\\n        key = self.head.key\\n        if self.head == self.tail:\\n            self.__emptied__()\\n        else:\\n            next = self.head.next\\n            self.head.next = next.prev = None\\n            del self.head\\n            self.head = next\\n        return key\\n\\n    def pop_back(self) -> int:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty:\\n            raise IndexError(\"LinkedList is empty!\")\\n        key = self.tail.key\\n        if self.head == self.tail:\\n            self.__emptied__()\\n        else:\\n            prev = self.tail.prev\\n            self.tail.prev = prev.next = None\\n            del self.tail\\n            self.tail = prev\\n        return key\\n\\n    def remove_node(self, node: DoubleNode) -> None:\\n        \"\"\"time: O(1), space: O(1)\"\"\"\\n        if self.is_empty or (node is None):\\n            raise IndexError(\"LinkedList is empty or node is None!\")\\n        if node == self.head:\\n            self.pop_front()\\n        elif node == self.tail:\\n            self.pop_back()\\n        else:\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            node.prev = node.next = None\\n            del node\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844415,
                "title": "python-is-easy",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom collections import OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, val, count):\\n        self.key = key\\n        self.val = val\\n        self.count = count\\n    \\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.key2node = {}\\n        self.count2node = defaultdict(OrderedDict)\\n        self.minCount = None\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        del self.count2node[node.count][key]\\n        \\n        # clean memory\\n        if not self.count2node[node.count]:\\n            del self.count2node[node.count]\\n        \\n        node.count += 1\\n        self.count2node[node.count][key] = node\\n        \\n        # NOTICE check minCount!!!\\n        if not self.count2node[self.minCount]:\\n            self.minCount += 1\\n            \\n            \\n        return node.val\\n        \\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if not self.cap:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            self.get(key) # NOTICE, put makes count+1 too\\n            return\\n        \\n        if len(self.key2node) == self.cap:\\n            # popitem(last=False) is FIFO, like queue\\n            # it return key and value!!!\\n            k, n = self.count2node[self.minCount].popitem(last=False) \\n            del self.key2node[k] \\n        \\n        self.count2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.minCount = 1\\n        return\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom collections import OrderedDict\\n\\nclass Node:\\n    def __init__(self, key, val, count):\\n        self.key = key\\n        self.val = val\\n        self.count = count\\n    \\nclass LFUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.cap = capacity\\n        self.key2node = {}\\n        self.count2node = defaultdict(OrderedDict)\\n        self.minCount = None\\n        \\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        \\n        node = self.key2node[key]\\n        del self.count2node[node.count][key]\\n        \\n        # clean memory\\n        if not self.count2node[node.count]:\\n            del self.count2node[node.count]\\n        \\n        node.count += 1\\n        self.count2node[node.count][key] = node\\n        \\n        # NOTICE check minCount!!!\\n        if not self.count2node[self.minCount]:\\n            self.minCount += 1\\n            \\n            \\n        return node.val\\n        \\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if not self.cap:\\n            return \\n        \\n        if key in self.key2node:\\n            self.key2node[key].val = value\\n            self.get(key) # NOTICE, put makes count+1 too\\n            return\\n        \\n        if len(self.key2node) == self.cap:\\n            # popitem(last=False) is FIFO, like queue\\n            # it return key and value!!!\\n            k, n = self.count2node[self.minCount].popitem(last=False) \\n            del self.key2node[k] \\n        \\n        self.count2node[1][key] = self.key2node[key] = Node(key, value, 1)\\n        self.minCount = 1\\n        return\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564561,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1778322,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1568771,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1566794,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1565882,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1573112,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1568474,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1567978,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1779143,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1778312,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1564561,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1778322,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1568771,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1566794,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1565882,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1573112,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1568474,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1567978,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1779143,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1778312,
                "content": [
                    {
                        "username": "steveo",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. Who the heck can come up with the solution without seeing it before and code it out in 45 mins."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I was asked this question in a mid-scale company in their VO and i did come up with this approach (array/hash table + double linked list) without knowing it before. However i only had 30 mins to implement it. I \"finished\" it, but definitely not bug free. I still passed that VO.\nI think the takeaway here is if you can come up with this double linked list approach (which i think isn't THAT hard) then it should be enough. Implementation wise, as long as you are not making too many mistakes, you should be fine even though your implementation is not bug-free."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@AdityaBhate](/AdityaBhate) finally someone downvoted this spam"
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I think this would be a good question for individuals specifically applying for a job in computer architecture. I would expect programmers specializing in caches to be familiar with the implementation of an LFU cache; though perhaps asking them to implement it from scratch during an interview is a bit much"
                    },
                    {
                        "username": "KirtiPahwa",
                        "content": "Even after seeing the approach , its taking more than 45 min to implement the code."
                    },
                    {
                        "username": "FrodeSandberg",
                        "content": "Leetcode trying to kill everyones january badge at the finish line with 3 hards in a row. "
                    },
                    {
                        "username": "manhalfgod",
                        "content": "If you also feel struggling to understand the ideas / intuition of LFU cache challenge,\\ntry solving these 2 problems first:\\n\\n1. [Maximum frequency stack](https://leetcode.com/problems/maximum-frequency-stack/)\\n2. [LRU cache](https://leetcode.com/problems/lru-cache/)\\n\\nLearn how to track max (min in LFU challenge case) from the 1st question.\\nLearn the concept of ordered / sorted dictionary keys from the 2nd question.\\n\\nFind your own favorite solutions for each question.\\n\\n**Pro tip**: sort by most recent and learn from newer solution to take advantage of newer programming language features. Most voted solutions can be outdated / convoluted quickly.\\n\\nFor example, if you are using Python, since Python 3.7 a regular dictionary is guaranteed to keep keys insertion order; so you do not need to rely on OrderedDict."
                    },
                    {
                        "username": "CharryLee0426",
                        "content": "Very good guidance!"
                    },
                    {
                        "username": "pratikpalashikar",
                        "content": "Test case is wrong the expected and output  does not match.\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"get\",\"get\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nMy answer: [null,null,null,2,1,2,null,null,3,2,-1,4]\\n\\nand the out from the leetcode [null,null,null,2,1,2,null,null,-1,2,1,4]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Output from LeetCode is the proper one here. Before 4 was inserted, the cache had 2,1 and 3 (full capacity) with 3 being the Least frequently used (get/put).  Hence when we were about to insert 4, in order to make place for it, 3 was removed."
                    },
                    {
                        "username": "Jaltair",
                        "content": "Great way to test if someone lies during the interview ))) \\nCandidate (C), Interviewer (I) at Amazon. \\nI: asks for LPs for part of the interview, uses the remaining 20-30 minutes to ask C to implement LFU\\nC: is able to come up and code optimal solution in 20 minutes\\nI: have you seen the problem before? \\nC: no\\nI (silently) puts a red flag next to Earn Trust/Integrity ))))"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "[@snehagoyal20](/snehagoyal20)  No, it\\'s better not to tell him that you solved this problem before.\\nIf you told him/her, the intervewer has to come up with another problem, and in this case he/she may not prepare himself/herself for another problem, and due to this conflict, you don\\'t guarantee the result you expect if you go ahead and solve the problem (without his/her knowledge of your awareness of the problem)."
                    },
                    {
                        "username": "snehagoyal20",
                        "content": "So should we tell them that we have solved a similar problem earlier?"
                    },
                    {
                        "username": "kkkkcom",
                        "content": "A stupid question: If we put a key-value that already exists in the cache, do we increase the frequency? Or do we reset the frequency of that key to 1?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "We need to increase the frequency while performing both get and put."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@Gleb_B](/Gleb_B)  The problem pretty clearly states \"The use counter for a key in the cache is incremented either a get or put operation is called on it.\""
                    },
                    {
                        "username": "Yongbi",
                        "content": "Just update value ^^\nAt first I misunderstood the description, increase `self.cache[key]+=value`\nevery time the function \n`put() and get() if key already exists`.\nBut it was not an expected solution.\n\nThen i add another \n`self.frequency[key]+=1`  and update `self.cache[key]=value`"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nSo, the frequency will be incremented -> 2"
                    },
                    {
                        "username": "Gleb_B",
                        "content": "I believe we should do nothing in this case above updating the value. Because we can\\'t \"put a key-value that already exists\", we just do a value update for a particular (existing) key."
                    },
                    {
                        "username": "pushkarambole",
                        "content": "![image](https://assets.leetcode.com/users/images/dd763199-10ba-4c05-b769-3657247d3a9c_1604277062.9412482.png)\\n\\nIf capacity is 0, then how put operation is valid?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Since the capacity is 0, put should not be able to add any key-value and get should always return -1.\\nThis should be handled generically and not treated as special case."
                    },
                    {
                        "username": "efim666",
                        "content": "This test case tripped me over as well.\\nAll it says :\\n- create cache with capacity 0\\n- try to put key 0, value 0 into it\\n- try to get value by key 0\\n\\nif you try to run it, \\nthe correct response to `get` is -1 \\nmeaning that cache with capacity 0 should never save any keys"
                    },
                    {
                        "username": "m-rossini",
                        "content": "it is not, that is what your code returned. You probably are not handling the scenario where there is no room properly"
                    },
                    {
                        "username": "brtsai",
                        "content": "If I have an item in my LFU cache, and I use set to change its value, should I reset its number of uses, and recency as though it were a new item, or increment the old frequency and recency?"
                    },
                    {
                        "username": "anu_ishi",
                        "content": "did anyone else get a time limit exceeded on the 23/26 testcase?\\nhow did you resolve it?"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you use built-in functions of the data structure you are using, which doesn\\'t take more than O(1) runtime, you are good to go. And yes, do not use any looping\\n\\nOn worst side you should not push it to more than O(LogN)\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "1dimir",
                        "content": "Used to store frequencies in a list. It was not enough efficient. Had to switch storage into bucket of buckets. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "avoid using loop and data structue which use more than O(1) time complexity for inserting the value or deleting or searching etc."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "3rd DAY of hard Question (consisteltly) .. Just 3 days remaining in january and LEETCODE be like--> Abb krke dikha january challenge poora.."
                    }
                ]
            },
            {
                "id": 1569502,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1779420,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1779346,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1778847,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1778341,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1569239,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1570606,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1570270,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1778309,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1574283,
                "content": [
                    {
                        "username": "codeonkar",
                        "content": "This test case will never work in C#. This is specific to Java HashMap which can accept duplicates for keys but c# dictionary object doesn\\'t. My test case output was 1 whereas they expect it to be 2 which is true if [2,2] were inserted in the cache bur c# doesn\\'t allow duplicate keys hence [2,2] will never be allowed to be inserted in the dictionary. hence it will return 1 from [2,1].\\n\\n[\"LFUCache\",\"put\",\"put\",\"put\",\"put\",\"get\"]\\n[[2],[3,1],[2,1],[2,2],[4,4],[2]]"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Bro... If you see a key-value incoming, where that key was already encountered before, you need to consider 2 scenarios:\\n1) If that key still exists, you simply need to update it\\'s value with the new incoming value.\\n2) If that key was encountered earlier, but was later removed during some process, you just need to add the new key-value pair again."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[2,2] is not a pair of duplicate keys, its a key value pair. 2 : 2. "
                    },
                    {
                        "username": "Boich",
                        "content": "The question says to update the value if a new value is provided for a given key.\n\nFrom the definition: \"Update the value of the key if present, or inserts the key if not already present.\""
                    },
                    {
                        "username": "aanand07",
                        "content": "This is a complete user story, I would take 2 story points at least to complete it."
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are thinking how to use a hash-map and yet find the minimum frequency in O(1) time, here\\'s the trick -\\n1. Keep a member/global variable ```minf``` say, to keep track of the minimum frequency. \\n2. While accessing an element ```k``` suppose we see that its frequency ```f``` is currently the same as ```minf```. After increasing the frequency of ```k``` to ```f + 1```, i.e. after moving it from bucket ```f``` to bucket ```f + 1```, if we see that there are no more elements with frequency ```minf```, i.e. bucket ```f``` is empty, we set ```minf``` to ```f + 1```.\\n3. What about updating the ```minf``` when the least frequently used item is pruned due to reaching capacity? Well, this happens only when a new element is getting added whose frequency will be 1. So, just need to set ```minf``` to ```1``` when adding a new element and we are done."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Before going for this problem,try to go through problem (146. LRU Cache) and solve it,[click here](https://leetcode.com/problems/lru-cache/description/)"
                    },
                    {
                        "username": "ajesk",
                        "content": "Tough problem until you know the trick to it. For those who need a little nudge...\\n\\nHint: Some data structures can be very powerful when stored within other data structures."
                    },
                    {
                        "username": "obelisk0114",
                        "content": "I met an input data with `capacity = 0`.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529399897.png)\\n\\n\\nHowever, when I used this input data to run code test, the system also threw an exception.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/obelisk0114/image_1529400069.png)\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Just use an additional conditional block to handle pushing into zero cap cache if you are using array implemented DS"
                    },
                    {
                        "username": "Hprasad234",
                        "content": "Just today I got this question in the Microsoft Onsite interview (with 1/2 hour left). I answered it correctly (without a flaw), interviewer was sitting like a rock, I explained him my solution at every step. After this round I was shown the door. ROFL, I don\\'t know what else MSFT is expecting. \\nMSFT : just realize either your interviewers are dumb or they don\\'t know what question to ask in the interview (with 1/2 hr left)."
                    },
                    {
                        "username": "btmcdaniel88",
                        "content": "it makes zero sense to support a capacity of zero for a cache. why are the constraints set up this way? ridiculous."
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "\"**Hard**\" week ..."
                    },
                    {
                        "username": "deepika8",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nNow, capacity is 3 and initially we toggle between 1 and 2 so the state of DLL will be 2 -> 1 where 1 is the least recently used.\\nNow when request for 3 comes, we will evict 1 then why is the get for 3 equal to -1 ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c 3 has freq = 1 (just one put) and 4 has it 1 as well (one put). At the same time 2 has freq = 3 (one put + 2 get), 1 has it = 2 (one put + 1 get)), and since 4 comes after 3, 3 gets removed from the cache (least used)"
                    }
                ]
            },
            {
                "id": 1572923,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1571731,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1571732,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1571734,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1571733,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 2074812,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 2049874,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 2019732,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1965118,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1946435,
                "content": [
                    {
                        "username": "steveo",
                        "content": "Who the heck can come up with this solution in 45 mins?!"
                    },
                    {
                        "username": "poradia",
                        "content": "Please correct me if I am wrong,\\n[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\n\\nExpected:\\n[null,null,null,2,1,2,null,null,-1,2,1,4]\\n\\nMy output:\\n[null,null,null,2,1,2,null,null,3,2,-1,4]"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "When we try to enter [4, 4] we need to invalidate anyone among [3, 2, 1] and since the least used entry in this cache is 3 (2 and 1 have already been referenced) so here 3 will be invalidated and not 1.\\nLFU \\u21FE Least Frequently used and not LRU \\u21FE Least Recently used\\nSo the first parameter for invalidating an entry is its frequency count. If frequency count is the same, then we look for least recently used"
                    },
                    {
                        "username": "TQINSYR",
                        "content": "Right Now, I am concentrated on the frequency. How the problem description calculate the frequency. Here is my test and results.\\n\\n[\"LFUCache\",\"set\",\"set\",\"get\",\"set\",\"get\",\"get\",\"set\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[6],[4,4],[3]]\\n[null,null,null,1,null,-1,-1,null,-1]\\n\\nI think the results should be [null,null,null,1,null,-1,-1,null,3]. Here is how I calculate the frequency. \\nTime  Instruction  Cache  \\n0        set[1:1]       [1:1]\\n1        set[2:2]       [1:1, 2:2]\\n2        get[1]          [1:1, 2:2]\\n3        set[3:3]       [1:1, 3:3]  \\n ***// For key = 1, its coming into cache time is 0. Right now, it last 3 instructions time and it was use for twice. The frequency is 2/3. For the key = 2, its coming into cache time is 1, it last 2 instructions time. It was used for only once. The frequency is 1/2. So evict the [2:2]***\\n4        get[2]          [1:1, 3:3]\\n5        get[6]          [1:1, 3:3]\\n6        set[4:4]       [4:4, 3:3]\\n***// When the set[4,4] comes, calculate the frequency of the items in the cache. key = 1 2/6 = 1/3; key = 3 1/3 since its coming into the cache at time 3 and it was only called once.***\\n7        get[3]\\nSo at time 7, it should return the value of key = 3 rather than - 1."
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Till when [4, 4] is being put, 3 has not been referenced even once, so the most frequently used is still 1.\\nSo for placing 4, 3 will be invalidated and not 1."
                    },
                    {
                        "username": "Oldman09",
                        "content": "From my understanding, when we set or update an entry, that operation shouldn't be considered as an 'Use' operation."
                    },
                    {
                        "username": "sameer13",
                        "content": "Please add C# to the language list."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\nSTRIVER\\nhttps://www.youtube.com/watch?v=0PSB9y8ehbk&ab_channel=takeUforward"
                    },
                    {
                        "username": "jzbdota",
                        "content": "I am confused about the LFU. If the cache is currently full of keys (number of keys = capacity), and the frequencies of the keys are all greater than 1, it is impossible to insert any new key in the cache. Am I right?"
                    },
                    {
                        "username": "vik333",
                        "content": "Albeit this an amazing question, but there\\'s no way you can code this in an interview. NO WAY. Takes way too much time imo."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is it time to throw in the towel? \\n\\nThis question has beckoned me ever since I did the [LRUCache problem](https://leetcode.com/problems/lru-cache/). This is of course a more difficult problem partly due to the number of caches being much larger and because you need a frequency table to keep track of the frequencies.\\n\\nAfter several days, I got the code to run without errors. It passed 24 testcases but on the 25th testcase, it gave a \"wrong answer\".  This testcase is far to large for me to trace through (it has 1101 caches alone).\\n\\nI don\\'t know how to progress from here.\\nhttps://leetcode.com/submissions/detail/990805776/"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) Thanks for the link. It pretty much confirms the algorithm that I used. Unfortunately it doesn\\'t suggest an edge case that I didn\\'t account for. I may have to completely redesign my code but I will wait and see."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Don't throw in the towel now, not after coming this close. I too faced similar issues, then I went through the below article. It helped me understand any corner cases, and how to keep the implementation minimal etc.\nhttps://www.enjoyalgorithms.com/blog/least-frequently-used-cache\n\nAnd finally, I implemented it:\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/c-solution-96-4-efficient/"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "This is extremely hard to come up with and implement in 45 mins unless you already have a strong fundamental knowledge about LRU/LFU. Focus on the fundamentals and use leetcode to learn the applications of the data structures!"
                    }
                ]
            },
            {
                "id": 1934732,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1928396,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1808698,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1781764,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1781249,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1780554,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1780476,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1779967,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1779901,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1779878,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Real Hard Problem.\\n\\nApproach\\nStriver Approach.\\nUsing Doubly linkedList + keyNode + freqListMap.\\nAlso using the LRU(Least Recent Used) concept.\\n\\nComplexity\\nTime complexity:\\nT.C=O(1) get and put.\\n\\nSpace complexity:\\nS.C=O(2N). for keyNode O(n) + O(n) freqListMap.\\n\\nPlease Upvote. If Understand solution..\\nSolution Link:\\nhttps://leetcode.com/problems/lfu-cache/solutions/3652639/c-real-hard-problem/"
                    },
                    {
                        "username": "Shailesh003",
                        "content": "i find its a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    },
                    {
                        "username": "sk_14",
                        "content": "Great Fun to solve this problem after solving the LRU Cache design problem."
                    },
                    {
                        "username": "TuringJest",
                        "content": "<p><div><div class=\"text-brand-orange\">There is one thing to realise, which will make this problem so much less of a headache!</div> </div></p>\\n\\nEvery time an item is removed from the cache the \\'minFrequency\\' is reset to \\'1\\' - because removing is always followed by adding a new item with freq 1! \\n\\nI missed that and came up with a horribly complicated solution, linking up things that don\\'t have to be linked up. "
                    },
                    {
                        "username": "cswartzell",
                        "content": "Absolutely stupid that there is a base case where the capacity is zero. What is the point of that? Sure, I\\'ll toss an if for the functions to just exit, but what an obtuse edge case"
                    },
                    {
                        "username": "nishadtardalkar",
                        "content": "If some key has count=4 and its removed and the reinserted in cache will its count be 5 or 1?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "count=1"
                    },
                    {
                        "username": "hrithik_248",
                        "content": "doesn\\'t erase for list STL have time complexity O(n)?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "OMG I cant believe questions like these exist, how can we even solve it an interview. Just wasted 5+ hours on this only for January badge."
                    },
                    {
                        "username": "MantisPraying",
                        "content": "There is something wrong with Leetcode\\'s answer checker,\\nfor Test case: `[\"LFUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n, [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\\nI\\'m getting wrong answer as `[null,-1,null,-1,null,null,2,-1]`\\nBut when I\\'m manually testing it the answer is correct as `[null,-1,null,-1,null,null,2,6]`\\n\\nCan anyone please help me and tell me why?\\n[My Submission](https://leetcode.com/problems/lfu-cache/submissions/887699252/)"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "[@Yongbi](/Yongbi) \\nAs i said, my solution is returning 6 when i manually tested that case, But Leetcode is saying it is giving -1 for it, which i wanted to know why. So is performing correctly when i use it.\\nWould be helpful if you can tell what is wrong with the code."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Srajan Gupta](/Mantis01)\nget(2) at the end, the last value of key \"2\" is 6, [2,6] then return 6 (why your return -1?) \n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n1. Capacity =2\n2. get 2 return -1\n3. put 2 with value 6, counter 2 =1\n4. get 1 return -1\n5. put 1 with value 5, counter 1=1\n6. put 1 with value 2, counter 1=2\n7. get 1 return 2, counter 1=3\n8. get 2 return 6, counter 2=2\n"
                    },
                    {
                        "username": "sauliusvince",
                        "content": "I am facing difficulty passing the test with a large dataset. Despite spending several hours trying to identify the mistake, I have been unable to do so. Can someone assist me in finding any logical errors?\\n\\n        map<int, int> Cache;\\n        unordered_map<int, int> Frequency;\\n        int Capacity;\\n\\n        LFUCache(int capacity)\\n        {\\n            Capacity = capacity;\\n        }\\n        \\n        int get(int key) \\n        {\\n            if(Cache.count(key) <= 0)\\n                return -1;\\n\\n            UpdateFrequency(key);\\n            return Cache[key];\\n        }\\n\\n        //update frequency and add to the end of map\\n        void UpdateFrequency(int key)\\n        {\\n            int freq = Frequency[key];\\n            Frequency.erase(key);\\n            Frequency[key] = freq + 1;\\n        }\\n\\n        //Finds least frequentlly used in cashe \\n        //Returns key, if Cashe is empty returns -1 key\\n        int FindLFU()\\n        {\\n            int leastValue = INT_MAX;\\n            int lKey = -1;\\n\\n            for(const auto& [key, value] : Frequency)\\n            {\\n                //update least value even if the value is the same\\n                if(value <= leastValue)\\n                {\\n                    leastValue = value;\\n                    lKey = key;\\n                }\\n            }\\n\\n            return lKey;\\n        }\\n        \\n        void put(int key, int value) \\n        {\\n            if(Capacity <= 0)\\n                return;\\n\\n            //if key does not exist and the size is over limit, remove LFU\\n            if(Cache.count(key) == 0 && Cache.size() >= Capacity)\\n            {\\n                int leastUsed = FindLFU();\\n                \\n                //if LFU was found remove it\\n                if(leastUsed != -1)\\n                {\\n                    Cache.erase(leastUsed);\\n                    Frequency.erase(leastUsed);\\n                }\\n            }\\n\\n            UpdateFrequency(key);\\n            Cache[key] = value;\\n        }`"
                    }
                ]
            },
            {
                "id": 1779817,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779731,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779728,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779719,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779579,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779541,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779516,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779348,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779337,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779242,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "My solution wasn\\'t fast nor memory efficient, but it was accepted and I didn\\'t lose my 28 (now 29) days streak. \"Only\" 336 days to go! (Yes, I joined this site on january 1st, but that\\'s just a coincidence)"
                    },
                    {
                        "username": "Aparannha",
                        "content": "class LFUCache {\\n    int maxSizeCache; // maximum capacity of the cache\\n    int size; // current number of elements in the cache\\n    int minFreq; // the minimum frequency of elements in the cache\\n    unordered_map<int, pair<int, int>> keyNode; // key to {value,freq}\\n    unordered_map<int, list<int>::iterator> keylist; // key to list iterator\\n    unordered_map<int, list<int>>  freqKeyLt;  // freq to key list\\npublic:\\n    LFUCache(int capacity) {\\n        maxSizeCache = capacity; // setting the maximum capacity of the cache\\n        size = 0; // initially the size is zero\\n    }\\n    \\n    int get(int key) {\\n        // if the key is not in the cache, return -1\\n        if(keyNode.count(key)==0) return -1;\\n        \\n        // remove the key from its current frequency list\\n        freqKeyLt[keyNode[key].second].erase(keylist[key]);\\n        \\n        // increase the frequency of the key\\n        keyNode[key].second++;\\n        \\n        // add the key to the frequency list with its new frequency\\n        freqKeyLt[keyNode[key].second].push_back(key);\\n        \\n        // update the key\\'s position in the keylist\\n        keylist[key]=--freqKeyLt[keyNode[key].second].end();\\n        \\n        // if the list of minimum frequency is empty, update the minimum frequency\\n        if(freqKeyLt[minFreq].size()==0 ) \\n              minFreq++;\\n        \\n        // return the value associated with the key\\n        return keyNode[key].first;\\n    }\\n    \\n   void put(int key, int value) {\\n        // if the cache has a maximum capacity of 0, return\\n        if(maxSizeCache<=0) return;\\n        \\n        // check if the key already exists in the cache\\n        int storedValue=get(key);\\n        if(storedValue!=-1)\\n        {\\n            // if the key already exists, update its value\\n            keyNode[key].first=value;\\n            return;\\n        }\\n        \\n        // if the cache is full, remove the least frequently used key\\n        if(size >= maxSizeCache)\\n        {\\n            keyNode.erase( freqKeyLt[minFreq].front() );\\n            keylist.erase( freqKeyLt[minFreq].front() );\\n            freqKeyLt[minFreq].pop_front();\\n            size--;\\n        }\\n        \\n        // add the new key to the cache\\n        keyNode[key]={value, 1};\\n        freqKeyLt[1].push_back(key);\\n        keylist[key]=--freqKeyLt[1].end();\\n        minFreq=1;\\n        size++;\\n    }\\n};\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache* obj = new LFUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */"
                    },
                    {
                        "username": "charonme",
                        "content": "I was pleasantly surprised PHP maintains its array order fast enough (including getting the first key, adding new keys, and removing arbitrary keys) for it to pass the problem constraints, although I\\'m still not sure it\\'s really all O(n). I only know adding keys is O(n) unless there are [key hash collisions](https://www.npopov.com/2011/12/28/Supercolliding-a-PHP-array.html)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "3 hards in a row!! Leetcode dont want me to get January badge"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the test cases seems it can be done using stream intervals question\\n"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Those who didn\\'t peek at the solution, please leave a comment below."
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I've completed in 30 min, but I solved Max Frequency Stack before, so I reused some techniques and code."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I completed it without peeking at the solution, took me 7 hours though"
                    },
                    {
                        "username": "faroukamr",
                        "content": "Before solving this problem, you need to solve (895. Maximum Frequency Stack) and (146. LRU Cache)"
                    },
                    {
                        "username": "akshajnair",
                        "content": "Getting time limit exceeded even though everywhere my time complexity everywhere is O(1) except the delete operation i.e O(N). \\uD83E\\uDD72"
                    },
                    {
                        "username": "Baymax_",
                        "content": "During Delete operation, you might be traversing the list to find the element you want to remove. Hence, you\\'ll have O(N) for this.\\n\\nInstead, if you have a dictionary that maps keys to the reference of the node, you can find that node via Dictionary key in O(1) and perform delete operation on it.\\n\\nHere is a C# solution using that approach.\\nhttps://leetcode.com/problems/lfu-cache/solutions/3600039/dictionary-linkedlist-priorityqueue-c-96-4-efficient/"
                    },
                    {
                        "username": "anoyash",
                        "content": "May I know , what is the significance of passing value in put function ? 🤔🤔🤔"
                    },
                    {
                        "username": "hoangtan1193",
                        "content": "This is a great question for testing people\\'s understanding of algorithms and data structures, but it\\'s way too long for a 45mins interview. "
                    }
                ]
            },
            {
                "id": 1779219,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779212,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779206,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779189,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779185,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779183,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779170,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779144,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779102,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1779032,
                "content": [
                    {
                        "username": "phcatuan",
                        "content": "My output and expected are the same but why is it wrong??\\n![image](https://user-images.githubusercontent.com/119845037/215319453-4b2a4d45-c33f-465b-8a06-d62a3a4ecfba.png)\\n![image](https://user-images.githubusercontent.com/119845037/215319487-a666a039-bcd9-4e8f-a22b-3fb6c03791b6.png)"
                    },
                    {
                        "username": "charonme",
                        "content": "the difference is beyond the three dots at the end"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well 3 Hard questions in a row in Daily questions + 2 Hard questions in Weekly 330\\nI\\'m so bored of it now \\uD83D\\uDE23"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "Code\\'s not working\\nclass ListNode:\\n    def __init__(self, val,prev=None, next=None):\\n        self.val = val\\n        self.prev= prev\\n        self.next= next\\nclass LinkedList: # rhis implements logic of LFU cache\\n# solve LRU before this.\\n    def __init__(self):\\n        self.left= ListNode(0)        \\n        self.right= ListNode(0)\\n        self.left.next =self.right\\n        self.map={}\\n    def length(self):\\n        return len(self.map)\\n    def pushRight(self,val):\\n        node= ListNode(val,self.right.prev,  self.right)\\n        self.map[val]=node\\n        self.right.prev=node\\n        node.prev.next=node\\n\\n    def get(self, key: int) -> int:\\n        return len(self.map)        \\n    def popLeft(self): # popping the LRU element\\n        res = self.left.next.val\\n        self.pop(self.left.next.val)\\n        return res\\n    def update(self,val):\\n        self.pop(val)\\n        self.pushRight(val) #push to the first one \\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        node = LisNode(val, self.right.prev, self.right)\\n        self.map[val]=node # save a reference of that node in the hashmap\\n        self.right.prev=node\\n        node.prev.next= node\\n\\n    def pop(self, val):\\n        if val in self.map:\\n            node= self.map[val]\\n            next, prev= node.next, node.prev\\n            next.prev=  prev\\n            prev.next = next\\n\\nclass LFUCache:\\n    def __init__(self, capacity:int):\\n        self.cap= capacity\\n        self.lfuCnt=0\\n        self.valMap={}\\n        self.countMap = collections.defaultdict(int)\\n        self.listMap = collections.defaultdict(LinkedList)\\n\\n    def counter(self ,key):\\n        cnt= self.countMap[key]\\n        self.countMap[key]  += 1\\n        self.listMap[cnt].pop(key) # follows the code that written above.\\n        self.listMap[cnt+1].pop(key)\\n\\n        if cnt== self.lfuCnt and self.listMap[cnt].length() ==0:\\n            self.lfuCnt +=1\\n\\n    def get(self,key:int)->int:\\n        if key not in self.valMap:\\n            return -1\\n        self.counter(key)\\n        return self.valMap[key]\\n    \\n    def put(self,key:int, value:int) -> None:\\n        if self.cap ==0:\\n            return \\n        \\n        if key not in self.valMap and len(self.valMap) == self.cap:\\n            # if capacity is full so now delte the value\\n            res = self.listMap[self.lfuCnt].popLeft() # deleting leasst recently used.\\n            self.valMap.pop(res)\\n            self.countMap.pop(res)\\n        self.valMap[key] = value\\n        self.counter(key)\\n        self.lfuCnt = min(self.lfuCnt, self.countMap[key]) \\n\\n\\n\\n# Your LFUCache object will be instantiated and called as such:\\n# obj = LFUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)"
                    },
                    {
                        "username": "be_quick",
                        "content": "1) Capacity is count of frequency of elements\\n2) Deleting a key results in deleting all instances of that key, lets say F is frequency of key K then we delete all instances of that key K.\\n3) You need to add freq for every call of Get and Put function calls\\n\\nFor me 2nd and 3rd point doesn\\'t make sense \\n\\nI don\\'t know why we need to delete all instance of Key K. Doesn\\'t deleting one instance creates space for new key to be inserted ?\\n\\nwhy do we need to add freq for get function,it doesnt increase count of that key present in\\nthe cache ?\\n\\nDoes LFU cache works this way ?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "2. There is only one instance of a key. If you call put(3,5) and then put(3,6) - it means that you have one instance of the key 3, which was called twice -> so its frequency  == 2, with value == 6 (value 5 is forgotten) "
                    },
                    {
                        "username": "pro_flow",
                        "content": "3 hards in a row - That\\'s pretty cool LeetCode \\uD83D\\uDC4D"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I have learned to read the question carefully.  I spotted that, according to the description  you should only check capacity BEFORE inserting.  On that basis, it would still store the last put in the case of capacity 0.  So much for reading carefully...  Capacity 0 is really capacity 0 :-("
                    },
                    {
                        "username": "anu_ishi",
                        "content": "!!NOT THE SOLUTION!!\n\n\n    from collections import deque \n    class LFUCache:\n        def __init__(self, capacity: int):\n            self.Q = deque(maxlen = capacity)\n            self.cnt = {}\n            self.val =  {}\n\n        def get(self, key: int) -> int:\n            if key not in self.Q:\n                return -1\n            else:\n                self.cnt[key] += 1\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                return self.val[key]                          \n\n        def put(self, key: int, value: int) -> None:\n            if key not in self.Q:\n                if self.Q.maxlen == len(self.Q) and self.Q.maxlen > 0:\n                    temp = min(self.cnt.values())\n                    res = [key for key in self.cnt if self.cnt[key] == temp]\n                    if len(res) == 1:\n                        self.Q.remove(res[0])\n                        del self.cnt [res[0]]\n                        del self.val [res[0]]\n                    elif len(res) == len(self.Q):\n                        i = self.Q.pop()\n                        del self.cnt [i]\n                        del self.val [i]\n                    else:\n                        temp = list(self.Q)\n                        temp.reverse()\n                        for i in temp:\n                            if i in res:\n                                self.Q.remove(i)\n                                del self.cnt [i]\n                                del self.val [i]\n                                break\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] = 1\n\n            else:\n                self.Q.remove(key)\n                self.Q.appendleft(key)\n                self.val[key] = value\n                self.cnt[key] += 1 \n\n    # Your LFUCache object will be instantiated         and called as such:\n    # obj = LFUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n\nthis showed time limit exceeded at 23/26.\nplease help someone!!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Today\\'s contest and that daily makes me crazy."
                    },
                    {
                        "username": "be_quick",
                        "content": "[\"LFUCache\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[2,2],[1,1],[2],[1],[2],[3,3],[4,4],[3],[2],[1],[4]]\\nExpected output : [null,null,null,2,1,2,null,null,-1,2,1,4]\\ncan someone expliain why answer is -1 when we call get(3) ?"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Because 2 and 1 are more frequently used as compared to 3 which has only been used once so it is an ideal candidate to get ejected from the cache.\n\nI was also facing this issue as I was thinking in terms of least recently used only whereas we have to think in terms of frequency also for the elements which are being accessed.\n\n\nCounter for all the elements in the cache look like this \n\n2 -> put once and get twice so total 3\n1 -> put once and get once so total 2\n3 -> put once only hence counter will be 1\n\nSo when we have to put [4,4] in the cache 3 will be ejected as it has the lowest count.\n\nDo upvote if this helps.\n"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "anybody has more than 61 lines?"
                    },
                    {
                        "username": "krishnakanna18",
                        "content": "167 :)"
                    },
                    {
                        "username": "Unrealwork",
                        "content": "I have 156=)"
                    }
                ]
            },
            {
                "id": 1778936,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778914,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778809,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778806,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778694,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778434,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778415,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778401,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778388,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            },
            {
                "id": 1778384,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "I can\\'t\\nI have to see the solution\\uD83E\\uDD72"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Great and hard question! I try my best to give a brute force solution (TLE) within 45 mins..."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Leetcode isn\\'t being generous these days"
                    },
                    {
                        "username": "user5248xm",
                        "content": "I had a doubt, what does the use counter function cnt(x) return when the key is not present in the LFU?"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "This Question+Today\\'s Contest is making me hate my Life"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Last 4 days have been too painful...\\nOnly hard problems leetcode !! :)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Can\\'t use BTreeSet.pop_first() in Rust because the Rust compiler is too old really kills the performance"
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "3 hard Questions in a row for POTD(problem of the day) !? hahaha, great way to celebrate the CNY, we\\'re off to a good start"
                    },
                    {
                        "username": "ethan__smith",
                        "content": "Nice problem, though I would\\'ve really appreciated it if the description included the following two statements:\\n\\n1. The counter for a key is SET TO ZERO whenever the key is deleted from the cache;\\n2. The counter for a key is NOT incremented when a \"get\" operation is called on a key that is not present in the cache (and therefore the \"get\" operation fails).\\n\\nStatement 1 is required because of how confusing the \"when the key is FIRST inserted into the cache\" phrase is. Like, what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache? As it turns out, it does. \\nStatement 2 is not required, strictly speaking, but would still be helpful.\\n\\nThough both already sort of follow from the description as it is, it wasn\\'t quite clear to me; perhaps I\\'m not alone."
                    },
                    {
                        "username": "Baymax_",
                        "content": "\"\"what if it had already been in the cache once, got removed and is now being inserted for a second time? Does it still count as being \"FIRST\" inserted into the cache?\"\"\\n\\nIt all depends on how you are maintaining the keys.. If you are removing it or simply hitting it\\'s counter to zero and it\\'s value to null..\\nSince it is coders approach, they would not be mentioning those points you wanted in the description :)"
                    },
                    {
                        "username": "user5248xm",
                        "content": "So if a key (let\\'s say x) is not present in the LFU, cnt(x) would return 0 ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Another hard problem in daily challenge in a row for 3 days. Unbelievable"
                    }
                ]
            }
        ]
    }
]