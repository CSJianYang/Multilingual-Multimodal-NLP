[
    {
        "title": "Search Insert Position",
        "question_content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must&nbsp;write an algorithm with&nbsp;O(log n) runtime complexity.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-104 <= nums[i] <= 104\n\tnums contains distinct values sorted in ascending order.\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 249092,
                "title": "come-on-forget-the-binary-search-pattern-template-try-understand-it",
                "content": "`l` means left index, `r` means right index, `m` means middle index\\n\\n**Comments**\\nI have seen many different styles of binary search solution, I saw some people tend to use some pattern whenever solving binary search problems, i.e. \\n1. `while(l <= r){...}`. Same while condition\\n2. `r = m - 1;`, right is always `m - 1`\\n3. `l = m + 1`: , left is always `m + 1`\\n\\n**It is a good idea to use pattern/template for binary search?**\\nI can only speak for myself. At least for me, I do not think so. I prefer to choose the binary search rules based on the context of the problem to decide how to play with `l` and `r`.\\nIf you are using pattern, you have to remember it. You are not understanding the core of binary search! This is a big issue I think.\\n\\n---\\n**Algorithms**\\nI want to give my explanation below:\\n\\n1. First of all, we assume `[l, r]` is the possible answer range(inclusive) for this question. So initially `l = 0;` and `r = n - 1;`\\n2. we calculate `int m = l + (r - l)/2;` rather than `int m = (l + r)/2;` to avoid overflow.\\n3. Clearly, if `A[m] = target`, `m` is exactly the position we should insert the target \\n4. if `A[m] < target`, then the insertion position should be **at least** at `m + 1`, because it can be even larger, i.e. to the right of `m + 1`(including `m + 1`),  we set `l = m + 1;`\\n5. if `A[m] > target`, the insertion position should be **at most** `m`, because it can even smaller. So we would set `r = m`. An example:\\n\\n\\t```\\n\\ttarget: 6 and m = 7\\n\\t1 \\t5 \\t7 \\t9\\n\\t\\t    m\\n\\t\\t  result\\n\\t```\\n6. Then how to determine the while loop condition, `l < r`, `l <= r` or `l < r - 1`? \\n\\tThe answer is that we analyse and conclude with the one **which will not cause deal while loop** in our code while we are moving our left and right pointers.\\n\\t1. `l = m + 1`\\n\\t2. `r = m`\\n\\t\\n\\tWe will analyse which would happen when we have 3, 2 and 1 elements at the end below\\n\\t\\n\\tFirst let\\'s assume there are **3 elements** left at last as shown below:\\n\\n\\t```\\n\\tx   x   x   5 \\t7 \\t9   x   x   x\\n\\t            l\\tm   r\\n\\t```\\n\\n\\twe can see that `l = m + 1` can help shrink the search space by 2:\\n\\t```\\n\\tx   x   x   5 \\t7 \\t9  x   x   x\\n                l\\tm   r\\n\\t```\\n\\tand `r = m` can help shrink the size by 1:\\n\\t```\\n\\tx   x   x   5 \\t7 \\t9   x   x   x\\n\\t            l\\tr\\n\\t```\\n\\tso 3 elements will not cause dead while loop. we should be fine.\\n\\t\\n\\tNext we reduce to **2 elements**:\\n\\t```\\n\\tx   x   x   5   7   x   x   x\\n\\t           l/m  r\\n\\t```\\n\\tSame way, we can see that `l = m + 1` and `r = m` can both shrink the size by 1, no dead loop as well.\\n\\t\\n\\tThen we can safely go to the cases when we have only **1 element** at the end:\\n\\n\\t```\\n\\tx   x   x   5   x   x   x\\n\\t          l/m/r\\n\\t```\\n\\tWe can see that  `l = m + 1` will not cause dead loop, but with `r = m` we **cannot shrink the size anymore**, so it might lead to a dead while loop. So we need to jump out of the while loop when we have 1 element. The condition of 1 element is `i = j`, so we choose our while condition: `while (l < r)`  \\n\\n7. At the end, we need to check the last element: `nums[l/r]` which has not been checked in binary search loop with target to determine the index. We call it the **post processing**.\\n\\n**Summary**\\nActually I always do my analysis start from 2 elements instead of 3 elements, because for most of binary search problems, we always can shrink the search space to 2 or 1 element at the end. With 2 elements, it is pretty quick to identify the condition based on your rule.\\n\\n---\\n**Final Code** \\n\\n```java\\nclass Solution {\\n\\tpublic int searchInsert(int[] nums, int target) {\\n\\t\\tif(nums == null || nums.length == 0) return 0;\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint l = 0;\\n\\t\\tint r = n - 1;\\n\\t\\twhile(l < r){\\n\\t\\t\\tint m = l + (r - l)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(nums[m] == target) return m;\\n\\t\\t\\telse if(nums[m] > target) r = m; // right could be the result\\n\\t\\t\\telse l = m + 1; // m + 1 could be the result\\n\\t\\t}\\n\\t\\t\\n\\t\\t// 1 element left at the end\\n\\t\\t// post-processing\\n\\t\\treturn nums[l] < target ? l + 1: l;\\n\\t}\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\nTC(Time Complexity): `O(logn)`\\nSC(Space Complexity): `O(1)`",
                "solutionTags": [],
                "code": "```\\n\\ttarget: 6 and m = 7\\n\\t1 \\t5 \\t7 \\t9\\n\\t\\t    m\\n\\t\\t  result\\n\\t```\n```\\n\\tx   x   x   5 \\t7 \\t9   x   x   x\\n\\t            l\\tm   r\\n\\t```\n```\\n\\tx   x   x   5 \\t7 \\t9  x   x   x\\n                l\\tm   r\\n\\t```\n```\\n\\tx   x   x   5 \\t7 \\t9   x   x   x\\n\\t            l\\tr\\n\\t```\n```\\n\\tx   x   x   5   7   x   x   x\\n\\t           l/m  r\\n\\t```\n```\\n\\tx   x   x   5   x   x   x\\n\\t          l/m/r\\n\\t```\n```java\\nclass Solution {\\n\\tpublic int searchInsert(int[] nums, int target) {\\n\\t\\tif(nums == null || nums.length == 0) return 0;\\n\\t\\t\\n\\t\\tint n = nums.length;\\n\\t\\tint l = 0;\\n\\t\\tint r = n - 1;\\n\\t\\twhile(l < r){\\n\\t\\t\\tint m = l + (r - l)/2;\\n\\t\\t\\t\\n\\t\\t\\tif(nums[m] == target) return m;\\n\\t\\t\\telse if(nums[m] > target) r = m; // right could be the result\\n\\t\\t\\telse l = m + 1; // m + 1 could be the result\\n\\t\\t}\\n\\t\\t\\n\\t\\t// 1 element left at the end\\n\\t\\t// post-processing\\n\\t\\treturn nums[l] < target ? l + 1: l;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15080,
                "title": "my-8-line-java-solution",
                "content": "        public int searchInsert(int[] A, int target) {\\n            int low = 0, high = A.length-1;\\n            while(low<=high){\\n                int mid = (low+high)/2;\\n                if(A[mid] == target) return mid;\\n                else if(A[mid] > target) high = mid-1;\\n                else low = mid+1;\\n            }\\n            return low;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public int searchInsert(int[] A, int target) {\\n            int low = 0, high = A.length-1;\\n            while(low<=high){\\n                int mid = (low+high)/2;\\n                if(A[mid] == target) return mid;\\n                else if(A[mid] > target) high = mid-1;\\n                else low = mid+1;\\n            }\\n            return low;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 15101,
                "title": "c-o-logn-binary-search-that-handles-duplicate",
                "content": "If there are duplicate elements equal to *target*, my code will always return the one with smallest index.\\n\\n    class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            int low = 0, high = nums.size()-1;\\n    \\n            // Invariant: the desired index is between [low, high+1]\\n            while (low <= high) {\\n                int mid = low + (high-low)/2;\\n    \\n                if (nums[mid] < target)\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }\\n    \\n            // (1) At this point, low > high. That is, low >= high+1\\n            // (2) From the invariant, we know that the index is between [low, high+1], so low <= high+1. Follwing from (1), now we know low == high+1.\\n            // (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index\\n            //     Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1\\n            return low;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            int low = 0, high = nums.size()-1;\\n    \\n            // Invariant: the desired index is between [low, high+1]\\n            while (low <= high) {\\n                int mid = low + (high-low)/2;\\n    \\n                if (nums[mid] < target)\\n                    low = mid+1;\\n                else\\n                    high = mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3208460,
                "title": "fastest-java-solution",
                "content": "Time complexity: $O(logn)$\\nSpace Complexity: $O(1)$\\n\\n## Explanation with examples & illustration\\n\\nhttps://www.youtube.com/watch?v=h1LrRCYLZ7I\\n\\n# JAVA CODE\\n``` JAVA []\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while (start <= end) {\\n            int mid = start + (end-start)/2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) end = mid-1;\\n            else start = mid+1;\\n        }\\n\\n        return start;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/d691ebb2-63ce-470b-92ab-474a955c3392_1676870623.1558764.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while (start <= end) {\\n            int mid = start + (end-start)/2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) end = mid-1;\\n            else start = mid+1;\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423166,
                "title": "binary-search-101",
                "content": "# Code for This Problem:\\n``` javascript\\nvar searchInsert = function(nums, target) {\\n    let lo = 0, hi = nums.length; // we might need to inseart at the end\\n    while(lo < hi) { // breaks if lo == hi\\n        let mid = lo + Math.floor((hi-lo)/2); // always gives the lower mid\\n        if (target > nums[mid]) {\\n            lo = mid + 1 // no way mid is a valid option\\n        } else {\\n            hi = mid // it might be possibe to inseart @ mid\\n        }\\n    }\\n    return lo;\\n};\\n```\\n\\n# Before We Begin\\nHave you ever wondered when to use `while(lo<hi)` `while(lo <= hi)` ?\\nHave you ever wondered when to use `left = mid + 1` `left = mid` `right = mid + 1` `right = mid` ?\\nHave you ever wondered why your binary search algorithm stuck in an infinity loop?\\nWell, at least I did all that, and if you are like me this article is for you.\\n\\n*I\\'m not writing this article to have people \"remember\" the code, instead, I want use this article to introduce people a gateway of solving binary search problems.\\n*Some of the content are sourced from [here(Chinese)](https://www.notion.so/Binary-Search-101-518118ba7a4246779d8e1394544e02a6#a5a01ce7b9944cf58175b186bf35c6a8). Much thanks to the original author.\\n### The Idea\\n\\n1. Set `lo` and `hi` boundary, compute `mid` index\\n2. Compare target with `mid` , adjust `lo` & `hi` accordingly\\n\\n![](https://miro.medium.com/max/600/1*EYkSkQaoduFBhpCVx7nyEA.gif)\\n\\n### Time Complexity\\n\\nO(log n)\\n\\n### Basic Implementation (JavaScript)\\n```javascript\\nvar search = function(nums, target) {\\n\\tlet lo = 0, hi = nums.length-1;\\n\\twhile (lo < hi) {\\n\\t\\tlet mid = lo + Math.floor((hi-lo+1)/2);\\n\\t\\tif (target < nums[mid]) {\\n\\t\\t\\thi = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tlo = mid; \\n\\t\\t}\\n\\t}\\n\\treturn nums[lo]==target?lo:-1;\\n};\\n```\\n### Logic Flow of Solving Binary Search Problems\\n\\n- **Choose `lo` & `hi`**\\n\\n    Always double check what is the maximum range of possible values. For example, <LeetCode 35>,  since it\\'s possible to insert a value at the very end, the boundary for this problem is actually `0 - n`.\\n\\n- **Calculate `mid`**\\nAlways use the following, since it avoids overflow.\\n```\\n// when odd, return the only mid\\n// when even, return the lower mid\\nint mid = lo + ((hi - lo)/2);\\n\\n// when odd, return the only mid\\n// when even, return the upper mid\\nint mid2 = lo + ((hi - lo + 1) / 2);\\n```\\n\\n- **How to move `lo` and `hi`?**\\n    Always use a condition we are 100% sure of.  It\\'s always easier to eliminate options when we are 100% sure of something. For eample, if we are we are looking for `target <= x`, then for `target>nums[mid]` , we are 100% sure that our mid should never be considered. Thus we can type `lo = mid + 1` with all the confidence.\\n```\\n        if (100% sure logic) {\\n        \\tleft = mid + 1; // 100% sure target is to the right of mid\\n        } else {\\n        \\tright = mid; \\n        }\\n        \\n        if (100% sure logic) {\\n        \\tright = mid - 1; // 100% sure target is to the left of mid\\n        } else {\\n        \\tleft = mid;\\n        }\\n```\\n- `while` **Condition**\\n    Always use `while (lo < hi)` so when the loop breaks, we are 100% sure that `lo == hi`\\n    If it\\'s possible that target doesn\\'t exist, extra check needs to be performed.\\n- \\uD83D\\uDD25**Avoid Infinite loop**\\n```\\n// \\u274C The following code results in inifite loop\\nlet mid = lo + ((hi - lo)/2); // aka the lower mid\\n// We should use:\\n// let mid = lo + ((hi - lo + 1)/2) // aka the upper mid\\n\\nif (100% sure logic) {\\n\\tright = mid - 1\\n} else {\\n\\tleft = mid // <-- note here\\n}\\n```\\nConsider when there\\'s only 2 elements left, if the `if` condition goes to the `else` statement, since `left = mid`, our left boundary will not shrink, this code will loop for ever. Thus, we should use the upper mid.\\n```\\n// \\u274C The following code results in inifite loop\\nlet mid = lo + ((hi - lo + 1)/2); // aka the upper mid\\n// We should use:\\n// let mid = lo + ((hi - lo)/2) // aka the lower mid\\n\\nif (100% sure logic) {\\n\\tleft = mid - 1;\\n} else {\\n\\tright = mid // <-- note here\\n}\\n```\\nConsider when there\\'s only 2 elements left, if the `if` condition goes to the `else` statement, since `right = mid` our right boundary will not shrink, this code will loop for ever. Thus, we should use the lower mid.\\n\\t\\n#### Take Away\\n\\\\* Always think of the situation where there\\'s only 2 elements left!\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "``` javascript\\nvar searchInsert = function(nums, target) {\\n    let lo = 0, hi = nums.length; // we might need to inseart at the end\\n    while(lo < hi) { // breaks if lo == hi\\n        let mid = lo + Math.floor((hi-lo)/2); // always gives the lower mid\\n        if (target > nums[mid]) {\\n            lo = mid + 1 // no way mid is a valid option\\n        } else {\\n            hi = mid // it might be possibe to inseart @ mid\\n        }\\n    }\\n    return lo;\\n};\\n```\n```javascript\\nvar search = function(nums, target) {\\n\\tlet lo = 0, hi = nums.length-1;\\n\\twhile (lo < hi) {\\n\\t\\tlet mid = lo + Math.floor((hi-lo+1)/2);\\n\\t\\tif (target < nums[mid]) {\\n\\t\\t\\thi = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tlo = mid; \\n\\t\\t}\\n\\t}\\n\\treturn nums[lo]==target?lo:-1;\\n};\\n```\n```\\n// when odd, return the only mid\\n// when even, return the lower mid\\nint mid = lo + ((hi - lo)/2);\\n\\n// when odd, return the only mid\\n// when even, return the upper mid\\nint mid2 = lo + ((hi - lo + 1) / 2);\\n```\n```\\n        if (100% sure logic) {\\n        \\tleft = mid + 1; // 100% sure target is to the right of mid\\n        } else {\\n        \\tright = mid; \\n        }\\n        \\n        if (100% sure logic) {\\n        \\tright = mid - 1; // 100% sure target is to the left of mid\\n        } else {\\n        \\tleft = mid;\\n        }\\n```\n```\\n// \\u274C The following code results in inifite loop\\nlet mid = lo + ((hi - lo)/2); // aka the lower mid\\n// We should use:\\n// let mid = lo + ((hi - lo + 1)/2) // aka the upper mid\\n\\nif (100% sure logic) {\\n\\tright = mid - 1\\n} else {\\n\\tleft = mid // <-- note here\\n}\\n```\n```\\n// \\u274C The following code results in inifite loop\\nlet mid = lo + ((hi - lo + 1)/2); // aka the upper mid\\n// We should use:\\n// let mid = lo + ((hi - lo)/2) // aka the lower mid\\n\\nif (100% sure logic) {\\n\\tleft = mid - 1;\\n} else {\\n\\tright = mid // <-- note here\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409777,
                "title": "easy-and-simple-c-approach-binary-search",
                "content": "\\n# Approach\\n- `binary seaerch` approach is damn easy for this question and also easy to think of it.\\n- the array is sorted so we just have to fugure out where should it be placed.\\n- so we just have to figure out the position at which the `prevoius value` is less that our element and `next` value is more than our element.\\n- Thats how its figured out that it\\'s a binary seach problem.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## `Upvote! It only takes 1 click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size();\\n        int mid;\\n        if(target>nums[high-1]){\\n            return high;\\n        }\\n        while(low<=high){\\n              mid=(low+high)/2;\\n            if(nums[mid]==target){  \\n                return mid;\\n            }\\n          \\n            if(target<nums[mid]){     \\n            high=mid-1;    \\n            }else{\\n            low=mid+1;        \\n            }\\n          \\n        }\\n         return  low;   \\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/90815d9e-dd68-4cea-952b-fe2b97fb5c17_1681320439.5123947.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0;\\n        int high=nums.size();\\n        int mid;\\n        if(target>nums[high-1]){\\n            return high;\\n        }\\n        while(low<=high){\\n              mid=(low+high)/2;\\n            if(nums[mid]==target){  \\n                return mid;\\n            }\\n          \\n            if(target<nums[mid]){     \\n            high=mid-1;    \\n            }else{\\n            low=mid+1;        \\n            }\\n          \\n        }\\n         return  low;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15378,
                "title": "a-fast-and-concise-python-solution-40ms-binary-search",
                "content": "For input without duplicates:\\n\\n    def searchInsert(self, nums, target):\\n        l , r = 0, len(nums)-1\\n        while l <= r:\\n            mid=(l+r)/2\\n            if nums[mid]== target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l\\n\\n\\n----------\\nFor input with duplicates, we only need a little bit modification:\\n\\n\\n    def searchInsert(self, nums, target): # works even if there are duplicates. \\n        l , r = 0, len(nums)-1\\n        while l <= r:\\n            mid=(l+r)/2\\n            if nums[mid] < target:\\n                l = mid+1\\n            else:\\n                if nums[mid]== target and nums[mid-1]!=target:\\n                    return mid\\n                else:\\n                    r = mid-1\\n        return l\\n\\n\\n\\nThis is a very simple binary search. (Surprisingly, all the binary search solutions I found here are much longer than mine.)<br>  The first solution only works when there is no duplicate. In this case, we return `mid` whenever `nums[mid]==target`. The second solution deals with the case where duplicates are allowed.<br> Note that it would exit the `while` loop ONLY when `target` is not in `nums`. When this happens, the if and else statement in the last loop will also adjust `l` so we simply return l at the end.<br>\\n \\n\\n    examples:\\n    nums=[1,3,5,7,9,11,13,15,17]\\n    (1) target 12, last loop: (l,r)= (5, 5) ; end of loop (l,r)= (6, 5), answer = 6\\n    (2) target 14, last loop: (l,r)= (7, 8) ; end of loop (l,r)= (7, 6), answer = 7",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "For input without duplicates:\\n\\n    def searchInsert(self, nums, target):\\n        l , r = 0, len(nums)-1\\n        while l <= r:\\n            mid=(l+r)/2\\n            if nums[mid]== target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l\\n\\n\\n----------\\nFor input with duplicates, we only need a little bit modification:\\n\\n\\n    def searchInsert(self, nums, target): # works even if there are duplicates. \\n        l , r = 0, len(nums)-1\\n        while l <= r:\\n            mid=(l+r)/2\\n            if nums[mid] < target:\\n                l = mid+1\\n            else:\\n                if nums[mid]== target and nums[mid-1]!=target:\\n                    return mid\\n                else:\\n                    r = mid-1\\n        return l\\n\\n\\n\\nThis is a very simple binary search. (Surprisingly, all the binary search solutions I found here are much longer than mine.)<br>  The first solution only works when there is no duplicate. In this case, we return `mid` whenever `nums[mid]==target`. The second solution deals with the case where duplicates are allowed.<br> Note that it would exit the `while` loop ONLY when `target` is not in `nums`. When this happens, the if and else statement in the last loop will also adjust `l` so we simply return l at the end.<br>\\n \\n\\n    examples:\\n    nums=[1,3,5,7,9,11,13,15,17]\\n    (1) target 12, last loop: (l,r)= (5, 5) ; end of loop (l,r)= (6, 5), answer = 6\\n    (2) target 14, last loop: (l,r)= (7, 8) ; end of loop (l,r)= (7, 6), answer = 7",
                "codeTag": "Python3"
            },
            {
                "id": 357893,
                "title": "python-solutions-linear-bisect-binary-search",
                "content": "Linear Search\\n\\n```python\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return 0\\n        \\n        for i, num in enumerate(nums):\\n            if num >= target:\\n                return i\\n        \\n        return len(nums)\\n```\\n\\nUsing bisect module\\n\\n```python\\nimport bisect\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\\n\\nBinary Search By Hand\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if target > nums[mid]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return 0\\n        \\n        for i, num in enumerate(nums):\\n            if num >= target:\\n                return i\\n        \\n        return len(nums)\\n```\n```python\\nimport bisect\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if target > nums[mid]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596479,
                "title": "c-3-solutions-well-explained-with-example-and-concise-solution",
                "content": "**The One-Liner ::**\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\\n\\n*The lower_bound() is used to return an iterator pointing to the first element in the range [first, last) which has a value >= target. \\nFunction returns the index of the next smallest number just greater than or equal to that number. That\\'s what our search insert position will be ....*\\n   \\n###   Recursive and iterative ways to implement this function -->>\\n  \\n \\n* Iterative method \\n```                                                                                        \\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n     \\n        int low = 0, high = nums.size()-1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            else if(nums[mid] > target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};         \\n```\\n**why to return low ?** \\n      *Because when high = low+1, then mid = low.*\\n      *If the target > nums[mid], then low = mid + 1 = high. The target position can be low or high, since they are the same.*\\n      *but if the target < nums[mid], then high = mid - 1 = low - 1. The target position must be low, not the high.*\\n  See the example -->      \\n                       ![image](https://assets.leetcode.com/users/images/626ecfc6-daaa-48e5-8124-b8ef79812cdd_1637888017.7145376.png)\\n         ***Hence, low is  always at the search index position*** \\n  \\n  \\n  \\n*    Recursive method\\n```                                                                                            \\nclass Solution {\\npublic:\\n    \\n    int rec(vector<int>& nums,int& target,int l,int r){\\n        if(l >= r) return nums[l] >= target ? l : l + 1;\\n        int mid = l + ((r - l) >> 1);\\n        return nums[mid] == target ? mid : nums[mid] > target ? rec(nums,target,l,mid-1) : rec(nums,target,mid+1,r);\\n    }\\n    \\n    int searchInsert(vector<int>& nums, int target) {\\n        return rec(nums,target,0,(int)nums.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\n```                                                                                        \\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n     \\n        int low = 0, high = nums.size()-1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(nums[mid] == target) return mid;\\n            \\n            else if(nums[mid] > target) high = mid-1;\\n            \\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 15226,
                "title": "java-solution-using-binary-search-with-explanation-of-why-it-works",
                "content": "Before I get down to explanation, Here is the solution\\n\\n```\\npublic int searchInsert(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }else if(nums[mid] > target){\\n                high= mid -1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n```\\nNow lets understand why this works the way it works and why the bounds are set the way they are set. The question says if we find the element we need to return the position of the element, hence we need the condition of low <= high. \\n\\nInitialize low = 0 and high as nums.length-1. while low <= high we iterate and change the bounds.\\n\\nNow if middle element is smaller than the target, then the potential position where we need to insert may lie from positions mid+1 till end. So we set low as mid+1. On the other hand,if the middle element is larger than the target, then the potential position will lie from low to mid-1. In either cases it cannot be mid. \\n\\nSo we continue iterating, and finally when low and high cross each other, we break out of the loop. Now the question is, which one to return low or high. if we consider carefully, low represents the lower bound of the potential positions where we can insert the elements. Meaning the position must be atleast low or greater. Since low and high have already crossed each other, We cannot insert at high. We have to insert at low. Hence we return low.",
                "solutionTags": [],
                "code": "```\\npublic int searchInsert(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low <= high){\\n            mid = low + (high-low)/2;\\n            \\n            if(nums[mid] == target){\\n                return mid;\\n            }else if(nums[mid] > target){\\n                high= mid -1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679918,
                "title": "python-2-solutions-oneliner-and-classical-bs-explained",
                "content": "### Solution 1: bisect\\nIt is not said in the problem statement not to use any libraries, so why not use `bisect_left` function, so conviniently provided by python? Why we use `bisect_left`? Because for `[1,3,5,6]` and number `5` we need to return index `2`: if element is already present in array, the insertion point will be before (to the left of) any existing entries.\\n\\n**Complexity** is classical for binary search: `O(log n)`\\n\\n```\\nclass Solution:\\n    def searchInsert(self, nums, target):\\n        return bisect.bisect_left(nums, target)\\n```\\n\\n### Solution 2: Classical binary search\\n\\nClassical binary search problem, where we need to return `beg` in the end, because we are looking for left place to insert our symbol.\\n\\n```\\nclass Solution:\\n    def searchInsert(self, nums, target):\\n        beg, end = 0, len(nums)\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if nums[mid] >= target:\\n                end = mid\\n            else:\\n                beg = mid + 1\\n        return beg\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums, target):\\n        return bisect.bisect_left(nums, target)\\n```\n```\\nclass Solution:\\n    def searchInsert(self, nums, target):\\n        beg, end = 0, len(nums)\\n        while beg < end:\\n            mid = (beg + end)//2\\n            if nums[mid] >= target:\\n                end = mid\\n            else:\\n                beg = mid + 1\\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274547,
                "title": "fastest-javascript-solution-binary-search-log-n",
                "content": "```\\nfunction searchInsert(nums, target) {\\n    return binarySearch(nums, target, 0, nums.length - 1);\\n};\\n\\n\\nfunction binarySearch(array, target, start, end) {\\n\\t // If the target is less then the very last item then insert it at that item index\\n\\t // because anything index less then that has already been confirmed to be less then the target.\\n\\t // Otherwise insert it at that item index + 1\\n\\t // because any index grater then that has already been confirmed to be greater then the target\\n    if (start > end) return start;\\n    \\n    const midPoint = Math.floor((start + end)/2);\\n    \\n\\t// found target\\n    if (array[midPoint] === target) return midPoint;\\n    \\n\\t// search the left side\\n    if (array[midPoint] > target) return binarySearch(array, target, start, midPoint - 1);\\n    // search the right side\\n    if (array[midPoint] < target) return binarySearch(array, target, midPoint + 1, end);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction searchInsert(nums, target) {\\n    return binarySearch(nums, target, 0, nums.length - 1);\\n};\\n\\n\\nfunction binarySearch(array, target, start, end) {\\n\\t // If the target is less then the very last item then insert it at that item index\\n\\t // because anything index less then that has already been confirmed to be less then the target.\\n\\t // Otherwise insert it at that item index + 1\\n\\t // because any index grater then that has already been confirmed to be greater then the target\\n    if (start > end) return start;\\n    \\n    const midPoint = Math.floor((start + end)/2);\\n    \\n\\t// found target\\n    if (array[midPoint] === target) return midPoint;\\n    \\n\\t// search the left side\\n    if (array[midPoint] > target) return binarySearch(array, target, start, midPoint - 1);\\n    // search the right side\\n    if (array[midPoint] < target) return binarySearch(array, target, midPoint + 1, end);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207854,
                "title": "simplest-solution-one-liner-2-approaches-binary-search-c-python3",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Using Binary Search\\n    Example : nums = [1,3,5,6], target = 2\\n    Initially `start` = 0, `end` = 3\\n\\n    Now, `mid` = 1, nums[mid] - 3 > 2\\n    So, `end` = mid - 1 = 0\\n\\n    Again `mid` = 0, nums[mid] - 1 < 2\\n    So, `start` = mid + 1 = 1\\n    Now while loop terminates as `start` > `end`\\n    So answer is `end` + 1 = `1` \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0, end = nums.size()-1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if (nums[mid]>target)\\n                end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return end+1;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums)-1\\n        while start <= end:\\n            mid = (start + end)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return end+1\\n```\\n**Approach 2**\\n```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ind = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        return ind;\\n    }\\n};\\n```\\n```python []\\nimport bisect\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0, end = nums.size()-1;\\n        while(start<=end){\\n            int mid = (start+end)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if (nums[mid]>target)\\n                end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return end+1;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums)-1\\n        while start <= end:\\n            mid = (start + end)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return end+1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ind = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        return ind;\\n    }\\n};\\n```\n```python []\\nimport bisect\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006912,
                "title": "java-runtime-0ms-beats-100-00-binary-search-o-log-n",
                "content": "# Intuition\\nThis problem requires finding a specific target value `target` within a sorted array of integers `nums` or determining the position where this target value should be inserted. My initial thoughts revolve around the need for an effective approach to accomplish the task of finding the target value or determining where to insert it.\\n\\n# Approach\\nTo solve this problem, I employ the binary search algorithm. Binary search provides an efficient way to locate or insert a target value within a sorted array. Below is an explanation with steps:\\n\\n1. Begin with two pointers, `left` and `right`, where `left` points to the start of the array, and `right` points to the end of the array.\\n\\n2. Initiate a loop and use these pointers, `left` and `right`, to define a search range within the array.\\n\\n3. Calculate the midpoint, `mid`, of the search range as `mid = left + (right - left) / 2`.\\n\\n4. Compare the element at index `mid` with the `target`:\\n   - If the element at `mid` is equal to the `target`, return `mid` as the index where the `target` is found.\\n   - If the element at `mid` is less than the `target`, update `left` to `mid + 1` to search in the right half of the current range.\\n   - If the element at `mid` is greater than the `target`, update `right` to `mid - 1` to search in the left half of the current range.\\n\\n5. Repeat steps 3 and 4 until `left` is less than or equal to `right`. This ensures that the search range narrows down with each iteration.\\n\\n6. When the loop exits, return the value of `left` as the index where the `target` should be inserted. This is because `left` points to the first element that is greater than or equal to the `target`.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n  The binary search algorithm reduces the search space by half with each iteration, resulting in a time complexity of O(log n), where n is the number of elements in the array.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of additional memory space for variables, making its space complexity constant.\\n\\n# Code\\n```java\\nclass Solution {\\n   public int searchInsert(int[] nums, int target) {\\n        int left = 0 ;\\n        int right = nums.length-1;\\n        while (left<=right){\\n            int mid  = left + (right-left)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/c44040ce-bc26-410e-9462-236686765977_1693938957.2745583.webp)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n   public int searchInsert(int[] nums, int target) {\\n        int left = 0 ;\\n        int right = nums.length-1;\\n        while (left<=right){\\n            int mid  = left + (right-left)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15391,
                "title": "a-simple-cpp-solution-with-lower-bound",
                "content": "Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple:\\n\\n    class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        }\\n    };\\nOr we can implement an inline lower_bound:\\n\\n    class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            auto first = nums.begin(), last = nums.end();\\n            while (first < last) {\\n                auto mid = first + ((last - first) >> 1);\\n                if (*mid < target) {\\n                    first = mid + 1;\\n                } else {\\n                    last = mid;\\n                }\\n            }\\n            return first - nums.begin();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1596603,
                "title": "c-python-simple-solutions-w-explanation-recursive-iterative-binary-search-built-in",
                "content": "\\u2714\\uFE0F ***Solution - I (Recursive Binary-Search)***\\n\\nWe can apply binary search recursive. We call the recursive function with search range `[L, R] = [0, n-1]` and then apply standard binary search - \\n1. If `nums[mid] == T`, the target is found, so return `mid`.\\n2. If `nums[mid] < T`, the index to insert the target lies in range `[mid+1, R]`. So recurse for that search space\\n3. If `nums[mid] > T`, we can potentially insert the target at index `mid` or somewhere in range `[L, mid-1]`. So we recurse for the search space `[L, mid-1]`. \\n4. Now, if we end up at `L > R`, which index should we return? We might have reached here by -\\n\\t*  previously finding the condition `A[mid] < T` & recursing for `[mid+1, R]`, in which case `L(=mid+1)` must be answer since `A[mid] < T` which tells us `mid` cannot be our index.\\n\\t*  previously finding the condition `A[mid] > T` & recursing for `[L, mid-1]` , in which case `L` must be answer again, since `A[mid] > T` in previous recursive call which tells us `mid` itself was potentially the answer & we couldn\\'t find any index lower than `mid` for which `A[.] > T`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        return search(nums, 0, size(nums)-1, T);\\n    }\\n    int search(vector<int> A, int L, int R, int T) {\\n        if(L > R) return L;\\n        int mid = (L + R) / 2;\\n        if(A[mid] == T) return mid;\\n        if(A[mid] < T) return search(A, mid + 1, R, T);\\n        return search(A, L, mid - 1, T);\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        def search(L, R):\\n            if L > R: return L\\n            mid = (L + R) >> 1\\n            if nums[mid] == T: return mid\\n            return search(mid + 1, R) if nums[mid] < T else search(L, mid - 1)\\n        return search(0, len(nums)-1)\\n```\\n\\n***Time Complexity :*** `O(logN)`, at each recursion, we are eliminating half of search space. The recurrence relation for this can be written as `T(N) = T(N/2) + O(1)`, solving which gives us `O(logN)`.\\n***Space Complexity :*** `O(logN)`, required by recursive stack. The worst case recursion depth can reach up to `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative Binary-Search)***\\n\\nWe follow a similar binary search logic in this iterative version as well. We start with search space `[L, R] = [0, n-1]` and use standard binary search -\\n\\n1. If `nums[mid] == T`, we can directly return `mid` as answer.\\n2. If `nums[mid] < T`, then target must be inserted in `[mid+1, R]`, so do `L = mid+1`.\\n3. If `nums[mid] > T`, then target can either be inserted at `mid` or somewhere in `[mid-1, R]`. Mark potential answer as `ans = mid` and search in `[L, mid-1]` by doing `R = mid-1`.\\n\\nNote that, we should initialize `ans = size(nums)` for cases where we may never come against `nums[mid] >= T` and get a chance to mark `ans` as potential answer. In those cases, the target must be inserted at the end.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        int L = 0, R = size(nums)-1, mid, ans = size(nums);\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            if(nums[mid] < T) \\n                L = mid + 1;\\n            else R = mid - 1, ans = mid;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        L, R, ans = 0, len(nums)-1, len(nums)\\n        while L <= R:\\n            mid = (L + R) >> 1\\n            if nums[mid] < T: \\n                L = mid + 1\\n            else:\\n                R, ans = mid - 1, mid\\n        return ans\\n```\\n\\n***Time Complexity :*** `O(logN)`, similar reasoning as above.\\n***Space Complexity :*** `O(1)`, only constant extra space is used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (In-built Functions)***\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        return lower_bound(begin(nums), end(nums), T) - begin(nums);\\n\\t\\t// lower_bound returns iterator to 1st element >= target element\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        return bisect_left(nums, T)\\n\\t\\t# bisect_left returns 1st position where target must be inserted to keep list sorted\\n```\\n\\n***Time Complexity :*** `O(logN)`\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\uD83D\\uDCA1 **Note:**\\n\\n* You can use the template for binary search similar to `Solution-II` for many binary search problems. It might be confusing looking at various binary search problems and knowing -\\n\\t* If we must use `L < R` or `L <= R` as the loop condition, \\n\\t* If we must do `L = mid` or `L = mid+1` and `R = mid` or `R = mid-1`, \\n\\t* If we should return `L` or `R` at the end of loop. \\n\\t\\n\\tI usually follow these steps in most cases -\\n\\t* Initialize `[L, R]` to cover your search space and use `L <= R` condition since answer may lie anywhere in the whole range.\\n\\t* You may use extra variable `ans` initialized to a value based on which condition in code marks your potential answer. Then you can use something similar to  -\\n\\t\\n\\t\\t```cpp\\n\\t    while(L <= R) {\\n\\t\\t\\tmid = L + ((R - L) >> 1);    // avoiding overflow\\n\\t\\t\\tif(condition(mid)) {\\n\\t\\t\\t\\tL = mid + 1;\\n\\t\\t\\t\\t// ans = mid;            // <-  use when satisfaction of condition denotes a possible answer\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tR = mid - 1;\\n\\t\\t\\t\\t// ans = mid;            // <-  use when condition not satisfied denotes a possible answer\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t```\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        return search(nums, 0, size(nums)-1, T);\\n    }\\n    int search(vector<int> A, int L, int R, int T) {\\n        if(L > R) return L;\\n        int mid = (L + R) / 2;\\n        if(A[mid] == T) return mid;\\n        if(A[mid] < T) return search(A, mid + 1, R, T);\\n        return search(A, L, mid - 1, T);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        def search(L, R):\\n            if L > R: return L\\n            mid = (L + R) >> 1\\n            if nums[mid] == T: return mid\\n            return search(mid + 1, R) if nums[mid] < T else search(L, mid - 1)\\n        return search(0, len(nums)-1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        int L = 0, R = size(nums)-1, mid, ans = size(nums);\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            if(nums[mid] < T) \\n                L = mid + 1;\\n            else R = mid - 1, ans = mid;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        L, R, ans = 0, len(nums)-1, len(nums)\\n        while L <= R:\\n            mid = (L + R) >> 1\\n            if nums[mid] < T: \\n                L = mid + 1\\n            else:\\n                R, ans = mid - 1, mid\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int T) {\\n        return lower_bound(begin(nums), end(nums), T) - begin(nums);\\n\\t\\t// lower_bound returns iterator to 1st element >= target element\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums, T):\\n        return bisect_left(nums, T)\\n\\t\\t# bisect_left returns 1st position where target must be inserted to keep list sorted\\n```\n```cpp\\n\\t    while(L <= R) {\\n\\t\\t\\tmid = L + ((R - L) >> 1);    // avoiding overflow\\n\\t\\t\\tif(condition(mid)) {\\n\\t\\t\\t\\tL = mid + 1;\\n\\t\\t\\t\\t// ans = mid;            // <-  use when satisfaction of condition denotes a possible answer\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tR = mid - 1;\\n\\t\\t\\t\\t// ans = mid;            // <-  use when condition not satisfied denotes a possible answer\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 15081,
                "title": "python-one-liner-48ms",
                "content": "    class Solution(object):\\n        def searchInsert(self, nums, target):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type target: int\\n            :rtype: int\\n            \"\"\"       \\n            return len([x for x in nums if x<target])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def searchInsert(self, nums, target):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type target: int\\n            :rtype: int\\n            \"\"\"       \\n            return len([x for x in nums if x<target])",
                "codeTag": "Java"
            },
            {
                "id": 15110,
                "title": "very-concise-and-efficient-solution-in-java",
                "content": "I have several solutions to this problem; this is the most concise and efficient one I have.\\n\\n    public class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int low = 0, high = nums.length;\\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int low = 0, high = nums.length;\\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3117812,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->BINARY SEARCH\\n\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Time complexity:O(logn)\\nSpace complexity:O(1)\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int st=0; int end=nums.size()-1;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]<target){\\n                st=ans=mid+1;\\n                \\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int st=0; int end=nums.size()-1;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]<target){\\n                st=ans=mid+1;\\n                \\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596628,
                "title": "java-binary-search-detailed-explanation-using-image",
                "content": "**Using JAVA inbuilt function of Binary Search:**\\n\\n**Ques:** What does the Arrays.binarySearch() function returns?\\n**Ans:** If the target element is present in the array then return the index of that element. But if not present then return the index where it should have been if it was peresent but in some different way.\\n**If the target element was to present at index i then it will return (-i-1) i.e., if 2 is the index then it will return -3.**\\n\\n```\\nclass Solution {\\n    public int searchInsert(int[] arr, int target) {\\n        \\n        int index = Arrays.binarySearch(arr,target);\\n        return index<0 ? -(index+1) : index;\\n    }\\n}\\n```\\n\\n**Iterative Approach of Binary Search:**\\n\\nReason why always left index is returned :\\n\\n![image](https://assets.leetcode.com/users/images/cb0deadf-fd3c-419f-befc-95abb2d417e5_1637897077.7096853.jpeg)\\n\\n```\\nclass Solution {\\n    public int searchInsert(int[] arr, int target) {\\n        \\n        int lo = 0, hi = arr.length-1;\\n        \\n        while(lo<=hi){\\n            \\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(arr[mid]==target){\\n                return mid;\\n            }\\n            else if(arr[mid]<target){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] arr, int target) {\\n        \\n        int index = Arrays.binarySearch(arr,target);\\n        return index<0 ? -(index+1) : index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588776,
                "title": "python-solution-24ms-super-fast-super-simple-binary-search",
                "content": "\\n##### Solution: \\n```\\n   def searchInsert(self, nums, target):\\n        i = 0\\n        j = len(nums) - 1\\n        while(i <= j):\\n            pivot = (i + j) // 2\\n            if (nums[pivot] == target):\\n                return pivot\\n            elif (nums[pivot] > target):\\n                j = pivot - 1\\n            else:\\n                i = pivot + 1\\n        return i\\n```\\n\\n#####    Submission info:\\n*Runtime: 24 ms, faster than 99.62% of Python online submissions.*\\n   \\n#####   Code description:\\n \\n * Almost the same approach as pure binary search problem.\\n * Return `i `(which is the \\'left\\' indicator) because we say that `i = pivot + 1` in the case where `nums[pivot] < target`. So that `i `indicates the next position after the element smaller than the target, which is what we want for the output.\\n\\n****Please upvote if you find it useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n   def searchInsert(self, nums, target):\\n        i = 0\\n        j = len(nums) - 1\\n        while(i <= j):\\n            pivot = (i + j) // 2\\n            if (nums[pivot] == target):\\n                return pivot\\n            elif (nums[pivot] > target):\\n                j = pivot - 1\\n            else:\\n                i = pivot + 1\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1320589,
                "title": "solution-swift-search-insert-position",
                "content": "```swift\\nclass Solution {\\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        var val = 0, idx = nums.count - 1\\n        \\n        while val <= idx {\\n            let num = val + (idx - val) / 2\\n            if nums[num] < target {\\n                val = num + 1\\n            } else if nums[num] > target {\\n                idx = num - 1\\n            } else {\\n                return num\\n            }\\n        }\\n        return val\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failuvalue (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    private let nums = [1,3,5,6]\\n    \\n    func test0() {\\n        let value = solution.searchInsert(nums, 5)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchInsert(nums, 2)\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchInsert(nums, 7)\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        var val = 0, idx = nums.count - 1\\n        \\n        while val <= idx {\\n            let num = val + (idx - val) / 2\\n            if nums[num] < target {\\n                val = num + 1\\n            } else if nums[num] > target {\\n                idx = num - 1\\n            } else {\\n                return num\\n            }\\n        }\\n        return val\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    private let nums = [1,3,5,6]\\n    \\n    func test0() {\\n        let value = solution.searchInsert(nums, 5)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchInsert(nums, 2)\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchInsert(nums, 7)\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025719,
                "title": "fast-and-simple-solution",
                "content": "```\\n\\t\\tif target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            return nums.index(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tif target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            return nums.index(target)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765764,
                "title": "c-binary-search-easy-fast-o-log-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int lo=0,hi=nums.size()-1;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(target == nums[mid]) return mid;\\n            else if(target > nums[mid]) lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int lo=0,hi=nums.size()-1;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(target == nums[mid]) return mid;\\n            else if(target > nums[mid]) lo = mid+1;\\n            else hi = mid-1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15372,
                "title": "simple-java-solution",
                "content": "    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] >= target)\\n                return i;\\n        }\\n        return nums.length;\\n    }",
                "solutionTags": [],
                "code": "    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] >= target)\\n                return i;\\n        }\\n        return nums.length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2749300,
                "title": "java-linear-binary-search-explanation",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n#### *[Watch my detailed explanation video \\u2714\\uFE0F](https://youtu.be/PYxRM-RyV20)*\\n---\\n## 1. Linear Search:\\n``` \\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i = 0;\\n        // go as long as we are < target\\n        while (i < nums.length && nums[i] < target) {\\n            i++;\\n        }\\n        // `i` will retain the insert position\\n        // or the index of target, if found\\n        return i;   \\n    }\\n}\\n```\\n##### Time complexity: $$O(n)$$\\n\\n---\\n## 2. Binary Search:\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == target) {\\n                return mid;   // if found, return index\\n            }\\n            if (target < nums[mid]) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        // if not found, the insert position will be retained by \\'lo\\'\\n        // WHY and HOW? Watch my video!\\n        return lo;  \\n    }\\n}\\n```\\n##### Time complexity: $$O(logn)$$\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` \\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i = 0;\\n        // go as long as we are < target\\n        while (i < nums.length && nums[i] < target) {\\n            i++;\\n        }\\n        // `i` will retain the insert position\\n        // or the index of target, if found\\n        return i;   \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == target) {\\n                return mid;   // if found, return index\\n            }\\n            if (target < nums[mid]) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        // if not found, the insert position will be retained by \\'lo\\'\\n        // WHY and HOW? Watch my video!\\n        return lo;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588136,
                "title": "the-one-tip-for-bug-free-binary-search-the-devil-is-in-the-detail",
                "content": "Binray search sounds like a simple algorithm, but the details are much more complicated than a beginner could ever expect.\\nIt took me some time to figure them out. The key point to remember is simple: **define your search interval and maintain the validity**.\\n\\nThere are two popular ways to difine search intervals: `[lo, hi]` and `[lo, hi)`, where `lo` and `hi` are the lower and upper limit of the search interval, repectively. Lets\\'s take Problem 35 as an example.\\n\\n- **[lo, hi]**: Inclusive on both left and right.\\nIn this case, the `hi` should be initialized as `hi = len(nums) - 1`. \\nAccordingly, the ternimal condition of the while loop should be `lo <= hi`, so that when loop ends, we have `lo == hi + 1`, which means an empty interval. If we write a terminal condition as `lo < hi`, then we have to check `nums[lo]` when the loop ends, because `lo==hi` is not an empty interval.\\nIn the while loop, most people will update `lo` to be `lo = mid + 1` without trouble, but how to update `hi`? \\nRemember our search interval is right inclusive, right? If `nums[mid]` is not target, of course we should exclude it out of our search interval, so we have `hi = mid - 1`\\n\\n- **[lo, hi)**: left inclusive while right exclusive\\nIn this case, the `h`i should be initialized as `hi = len(nums)`. \\nAccordingly, the ternimal condition of while loop should be `lo < hi`, so that when loop ends, we have `lo == hi `, which means an empty interval.\\nBecause our search interval is exclusive at upper limit `hi`, we should update `hi` using `hi = mid`. If `hi = mid - 1` is used, we are excluding `nums[mid-1]` without checking it.\\n\\nTherefore, we have two ways to implements Problem 35.\\n\\n**Solution 1**\\n```\\nlo = 0\\nhi = len(nums) - 1\\n\\nwhile lo <= hi:\\n\\tmid = (lo + hi) // 2\\n\\tif target <= nums[mid]:\\n\\t\\thi = mid - 1\\n\\telse:\\n\\t\\tlo = mid + 1\\n\\nreturn lo\\n```\\n\\n**Solution 2**\\n```\\nlo = 0\\nhi = len(nums)\\n\\nwhile lo < hi:\\n\\tmid = (lo + hi) // 2\\n\\tif target <= nums[mid]:\\n\\t\\thi = mid\\n\\telse:\\n\\t\\tlo = mid + 1\\n\\nreturn lo\\n```\\n\\nNow it is much clear right?\\n\\n**One step further**\\nProblem 35 assumes no duplicates, which makes it much easier. What if there are duplicates and you are asked to return the index of the first element lareger than target (insert to the right boundary of the duplicate targets)? Or insert to the index of the first element equals to target (left boundary of the duplicate targets)?\\n\\nIt is perfectly implemented in python built-in function `bisect.bisect_left` and `bisect.bisect_right`. It is highly recommended to go through the [source code](https://github.com/python/cpython/blob/3.8/Lib/bisect.py) and [documents](https://docs.python.org/3/library/bisect.html), which is simple, clear and elegent.\\nThe key point is how to update the interval boundaries when `nums[mid] == target`, and maintain the validity of the search interval definition.\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nlo = 0\\nhi = len(nums) - 1\\n\\nwhile lo <= hi:\\n\\tmid = (lo + hi) // 2\\n\\tif target <= nums[mid]:\\n\\t\\thi = mid - 1\\n\\telse:\\n\\t\\tlo = mid + 1\\n\\nreturn lo\\n```\n```\\nlo = 0\\nhi = len(nums)\\n\\nwhile lo < hi:\\n\\tmid = (lo + hi) // 2\\n\\tif target <= nums[mid]:\\n\\t\\thi = mid\\n\\telse:\\n\\t\\tlo = mid + 1\\n\\nreturn lo\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15106,
                "title": "python-beats-98",
                "content": "    class Solution(object):\\n    def searchInsert(self, nums, key):\\n        if key > nums[len(nums) - 1]:\\n            return len(nums)\\n\\n        if key < nums[0]:\\n            return 0\\n\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            m = (l + r)/2\\n            if nums[m] > key:\\n                r = m - 1\\n                if r >= 0:\\n                    if nums[r] < key:\\n                        return r + 1\\n                else:\\n                    return 0\\n\\n            elif nums[m] < key:\\n                l = m + 1\\n                if l < len(nums):\\n                    if nums[l] > key:\\n                        return l\\n                else:\\n                    return len(nums)\\n            else:\\n                return m\\n\\nOnce the left border is larger than key, than return index. Once the right border is less than key, then return index.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def searchInsert(self, nums, key):\\n        if key > nums[len(nums) - 1]:\\n            return len(nums)\\n\\n        if key < nums[0]:\\n            return 0\\n\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            m = (l + r)/2\\n            if nums[m] > key:\\n                r = m - 1\\n                if r >= 0:\\n                    if nums[r] < key:\\n                        return r + 1\\n                else:\\n                    return 0\\n\\n            elif nums[m] < key:\\n                l = m + 1\\n                if l < len(nums):\\n                    if nums[l] > key:\\n                        return l\\n                else:\\n                    return len(nums)\\n            else:\\n                return m\\n\\nOnce the left border is larger than key, than return index. Once the right border is less than key, then return index.",
                "codeTag": "Java"
            },
            {
                "id": 2756231,
                "title": "c-easy-code-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size() ;\\n        int start= 0 ;\\n        int last= n-1 ;\\n        int mid= start + (last - start)/2 ;\\n        while(start <= last){\\n            mid= start + (last- start)/2 ;\\n            if(nums[mid] == target){\\n                return mid ;\\n            }\\n            else if(nums[mid] > target){\\n                last= mid -1 ;\\n            }\\n            else{\\n                start= mid + 1 ;\\n            }\\n        }\\n\\t\\t// Edge Case\\n        return start ;\\n    }\\n};\\n\\n// Find Helpful Pls Upvote\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size() ;\\n        int start= 0 ;\\n        int last= n-1 ;\\n        int mid= start + (last - start)/2 ;\\n        while(start <= last){\\n            mid= start + (last- start)/2 ;\\n            if(nums[mid] == target){\\n                return mid ;\\n            }\\n            else if(nums[mid] > target){\\n                last= mid -1 ;\\n            }\\n            else{\\n                start= mid + 1 ;\\n            }\\n        }\\n\\t\\t// Edge Case\\n        return start ;\\n    }\\n};\\n\\n// Find Helpful Pls Upvote\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042881,
                "title": "binary-search-javascript-o-logn-time-o-1-space",
                "content": "```\\nvar searchInsert = function(nums, target) {\\n    let high = nums.length - 1;\\n    let low = 0;\\n    while (low <= high) {\\n        let mid = Math.floor((high + low) / 2);\\n        if (nums[mid] == target) return mid;\\n        else if (nums[mid] > target) {\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return low;\\n};\\n```\\nWhat do we mean when we say O(logn)? : https://rohitdhatrak.netlify.app/time-space-complexity/\\nMy Ds-Algo Repo : https://github.com/RohitDhatrak/DS-Algo",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    let high = nums.length - 1;\\n    let low = 0;\\n    while (low <= high) {\\n        let mid = Math.floor((high + low) / 2);\\n        if (nums[mid] == target) return mid;\\n        else if (nums[mid] > target) {\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3025822,
                "title": "python-easy-with-3-methods",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n3 Methods\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnly use 3 methods which all have to know!!! \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            return sorted(nums).index(target)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            return sorted(nums).index(target)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512849,
                "title": "c-java-python-javascript-o-logn-binary-search-with-explanation",
                "content": "# Intuition:\\nThe given code implements a binary search algorithm to find the index where a target number should be inserted into a sorted array. If the target number is already present in the array, the function returns its index. If not, it returns the index where the target should be inserted to maintain the sorted order.\\n\\n# Approach:\\n1. Initialize the start pointer to 0, representing the first index of the array, and the end pointer to `nums.size() - 1`, representing the last index of the array.\\n2. Set the answer variable `ans` to `nums.size()`, which is the default answer when the target is greater than all elements in the array.\\n3. Enter a while loop while the start pointer is less than or equal to the end pointer.\\n4. Calculate the mid index using the formula: `mid = start + (end - start) / 2`. This formula ensures that the mid index is always rounded down to the nearest integer.\\n5. Compare the element at the mid index, `nums[mid]`, with the target:\\n   a. If they are equal, return the mid index because the target is found in the array.\\n   b. If `nums[mid]` is less than the target, update the start pointer to `mid + 1` because the target should be on the right side of the mid index.\\n   c. If `nums[mid]` is greater than the target, update the answer `ans` to the current mid index and update the end pointer to `mid - 1` because the target should be on the left side of the mid index.\\n6. If the while loop exits without finding the target, return the answer `ans`, which represents the index where the target should be inserted to maintain the sorted order.\\n\\n# Complexity:\\n- The time complexity of this solution is O(log n) because the binary search algorithm divides the search space in half at each step.\\n- The space complexity is O(1) since the algorithm uses only a constant amount of extra space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        int ans = nums.size(); // Default answer when target is greater than all elements\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid; // Update the answer to the current index\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int ans = nums.length; // Default answer when target is greater than all elements\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid; // Update the answer to the current index\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        ans = len(nums) # Default answer when target is greater than all elements\\n        \\n        while start <= end:\\n            mid = (start + end) / 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                ans = mid # Update the answer to the current index\\n                end = mid - 1\\n                \\n        return ans\\n\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar searchInsert = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let ans = nums.length; // Default answer when target is greater than all elements\\n    \\n    while (start <= end) {\\n        let mid = Math.floor((start + end) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            ans = mid; // Update the answer to the current index\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        int ans = nums.size(); // Default answer when target is greater than all elements\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid; // Update the answer to the current index\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0, end = nums.length - 1;\\n        int ans = nums.length; // Default answer when target is greater than all elements\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                ans = mid; // Update the answer to the current index\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        start, end = 0, len(nums) - 1\\n        ans = len(nums) # Default answer when target is greater than all elements\\n        \\n        while start <= end:\\n            mid = (start + end) / 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                ans = mid # Update the answer to the current index\\n                end = mid - 1\\n                \\n        return ans\\n\\n\\n```\n```\\nvar searchInsert = function(nums, target) {\\n    let start = 0, end = nums.length - 1;\\n    let ans = nums.length; // Default answer when target is greater than all elements\\n    \\n    while (start <= end) {\\n        let mid = Math.floor((start + end) / 2);\\n        \\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            ans = mid; // Update the answer to the current index\\n            end = mid - 1;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905776,
                "title": "100-fastest-swift-solution-o-log-n-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count\\n\\n        while start < end {\\n            let mid = start + (end - start) / 2\\n\\n            if nums[mid] < target {\\n                start = mid + 1\\n            } else {\\n                end = mid\\n            }\\n        }\\n        return start\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(log n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n        var start = 0\\n        var end = nums.count\\n\\n        while start < end {\\n            let mid = start + (end - start) / 2\\n\\n            if nums[mid] < target {\\n                start = mid + 1\\n            } else {\\n                end = mid\\n            }\\n        }\\n        return start\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529360,
                "title": "java-tc-o-logn-sc-o-1-optimized-binary-search-w-early-exits",
                "content": "```java\\n/**\\n * Optimized Binary Search w/ Early Exits\\n *\\n * We are trying to find the index of number equal to target or index of number\\n * just larger than target.\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0 || target <= nums[0]) {\\n            return 0;\\n        }\\n        if (target == nums[len - 1]) {\\n            return len - 1;\\n        }\\n        if (target > nums[len - 1]) {\\n            return len;\\n        }\\n\\n        /*\\n         * Here the search space is from 0 to len. Since we have already handled 0 and\\n         * len in above base conditions, we can reduce the search space to 1 -> len-1.\\n         */\\n        int start = 1;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (target < nums[mid]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Optimized Binary Search w/ Early Exits\\n *\\n * We are trying to find the index of number equal to target or index of number\\n * just larger than target.\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0 || target <= nums[0]) {\\n            return 0;\\n        }\\n        if (target == nums[len - 1]) {\\n            return len - 1;\\n        }\\n        if (target > nums[len - 1]) {\\n            return len;\\n        }\\n\\n        /*\\n         * Here the search space is from 0 to len. Since we have already handled 0 and\\n         * len in above base conditions, we can reduce the search space to 1 -> len-1.\\n         */\\n        int start = 1;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (target == nums[mid]) {\\n                return mid;\\n            }\\n            if (target < nums[mid]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160170,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\t# binary search O(log N)\\n        if len(nums) == 0:\\n            return 0\\n        N = len(nums)\\n        mid = N / 2\\n        if nums[mid] == target:\\n            return mid\\n        elif nums[mid] > target:\\n            return self.searchInsert(nums[:mid],target)\\n        else:\\n            res = self.searchInsert(nums[mid+1:],target)\\n            return res + mid + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n\\t# binary search O(log N)\\n        if len(nums) == 0:\\n            return 0\\n        N = len(nums)\\n        mid = N / 2\\n        if nums[mid] == target:\\n            return mid\\n        elif nums[mid] > target:\\n            return self.searchInsert(nums[:mid],target)\\n        else:\\n            res = self.searchInsert(nums[mid+1:],target)\\n            return res + mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013307,
                "title": "python-3-1-line-simple",
                "content": "# Intuition\\nLet\\'s bisect do the work\\n\\n# Approach\\nbisect_lect do exactly what the problems is asking for\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\nIf you learnt something, please upvote!!!:\\n- It\\'s free\\n- I will be happier\\n- Karma will return you something nice\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059376,
                "title": "c-binary-search-o-log-n-cool-easy-understanding-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int SearchInsert(int[] nums, int target) {\\n\\t\\t\\tint left = 0, right = nums.Length - 1, mid;\\n\\t\\t\\twhile ( left <= right ){\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] < target ) left = mid + 1;\\n\\t\\t\\t\\telse if ( nums[mid] > target ) right = mid - 1;\\n\\t\\t\\t\\telse return mid;\\n\\t\\t\\t}   \\n\\t\\treturn left;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C#",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int SearchInsert(int[] nums, int target) {\\n\\t\\t\\tint left = 0, right = nums.Length - 1, mid;\\n\\t\\t\\twhile ( left <= right ){\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] < target ) left = mid + 1;\\n\\t\\t\\t\\telse if ( nums[mid] > target ) right = mid - 1;\\n\\t\\t\\t\\telse return mid;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 15371,
                "title": "my-understanding-of-lower-bound-upper-bound-binary-search-in-c-thanks-to-two-post",
                "content": "thanks to [A simple CPP solution with lower_bound][1]\\nand [C++ O(logn) Binary Search that handles duplicate][2],  thanks to phu1ku 's answer on the second post.\\n\\nlinks for [std::lower_bound][3]  and  [std::upper_bound][4]\\n\\n    class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            /// return index of first one that comp(item,target)==true, or nums.size() if not found\\n\\t\\t\\t/// comp is greater or equal to for lower_bound\\n\\t\\t\\t/// comp is greater for upper_bound\\n            int first=0, last=nums.size(), mid;\\n            while (first<last) {\\n                mid=first+((last-first)>>1); // first<=mid, mid<last\\n\\t\\t\\t\\t/// if comp(item,target)==false, advance first\\n\\t\\t\\t\\t// if(nums[mid]<=target) // for upper_bound\\n\\t\\t\\t\\tif (nums[mid]<target) // for lower_bound\\n\\t\\t\\t\\t\\tfirst=mid+1; // first always increases\\n\\t\\t\\t\\telse /// else recede last\\n\\t\\t\\t\\t\\tlast=mid; // last always decreases (even last-first==1)\\n            }\\n            return first;\\n        }\\n    };\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/41251/a-simple-cpp-solution-with-lower_bound\\n  [2]: https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate\\n  [3]: http://en.cppreference.com/w/cpp/algorithm/lower_bound\\n  [4]: http://en.cppreference.com/w/cpp/algorithm/upper_bound",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int searchInsert(vector<int>& nums, int target) {\\n            /// return index of first one that comp(item,target)==true, or nums.size() if not found\\n\\t\\t\\t/// comp is greater or equal to for lower_bound\\n\\t\\t\\t/// comp is greater for upper_bound\\n            int first=0, last=nums.size(), mid;\\n            while (first<last) {\\n                mid=first+((last-first)>>1); // first<=mid, mid<last\\n\\t\\t\\t\\t/// if comp(item,target)==false, advance first\\n\\t\\t\\t\\t// if(nums[mid]<=target) // for upper_bound\\n\\t\\t\\t\\tif (nums[mid]<target) // for lower_bound\\n\\t\\t\\t\\t\\tfirst=mid+1; // first always increases\\n\\t\\t\\t\\telse /// else recede last\\n\\t\\t\\t\\t\\tlast=mid; // last always decreases (even last-first==1)\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4041860,
                "title": "video-visualization-of-binary-search-o-log-n-solution",
                "content": "https://youtu.be/v4J_AWp-6EQ\\n\\nIf we simply iterated over the entire array to find the target, the algorithm would run in O(n) time.  We can improve this by using binary search instead to find the element, which runs in O(log n) time (see the video for a review of binary search).\\n\\nNow, why does binary search run in O(log n) time?  Well, with each iteration, we eliminate around half of the array.  So now the question is: how many iterations does it take to converge on a single element?  In other words, how many times do we need to divide `n` by 2 until we reach 1?\\n\\nIf <b>k</b> is the number of times we need to divide `n` by 2 to reach 1, then the equation is:\\n\\nn / 2<sup>k</sup> = 1\\n\\nn = 2<sup>k</sup> &nbsp;&nbsp;(multiply both sides by  2<sup>k</sup>)\\n\\nlog<sub>2</sub>n = k &nbsp;&nbsp;(definition of logarithms)\\n\\nSo we know that it takes log<sub>2</sub>n steps in the worst case to find the element.   But in Big O notation, we drop the base, so this ends up running in O(log n) time.\\n\\nIf the target was not in the array, then we need to figure out what index the target <i>would</i> be at if it were inserted in sorted order.  For a detailed visualization, please see the video (it\\'s difficult to describe here) but basically, at the end of the loop, the left pointer will have passed the right pointer (so l > r) and the target needs to be inserted between them.  Inserting at index `r` actually ends up inserting the target at 1 spot behind the correct spot, so inserting at index `l` is the correct answer.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target:\\n                l = mid + 1\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                return mid\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target:\\n                l = mid + 1\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                return mid\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208377,
                "title": "putta-easy-solution-c-beats-100-runtime-0ms-as-always",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int left =0;\\n        int right = nums.size()-1;\\n        //Binary Search Algo\\n        while(left<= right){\\n            int mid = left + (right-left)/2;\\n\\n            // if target is found return its index\\n            if(nums[mid] == target) return mid;\\n\\n            else if(nums[mid] > target) right = mid-1;\\n            else left = mid+1;\\n\\n        }\\n        //returning left index as it contains the position where it would be if it were inserted in order.\\n        return left;\\n    }\\n};\\n```\\n![Screenshot (10).png](https://assets.leetcode.com/users/images/074c3058-c518-4d6f-a55a-654c9be56d2a_1676868997.1759658.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int left =0;\\n        int right = nums.size()-1;\\n        //Binary Search Algo\\n        while(left<= right){\\n            int mid = left + (right-left)/2;\\n\\n            // if target is found return its index\\n            if(nums[mid] == target) return mid;\\n\\n            else if(nums[mid] > target) right = mid-1;\\n            else left = mid+1;\\n\\n        }\\n        //returning left index as it contains the position where it would be if it were inserted in order.\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073695,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a Binary Search Algorithm for solving this problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)-1\\n        while right>=left:\\n            mid = (left + right)//2\\n\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]<target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                \\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)-1\\n        while right>=left:\\n            mid = (left + right)//2\\n\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]<target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850385,
                "title": "javascript-solution",
                "content": "Runtime: 60 ms, faster than 93.28% of JavaScript online submissions for Search Insert Position.\\nMemory Usage: 42.3 MB, less than 43.22% of JavaScript online submissions for Search Insert Position.\\n```\\nvar searchInsert = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while(start < end){\\n        let mid = Math.floor((start+end)/2);\\n        if (nums[mid] === target) return mid;\\n        nums[mid] > target ? end = mid : start = mid + 1;\\n    }\\n    if (start === end){\\n        return target <= nums[start] ? start : start + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    \\n    while(start < end){\\n        let mid = Math.floor((start+end)/2);\\n        if (nums[mid] === target) return mid;\\n        nums[mid] > target ? end = mid : start = mid + 1;\\n    }\\n    if (start === end){\\n        return target <= nums[start] ? start : start + 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890588,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction searchInsert(nums: number[], target: number): number {\\n  let min = 0\\n  let max = nums.length - 1\\n\\n  while (true) {\\n    const middle = Math.floor((min + max) / 2)\\n    const num = nums[middle]\\n\\n    if (max - min <= 1) {\\n      if (target <= nums[min]) {\\n        return min\\n      } else if (target <= nums[max]) {\\n        return max\\n      } else {\\n        return max + 1\\n      }\\n    }\\n\\n    if (num > target) {\\n      max = middle\\n    } else if (num < target) {\\n      min = middle\\n    } else {\\n      return middle\\n    }\\n  }\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction searchInsert(nums: number[], target: number): number {\\n  let min = 0\\n  let max = nums.length - 1\\n\\n  while (true) {\\n    const middle = Math.floor((min + max) / 2)\\n    const num = nums[middle]\\n\\n    if (max - min <= 1) {\\n      if (target <= nums[min]) {\\n        return min\\n      } else if (target <= nums[max]) {\\n        return max\\n      } else {\\n        return max + 1\\n      }\\n    }\\n\\n    if (num > target) {\\n      max = middle\\n    } else if (num < target) {\\n      min = middle\\n    } else {\\n      return middle\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787521,
                "title": "go-concise-100",
                "content": "```\\nfunc searchInsert(nums []int, target int) int {\\n\\tl := 0\\n\\tr := len(nums) - 1\\n\\tfor l <= r {\\n\\t\\tm := l + (r-l)/2\\n\\t\\tv := nums[m]\\n\\t\\tswitch {\\n\\t\\tcase v < target:\\n\\t\\t\\tl = m + 1\\n\\t\\tcase v > target:\\n\\t\\t\\tr = m - 1\\n\\t\\tdefault:\\n\\t\\t\\treturn m\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```\\n\\nAlso, the Go troll solution since this is the exact behavior of `sort.SearchInts`:\\n```\\nfunc searchInsert_troll(nums []int, target int) int {\\n\\treturn sort.SearchInts(nums, target)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchInsert(nums []int, target int) int {\\n\\tl := 0\\n\\tr := len(nums) - 1\\n\\tfor l <= r {\\n\\t\\tm := l + (r-l)/2\\n\\t\\tv := nums[m]\\n\\t\\tswitch {\\n\\t\\tcase v < target:\\n\\t\\t\\tl = m + 1\\n\\t\\tcase v > target:\\n\\t\\t\\tr = m - 1\\n\\t\\tdefault:\\n\\t\\t\\treturn m\\n\\t\\t}\\n\\t}\\n\\treturn l\\n}\\n```\n```\\nfunc searchInsert_troll(nums []int, target int) int {\\n\\treturn sort.SearchInts(nums, target)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793793,
                "title": "rust-0ms-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\\n        nums.binary_search(&target).unwrap_or_else(|x| x) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\\n        nums.binary_search(&target).unwrap_or_else(|x| x) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243543,
                "title": "5-lines-javascript-simple-solution",
                "content": "```\\nvar searchInsert = function(nums, target) {\\n    // if nums includes target, return its index\\n    if(nums.includes(target)) return nums.indexOf(target)\\n    \\n    //else push the target in to nums and sort it, and then return its index\\n    else {\\n        nums.push(target)\\n        nums.sort((a,b) => a-b)\\n        return nums.indexOf(target)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    // if nums includes target, return its index\\n    if(nums.includes(target)) return nums.indexOf(target)\\n    \\n    //else push the target in to nums and sort it, and then return its index\\n    else {\\n        nums.push(target)\\n        nums.sort((a,b) => a-b)\\n        return nums.indexOf(target)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187567,
                "title": "javascript-binary-search",
                "content": "```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let start = 0;\n    let end = nums.length - 1;\n    while(start<=end) {\n        const mid = Math.floor((start + end)/2);\n        if(nums[mid] < target) {\n            start = mid + 1;\n        } else {\n            end = mid -1;\n        }   \n    }\n    return start;\n};\n```",
                "solutionTags": [],
                "code": "```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let start = 0;\n    let end = nums.length - 1;\n    while(start<=end) {\n        const mid = Math.floor((start + end)/2);\n        if(nums[mid] < target) {\n            start = mid + 1;\n        } else {\n            end = mid -1;\n        }   \n    }\n    return start;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767670,
                "title": "c-c-short-and-simple-solution-o-logn-faster-than-100",
                "content": "**Binary Search - O(logn)**\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] < target) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n};\\n```\\n****\\n**Stupid O(n) Linear Search**\\n```\\nint searchInsert(int* nums, int numsSize, int target){\\n    for (int i=0; i<numsSize; i++)\\n    {\\n        if ((target == nums[i]) || (target < nums[i]))\\n            return i;\\n    }\\n    return numsSize;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] < target) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n};\\n```\n```\\nint searchInsert(int* nums, int numsSize, int target){\\n    for (int i=0; i<numsSize; i++)\\n    {\\n        if ((target == nums[i]) || (target < nums[i]))\\n            return i;\\n    }\\n    return numsSize;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034842,
                "title": "simplest-c-solution-for-search-insert-position",
                "content": "# Intuition\\nSimple binary search but with some simple conditions.\\n\\n\\n# Approach\\nWe will perform simple binary search on this but with some condition.\\nConditions(**These conditions will be met if the element won\\'t be found**) are : -\\n- if start and end will be equal, we will return the *end index* if *the element at that index is bigger than the target*, else we will return *end+1*\\n- if somehow end and start pointers do not gets equal and crosses each other, just *return the start index*.\\n\\nThere will be many solutions other than this, mine is just easier to understand and is good for beginners.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int s = 0,e = nums.size()-1,mid = 0;\\n\\n        while(s <= e){\\n            mid = s + (e-s)/2;\\n\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                s = mid + 1;\\n            else\\n                e = mid - 1;\\n\\n        }\\n\\n        if(target > nums[mid])\\n            return mid + 1;\\n        else\\n            return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int s = 0,e = nums.size()-1,mid = 0;\\n\\n        while(s <= e){\\n            mid = s + (e-s)/2;\\n\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                s = mid + 1;\\n            else\\n                e = mid - 1;\\n\\n        }\\n\\n        if(target > nums[mid])\\n            return mid + 1;\\n        else\\n            return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765281,
                "title": "one-liner-cpp",
                "content": "```\\nreturn lower_bound(nums.begin(), nums.end(), tar) - nums.begin();\\n```",
                "solutionTags": [],
                "code": "```\\nreturn lower_bound(nums.begin(), nums.end(), tar) - nums.begin();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2316272,
                "title": "very-easy-100-fully-explained-java-c-python-c-js-python3",
                "content": "# **Java Solution:**\\n```\\n// The insert position is the index which element\\u2019s value is greater or equal with target.\\n// So we scan linearly the array will find the answer.\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        //Traverse all elements through the loop...\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] >= target)   return i;\\n        }\\n    return nums.length;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Using Binary Search Approach...\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int beg = 0;\\n        int end = nums.size()-1;\\n        while(beg <= end){\\n            int mid = (beg + end)/2;\\n            if(target > nums[mid]){\\n                beg = mid + 1;\\n            }else if(target < nums[mid]){\\n                end = mid - 1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return beg;\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nint searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }\\n    return numsSize;\\n}\\n```\\n\\n# Python Solution:\\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        for i in range(len(nums)):\\n            if(nums[i] >= target):\\n                return i\\n        return len(nums)\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar searchInsert = function(nums, target) {\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i] >= target)   return i;\\n    }\\n    return nums.length;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        #Traverse all elements through the loop...\\n        for i in range(len(nums)):\\n            if(nums[i] >= target):\\n                return i\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// The insert position is the index which element\\u2019s value is greater or equal with target.\\n// So we scan linearly the array will find the answer.\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        //Traverse all elements through the loop...\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] >= target)   return i;\\n        }\\n    return nums.length;\\n    }\\n}\\n```\n```\\n// Using Binary Search Approach...\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int beg = 0;\\n        int end = nums.size()-1;\\n        while(beg <= end){\\n            int mid = (beg + end)/2;\\n            if(target > nums[mid]){\\n                beg = mid + 1;\\n            }else if(target < nums[mid]){\\n                end = mid - 1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return beg;\\n    }\\n};\\n```\n```\\nint searchInsert(int* nums, int numsSize, int target){\\n    for(int i = 0; i < numsSize; i++){\\n        if(nums[i] >= target)   return i;\\n    }\\n    return numsSize;\\n}\\n```\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        for i in range(len(nums)):\\n            if(nums[i] >= target):\\n                return i\\n        return len(nums)\\n```\n```\\nvar searchInsert = function(nums, target) {\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i] >= target)   return i;\\n    }\\n    return nums.length;\\n};\\n```\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        #Traverse all elements through the loop...\\n        for i in range(len(nums)):\\n            if(nums[i] >= target):\\n                return i\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421416,
                "title": "binary-search-nice-explanation-c-implementation",
                "content": "**Approach** : we make a simple binary search on our array and once (left == right) we                            stop , there are two things may to be happen here . first we find nums[left]                          is our target or it\\'s greater than it and here we return (left) because this                              his place or will be his place or we find nums[left] < target so we return                              left+1 because our target his place after left because it greater than left.                            and this will happen if not find target while we make a binary search!\\n```\\nint searchInsert(vector<int>& nums, int target) {\\n        int left = 0 ; int right = nums.size()-1;\\n        while(left < right) {\\n            int mid = (left+right)/2;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target) right = mid-1;\\n            else left = mid+1;\\n        }\\n        return (nums[left] >= target) ? left : left+1;\\n    }\\n```\\nTime Complexity : O(log n)\\nSpace Complexity : O(1)\\n\\n***Upvotes would be appreciated !***",
                "solutionTags": [],
                "code": "```\\nint searchInsert(vector<int>& nums, int target) {\\n        int left = 0 ; int right = nums.size()-1;\\n        while(left < right) {\\n            int mid = (left+right)/2;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target) right = mid-1;\\n            else left = mid+1;\\n        }\\n        return (nums[left] >= target) ? left : left+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059959,
                "title": "python-one-liner",
                "content": "Too lazy to write a binary search right now.\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return sorted(nums + [target]).index(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return sorted(nums + [target]).index(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574073,
                "title": "simple-javascript-solution",
                "content": "my simple solution\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    var right = nums.length - 1;\\n    var left = 0;\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        } else if (target < nums[mid]) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    \\n    return target > nums[left] ? left + 1 : left;\\n};\\n```",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    var right = nums.length - 1;\\n    var left = 0;\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (target === nums[mid]) {\\n            return mid;\\n        } else if (target < nums[mid]) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n    \\n    return target > nums[left] ? left + 1 : left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209717,
                "title": "easiest-js-method-outhere",
                "content": "# Intuition \\nNormally we\\'d solve it via loop but thats computationally consuming so we need to think differently\\nWe can use depth search or even first order search but why complicate it? \\n# Approach\\nThe below approach is simple it includes using Javascript built in methods and it\\'s a good practice on the following:\\nIf you\\'re new to Js or maybe studying ***react*** or ***vue***  or even anyother framework \\nKnowing and learning those methods will help you\\n 1- includes\\n2-indexOf\\n3-rest operator and destructuring \\n4- arrow function\\n5-sorting via sort method\\n\\nMY ADVICE? READ THE SOLUTION CAREFULLY AND THEN HIT THE SEARCH BUTTON AND CHECK THOSE METHODS LISTED ABOVE,\\nYOU\\'LL THANK ME LATER\\nplease upvote if I helped you in anyway :)\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    // includes,indexOf,rest operator,arrow function,sorting via sort method\\n     if(nums.includes(target))  //includes method\\n      return nums.indexOf(target); //returns index method//\\n     return [...nums, target].sort((a,b) => a-b).indexOf(target); //return where it shold be inserted//\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    // includes,indexOf,rest operator,arrow function,sorting via sort method\\n     if(nums.includes(target))  //includes method\\n      return nums.indexOf(target); //returns index method//\\n     return [...nums, target].sort((a,b) => a-b).indexOf(target); //return where it shold be inserted//\\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209078,
                "title": "c-2-lines",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int SearchInsert(int[] nums, int target)\\n    {\\n        var index = Array.BinarySearch(nums, target);\\n        return index >= 0 ? index : ~index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int SearchInsert(int[] nums, int target)\\n    {\\n        var index = Array.BinarySearch(nums, target);\\n        return index >= 0 ? index : ~index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773650,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimply use binary search\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start=0;\\n        int end=nums.length - 1;\\n        while(start <= end)\\n        {\\n            int mid= start + ( end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            if( nums[mid] > target) end=mid - 1;\\n            if(nums[mid] < target) start=mid + 1;\\n        }\\n       return start;\\n    }\\n}\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/17ae2909-06f0-4e4e-9879-3501f4e29a36_1689511672.495058.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start=0;\\n        int end=nums.length - 1;\\n        while(start <= end)\\n        {\\n            int mid= start + ( end - start) / 2;\\n            if(nums[mid] == target) return mid;\\n            if( nums[mid] > target) end=mid - 1;\\n            if(nums[mid] < target) start=mid + 1;\\n        }\\n       return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208176,
                "title": "c-faster-than-75-easy-binary-search-clean-code",
                "content": "\\n# Code\\n# PLEASE DO UPVOTE!!!!\\n```\\nclass Solution {\\npublic:\\n  \\n    int searchInsert(vector<int>& nums, int target) {\\n     \\n       int hi = nums.size()-1, lo=0;\\n       while(hi >= lo)\\n       {\\n         int mid = (hi + lo)/2;\\n\\n         if(nums[mid]==target) return mid;\\n    \\n         else if(nums[mid] > target) hi = mid - 1;\\n         \\n         else lo = mid + 1;\\n       }\\n\\n      return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int searchInsert(vector<int>& nums, int target) {\\n     \\n       int hi = nums.size()-1, lo=0;\\n       while(hi >= lo)\\n       {\\n         int mid = (hi + lo)/2;\\n\\n         if(nums[mid]==target) return mid;\\n    \\n         else if(nums[mid] > target) hi = mid - 1;\\n         \\n         else lo = mid + 1;\\n       }\\n\\n      return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208027,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=xGMSX3eK2vs&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=20) if you are interested.\\n\\n---\\n\\n**Suggested Problems**\\n\\n- https://leetcode.com/problems/binary-search/\\n- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\n- https://leetcode.com/problems/find-peak-element/\\n- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\\n\\n**Approach 1: Lower Bound**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n\\t\\t// ref: https://en.cppreference.com/w/cpp/algorithm/lower_bound\\n\\t    // lower_bound: returns an iterator pointing to the first element in the range [first, last) \\n\\t\\t// that does not satisfy element < value (or comp(element, value)), (i.e. greater or equal to), \\n\\t\\t// or last if no such element is found.\\n\\t\\t// adding `- nums.begin()` to get the position\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\\n\\n**Approach 2: Pure Binary Search**\\n\\nSee [Binary Search](https://leetcodethehardway.com/tutorials/basic-topics/binary-search) for the tutorial.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        // init the possible range\\n        // as we insert at the end of the array,\\n        // use nums.size() instead of nums.size() - 1\\n        int l = 0, r = nums.size();\\n        while (l < r) {\\n            // take the lower mid for even elements\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (target > nums[m]) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums)\\n        while l < r:\\n            m = (l + r) // 2\\n            if nums[m] >= target:\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n            \\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n\\t\\t// ref: https://en.cppreference.com/w/cpp/algorithm/lower_bound\\n\\t    // lower_bound: returns an iterator pointing to the first element in the range [first, last) \\n\\t\\t// that does not satisfy element < value (or comp(element, value)), (i.e. greater or equal to), \\n\\t\\t// or last if no such element is found.\\n\\t\\t// adding `- nums.begin()` to get the position\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect.bisect_left(nums, target)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        // init the possible range\\n        // as we insert at the end of the array,\\n        // use nums.size() instead of nums.size() - 1\\n        int l = 0, r = nums.size();\\n        while (l < r) {\\n            // take the lower mid for even elements\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (target > nums[m]) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums)\\n        while l < r:\\n            m = (l + r) // 2\\n            if nums[m] >= target:\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185345,
                "title": "java-easy-solution-o-log-n-runtime-0-ms",
                "content": "\\n# Complexity\\n- Time complexity: O(log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n      \\n        int low = 0, high = nums.length;\\n        while(low < high) {\\n\\n            // Calculate middle index\\n            int mid = low + (high - low)/2;\\n            if(target > nums[mid])\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n      \\n        int low = 0, high = nums.length;\\n        while(low < high) {\\n\\n            // Calculate middle index\\n            int mid = low + (high - low)/2;\\n            if(target > nums[mid])\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812734,
                "title": "built-in-python",
                "content": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n            nums.append(target)\\n            return sorted(nums).index(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n            nums.append(target)\\n            return sorted(nums).index(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669411,
                "title": "js-95-binary-search-o-log-n",
                "content": "[image](https://assets.leetcode.com/users/images/9ad2d5f5-9c05-46ba-917b-94f80be4b598_1665074483.1153562.png)\\nBinary search is a search algorithm that finds the index of a target value in a sorted array. A binary search compares the target value to the middle element of the array (rounding to get an integer, in my case using a double bitwise NOT (~), i.e. (~~). If they are not equal, the half in which the target cannot lie is discarded, and the search continues on the second half, we again take the middle element to compare with the target value and repeat this until the target value is found, if the search ends with the half remaining empty, it means that the target is not in the array, so we return the last the value is low.!\\n\\n\\n```\\nvar searchInsert = function (nums, target) {\\n\\n    let low = 0;\\n    let high = nums.length - 1;\\n\\t\\n    while (low <= high) {\\n        let mid = ~~(low + (high - low) / 2);\\n        if (nums[mid] > target) {\\n            high = --mid;\\n        } else if (nums[mid] < target) {\\n            low = ++mid;\\n        } else return mid;\\n    }\\n    return low;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchInsert = function (nums, target) {\\n\\n    let low = 0;\\n    let high = nums.length - 1;\\n\\t\\n    while (low <= high) {\\n        let mid = ~~(low + (high - low) / 2);\\n        if (nums[mid] > target) {\\n            high = --mid;\\n        } else if (nums[mid] < target) {\\n            low = ++mid;\\n        } else return mid;\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660728,
                "title": "java-solution-binary-search-easy-to-understand",
                "content": "**If Liked Please UpVote me Means a lot**\\n\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid = end + ( start - end) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            if(target < nums[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid = end + ( start - end) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            if(target < nums[mid]){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150427,
                "title": "8-lines-of-clean-binary-search-explained",
                "content": "The idea is to do a binary search.\\nIf we exit the binary search and don\\'t find the target, the insert index will be the `left` index after the binary search\\n\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            middle = left + (right-left) // 2\\n            if nums[middle] == target: return middle\\n            if nums[middle] > target: right = middle - 1\\n            else: left = middle + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            middle = left + (right-left) // 2\\n            if nums[middle] == target: return middle\\n            if nums[middle] > target: right = middle - 1\\n            else: left = middle + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980782,
                "title": "4-lines-java-code-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) return i;  // this means the value is present and we will returen the index\\n            else if(nums[i]>target) return i;  // this mean the array value is more that target value and \\n\\t\\t\\t//we havn\\'e found any match yet this mean the value is not present so we will put target \\n\\t\\t\\t//value in the index of its just greater value that is present at index i\\n        }\\n        return nums.length;// we have traversed the whole array and niether able to find the value,\\n\\t\\t//nor the value greater then it i.e. target will be added at the end end so return nums.length\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) return i;  // this means the value is present and we will returen the index\\n            else if(nums[i]>target) return i;  // this mean the array value is more that target value and \\n\\t\\t\\t//we havn\\'e found any match yet this mean the value is not present so we will put target \\n\\t\\t\\t//value in the index of its just greater value that is present at index i\\n        }\\n        return nums.length;// we have traversed the whole array and niether able to find the value,\\n\\t\\t//nor the value greater then it i.e. target will be added at the end end so return nums.length\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680006,
                "title": "to-find-the-floor-of-target-in-a-given-sorted-array",
                "content": "```\\n public int searchInsert(int[] nums, int target) {\\n        return floor(nums,target);\\n    }\\n    public static int floor(int nums[], int key){\\n        int l=0;\\n        int r=nums.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]>=key)\\n                r=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int searchInsert(int[] nums, int target) {\\n        return floor(nums,target);\\n    }\\n    public static int floor(int nums[], int key){\\n        int l=0;\\n        int r=nums.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]>=key)\\n                r=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399777,
                "title": "a-simple-c-solution-faster-than-94",
                "content": "**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\nRuntime: 92 ms, faster than 93.54% of C# online submissions for Search Insert Position.\\nMemory Usage: 23.8 MB, less than 5.26% of C# online submissions for Search Insert Position.\\n\\n    public int SearchInsert(int[] nums, int target) {\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] >= target){\\n                return i;\\n            }\\n        }\\n        \\n        return nums.Length;\\n    }",
                "solutionTags": [],
                "code": "**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\nRuntime: 92 ms, faster than 93.54% of C# online submissions for Search Insert Position.\\nMemory Usage: 23.8 MB, less than 5.26% of C# online submissions for Search Insert Position.\\n\\n    public int SearchInsert(int[] nums, int target) {\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] >= target){\\n                return i;\\n            }\\n        }\\n        \\n        return nums.Length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 159489,
                "title": "python-one-line-20ms-beats-100",
                "content": "    def searchInsert(self, nums, target):\\n        return sorted(nums + [target]).index(target)",
                "solutionTags": [],
                "code": "    def searchInsert(self, nums, target):\\n        return sorted(nums + [target]).index(target)",
                "codeTag": "Python3"
            },
            {
                "id": 3436467,
                "title": "best-solution-in-java-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n         for (int i = 0; i < nums.length; i++) {\\n          if (nums[i] == target || nums[i] > target)\\n              return i;\\n\\n          if (i == nums.length-1)\\n              return nums.length;\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n         for (int i = 0; i < nums.length; i++) {\\n          if (nums[i] == target || nums[i] > target)\\n              return i;\\n\\n          if (i == nums.length-1)\\n              return nums.length;\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945926,
                "title": "simple-java-solution-in-o-log-n-100-beat",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n         int mid = l +(r-l)/2;\\n        while(l<=r){\\n             mid = l +(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n                else if(nums[mid]>target){\\n                    r = mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n        } \\n        return l;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l = 0, r = nums.length-1;\\n         int mid = l +(r-l)/2;\\n        while(l<=r){\\n             mid = l +(r-l)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n                else if(nums[mid]>target){\\n                    r = mid-1;\\n                }else{\\n                    l=mid+1;\\n                }\\n        } \\n        return l;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945855,
                "title": "simple-java-solution-in-o-log-n-100-beat",
                "content": "\\n```\\nclass Solution {\\n   public int searchInsert(int[] nums, int target) {\\n    int res = 0, l = 0, h = nums.length - 1;\\n    while (l <= h) {\\n        int mid = l + (h - l) / 2;\\n\\n        if (target > nums[mid]) {\\n            l = mid + 1;\\n            res = mid + 1;\\n        } else if (target < nums[mid]) {\\n            h = mid - 1;\\n            res = mid;\\n        } else {\\n            res = mid;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int searchInsert(int[] nums, int target) {\\n    int res = 0, l = 0, h = nums.length - 1;\\n    while (l <= h) {\\n        int mid = l + (h - l) / 2;\\n\\n        if (target > nums[mid]) {\\n            l = mid + 1;\\n            res = mid + 1;\\n        } else if (target < nums[mid]) {\\n            h = mid - 1;\\n            res = mid;\\n        } else {\\n            res = mid;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692962,
                "title": "100-faster-0ms-solution-its-just-a-binary-search-template",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int low = 0, high = A.length-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(A[mid] == target) return mid;\\n            else if(A[mid] > target) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }       \\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int low = 0, high = A.length-1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(A[mid] == target) return mid;\\n            else if(A[mid] > target) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }       \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551777,
                "title": "my-45ms-javascript-solution",
                "content": "Runtime - 45ms -> faster than 99.96% of JS submissions\\nMemory Usage - 42.1 MB, less than 60.71% of JS submissions\\n\\nRuntime Complexity - O(log n)\\n\\n```\\nvar searchInsert = function(nums, target) {\\n    var start = 0;\\n    var end = nums.length - 1;\\n    \\n    while(start<=end) {\\n        const mid = Math.floor((start + end)/2);\\n        \\n        if(nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid -1;\\n        }   \\n    }\\n    \\n    return start;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/098d8d7f-9a9e-4e2a-b57d-97d9159eaff7_1662689948.7419305.png)\\n\\n![image](https://assets.leetcode.com/users/images/c1fe3a58-0842-4583-baf6-5737c291033a_1662689996.120624.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    var start = 0;\\n    var end = nums.length - 1;\\n    \\n    while(start<=end) {\\n        const mid = Math.floor((start + end)/2);\\n        \\n        if(nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid -1;\\n        }   \\n    }\\n    \\n    return start;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102267,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n            int start=0,end=nums.size()-1;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (nums[mid]==target) return mid;\\n            else if (nums[mid]<target) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return start;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n            int start=0,end=nums.size()-1;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (nums[mid]==target) return mid;\\n            else if (nums[mid]<target) start=mid+1;\\n            else end=mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1596607,
                "title": "c-2-simple-methods-faster-than-100",
                "content": "**Firstly, thank you for refering to my solutions in advance :)**\\n\\n**APPROACH 1 :** Using ```std::lower_bound()```\\n\\n* \\'std::lower_bound()\\' returns the iterator to the first element in the range [first, last) which has a value not less than val.\\n* i.e; the function returns the iterator to the next smallest number that is greater than or equal to that number.\\n* If there are multiple elements that are equal to the target number, \\'std::lower_bound()\\' returns the iterator to the first such element.\\n* To get the index of the element, we subtract the \\'nums.begin()\\' from the value returned by \\'std::lower_bound()\\' .\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(logn) - n = size of the given array\\n**Auxiliary Space :** O(1)\\n\\n**APPROACH - 2 :** Binary Search \\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1, mid;\\n        \\n        while(l <= r){\\n            mid = l+(r-l)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid] > target) r = mid-1;\\n            else l = mid+1;\\n        }\\n        return l;  //(or) return r+1;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(logn) \\n\\n**Auxiliary Space :** O(1)\\n\\n**If you like my solutions, PLEASE UPVOTE :)** \\uD83D\\uDD3C\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```std::lower_bound()```\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return std::lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1, mid;\\n        \\n        while(l <= r){\\n            mid = l+(r-l)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid] > target) r = mid-1;\\n            else l = mid+1;\\n        }\\n        return l;  //(or) return r+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456649,
                "title": "simplest-java-solution-searching-ceiling-index-using-binary-search-100-faster",
                "content": "#### Time complexity : O(log(n))\\nwe are simply using binary search algorithm here to search the ceiling index , because there only we will insert the incoming value . \\nceiling value : its either equal to the target element , or the smallest value among the elements which r larger than target .\\nExample : \\narray = { 1 , 2 , 3 ,4 , 5 , 8 ,9 }\\ntarget = 5 , ceiling value = 5\\ntarget = 6 , ceiling value = 8\\nso if 6 is coming , it will take index of 8 only ,\\nHope I was able to make you unserstand :)\\n\\n```\\nclass Solution \\n{\\n    public int searchInsert(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start )/2;\\n            if(nums[mid] == target )\\n                return mid;\\n            else if(nums[mid] < target)\\n                start = mid+1;\\n            else \\n                end = end-1;\\n        }\\n        return start ;\\n    }\\n}\\n```\\n\\nTry it once on paper , to understand it better :) ,\\nint mid = start + (end - start )/2;\\nis equal to int mid = (start + end )/2;\\nits a better approach to prevent integer overflow .\\n\\nIf something confuses u , feel free to ask me the same",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int searchInsert(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length -1;\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start )/2;\\n            if(nums[mid] == target )\\n                return mid;\\n            else if(nums[mid] < target)\\n                start = mid+1;\\n            else \\n                end = end-1;\\n        }\\n        return start ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15169,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        if (nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int i = 0,\\n            j = nums.Length - 1;\\n        \\n        while (i <= j)\\n        {\\n            int m = j + (i - j) / 2;\\n            \\n            if (nums[m] == target)\\n                return m;\\n            else if (nums[m] < target)\\n                i = m + 1;\\n            else\\n                j = m - 1;\\n        }\\n        \\n        return i;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        if (nums == null || nums.Length == 0)\\n            return -1;\\n        \\n        int i = 0,\\n            j = nums.Length - 1;\\n        \\n        while (i <= j)\\n        {\\n            int m = j + (i - j) / 2;\\n            \\n            if (nums[m] == target)\\n                return m;\\n            else if (nums[m] < target)\\n                i = m + 1;\\n            else\\n                j = m - 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 15303,
                "title": "simple-binary-search-solution",
                "content": "I think the solution does not need a lot of if statement.\\nOnly two cases:\\n1 if found, just return current index\\n2 if not found, return next index where the search end\\n\\n    int search(int A[], int start, int end, int target) {\\n        if (start > end) return start;\\n        int mid = (start + end) / 2;\\n        if (A[mid] == target) return mid;\\n        else if (A[mid] > target) return search(A, start, mid - 1, target);\\n        else return search(A, mid + 1, end, target);\\n    }\\n    int searchInsert(int A[], int n, int target) {\\n        return search(A, 0, n - 1, target);\\n    }",
                "solutionTags": [],
                "code": "I think the solution does not need a lot of if statement.\\nOnly two cases:\\n1 if found, just return current index\\n2 if not found, return next index where the search end\\n\\n    int search(int A[], int start, int end, int target) {\\n        if (start > end) return start;\\n        int mid = (start + end) / 2;\\n        if (A[mid] == target) return mid;\\n        else if (A[mid] > target) return search(A, start, mid - 1, target);\\n        else return search(A, mid + 1, end, target);\\n    }\\n    int searchInsert(int A[], int n, int target) {\\n        return search(A, 0, n - 1, target);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3632532,
                "title": "one-line-c-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing STL function for binary search.\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n    }\\n};\\n```\\n![da40578e-3278-4fca-a939-3861f2644e15_1679154045.78228.png](https://assets.leetcode.com/users/images/e4fd6205-d915-4d44-a082-52dbec1a57d8_1686647671.9273503.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208036,
                "title": "day-51-c-o-logn-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\n1) *[1,3,5,6], target = 0, for this type of example in which target is less than arr[0], in this case the index of \"last\" is always \"-1\".*\\n\\n2) *[1,3,5,6], target = 7, for this type of example in which target is greater than arr[n-1], in this case the index of \"last\" is always \"n-1\".*\\n\\n3) *\"last\" is always point to the index which is just smaller or equal to the target at the end of the program.\\nEx - [1,3,5,6], target = 2, for this case \"last\" is pointing to 0th index which is just smaller than target i.e. 2.*\\n\\n*It means no need to cover \"edge case\" additionally. When you will return \"last + 1\" at the end of code then it will automatically cover both the cases i.e. 1st and 2nd.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Get the size of the input vector nums.\\n2. If the target value is greater than the last element of nums, return the size of nums.\\n3. If the target value is smaller than the first element of nums, return 0.\\n4. Initialize variables first and last to 0 and n - 1 respectively,\\n5. where n is the size of nums.\\n6. Initialize variable mid to -1.\\n7. While first is less than or equal to last, do the following:\\n    - a. Calculate mid as the average of first and last.\\n    - b. If the element at index mid is equal to target, return mid.\\n    - c. If the element at index mid is less than target, update first to mid + 1.\\n    - d. If the element at index mid is greater than target, update last to mid - 1.\\n1. If target is less than the element at index mid, return mid. Otherwise, return mid + 1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int first = 0, last = n-1, mid = -1;\\n        while (first <= last) {\\n             mid = (last + first) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (target > nums[mid])\\n                first = mid + 1;\\n            else    \\n                last = mid - 1;\\n        }\\n        return last + 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int n = nums.length;\\n        if (target > nums[n-1])\\n            return n;\\n        if (target < nums[0])\\n            return 0;\\n        int first = 0, last = n-1, mid = -1;\\n        while (first <= last) {\\n            mid = (last + first) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (target > nums[mid])\\n                first = mid + 1;\\n            else    \\n                last = mid - 1;\\n        }\\n        if (target < nums[mid])\\n            return mid;\\n        else \\n            return mid + 1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        if target > nums[n-1]:\\n            return n\\n        if target < nums[0]:\\n            return 0\\n        first, last, mid = 0, n-1, -1\\n        while first <= last:\\n            mid = (last + first) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif target > nums[mid]:\\n                first = mid + 1\\n            else:\\n                last = mid - 1\\n        if target < nums[mid]:\\n            return mid\\n        else:\\n            return mid + 1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int first = 0, last = n-1, mid = -1;\\n        while (first <= last) {\\n             mid = (last + first) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (target > nums[mid])\\n                first = mid + 1;\\n            else    \\n                last = mid - 1;\\n        }\\n        return last + 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int n = nums.length;\\n        if (target > nums[n-1])\\n            return n;\\n        if (target < nums[0])\\n            return 0;\\n        int first = 0, last = n-1, mid = -1;\\n        while (first <= last) {\\n            mid = (last + first) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (target > nums[mid])\\n                first = mid + 1;\\n            else    \\n                last = mid - 1;\\n        }\\n        if (target < nums[mid])\\n            return mid;\\n        else \\n            return mid + 1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        if target > nums[n-1]:\\n            return n\\n        if target < nums[0]:\\n            return 0\\n        first, last, mid = 0, n-1, -1\\n        while first <= last:\\n            mid = (last + first) // 2\\n            if nums[mid] == target:\\n                return mid\\n            elif target > nums[mid]:\\n                first = mid + 1\\n            else:\\n                last = mid - 1\\n        if target < nums[mid]:\\n            return mid\\n        else:\\n            return mid + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162821,
                "title": "simple-c-code-using-single-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]<target) l= m+1;\\n            else r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int l=0,r=n-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target) return m;\\n            if(nums[m]<target) l= m+1;\\n            else r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986371,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n\\n        return nums.index(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n\\n        return nums.index(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592582,
                "title": "javascript-solution-within-6-code-lines-and-explanation",
                "content": "Binary Search solution with O(logn):\\n```\\nvar searchInsert = function(nums, target) {\\n    let left = 0, right = nums.length - 1;\\n    while (left <= right) {\\n        if (left === right) return target <= nums[left] ? left : left +1;\\n        const mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < target) left = mid + 1;\\n         else right = mid;\\n    }\\n};\\n```\\n**Explain**:\\n**Line 1**: We define the range boundary we want to search\\n\\n**Line 2**: Run the loop to find the target\\n\\n**Line 3**: Instead of using loop condition `left < right` and return the result outside of loop when `left === right`. I use `left <= right`, then I can check when `left === right`: \\nFor simple, you can imagine after looping to the end and `left === right === 3` (index) and at `index 3` of nums array `[1, 3, 5, 9]` is number `5`. We will have 3 cases:\\n- `target` is `5` => `nums[left] === target` => index is `3` (left)\\n- `target` is `4` => `nums[left] > target` => `target` should be inserted before `nums[left]`. When we insert `target`, it will take the `index of number 5` and shift all the numbers that behind `target` to 1 (increase 1, EX: `index of 5 will be 4` and `index of 9 will be 5`) => index is `3` (left)\\n- `target` is `6` => `nums[left] < target` => `target` should be inserted after `nums[left]`. When we insert `target`, it will take the index of the current number that behind `nums[left]`. Then shift all the numbers that behind target to 1 (same as above). If there is no element after `nums[left]`, nothing is shifted => index is `4` (left + 1)\\nTo sumary above cases => if `target <= nums[left]` => return `left` else we return `left + 1`\\n\\n**Line 4**: Calculates the mid pivot. We shouldn\\'t use `mid = (left + right)/2` as it can cause overflow\\n\\n**Line 5,6**: We check `nums[mid] < target`. We will have 2 cases:\\n- If `nums[mid] < target`. It means the `target` we want to find is not in range `left <-> nums[mid]` => we increase the boundary on the left: `left = mid + 1`\\n- If `nums[mid] < target` is wrong. It means `nums[mid] >= target` and the `target` we want to find is not in range `nums[mid] <-> right` => we decrease the boundary on the right: `right = mid `(Because `nums[mid]` can be equal to `target` so we still keep` right = mid `not `right = mid - 1`)\\n\\nThen the problem is solved. If you have any concern, please leave the comments. Thanks",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    let left = 0, right = nums.length - 1;\\n    while (left <= right) {\\n        if (left === right) return target <= nums[left] ? left : left +1;\\n        const mid = left + Math.floor((right - left)/2);\\n        if (nums[mid] < target) left = mid + 1;\\n         else right = mid;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1129683,
                "title": "simple-faster-than-100",
                "content": "**CODE:**\\n```\\n    public int searchInsert(int[] nums, int target) {\\n        int l=0;\\n        int r=nums.length-1;\\n         \\n        while(l<=r){\\n            int mid=l + (r-l)/2;\\n            \\n            if(nums[mid]==target){\\n                return mid;\\n            }else if(nums[mid]>target){\\n                r=mid-1;  \\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n        \\n    }\\n```\\n**Complexity:** `Time:O(logn) and Space:O(1)`\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n    public int searchInsert(int[] nums, int target) {\\n        int l=0;\\n        int r=nums.length-1;\\n         \\n        while(l<=r){\\n            int mid=l + (r-l)/2;\\n            \\n            if(nums[mid]==target){\\n                return mid;\\n            }else if(nums[mid]>target){\\n                r=mid-1;  \\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059354,
                "title": "c-binary-search-o-log-n-cool-easy-understanding",
                "content": "\\tint searchInsert(int* nums, int numsSize, int target){\\n\\t\\tint left = 0, right = numsSize - 1, mid;\\n\\t\\twhile ( left <= right ){\\n\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\tif ( nums[mid] < target ) left = mid + 1;\\n\\t\\t\\telse if ( nums[mid] > target ) right = mid - 1;\\n\\t\\t\\telse return mid;\\n\\t\\t}   \\n\\t\\treturn left;\\n\\t}",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "\\tint searchInsert(int* nums, int numsSize, int target){\\n\\t\\tint left = 0, right = numsSize - 1, mid;\\n\\t\\twhile ( left <= right ){\\n\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\tif ( nums[mid] < target ) left = mid + 1;\\n\\t\\t\\telse if ( nums[mid] > target ) right = mid - 1;\\n\\t\\t\\telse return mid;\\n\\t\\t}   \\n\\t\\treturn left;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 852372,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n               return i;\\n            }\\n        \\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(target<nums[i]){\\n                return i;\\n            }\\n        }\\n        return nums.length;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n               return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 15111,
                "title": "my-8ms-accepted-code",
                "content": "    class Solution {\\n    public:\\n        int searchInsert(int A[], int n, int target) {\\n            int low = 0,high = n - 1;\\n    \\t\\twhile (low <= high){\\n    \\t\\t\\tint mid = (low + high) / 2;\\n    \\t\\t\\tif(A[mid]==target) return mid;\\n    \\t\\t\\telse if (A[mid] >target){\\n    \\t\\t\\t\\thigh = mid - 1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tlow = mid + 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn low;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int searchInsert(int A[], int n, int target) {\\n            int low = 0,high = n - 1;\\n    \\t\\twhile (low <= high){\\n    \\t\\t\\tint mid = (low + high) / 2;\\n    \\t\\t\\tif(A[mid]==target) return mid;\\n    \\t\\t\\telse if (A[mid] >target){\\n    \\t\\t\\t\\thigh = mid - 1;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3358008,
                "title": "c-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }\\n        else if (nums[i] >= target) {\\n            index2 = i;\\n            break;\\n        }\\n    }\\n    \\n    if (index1 == -1 && index2 == -1) return numsSize;\\n\\n    return index1 != -1 ? index1 : index2;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint searchInsert(int* nums, int numsSize, int target){\\n    int index1 = -1;\\n    int index2 = -1;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == target) {\\n            index1 = i;\\n            break;\\n        }\\n        else if (nums[i] >= target) {\\n            index2 = i;\\n            break;\\n        }\\n    }\\n    \\n    if (index1 == -1 && index2 == -1) return numsSize;\\n\\n    return index1 != -1 ? index1 : index2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209553,
                "title": "python-binary-search-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormal binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe perform binary search as usual, but have 2 extra variables \\n- previous last (pl) to store the previous iteration\\'s value of last\\n- previous first (pf) to store the previous iteration\\'s value of first\\n\\nSo that in the occasion of element not found, we can have pf and pl and thus last mid value before, first becomes greater than last. we can eliminate 2 variables and just store previous mid value also.\\n\\nBy having that we can compare the mid element\\'s value with our target. if it is less than target, then we insert one element next\\nelse we will insert target there itself.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) due to nums\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        first=0\\n        last=len(nums)-1\\n        pf=0\\n        pl=len(nums)-1\\n        mid=(first+last)//2\\n        while(first<=last):\\n            mid=(first+last)//2\\n            if(nums[mid]==target):\\n                return mid\\n            elif(nums[mid]<target):\\n                pf=first\\n                first=mid+1\\n            else:\\n                pl=last\\n                last=mid-1\\n        mid=(pf+pl)//2\\n        if(nums[mid]>target):\\n            return mid\\n        else:\\n            return mid+1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        first=0\\n        last=len(nums)-1\\n        pf=0\\n        pl=len(nums)-1\\n        mid=(first+last)//2\\n        while(first<=last):\\n            mid=(first+last)//2\\n            if(nums[mid]==target):\\n                return mid\\n            elif(nums[mid]<target):\\n                pf=first\\n                first=mid+1\\n            else:\\n                pl=last\\n                last=mid-1\\n        mid=(pf+pl)//2\\n        if(nums[mid]>target):\\n            return mid\\n        else:\\n            return mid+1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207732,
                "title": "daily-leetcoding-challenge-february-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3181854,
                "title": "don-t-miss-the-edge-case",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target < nums[0]:\\n            return 0\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        print(l, r, mid)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target < nums[0]:\\n            return 0\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        print(l, r, mid)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125048,
                "title": "javascript-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    \\n    let low = 0,\\n        high = nums.length - 1;\\n    \\n    while(low <= high){\\n        let mid = Math.floor(low +(high-low)/2);\\n        \\n        if(nums[mid] == target){\\n            return mid;\\n        }\\n        else if (nums[mid] < target){\\n          low = mid + 1;\\n        }\\n        else{\\n           high = mid - 1;\\n        }\\n    }\\n    return low;\\n    \\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    \\n    let low = 0,\\n        high = nums.length - 1;\\n    \\n    while(low <= high){\\n        let mid = Math.floor(low +(high-low)/2);\\n        \\n        if(nums[mid] == target){\\n            return mid;\\n        }\\n        else if (nums[mid] < target){\\n          low = mid + 1;\\n        }\\n        else{\\n           high = mid - 1;\\n        }\\n    }\\n    return low;\\n    \\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004738,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n     int low=0,high = nums.length-1;\\n        while (low<=high) {\\n            int mid = low+(high-low)/2;\\n            if (nums[mid]==target) {return mid;}\\n            else if (target < nums[mid]) { high = mid-1;}\\n            else {low = mid+1;}\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n     int low=0,high = nums.length-1;\\n        while (low<=high) {\\n            int mid = low+(high-low)/2;\\n            if (nums[mid]==target) {return mid;}\\n            else if (target < nums[mid]) { high = mid-1;}\\n            else {low = mid+1;}\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802810,
                "title": "python-simple-solution-to-solve-search-insert-position-problem",
                "content": "![image.png](https://assets.leetcode.com/users/images/a4e1cf28-6f62-4d2f-a401-efc505c73875_1668155554.2544525.png)\\n\\n# Intuition\\nUse Binary Search\\n\\n# Approach\\n1. find the mid element\\n2. compare with target\\n    1. if equals, return mid\\n    2. if less than target, move l to mid + 1 \\n    3. else move r to mid - 1\\n3. finally return l.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n\\n        while l<=r:\\n            mid = l + (r-l) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid -1\\n        \\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums) - 1\\n\\n        while l<=r:\\n            mid = l + (r-l) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid -1\\n        \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718732,
                "title": "search-insert-position-js",
                "content": "```\\n--- First Solution ---\\nRuntime: 55 ms, faster than 98.82% of JavaScript online submissions for Search Insert Position.\\nMemory Usage: 41.9 MB, less than 87.98% of JavaScript online submissions for Search Insert Position.\\n\\nvar searchInsert = function(nums, target) {\\n    var left = 0, right = nums.length - 1;\\n    while(left <= right) {\\n        var mid = Math.floor((left + right )/ 2)\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        else if(nums[mid] > target) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n\\n--- Second Solution ---\\nconst searchInsert = (nums, target) => {\\n\\n    if(nums.indexOf(target) != -1) {\\n        return nums.indexOf(target);\\n    } else {\\n        if(Math.max(...nums, target) == target) {\\n            return nums.length;\\n        } else {\\n            for(let i =0; i < nums.length; i++) {\\n                if(nums[i] > target) {\\n                    return nums.indexOf(nums[i]);\\n                } \\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n--- First Solution ---\\nRuntime: 55 ms, faster than 98.82% of JavaScript online submissions for Search Insert Position.\\nMemory Usage: 41.9 MB, less than 87.98% of JavaScript online submissions for Search Insert Position.\\n\\nvar searchInsert = function(nums, target) {\\n    var left = 0, right = nums.length - 1;\\n    while(left <= right) {\\n        var mid = Math.floor((left + right )/ 2)\\n        if(nums[mid] == target) {\\n            return mid;\\n        }\\n        else if(nums[mid] > target) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return left;\\n};\\n\\n--- Second Solution ---\\nconst searchInsert = (nums, target) => {\\n\\n    if(nums.indexOf(target) != -1) {\\n        return nums.indexOf(target);\\n    } else {\\n        if(Math.max(...nums, target) == target) {\\n            return nums.length;\\n        } else {\\n            for(let i =0; i < nums.length; i++) {\\n                if(nums[i] > target) {\\n                    return nums.indexOf(nums[i]);\\n                } \\n            }\\n        }\\n        \\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2094482,
                "title": "swift-solution",
                "content": "My solution\\n```\\nfunc searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n    for index in 0..<nums.count {\\n        if nums[index] == target || nums[index] > target {\\n            return index\\n        }\\n    }\\n    return nums.count\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc searchInsert(_ nums: [Int], _ target: Int) -> Int {\\n    for index in 0..<nums.count {\\n        if nums[index] == target || nums[index] > target {\\n            return index\\n        }\\n    }\\n    return nums.count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596421,
                "title": "c-python-o-log-n-binary-search-solution",
                "content": "**C++ :**\\n\\n```\\nint searchInsert(vector<int>& nums, int target) {\\n\\tint low = 0;\\n\\tint high = nums.size();\\n\\tint mid;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tmid = (low + high) / 2;\\n\\t\\tif (target > nums[mid])\\n\\t\\t\\tlow = mid + 1;\\n\\t\\telse\\n\\t\\t\\thigh = mid;\\n\\t}\\n\\treturn low;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef searchInsert(self, nums: List[int], target: int) -> int:\\n\\tlow, high = 0, len(nums)\\n\\twhile low < high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif target > nums[mid]:\\n\\t\\t\\tlow = mid + 1\\n\\t\\telse:\\n\\t\\t\\thigh = mid\\n\\treturn low\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint searchInsert(vector<int>& nums, int target) {\\n\\tint low = 0;\\n\\tint high = nums.size();\\n\\tint mid;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tmid = (low + high) / 2;\\n\\t\\tif (target > nums[mid])\\n\\t\\t\\tlow = mid + 1;\\n\\t\\telse\\n\\t\\t\\thigh = mid;\\n\\t}\\n\\treturn low;\\n}\\n```\n```\\ndef searchInsert(self, nums: List[int], target: int) -> int:\\n\\tlow, high = 0, len(nums)\\n\\twhile low < high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif target > nums[mid]:\\n\\t\\t\\tlow = mid + 1\\n\\t\\telse:\\n\\t\\t\\thigh = mid\\n\\treturn low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1539457,
                "title": "python-o-log-n-search",
                "content": "# Binary Search\\n```\\nBinary Search O(log n) Time Complecity\\n```\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], key: int) -> int:\\n        \\n        i, j = 0, len(nums)-1\\n        \\n        while i <= j:\\n            m = (i + j) // 2\\n            mid = nums[m]\\n            if mid > key : j = m - 1\\n            elif mid < key : i = m + 1\\n            else : return m\\n        else:\\n            return i\\n```\\n![image](https://assets.leetcode.com/users/images/f157f5d6-d961-4097-a81c-100e1cec2f0a_1635136725.159537.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nBinary Search O(log n) Time Complecity\\n```\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], key: int) -> int:\\n        \\n        i, j = 0, len(nums)-1\\n        \\n        while i <= j:\\n            m = (i + j) // 2\\n            mid = nums[m]\\n            if mid > key : j = m - 1\\n            elif mid < key : i = m + 1\\n            else : return m\\n        else:\\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182027,
                "title": "with-javascript-simple-and-short-also-find-simple-binary-search-approach-as-well",
                "content": "```\\nvar searchInsert = function(nums, target) {\\n    nums.push(target);\\n    nums.sort((a,b)=>a-b);\\n    return nums.indexOf(target);\\n};\\n```\\nBinary Search simple readable approch\\n```\\nvar searchInsert = function(nums, target) {\\n    let left=0, right=nums.length-1;\\n    while(left!==right){\\n        let mid = Math.floor((left+right)/2);\\n        if(target>nums[mid]){\\n            left = mid+1;\\n        }else right=mid;\\n    }\\n    return target>nums[nums.length-1]?left+1:left;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    nums.push(target);\\n    nums.sort((a,b)=>a-b);\\n    return nums.indexOf(target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719713,
                "title": "java-one-pass-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;\\n        while(i<nums.length && nums[i] < target){\\n            i++;\\n        }\\n        return i;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;\\n        while(i<nums.length && nums[i] < target){\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 331168,
                "title": "simple-solutions-in-python3-beats-99-linear-scan-and-binary-search",
                "content": "_Linear Scan:_ (Three Lines)\\n```\\nclass Solution:\\n    def searchInsert(self, N: List[int], t: int) -> int:\\n    \\tfor i,n in enumerate(N):\\n    \\t\\tif n >= t: return i\\n    \\treturn len(N)\\n\\n\\n```\\n_Linear Scan:_ (Two Lines)\\n```\\nclass Solution:\\n    def searchInsert(self, N: List[int], t: int) -> int:\\n    \\tfor i,n in enumerate(N+[math.inf]):\\n    \\t\\tif n >= t: return i\\n\\n\\n```\\n_Binary Search:_ (One Line)\\n```\\nclass Solution:\\n    def searchInsert(self, N: List[int], t: int) -> int:\\n        return bisect.bisect_left(N,t)\\n\\t\\t\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, N: List[int], t: int) -> int:\\n    \\tfor i,n in enumerate(N):\\n    \\t\\tif n >= t: return i\\n    \\treturn len(N)\\n\\n\\n```\n```\\nclass Solution:\\n    def searchInsert(self, N: List[int], t: int) -> int:\\n    \\tfor i,n in enumerate(N+[math.inf]):\\n    \\t\\tif n >= t: return i\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293227,
                "title": "c-2-liner",
                "content": "```\\npublic class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        int i = nums.ToList().BinarySearch(target);\\n        return i >= 0 ? i: ~i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        int i = nums.ToList().BinarySearch(target);\\n        return i >= 0 ? i: ~i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15404,
                "title": "short-accepted-c-o-log-n-solution-189ms",
                "content": "    public class Solution {\\n        public int SearchInsert(int[] nums, int target) {\\n            int begin = 0, end = nums.Length - 1;\\n            while(begin <= end)\\n            {\\n                if(begin == end)\\n                    break;\\n                if(nums[(begin+end)/2] > target)\\n                    end = (begin+end)/2;\\n                else if(nums[(begin+end)/2] < target)\\n                    begin = (begin+end)/2 + 1;\\n                else if(nums[(begin+end)/2] == target)\\n                    return (begin+end)/2;\\n            }\\n            if(nums[begin] >= target)\\n                return begin;\\n            if(nums[begin] < target)\\n                return begin + 1;\\n            return -1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int SearchInsert(int[] nums, int target) {\\n            int begin = 0, end = nums.Length - 1;\\n            while(begin <= end)\\n            {\\n                if(begin == end)\\n                    break;\\n                if(nums[(begin+end)/2] > target)\\n                    end = (begin+end)/2;\\n                else if(nums[(begin+end)/2] < target)\\n                    begin = (begin+end)/2 + 1;\\n                else if(nums[(begin+end)/2] == target)\\n                    return (begin+end)/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 15187,
                "title": "accepted-o-logn-java-solution-binary-search",
                "content": "    public class Solution {\\n        public int searchInsert(int[] A, int target) {\\n            \\n            if(A.length == 0)return 0;\\n            \\n            int left = 0, right = A.length - 1;\\n            int mid = 0;\\n            \\n            while(left <= right){\\n                \\n                if(target<A[left])return left;\\n                if(target>A[right])return right+1;\\n                \\n                mid = (left+right)/2;\\n                \\n                if(A[mid]==target)return mid;\\n                else if(target < A[mid]){\\n                    right = mid-1;\\n                }else{\\n                    left = mid +1;\\n                }\\n                \\n            }\\n            return -1;\\n            \\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int searchInsert(int[] A, int target) {\\n            \\n            if(A.length == 0)return 0;\\n            \\n            int left = 0, right = A.length - 1;\\n            int mid = 0;\\n            \\n            while(left <= right){\\n                \\n                if(target<A[left])return left;\\n                if(target>A[right])return right+1;\\n                \\n                mid = (left+right)/2;\\n                \\n                if(A[mid]==target)return mid;\\n                else if(target < A[mid]){\\n                    right = mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3747957,
                "title": "c-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        if(k>a[n-1]) return n;\\n        \\n        int l=0, r=n-1;\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            \\n            if(a[m]>=k){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l; // smallest index with value >= k\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        if(k>a[n-1]) return n;\\n        \\n        int l=0, r=n-1;\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            \\n            if(a[m]>=k){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l; // smallest index with value >= k\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208039,
                "title": "python-o-logn-binary-search",
                "content": "# Intuition\\nThis problem can be reworded to \"Find the smallest `i` such that `nums[i] >= target`\". We can find this index using binary search.\\n\\n# Complexity\\n- Time complexity: O(logn). Binary search cuts the search space in half each time. An array of size `n` can be cut in half at most `log(n)` times.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] > target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return r\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        l, r = 0, len(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] > target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return r\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098214,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] >= target)\\n                break;\\n        return i;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] >= target)\\n                break;\\n        return i;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063531,
                "title": "best-java-solution-binary-search-approach-0-ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sorted Array So Apply Binary Search\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n    \\n        while (start <= end) {\\n\\n        int mid = start + (end - start) / 2;\\n\\n        if (target < nums[mid]) {\\n            end = mid - 1;\\n        }\\n\\n        else if (target > nums[mid]) {\\n            start = mid + 1;\\n        }\\n\\n        else {\\n            return mid;\\n        }\\n    }\\n    return start;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity : O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n    \\n        while (start <= end) {\\n\\n        int mid = start + (end - start) / 2;\\n\\n        if (target < nums[mid]) {\\n            end = mid - 1;\\n        }\\n\\n        else if (target > nums[mid]) {\\n            start = mid + 1;\\n        }\\n\\n        else {\\n            return mid;\\n        }\\n    }\\n    return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938625,
                "title": "c-search-insert-position",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (target == nums[i] || nums[i] > target)\\n            {\\n                return i;\\n            }\\n        }\\n        return nums.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SearchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (target == nums[i] || nums[i] > target)\\n            {\\n                return i;\\n            }\\n        }\\n        return nums.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827170,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint searchInsert(vector<int>& nums, int target) {\\n\\t\\t\\tint i=0, j=nums.size()-1;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(nums[mid]==target){return mid;}\\n\\t\\t\\t\\telse if(nums[mid]>target){j=mid-1;}\\n\\t\\t\\t\\telse{i=mid+1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint searchInsert(vector<int>& nums, int target) {\\n\\t\\t\\tint i=0, j=nums.size()-1;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(nums[mid]==target){return mid;}",
                "codeTag": "Java"
            },
            {
                "id": 2693851,
                "title": "c-search-insert-position-solution-easy-to-understand-0ms-100-percent-efficient",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n# Upvote if you like\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            else if(nums[mid]>target)\\n            j=mid-1;\\n            else\\n            i=mid+1;\\n        }\\n        if(nums[i]>=target)\\n        return i;\\n        else return i+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            else if(nums[mid]>target)\\n            j=mid-1;\\n            else\\n            i=mid+1;\\n        }\\n        if(nums[i]>=target)\\n        return i;\\n        else return i+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489558,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l=0,h=nums.length-1,m=0;\\n        while(l<=h){\\n            m=(h+l)/2;\\n            if(nums[m]==target)\\n                return m;\\n            else if(nums[m]>target)\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l=0,h=nums.length-1,m=0;\\n        while(l<=h){\\n            m=(h+l)/2;\\n            if(nums[m]==target)\\n                return m;\\n            else if(nums[m]>target)\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256984,
                "title": "c-simple-easy-solution-search-insert-position",
                "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        \\n         int n = nums.size();\\n        \\n          int ans = 0;\\n        \\n         for(int i=0; i<n; i++){\\n               if(nums[i]<target){\\n                   ans = i+1;\\n               }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        \\n         int n = nums.size();\\n        \\n          int ans = 0;\\n        \\n         for(int i=0; i<n; i++){\\n               if(nums[i]<target){\\n                   ans = i+1;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1828673,
                "title": "python-easiest-solution-with-explanation-beg-to-adv-binary-search",
                "content": "```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        \\n        l, r = 0, len(nums)-1\\n        \\n        while l <= r:\\n            \\n            mid = l + (r - l) // 2 # this is how we calculate middle of the array\\n            \\n            if nums[mid] == target: # if the middle index value of array is  equal to target then return the index. \\n                return mid\\n            elif target < nums[mid]: # if the target value is lower then middle index\\n                r = mid - 1 # then remove all the right hand side elements.\\n            else: \\n                l = mid + 1 # if target is greater then the middle, then remove the smaller elements which are on left side. \\n\\n        return l # index where target element can be stored\\n```\\n\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        \\n        l, r = 0, len(nums)-1\\n        \\n        while l <= r:\\n            \\n            mid = l + (r - l) // 2 # this is how we calculate middle of the array\\n            \\n            if nums[mid] == target: # if the middle index value of array is  equal to target then return the index. \\n                return mid\\n            elif target < nums[mid]: # if the target value is lower then middle index\\n                r = mid - 1 # then remove all the right hand side elements.\\n            else: \\n                l = mid + 1 # if target is greater then the middle, then remove the smaller elements which are on left side. \\n\\n        return l # index where target element can be stored\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597639,
                "title": "python-binary",
                "content": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        N = len(nums)-1\\n        l,r = 0,N\\n        best_pos = 0\\n        \\n        \\n        while l<=r:\\n            mid = (l+r)//2\\n            \\n            val = nums[mid]\\n            \\n            if val == target:\\n                return mid\\n            \\n            if target < val:\\n                best_pos = mid\\n                r = mid-1\\n            else:\\n                best_pos = mid+1\\n                l = mid+1\\n                \\n        return best_pos\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        N = len(nums)-1\\n        l,r = 0,N\\n        best_pos = 0\\n        \\n        \\n        while l<=r:\\n            mid = (l+r)//2\\n            \\n            val = nums[mid]\\n            \\n            if val == target:\\n                return mid\\n            \\n            if target < val:\\n                best_pos = mid\\n                r = mid-1\\n            else:\\n                best_pos = mid+1\\n                l = mid+1\\n                \\n        return best_pos\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503176,
                "title": "100-java",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(nums[i]==target) return i;\\n        \\n            if(nums[i]>target) return i;       \\n        }\\n        \\n        return nums.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(nums[i]==target) return i;\\n        \\n            if(nums[i]>target) return i;       \\n        }\\n        \\n        return nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424361,
                "title": "0ms-100",
                "content": "```\\nfunc searchInsert(nums []int, target int) int {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] >= target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn len(nums)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchInsert(nums []int, target int) int {\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] >= target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn len(nums)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256126,
                "title": "my-0ms-rust-solution",
                "content": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\\n        let (mut low, mut high) = (0i32, nums.len() as i32 - 1);\\n\\n        while low <= high {\\n            let mid = low + (high - low) / 2;\\n\\n            match nums[mid as usize].cmp(&target) {\\n                Ordering::Equal => { return mid; }\\n                Ordering::Greater => { high = mid - 1; }\\n                Ordering::Less => { low = mid + 1; }\\n            }\\n        }\\n\\n        low\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\\n        let (mut low, mut high) = (0i32, nums.len() as i32 - 1);\\n\\n        while low <= high {\\n            let mid = low + (high - low) / 2;\\n\\n            match nums[mid as usize].cmp(&target) {\\n                Ordering::Equal => { return mid; }\\n                Ordering::Greater => { high = mid - 1; }\\n                Ordering::Less => { low = mid + 1; }\\n            }\\n        }\\n\\n        low\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139210,
                "title": "javascript-simple-solution",
                "content": "```\\nvar searchInsert = function(nums, target) {\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] >= target){\\n            return i;\\n        }\\n    }\\n    return nums.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n    for (let i = 0; i < nums.length; i++){\\n        if (nums[i] >= target){\\n            return i;\\n        }\\n    }\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15425,
                "title": "share-my-python-solution",
                "content": "    class Solution:\\n        # @param A, a list of integers\\n        # @param target, an integer to be inserted\\n        # @return integer\\n        def searchInsert(self, A, target):\\n    \\t\\tfor i in range(len(A)):\\n    \\t\\t\\tif A[i]>=target:\\n    \\t\\t\\t\\treturn i\\n    \\t\\treturn i+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param A, a list of integers\\n        # @param target, an integer to be inserted\\n        # @return integer\\n        def searchInsert(self, A, target):\\n    \\t\\tfor i in range(len(A)):\\n    \\t\\t\\tif A[i]>=target:\\n    \\t\\t\\t\\treturn i\\n    \\t\\treturn i+1",
                "codeTag": "Java"
            },
            {
                "id": 3515936,
                "title": "superb-binary-search-logic-using-python",
                "content": "\\n# O(log n)----------> Binary Search Logic\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]<target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]<target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341430,
                "title": "easy-step-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    nums.push(target)\\n    let sortedArray = nums.sort((a, b) => a - b);\\n    return sortedArray.indexOf(target);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar searchInsert = function(nums, target) {\\n    nums.push(target)\\n    let sortedArray = nums.sort((a, b) => a - b);\\n    return sortedArray.indexOf(target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3208627,
                "title": "python3-one-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums,target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums,target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207808,
                "title": "python3-42-ms-faster-than-98-06-of-python3-o-logn",
                "content": "![image](https://assets.leetcode.com/users/images/07897020-0e86-4deb-8faf-a81c224b127c_1676853207.3547254.png)\\n```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        beg = 0\\n        end = len(nums) - 1\\n        while beg <= end:\\n            mid  = (end + beg)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(nums[mid] > target):\\n                end = mid - 1\\n            else:\\n                beg = mid + 1\\n        return beg\\n```\\n\\nHere is a step by step description of the code:\\n1. Define a function searchInsert that takes a list of integers nums and an integer target as input, and returns an integer.\\n1. Set a variable beg to 0, which represents the beginning of the search range.\\n1. Set a variable end to the length of the list nums minus 1, which represents the end of the search range.\\n1. While beg is less than or equal to end, do the following steps:\\n\\t1. Set a variable mid to the integer division of the sum of beg and end by 2, which represents the middle of the search range.\\n\\t1. If the element at the index mid in the list nums is equal to the target, return mid.\\n\\t1. If the element at the index mid in the list nums is greater than the target, update the value of end to mid - 1, which means the target would be in the first half of the search range.\\n\\t1. If the element at the index mid in the list nums is less than the target, update the value of beg to mid + 1, which means the target would be in the second half of the search range.\\n1. If the target is not found in the list nums, return the value of beg, which represents the index where the target would be if it were inserted in order.\\n1. The time complexity of the searchInsert function is O(log n), which is the time complexity of binary search.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        beg = 0\\n        end = len(nums) - 1\\n        while beg <= end:\\n            mid  = (end + beg)//2\\n            if(nums[mid] == target):\\n                return mid\\n            elif(nums[mid] > target):\\n                end = mid - 1\\n            else:\\n                beg = mid + 1\\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164061,
                "title": "best-c-solutions-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] >= target){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[mid] > target){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Third Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        return nums[low] < target ? low+1 : low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Four Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] >= target){\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[mid] > target){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Third Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        return nums[low] < target ? low+1 : low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Four Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986673,
                "title": "single-line-c-solution-o-log-n",
                "content": "# Intuition\\nGiven Array is sorted. So, we can apply binary search here.\\n\\n# Approach\\nSolution uses lower_bound() function from C++ STL.\\nlower_bound returns an iterator pointing to the first element in the range [first,last) which has a value not less than target and if the value is not present in the vector then it returns the end iterator.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& arr, int t) {\\n        return lower_bound(arr.begin(), arr.end(), t) - arr.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& arr, int t) {\\n        return lower_bound(arr.begin(), arr.end(), t) - arr.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673270,
                "title": "o-log-n-solution-0ms-time",
                "content": "```\\n public int searchInsert(int[] nums, int target) {\\n       int l = 0;\\n        int r = nums.length-1;\\n        \\n        while(l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] > target)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int searchInsert(int[] nums, int target) {\\n       int l = 0;\\n        int r = nums.length-1;\\n        \\n        while(l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] > target)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640934,
                "title": "python-3-4-lines-runtime-50-ms-faster-than-96-28-of-python3-not-binary-search-though",
                "content": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            nums.append(target)\\n            nums.sort()      \\n        return nums.index(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            nums.append(target)\\n            nums.sort()      \\n        return nums.index(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295409,
                "title": "binary-search-beats-100",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0, high=nums.size();\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(nums[mid]==target) return mid;\\n            if(nums[mid]>target){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0, high=nums.size();\\n        \\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(nums[mid]==target) return mid;\\n            if(nums[mid]>target){\\n                high=mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214775,
                "title": "2-approach-using-c-easy-understanding",
                "content": "**One line code using Lower Bound of STL**\\nWhat is lower bound in array?\\nEach element of an array stores one value and is referenced by its index (coordinate position). The index of the first element of an array is called its lower bound. Function returns the index of the next smallest number just smaller than or equal to that number. \\n\\n```\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n```\\n\\n**Now we will use iterative approach (Second Approach)**\\n\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while (low<=high){\\n            int mid = (high+low)/2;\\n            if (nums[mid]==target) return mid;\\n            if (nums[mid]>target) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n};\\n```\\n\\n**Kindly upvote if you like the solution**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int low=0, high=nums.size()-1;\\n        while (low<=high){\\n            int mid = (high+low)/2;\\n            if (nums[mid]==target) return mid;\\n            if (nums[mid]>target) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044765,
                "title": "very-easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\nint searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n\\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if (nums[mid] < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n\\n        while (low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if (nums[mid] < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999608,
                "title": "python-binary-search-30ms-beats-93-69-with-explanation",
                "content": "We use a classic algorithm of [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm).\\nEvery time we are given a middle, and if the middle is greater than the target, you search the items that are smaller than the middle. If the middle is less than the target, you search the items that are larger than the middle. This decreases the time complexity from O(n) to O(log n), which is a very massive decrease in time. \\n\\n```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            middle = left + (right-left)//2\\n            if nums[middle] < target:\\n                left = middle + 1   \\n            elif nums[middle] > target:\\n                right = middle - 1\\n            elif nums[middle] == target:\\n                return middle\\n            \\n        \\n        return left\\n```\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            middle = left + (right-left)//2\\n            if nums[middle] < target:\\n                left = middle + 1   \\n            elif nums[middle] > target:\\n                right = middle - 1\\n            elif nums[middle] == target:\\n                return middle\\n            \\n        \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983652,
                "title": "c-binary-search-o-logn-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!***\\t\\n\\t\\n\\tint searchInsert(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        \\n        int l=0,h=n-1,res=0;\\n        \\n        while(l<=h){\\n            \\n            int mid=l+(h-l)/2;\\n            \\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                h=mid-1;\\n            }\\n            else{\\n                // res=mid+1;  //res=mid is the floor value, add 1 to it\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!***\\t\\n\\t\\n\\tint searchInsert(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        \\n        int l=0,h=n-1,res=0;\\n        \\n        while(l<=h){\\n            \\n            int mid=l+(h-l)/2;\\n            \\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                h=mid-1;\\n            }\\n            else{\\n                // res=mid+1;  //res=mid is the floor value, add 1 to it\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1885711,
                "title": "100-faster-for-loop-solution",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int c = 0;\\n        for (int num : nums) {\\n            if (num < target) {\\n                c++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int c = 0;\\n        for (int num : nums) {\\n            if (num < target) {\\n                c++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691106,
                "title": "one-line-c-solution-explanation-time-complexity",
                "content": "The main idea is to find the first equal or bigger number in the array and return that index.\\nIn cpp, given a pointer to some element in the array, the index is the distance between the pointer and header pointer (which point to the head of the array). We can use distance(nums.begin(),it) to calculate that.\\n\\nNext, how do when get \\'that\\' pointer that we want. In Cpp, there is a default function that gives you the pointer to the first element that is equal or higher to some target number. That function is lower_bound. Actually, lower_bound is implemented using binary search and its time complexity is O(log(n)). \\n\\nBy combining both, we can calculate the distance from the lower_bound to the header pointer as shown in the code below.\\n\\n```\\nint searchInsert(vector<int>& nums, int target) {\\n        return distance(nums.begin(),lower_bound(nums.begin(),nums.end(),target));\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nint searchInsert(vector<int>& nums, int target) {\\n        return distance(nums.begin(),lower_bound(nums.begin(),nums.end(),target));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682914,
                "title": "solution-in-1-line-using-cpp-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n            return (lower_bound(nums.begin(), nums.end(), target)- nums.begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n            return (lower_bound(nums.begin(), nums.end(), target)- nums.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621008,
                "title": "4-line-solution",
                "content": "```\\nint searchInsert(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++){\\n                if(nums[i] >= target){\\n                    return i;  \\n                }\\n            }\\n        return nums.size();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint searchInsert(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++){\\n                if(nums[i] >= target){\\n                    return i;  \\n                }\\n            }\\n        return nums.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596853,
                "title": "java-3-line-of-code-explained",
                "content": "Learn this technique too, for competive programming\\n\\nx=Arrays.binarySearch(num,target)\\n\\nif target found then it return position of x\\notherwise return (-insertion_point -1) \\nx=(-insertion_point -1)\\nx=-x-1\\nx=-(-insertion_point -1)-1\\nx=insertion_point\\nso, x will be the position where we can insert the target!\\n\\n\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n     \\n        int x=Arrays.binarySearch(nums,target);\\n        if(x<0)\\n            x=-x-1;\\n        return x;\\n    }\\n}\\n```\\n\\nIf you get it then please upvote my solution :))",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n     \\n        int x=Arrays.binarySearch(nums,target);\\n        if(x<0)\\n            x=-x-1;\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544008,
                "title": "simple-and-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;\\n        while(i<nums.length&& nums[i]<=target){\\n            if(nums[i]==target)\\n                return i;\\n            i++;   \\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;\\n        while(i<nums.length&& nums[i]<=target){\\n            if(nums[i]==target)\\n                return i;\\n            i++;   \\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078885,
                "title": "a-simple-c-solution-0ms-running-time-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1, mid;\\n        while(true){\\n            mid = low + (high-low)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(low == high){\\n                return (target < nums[mid])? mid : mid+1;\\n            }\\n            (target < nums[mid])? (high = mid):(low = mid+1);\\n        }   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int searchInsert(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1, mid;\\n        while(true){\\n            mid = low + (high-low)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(low == high){\\n                return (target < nums[mid])? mid : mid+1;\\n            }\\n            (target < nums[mid])? (high = mid):(low = mid+1);\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966367,
                "title": "kotlin-solution",
                "content": "```\\nfun searchInsert(nums: IntArray, target: Int): Int {\\n        \\n        var i = 0\\n        while (i < nums.size) {\\n            if (nums[i] == target) return i\\n            if (i == 0 && target < nums[i]) return i\\n            if (i > 0 && target > nums[i-1] && target < nums[i]) return i\\n            i++\\n        }\\n        return i\\n    }\\n\\t```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun searchInsert(nums: IntArray, target: Int): Int {\\n        \\n        var i = 0\\n        while (i < nums.size) {\\n            if (nums[i] == target) return i\\n            if (i == 0 && target < nums[i]) return i\\n            if (i > 0 && target > nums[i-1] && target < nums[i]) return i\\n            i++\\n        }\\n        return i\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 679999,
                "title": "java-2-line-library-method",
                "content": "Not something that is encouraged in interviews, but still handy to know - \\n\\n```\\npublic int searchInsert(int[] nums, int target) {\\n        int index = Arrays.binarySearch(nums, target);\\n        return index >= 0 ? index : -index-1;\\n}\\n```\\n\\nThe [Arrays.binarySearch(array, target)](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#binarySearch(byte[],%20byte)) method returns the index of the target element in the array. If the element isn\\'t found, it\\'ll return `(-(insertion point) - 1)` , where `insertion point` is nothing but the place in the sorted array where the target element ***would have appeared*** had it been a part of the array.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\npublic int searchInsert(int[] nums, int target) {\\n        int index = Arrays.binarySearch(nums, target);\\n        return index >= 0 ? index : -index-1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601952,
                "title": "javascript-binary-search-o-logn-92-100",
                "content": "```\\nvar searchInsert = function(nums, target) {\\n  let start = 0;\\n  let end = nums.length - 1;\\n  \\n  while (start <= end) {\\n    const middle = Math.floor((end + start) / 2);\\n    \\n    if (nums[middle] === target) {\\n      return middle;\\n    }\\n    \\n    if (nums[middle] < target) {\\n      start = middle + 1\\n      continue;\\n    }\\n      \\n    if (nums[middle] > target) {\\n      end = middle - 1;\\n      continue;\\n    }\\n    \\n    return middle;\\n  }\\n  \\n  return start;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchInsert = function(nums, target) {\\n  let start = 0;\\n  let end = nums.length - 1;\\n  \\n  while (start <= end) {\\n    const middle = Math.floor((end + start) / 2);\\n    \\n    if (nums[middle] === target) {\\n      return middle;\\n    }\\n    \\n    if (nums[middle] < target) {\\n      start = middle + 1\\n      continue;\\n    }\\n      \\n    if (nums[middle] > target) {\\n      end = middle - 1;\\n      continue;\\n    }\\n    \\n    return middle;\\n  }\\n  \\n  return start;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122181,
                "title": "pythonic-1-line-and-0-line",
                "content": "1 line O(N), count length of smaller number list\\n```\\n    def searchInsert(self, nums, target):\\n        return len(x for x in nums if x < target)\\n```\\n\\n1 line O(N) shorter, count smaller number from generator\\n```\\n    def searchInsert(self, nums, target):\\n        return sum(x < target for x in nums)\\n```\\n\\n1-line O(logN), binary search build-in\\n```\\n    def searchInsert(self, nums, target):\\n        return bisect.bisect_left(nums, target)\\n```\\n\\n0-line O(logN), define ```searchInsert``` directly to existing function\\n```\\n    searchInsert = bisect.bisect_left\\n",
                "solutionTags": [],
                "code": "```\\n    def searchInsert(self, nums, target):\\n        return len(x for x in nums if x < target)\\n```\n```\\n    def searchInsert(self, nums, target):\\n        return sum(x < target for x in nums)\\n```\n```\\n    def searchInsert(self, nums, target):\\n        return bisect.bisect_left(nums, target)\\n```\n```searchInsert```",
                "codeTag": "Python3"
            },
            {
                "id": 15065,
                "title": "3-line-clean-code-use-c",
                "content": "Here is my code of C, yeah only 3 line.\\n\\n```\\nint searchInsert(int* nums, int numsSize, int target) {\\n    int i=0;\\n    \\n    for (;i<numsSize&&nums[i]<target;i++) ;\\n    return i;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint searchInsert(int* nums, int numsSize, int target) {\\n    int i=0;\\n    \\n    for (;i<numsSize&&nums[i]<target;i++) ;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15070,
                "title": "java-c-clean-code-binary-cut",
                "content": "* this is to find the `first item >= target`, the insert position will be its index.\\n* the binary search will stop with `l == r` while `l` is the potential result if there is one.\\n* if an item >= target cannot be found, `l` will end up as `size-1`,\\n\\n**Java**\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] >= target) r = m;\\n            else l = m + 1;\\n        }\\n        return nums[l] >= target ? l : l + 1;        \\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] >= target) r = m;\\n            else l = m + 1;\\n        }\\n        return nums[l] >= target ? l : l + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] >= target) r = m;\\n            else l = m + 1;\\n        }\\n        return nums[l] >= target ? l : l + 1;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (nums[m] >= target) r = m;\\n            else l = m + 1;\\n        }\\n        return nums[l] >= target ? l : l + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15283,
                "title": "java-simple-binary-search-with-explanation",
                "content": "The tricky part is \"if(start>end) return -(start+1);\" if this if statement is true, we are sure that target is NOT FOUND, so we just need to return the insertion position.\\n\\nNow let's think about cases which makes start > end.\\nThe previous caller must be the case start==end, so mid==start==end then \\n\\n - case 1: binarySearchInsert(nums, mid+1, end, target), meaning\\n   nums[mid]<target, the insertion position should be mid+1 (insert\\n   target after mid) \\n - case 2: binarySearchInsert(nums, start, mid-1,    target), meaing\\n   nums[mid]>target, the insertion position should be    mid (insert\\n   target into mid and shift old mid value afterwards)\\n\\nSo it is clear, in the next call, when start>end, the start should be the insertion position. \\n\\n - But WAIT, if target is found, the found idx>=0, if target if NOT\\n   FOUND, the insertion idx also >=0, then how to differentiate it is\\n   found or not? Here we use a trick to return negative value when not\\n   found.\\n - But WAIT again, how about the found value is ZERO? -0==0, so we use\\n   another trick to increment insertion idx before negation.\\n\\nThis is just what the Java's Collections binarySearch API returns. It all makes sense.\\n\\n    public class Solution {\\n        \\n        public int binarySearchInsert(int[] nums, int start, int end, int target) {\\n            if(start>end)\\n                return -(start+1); \\n            int mid = start+(end-start)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n                return binarySearchInsert(nums, mid+1, end, target);\\n            else\\n                return binarySearchInsert(nums, start, mid-1, target);\\n        }\\n        \\n        public int searchInsert(int[] nums, int target) {\\n            int idx = binarySearchInsert(nums, 0, nums.length-1, target);\\n            return idx>=0 ? idx : -idx-1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int binarySearchInsert(int[] nums, int start, int end, int target) {\\n            if(start>end)\\n                return -(start+1); \\n            int mid = start+(end-start)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target)\\n                return binarySearchInsert(nums, mid+1, end, target);\\n            else\\n                return binarySearchInsert(nums, start, mid-1, target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 15370,
                "title": "c-binary-search",
                "content": "Use binary search. Note that `r` is initialized to be `nums.size()` to handle the case that `target` needs to be inserted after the end of `nums`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= target) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nA one-liner is to use `lower_bound`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (nums[m] >= target) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701878,
                "title": "brute-force-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is a solution to the Search Insert Position problem, which requires finding the index of the target element in a sorted array, or the index where it should be inserted if it is not present in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI just used the most basic brute force approach which came to my mind.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                return i;\\n            }else{\\n                if(target<nums[0]){\\n                    return 0;\\n                }else if(target>nums[nums.length-1]){\\n                    return nums.length;\\n                }else if(i>0 && nums[i-1]<target && target<nums[i]){\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/0ac4b51b-14a2-4e2f-9b40-003e5b013e1d_1688153685.333757.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                return i;\\n            }else{\\n                if(target<nums[0]){\\n                    return 0;\\n                }else if(target>nums[nums.length-1]){\\n                    return nums.length;\\n                }else if(i>0 && nums[i-1]<target && target<nums[i]){\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695229,
                "title": "2-line-simplest-possible-solution-ever",
                "content": "# Intuition\\nWe will use Collections function for binary search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif element is not present int the array binarySearch returns NEGATIVE VALUE of index just greater element in array than target which we will make positive.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int idx= Arrays.binarySearch(nums,target);\\n        if(idx<0) return Math.abs(idx)-1;\\n\\n        return idx;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/c97d3b04-9ff7-484a-a7db-aafdf0d32d53_1688017458.004746.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int idx= Arrays.binarySearch(nums,target);\\n        if(idx<0) return Math.abs(idx)-1;\\n\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1684641,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807661,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1575450,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807659,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1565311,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1567817,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1906020,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807684,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1569256,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1575862,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1684641,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807661,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1575450,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807659,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1565311,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1567817,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1906020,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1807684,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1569256,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1575862,
                "content": [
                    {
                        "username": "shoshinsha_coder",
                        "content": "I finally got a leetcode easy all by myself!! Even though this is an easy one it was so satisfying to pass all tests and edge cases. I just used a for loop with a bunch of if / if else statements. (Javascript)"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "[@Crispy_coffee](/Crispy_coffee) \\nyou are right the technic you just said is called binary search algorithm\\nusing single while loop and it has a time complexity of O(log N)\\n"
                    },
                    {
                        "username": "cuzzo5",
                        "content": "I just used Array.BinarySearch(nums, target) lol"
                    },
                    {
                        "username": "GitG0",
                        "content": "[@GrayBurford](/GrayBurford) unfortunately O(n) solutions such as this get accepted\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] >= target)\\n                return i;\\n        return nums.length;\\n    }\\n}\\n``` \\nTest cases should be more extravagant to better force an O(log n) runtime"
                    },
                    {
                        "username": "6fitzy",
                        "content": "Congrats man, keep at it"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@shoshinsha_coder](/shoshinsha_coder)\ninstead of bunch of if else, use this \nif found return mid\nelse if target > nums[mid] then start = mid+1;\nelse end = mid-1;\n\nand outer loop just return start\n\nit will work  exact same and work very efficiently, try to use it"
                    },
                    {
                        "username": "GD18",
                        "content": "great job man, keep it up"
                    },
                    {
                        "username": "harshitisback",
                        "content": "[@GrayBurford](/GrayBurford)  you are right but this is simple concept of binary search so it is easy \\n"
                    },
                    {
                        "username": "harshitisback",
                        "content": "and i use Arrays.binarySearch() "
                    },
                    {
                        "username": "mgrand94",
                        "content": "congrats..still searching for mine :)"
                    },
                    {
                        "username": "mputnick",
                        "content": "Hey guys! You may look at \"Related topics\" tab on each problem to better understand the way you can solve the problem. For example, this problem marked with \"Binary search\", and it has typical binary search solution."
                    },
                    {
                        "username": "GrayBurford",
                        "content": "I believe if you used a for loop, the time complexity would be O(n) right? The instructions state to explicitly find a solution that is O(log n) time complexity. These \"Easy\" problems ARE hard, I totally agree, especially compared to Codewars 8kyu and 7kyu easy problems."
                    },
                    {
                        "username": "mekaael",
                        "content": " Same feelings here, this is my first leetcode problem i solved completely on my own and i feel satisfied, even if it`s an easy problem."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Seems like silence before the Storm."
                    },
                    {
                        "username": "theRadFad",
                        "content": "This joke has been lame for one week already"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "Now we will get 3 HARD in a row :)"
                    },
                    {
                        "username": "harshitisback",
                        "content": "yesterday there was a middle storm now easy storm relax "
                    },
                    {
                        "username": "nzjony",
                        "content": "I get the following issue with the testcase.\\n\\n[1]\\n1\\n\\nI output 1, but the expected is 0, why is that? Either 0 or 1 should be valid? Is there something I miss?"
                    },
                    {
                        "username": "Devvrat12",
                        "content": "The target value is 1 and 1 is found in the nums array , so you have to return the index of 1, i.e. 0."
                    },
                    {
                        "username": "bnl29",
                        "content": "wouldn\\'t inserting 1 in this array also break the \"distinct integer\" condition?"
                    },
                    {
                        "username": "dhru_10",
                        "content": "Because Java is 0 Base indexing ,so first element\\'s index is 0. that\\'s why expected output is 0"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[@AdityaBhate](/AdityaBhate) OMG 1 Liner"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "Since the index of 1 in the list is 0 (nums[0] = 1), you return 0. A 1 would be if nums was [0], and you would have to insert 1 at index 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "The same as `binary search` but here `return leftPointer` at the end. \n\n**Time complexity:** *O(logn)*\n**Space complexity:** *O1*"
                    },
                    {
                        "username": "fedor993",
                        "content": "Or return rightPointer"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thank you very much! the hint return leftPointer helped me! \\n\\nI was really stuck, was thinking of making an inner function with a binary search and calling it with changing (+1 and -1) the target untill the result won\\'t be found, lol "
                    },
                    {
                        "username": "OrabiMix",
                        "content": "yup that tip was really helpful !!"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "True! The question did drop hints with sorted array and O( log n) time complexity "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-insert-position/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Back Feb 19 2023, one whole week of easy Daily Qs lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "john6",
                        "content": "First off, sorry for submitting under a problem, I couldn't figure out how to post as a general question. \\n\\nJust wondering what \"Total Submissions\" on the site actually means. Does every submission, even if it fails or doesn't compile count towards the total submissions number?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@AdityaBhate](/AdityaBhate) this dude is everywhere"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "yes they all are counted\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the binary search solution with an explanation of the O(log n) runtime:\nhttps://youtu.be/v4J_AWp-6EQ"
                    },
                    {
                        "username": "scor32k",
                        "content": "leetcode leetcode leetcode leetcode leetcode leetcode leetforces leetcode :)\n\nthose who knwo they know"
                    },
                    {
                        "username": "Tushar458",
                        "content": "what you gonna call the hard one"
                    },
                    {
                        "username": "shell769324",
                        "content": "It doesn\\'t make sense"
                    },
                    {
                        "username": "tonycodes2020",
                        "content": "I dont even know how to begin. any help on how i can break this problem down into tangible steps wod be greatly appreciated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Two hints : sorted array and must write an algo in log(n) time. \\n\\nThose two should be enough of a hint that its binary search"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I was in the same situation. First I started by iterating in the list one by one. But there was a catch. Need to use O(log n) time complexity. I'll say just understand the concept behind the algo and then start to code which revolves around the algorithm. For a beginner like me, It was not much difficult to do after I completely understood the approach. "
                    },
                    {
                        "username": "CT-7567",
                        "content": "what I did \\nI used for loop, and used \"break\" when I found the index.\\nkeep in mind that this is sorted array so current element can not be bigger than the target if it is, that mean you found the index.\\nAlso I used one boolean in any case of target is out of bound ( if bool haven\\'t changed through for loop this mean target should be out of array) \\nI\\'m not saying this is the right way, this is just how I did.  "
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "Identify the pattern here, if a problem statement says that array is sorted and is requiring searching, then it will be done using binary search. The main aim is to get the hidden pattern of questions."
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "This is a classic binary search problem. If I were you, I'd start with studying binary search in a sorted array. Then, you can figure out how to solve the problem yourself. Hope this helps."
                    }
                ]
            },
            {
                "id": 1808383,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1573956,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1807821,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1571824,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1808619,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1808507,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1808433,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1807891,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1807670,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1576133,
                "content": [
                    {
                        "username": "chetan_coding",
                        "content": "As a newbie at leetcode problem solving, I solved my first problem today in easy and fast way without Any difficulty and error."
                    },
                    {
                        "username": "nitishdeolia",
                        "content": "**Easy One-liner Python Solution**\\n\\nreturn bisect.bisect_left(nums,target)"
                    },
                    {
                        "username": "Dhruvkaravadiya",
                        "content": "[@trawler69](/trawler69) yes its allowed , but it will be of no use. U dont learn the logic of the code , u just copy paste the syntax. This question has implementation of Binary Search , just a bit twisted. "
                    },
                    {
                        "username": "kanishk--",
                        "content": "[@Sin4ik02](/Sin4ik02) these one liner are not for learning people just do this for self satisfaction and it has its own benefits which can help in long run, but sometimes people overdo this and just kills the readability of code."
                    },
                    {
                        "username": "Sin4ik02",
                        "content": "[@trawler69](/trawler69) It is probably if you just want to pass the tests, but you learn nothing this way.\\nSo better just struggle, do it yourself and at hte end you will learn something new!"
                    },
                    {
                        "username": "trawler69",
                        "content": "is using packages like that allowed?"
                    },
                    {
                        "username": "thisannie",
                        "content": "Probably Leetcode is hacked."
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "`return bisect.bisect_left(nums, target)`"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "this video made it really easy, 5 mins only https://youtu.be/EpZ6Z0j2vLw"
                    },
                    {
                        "username": "wild_knight",
                        "content": "If anyone having doubts about will leetcoding regularly eventually be worth it, check this out !\nSolution of June 12th 2022\n`\nfunction smartBinarySearch(nums,target,start,end){\n  // console.log(start,end);\n let mid = Number.parseInt((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n  if(mid===0)\n    {\n      if(target<nums[mid])\n        {\n          return 0;\n        }\n      if(end===0)\n        {\n         return 1; \n        }\n    }\n  if(mid===nums.length-1)\n    {\n      return nums.length;\n    }\n  if((target>nums[mid-1]||(mid-1)<0) && target<nums[mid+1])\n    {\n      if(target>nums[mid])\n      {\n      return mid+1;\n      }\n      else\n        return mid;\n    }\n    if(target>nums[mid])\n    {\n      return smartBinarySearch(nums,target,mid+1,end);\n    }\n  if(target<nums[mid])\n    {\n      return smartBinarySearch(nums,target,start,mid-1);\n    }\n}\nvar searchInsert = function(nums, target) {\n    const result = smartBinarySearch(nums,target,0,nums.length-1);\n  return result;\n};\n`\nSolution on June 22nd 2022\n`\nfunction search(nums,target,start,end)\n{\n  let mid = Math.floor((start+end)/2);\n  if(nums[mid]===target)\n    {\n      return mid;\n    }\n   if(mid===0 && nums[mid]>target){\n       return 0;\n      }\n   if((target > nums[mid] && target < nums[mid+1]) || mid>=nums.length-1 )\n     {\n       return mid+1;\n     }\n   if(target > nums[mid])\n     {\n       return search(nums,target,mid+1,end);\n     }\n    return search(nums,target,start,mid-1);\n}\nvar searchInsert = function(nums, target) {\n  const result = search(nums,target,0,nums.length-1);  \n  return result;\n};\n`\nSolution on 20th Feb 2023\n`\nvar searchInsert = function(nums, target) {\n  let s =0;\n  let e = nums.length-1;\n  while(e>=s){\n      const mid=Math.floor((s+e)/2);\n      if(nums[mid]==target) return mid;\n      if(nums[mid]>target) e=mid-1;\n      else s = mid+1;\n  }\n  return e+1;\n};\n`"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "this question is good but it's a waste, the power of lower complexity is shown when the input length is very high for a simple loop with o(n),but instead of make it higher and show the difference between the time taken. you limit the inputs maximum length by 1e4,wich is a piece of cake for an o(n) search algorithm. the test case should be of length 1e10 which will take 1e10 iteration with a o(n) algorithm but 34 iteration only for o(logn)! FYI: the average cpu can make a 1e9 instructions in range between 3-4 seconds ,imagine how much it will take for a larger inputs"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": " most of the problems are easy after valentine week !! \\n\\n"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like its an never Ending loop of easy problems !! ; )**"
                    },
                    {
                        "username": "nirmitlakhani314",
                        "content": "![image](https://assets.leetcode.com/users/images/ed61097f-eb76-49ee-83be-a9e2d13a01f1_1640772685.8617418.png)\\n"
                    },
                    {
                        "username": "animo55",
                        "content": "Hey man, don\\'t post solution in discussion tab\\n"
                    }
                ]
            },
            {
                "id": 1575737,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1572677,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1572614,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1572489,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1572334,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1571086,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 1571087,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 2075737,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 2050162,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 2048548,
                "content": [
                    {
                        "username": "aakodadi",
                        "content": "I know it\\'s unlikly to be asked this easy question in a big tech company iterview but I wanna know if it is a good idea if I use Arrays::binarySearch. would it be acceptable or would they ask me to implement it by myself?"
                    },
                    {
                        "username": "itundefined",
                        "content": "ahh well you have to implement it, tbh it is not difficult to implement it, I also implemented in my solution to achieve the o(log n) where base is 10;"
                    },
                    {
                        "username": "FreeThrill",
                        "content": "I believe that would have an O(n) time complexity, instead of an o(log n)"
                    },
                    {
                        "username": "flpanbin",
                        "content": "![image](https://assets.leetcode.com/users/flpanbin/image_1557798618.png)\\n"
                    },
                    {
                        "username": "zhengshukai",
                        "content": "return len([val for val in nums if val < target])"
                    },
                    {
                        "username": "voidpresence",
                        "content": "you can skip array searching all together (for where it should fit) if you check the cases for when the first element is greater than target or the last element is less than the target.\\n\\nchecking if it\\'s there at all is trivial in Python"
                    },
                    {
                        "username": "Pawan_Tilara",
                        "content": "int x=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n return x;"
                    },
                    {
                        "username": "LambertT",
                        "content": " int result =Arrays.binarySearch(nums,target);\\nif(result < 0){\\n    result = -1*(result+1); \\n}\\nreturn result;"
                    },
                    {
                        "username": "Mr-Bin",
                        "content": "Re: [My 8 line Java solution](/topic/7874/my-8-line-java-solution)\\n\\nHere is the code:\\npublic int searchInsert(int[] nums, int target) {\\n\\t\\tint pos = Arrays.binarySearch(nums, target);\\n\\t\\treturn pos >= 0 ? pos : -pos - 1;\\n\\t}\\n\\nThe trick is to use Java's standard Arrays function, check this out:\\nbinarySearch\\npublic static int binarySearch(int[] a,int key)\\nSearches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort(int[]) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.\\n\\nParameters:\\na - the array to be searched\\nkey - the value to be searched for\\n\\nReturns:\\nindex of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\\n\\nThe official document is avaliable [here](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#binarySearch-int:A-int-)."
                    },
                    {
                        "username": "harshitisback",
                        "content": "make sense nicely explained. "
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Guess what, I didnt have to use binary search *evil laugh*"
                    },
                    {
                        "username": "dangardhruvan117",
                        "content": "This code is in c, \\ni dont know why my center first time not incremented, this same demo code working proper in online gdb c compiler, but not working on this one.\\nint searchInsert(int* nums, int numsSize, int target){\\n    int start = 0,end = numsSize-1,center = 0;\\n    center = (end - start)/2;\\n    while(nums[center] != target)\\n    {\\nprintf(\"current nums[%d] is %d\\\\n\",center,nums[center]);\\n        if(target < nums[center])\\n        {\\n            end = center-1;\\n            center = (end - start)/2;\\nprintf(\"end %d and start %d and (end - start)/2 = center is %d new nums[%d] %d\\\\n\",end, start,center,center,nums[center]);\\n        }\\n        else if(target > nums[center])\\n        {\\n            start = center;\\n            center = (end + start)/2;\\nprintf(\"end %d and start %d and (end + start)/2 = center is %d new nums[center] %d\\\\n\",end, start,center,nums[center]);\\n        }\\n        printf(\"center value is %d,nums[center] %d target %d\\\\n\",center,nums[center],target);\\n    }\\n    return center;\\n}\\n\\n\\noutput:\\ncurrent nums[1] is 3\\nend 3 and start 1 and (end + start)/2 = center is 2 new nums[center] 5\\ncenter value is 2,nums[center] 5 target 5\\ncurrent nums[1] is 3\\nend 0 and start 0 and (end - start)/2 = center is 0 new nums[0] 1\\ncenter value is 0,nums[center] 1 target 2\\ncurrent nums[0] is 1\\nend 0 and start 0 and (end + start)/2 = center is 0 new nums[center] 1...\\n"
                    },
                    {
                        "username": "Ezaidi",
                        "content": "A basic observation,applying simple binary search with the template \"while(l<=h)\" does the job. If the target is not found,\"l\" is > \"h\" and loop exits,giving us the value where the element needs to be inserted,so just return l."
                    }
                ]
            },
            {
                "id": 2039668,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 2025564,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 2020604,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 2018254,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 2010980,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1995936,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1995033,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1994914,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1989401,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1987347,
                "content": [
                    {
                        "username": "__rajneeesh__13",
                        "content": "use binary search for solve this program in optimize way."
                    },
                    {
                        "username": "valenpecunia",
                        "content": "no stress, purely enjoyed the question while solving"
                    },
                    {
                        "username": "ansh_thecoder",
                        "content": "what is this error?\\n\\n\\n=================================================================\\n==24==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x000000355096 bp 0x7ffd7d4bad10 sp 0x7ffd7d4bad08\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f7d1af3d082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==24==ABORTING"
                    },
                    {
                        "username": "AnishDeshpande",
                        "content": "\\n\\nI know this is kind of a foolish solution but nevertheless its working for 46/65 cases, and its inexplicably not working for a few, what\\'s wrong \\n`var searchInsert = function(nums, target) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === target){\\n            return i\\n        } else {\\n            nums.push(target)\\n            nums = nums.sort()\\n            return nums.indexOf(target)\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "geybriyel",
                        "content": "I think the code inside your else clause should be outside the for loop. \\n\\nIf I understand it correctly, you want to first iterate and search all elements and see if the target exists. if it does, return the index i. if not, then that\\'s when you insert the target, sort and return its index.\\n\\nclever thinking btw  "
                    },
                    {
                        "username": "PiotrZak",
                        "content": "Binary Search algorithm work well for myself. \\n\\nHowever list comprehensions also:\\n\\n` return len([x for x in nums if x < target])`"
                    },
                    {
                        "username": "user8996Al",
                        "content": "why in the case: nums = [3,6,7,8,10] and target = 5, it waits index 1? if 3 is index 0, then 4 it\\'s index 1 and 5 has to be index 2"
                    },
                    {
                        "username": "vai_bhav_02",
                        "content": "If not, return the index where it would be if it were inserted in order. I don\\'t think so this line make any sense."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem is a great way to understand and apply the binary search algorithm.  The problem requires the handling of the scenario where the target is not found in the array, and hence needs to be \"inserted\". This is an interesting twist on the classic binary search problem. The problem scenario is quite common in real-world applications, such as searching in databases or inserting in a sorted list. Also, the problem specifically mentions a requirement on time complexity `(O(log n))`, makes for good practice in considering and optimizing time complexity of a solution."
                    },
                    {
                        "username": "eduard92",
                        "content": "After 10 medium problems of Sliding Window.. I had to take a break. Please give me a job Binary Search"
                    },
                    {
                        "username": "Yenduva_Laxmunaidu",
                        "content": "dont change the original binary search condition in while then think about the logic on paper you will get answer"
                    }
                ]
            },
            {
                "id": 1965362,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1951960,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1922673,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1910018,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1909692,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1906409,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1904975,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1903997,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1897521,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1890960,
                "content": [
                    {
                        "username": "rasiki123567",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        def searchBinary(arr , l ,h, target):\\n            if l>h:\\n                arr.append(target)\\n                arr.sort()\\n                return arr.index(target)\\n            mid=(l+h)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                return searchBinary(nums , l,mid-1, target)\\n            else: \\n                return searchBinary(nums , mid +1,h, target )\\n        return searchBinary(nums, 0,len(nums)-1,target)\\n"
                    },
                    {
                        "username": "columbianboi29",
                        "content": "I DID IT!!!!! I solved my first leet code problem \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D \\n"
                    },
                    {
                        "username": "Sid_Dart",
                        "content": "return lower_bound(nums.begin(),nums.end(),target)-nums.begin();"
                    },
                    {
                        "username": "White_collar",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        if(nums.length==1 && target<=nums[0])\\n        return 0;\\n        int i=0,j=nums.length-1;\\n        while(i<j && nums[j]>=target && nums[i]<=target)\\n        {\\n            int mid=(i+j)/2;\\n            if(nums[mid]>target && nums[mid+1]<target)\\n            return mid+1;\\n            if(nums[mid]==target)\\n            return mid;\\n            if(nums[mid]<target)\\n            i=mid+1;\\n            else\\n            j=mid;\\n        }\\n        if(target>nums[j])\\n        return j+1;\\n        if(i<nums.length)\\n        return i;\\n        else\\n        return i+1;\\n\\n    }\\n}"
                    },
                    {
                        "username": "chojiin",
                        "content": "why does the test case [1,3,5], target 4 return 3?\\nclass Solution(object):\\n    def searchInsert(self, nums, target):\\n        if len(nums) == 1 and target < nums[0]:\\n            return int(0)\\n        elif len(nums) == 1 and target > nums[0]:\\n            return 1\\n        elif target not in nums:\\n            for i in range(len(nums)):\\n                for j in range(i+1,len(nums)):\\n                    if target > nums[i] and target < nums[j]:\\n                        return nums.index(nums[j])\\n                        break\\n                    if target < nums[i]:\\n                        return nums.index(nums[i])\\n                        break\\n                    else:\\n                        return len(nums)\\n                        break\\n                break\\n        else:\\n            return nums.index(target)"
                    },
                    {
                        "username": "b_saiharsh",
                        "content": "I have a doubt in the following: In the while condition why should it be start<=end and not start< end ?\\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }else if(target>mid){\\n                start=mid+1;\\n            }else if(target<mid){\\n                end=mid-1;\\n            }\\n             \\n        } \\n        return end;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "salahkobia13",
                        "content": "use binary search to solve it \\ntime complexity is O(log n) "
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "        for(int position=0; position< nums.length;position++){\n\n            if(nums[position]==target){\n                return position;\n            }\n        }\n\n        for(int position2=nums.length-1;position2>=0;position2--){\n            if(nums[position2]< target ){\n                return position2+1;\n            }\n\n        }\n\n        return 0;"
                    },
                    {
                        "username": "ronnyvega",
                        "content": "Some of the top solutions are O(n) linear scans. Is leetcode broken?"
                    },
                    {
                        "username": "khoinpb96",
                        "content": "Using `binary search` technique but instead return some default value like `-1`, you should return the `left` pointer itself because if `nums` does not include `target` which mean we have already got to the point where `left` is more than `right` which is the `\"where it would be\"` as the question ask for."
                    }
                ]
            },
            {
                "id": 1876838,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1873907,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1858202,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1853176,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1852666,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1849615,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1841624,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1831306,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1827407,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1825068,
                "content": [
                    {
                        "username": "ayushxsharma",
                        "content": "I guess we have to use binary search algorithm to get the time complexity as O(logn) ."
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "any one help of this code \\n\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int st = 0 ;  // left ...\\n        int ed = nums.length ;  // right...\\n        while(st < ed){\\n            int mid = (st + ed) / 2 ;  // calculated the mid point \\n            if(nums[mid] == target) \\n                return mid ;\\n            \\n            if(nums[mid] < target)\\n                st = mid + 1 ;\\n            else \\n                ed = mid -1 ;\\n        }\\n        return st ;\\n    }\\n}"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def searchInsert(self, digits, target):\\n        for i, n in enumerate(digits):\\n            if n >= target:\\n                return i\\n        return len(digits)\\n\\nPlease immediately submit this code, don\\'t run, it works\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kmaxwell",
                        "content": "Binary search should work\\n"
                    },
                    {
                        "username": "prabhash194",
                        "content": "how to solve the case when target element is 2 in [1,3,5,6] and like 4 in [1,3,5]\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": "    for(int position=0; position< nums.length;position++){\\n\\n            if(nums[position]==target){\\n                return position;\\n            }\\n        }\\n\\n        for(int position2=nums.length-1;position2>=0;position2--){\\n            if(nums[position2]< target ){\\n                return position2+1;\\n            }\\n\\n        }\\n\\n        return 0;"
                    },
                    {
                        "username": "aditya12109970",
                        "content": "It will be acceptable if I did this question in O(logn)?\\nBecause I did it in O(logn), somebody plzzz let me know.\\nThanku"
                    },
                    {
                        "username": "mjeevan320",
                        "content": "so satisfying :)"
                    },
                    {
                        "username": "Housni01",
                        "content": "I might be new to bigO notation, but didn\\'t they ask to solve the problem with complexity O(long n)? I tried a solution with a for loop which to my knowledge is O(n) and it passed successfully! anyone can clear why for me please?"
                    },
                    {
                        "username": "192731",
                        "content": "list too short"
                    },
                    {
                        "username": "traderr",
                        "content": "When i press \"RUN\" then result - \"acceptet\"\\nbut when i press Submit then result - Runtime Error\\nwhy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You will be shown the test case where your code failed and you can add it to the test cases that are called when you press RUN."
                    },
                    {
                        "username": "21mea09",
                        "content": "explain about this problem"
                    }
                ]
            },
            {
                "id": 1822836,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808735,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808721,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808477,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808468,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808424,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808413,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808380,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808364,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808319,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Most of the test cases must be relatively short. Many linear searches ran quicker than my binary search (beats only 40% of submissions)."
                    },
                    {
                        "username": "matilogm",
                        "content": "This one is easy i think i solved it pretty good with javascript. i would love to see other solutions using javascript"
                    },
                    {
                        "username": "nikhilpatel99",
                        "content": "//c++ code\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int str=0,res;\\n        int end=nums.size()-1;\\n        while(end>=str)\\n        {\\n            int mid=(str+end)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }else if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                str=mid+1;\\n            }\\n        }\\n        return str;\\n    }\\n};"
                    },
                    {
                        "username": "Priyanshu5603",
                        "content": "int searchInsert(int* nums, int numsSize, int target)\\n{\\n    int i=0;\\n    while(target>nums[i])\\n        i++;\\n  \\n    return i;\\n}\\nIDK why is it showing heap buffer overflow "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "the while function test if target >nums[i], but what if the target is bigger than the last element of the array? how you will access an invalid position . the solution is to put a condition i<numsSize. so the so;ution is \\n         int i=0;\\n        while(i<numsSize && target>nums[i]) i++;\\n        return i;"
                    },
                    {
                        "username": "wild_knight",
                        "content": "The solution has to be in O(logn)"
                    },
                    {
                        "username": "Buncarski",
                        "content": "Oh hey I already did this lol"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "just here for comment #100"
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "First run - pass, first - submission pass! Easy leetcode - so relaxing!"
                    },
                    {
                        "username": "Shivam_Rawat02",
                        "content": "why it is showing me AddressSanitizer: heap-buffer-overflow on address 0x6020000000bc at pc 0x0000003458a8 bp 0x7fff3bce59f0 sp 0x7fff3bce59e8 this error \nplzzz help\n"
                    },
                    {
                        "username": "Mohamed_Yehia",
                        "content": "the best algorithm is `binary search` "
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Why is leetcode test timing so variable? Sometimes I get 3ms, sometimes 7ms, sometimes 0ms: It tells me more about the server busyness than about the quality of my code...."
                    }
                ]
            },
            {
                "id": 1808274,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1808215,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1808200,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1808179,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1808116,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1808084,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1807963,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1807927,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1807908,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1807849,
                "content": [
                    {
                        "username": "maaz2006",
                        "content": " I can\\'t believe it, I did it without any for loop in python."
                    },
                    {
                        "username": "nomad_pranab",
                        "content": "It was easy but the thing was to find an optimal solution but i used for loop and solved."
                    },
                    {
                        "username": "user3803Ce",
                        "content": "It could also be while-loop or even recursive function, which would be quicker, thus more optimal solution"
                    },
                    {
                        "username": "Avinash_Agrawal",
                        "content": "Seeing the problems like this make my day."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link https://leetcode.com/problems/search-insert-position/solutions/3209228/c-easy-and-simple-solution-using-binary-search/\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "LeetCode is in love with Easy problems, and I am not complaining. \\uD83D\\uDE05"
                    },
                    {
                        "username": "adityaharsh1212",
                        "content": "using lower bound in cpp gives a single line of code as solution for this problem."
                    },
                    {
                        "username": "rutujmirzapure",
                        "content": "use binary search. "
                    },
                    {
                        "username": "Expertmind143",
                        "content": "Easy solution\\nhttps://youtu.be/vjyC1DcVMK0"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "get the idea, but the edge case is kinda annoying..."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "which one?"
                    },
                    {
                        "username": "thisannie",
                        "content": "is Leetcode giving personalized problem based on individual ability to solve?"
                    }
                ]
            },
            {
                "id": 1807819,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807786,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807727,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807722,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807718,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807698,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807693,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1807692,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1805878,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1804237,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Maybe they are trying to increase users motivation."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There would be many users who struggle with this question as well, its not easy for all"
                    },
                    {
                        "username": "jaradomkar24",
                        "content": "class Solution {\\nprivate:\\n    int binarySearch(vector<int>& nums, int target, int low, int high){\\n        int mid;\\n        if(low>high){\\n            return low;\\n        }else{\\n            mid=(low+high)/2;\\n            if(target==nums[mid]){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                return binarySearch(nums,target,low,mid-1);\\n            }else{\\n                return binarySearch(nums,target,mid+1,high);\\n            }\\n        }\\n    }\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int n=nums.size()-1;\\n        int low=0;\\n        int high=n;\\n        return binarySearch(nums,target,low,high);\\n    }\\n};"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Great!! I thought another easy will never come back!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "one line c++ solution with lower_bound: \\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();"
                    },
                    {
                        "username": "luanct",
                        "content": "easy binary search"
                    },
                    {
                        "username": "Prerna_",
                        "content": "very Easy question, just use BINARY SEARCH and return the starting index at the end.\n\nhappy coding🎉"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy Feb!!!"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Just like previous week, Monday started with easy again..\\nLove you Leetcode \\uD83D\\uDE0D\\uD83D\\uDE1C"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "this question can solve using simple Binary search. it is same as ceiling number \\nfor example, if we have array = [ 2,3,5,9,14,16,18].\\n\\nthe concept of ceiling number is ** smallest element of array which is greater than or equals to target. \\n\\nEx. ceiling (array , target=14) result will be 14.\\n      ceiling (array , target=15) and result will be 16 because the number >= target and our start pointer End will become 14 and start will 16 and ours Mid element is target which is 15.\\n\\nso approach is that solve like simple binary array where check condition for order of sorted array is in ascending or descending order make sure comparison for ascending and descending  with start pointer with end pointer *{ nums[start]<=nums[end] }*\\nand lastly just return the starting index of element."
                    },
                    {
                        "username": "user7924KL",
                        "content": "recursive binary search:\\n.\\n.\\n.\\n>\\n.\\n.\\n.\\n.\\n\\n\\nclass Solution:\\n    def searchInsert(self, nums, target, low, high):\\n        if high >= low:\\n            mid = (high + low) // 2\\n            if nums[mid] > target:\\n                return Solution.searchInsert(self, nums, target, low, mid - 1)\\n            if nums[mid] < target:\\n                return Solution.searchInsert(self, nums, target, mid + 1, high)\\n            if nums[mid] == target:\\n                return mid\\n        else:\\n            return high + 1"
                    }
                ]
            },
            {
                "id": 1803862,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1801997,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1799696,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1799480,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1797197,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1795129,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1789028,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1785100,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1784540,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1782304,
                "content": [
                    {
                        "username": "user0291CQ",
                        "content": "Java solution to solve it in fewer steps. Would like help. Passes all but the last few test cases. Everything I seem to find online about a binary search has you iterating the array as normal, just from two different ends-- high and low. I want to do something different. My thinking is I want to eliminate half the remaining valid guesses with each guess. Can you tell me what's wrong with my thinking?\n\nSomething like this: [binary search](https://www.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/a/a-guessing-game)\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] >= target) return 0;\n        if(nums[nums.length-1] < target) return nums.length;\n        int i = (nums.length)/2;\n        while(i > 0 && i < nums.length){\n            if(nums[i] >= target && nums[i-1] < target){\n                return i;\n            } else {\n// Eliminate half of remaining values\n                i += ((nums.length - i) * ((target - nums[i])/ Math.abs(target - nums[i]))) / 2;\n            }\n        }\n        return 0;\n    }\n}\n"
                    },
                    {
                        "username": "SanketSonu",
                        "content": "Can some one help me Understand Time Complexity of this Code written by me:\\nI think its O(log n) because I have used \"for i in range(len(nums)):\", however, I have also used \" for j in nums:\" in else which is O(n). Please help me understand:\\n\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                return i\\n            else:\\n                i = 0\\n                for j in nums:\\n                    if j < target:\\n                        i += 1\\n                return i"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It is of O(N) as first for loop will run only one time and another for loop is working N time ... so O(N+1) = O(N)"
                    },
                    {
                        "username": "kvp232003",
                        "content": "why isn\\'t this code working?can someone help?\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        nums.append(target)\\n        nums.sort()\\n        ind=nums.index(target)\\n    return ind"
                    },
                    {
                        "username": "Pellyyy",
                        "content": ".sort() method doesn\\'t work in log n time though so you\\'re not doing what the problem is asking you to do"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "It will work there is nothing wrong ... by the way nice trick"
                    },
                    {
                        "username": "_ismoil",
                        "content": "Can I solve this using Interpolation Search"
                    },
                    {
                        "username": "aiusha",
                        "content": "Нou can simply use iteration and then the complexity will be O(N)\n\nOr try to use the fact that the array is already sorted using binary search. then the complexity is O(n log n)\n\nDon't forget the testcases :)\n\nGood luck"
                    },
                    {
                        "username": "sahilwagh142",
                        "content": "    `int searchInsert(vector<int>& nums, int target) {\\n    int s = 0;\\n    int e = nums.size() - 1;\\n    int mid = s + (e - s) / 2;\\n    while (s <= e)\\n    {\\n        mid = s + (e - s) / 2;\\n        if (nums[mid] == target)\\n        {\\n            return mid;\\n        }\\n        else if (target < nums[mid])\\n        {\\n            e=mid-1;\\n        }\\n        else\\n        {\\n            s=mid+1;\\n        }\\n    }\\n    if(target < nums[mid]){\\n        return mid;\\n    }\\n    else{\\n        return mid+1;\\n    }} \\n`"
                    },
                    {
                        "username": "akaankshappu",
                        "content": "if target in nums:\\n            i=nums.index(target)\\n            return i\\n        \\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            q=nums.index(target)\\n            return q"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this solution is slower than log n time though"
                    },
                    {
                        "username": "Abdelmawla98",
                        "content": "Compile Error issue !\n\nint left{}, mid{}, right = nums.size() - 1;      \n if (target < nums[left])\n            return 0;\n        else if (target > nums[right])\n            return right + 1;\n        else\n        {\n            while (left <= right)\n            {\n                mid = (left + right) / 2;\n                if (nums[mid] == target)\n                    return mid;\n                else if (nums[mid] > target)\n                    right = mid - 1;\n                else if (nums[mid] < target)\n                    left = mid + 1;\n            }\n        }\n\n// when i try the code on visual studio works perfectly \nbut when i try here it shows Compile Error \"Line 23: Char 5: error: non-void function does not return a value in all control paths \"\n\nany suggestions ??\n"
                    },
                    {
                        "username": "harshit_55",
                        "content": "The function is expecting a return statement but your code is not providing any...... Hope this helps."
                    },
                    {
                        "username": "shivam08122001",
                        "content": "by using c language  ,#C \\n1st approach ) if num[i]==target \\n                       flag==1\\n\\nreturn i;\\n2nd approach) // if any number is not equal to target \\n                       if(flag!=1)\\n                       then using for loop if(number[i]>target\\nreturn i;      "
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "use binary search algorithm\\nreturn `low` if target not found"
                    }
                ]
            },
            {
                "id": 1781169,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1781127,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1779094,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1778197,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1777329,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1777012,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1770023,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1767638,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1757375,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1755858,
                "content": [
                    {
                        "username": "sid0542",
                        "content": "The most efficient solution for this problem is the binary search solution with a time complexity of O(log n) and a space complexity of O(1). This solution can be further optimized by using more advanced algorithms, but in general, the binary search approach is already considered to be the most efficient for this problem.\\n\\n\\n\\n"
                    },
                    {
                        "username": "amaan7",
                        "content": "hey can you pls share what are the different complex algorithms that can be used for optimizations here?"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " int n=nums.size();\\n        int low=0,high=n-1;\\n        while(low<=high){\\n        int mid=(low+high)/2;\\n        if(nums[mid]==target)\\n        return mid;\\n        else if(nums[mid]<target)\\n        {\\n            low=mid+1;\\n        }\\n        else{\\n            high=mid-1;\\n        }\\n\\n        }\\n        return low;"
                    },
                    {
                        "username": "sainath81061",
                        "content": "int i, count = 0;\\n       for (i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                count = i;\\n                break;\\n            }\\n            else if(i == target)\\n            {\\n                count = i-1;\\n                break;\\n            }\\n        }\\n       if(target == 0)\\n        {\\n            count= 0;\\n        }\\n        else if (count == 0)\\n        {\\n\\n            count = nums.Length;\\n        }\\n       return count;"
                    },
                    {
                        "username": "jyotirmoydotdev",
                        "content": "C++\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start=0;\\n        int end=(nums.size())-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};"
                    },
                    {
                        "username": "Amn_Yadav",
                        "content": "how to handle heap buffer overflow  on --- address  error\\n--<plz help-->"
                    },
                    {
                        "username": "shubhankarsen9955",
                        "content": "Easy Solution\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n         int count=0;\n\n        if (nums[nums.length - 1] < target) {\n            return nums.length;\n        }\n        if (nums[0] > target) {\n            return 0;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (target == nums[i])\n                return i;\n            else if (nums[i] > target) {\n                count++;\n                if (count > 0) {\n                    return i;\n                }\n            }\n\n        }\n        return 0;\n    }\n}"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "doesn\\'t work in log n time. bad solution"
                    },
                    {
                        "username": "Pratibh29",
                        "content": " nums.append(float(\\'inf\\'))\\n        s,e=0,len(nums)-1\\n        while(s<e):\\n            mid=(s+e)//2\\n            if target<=nums[mid]:\\n                e=mid\\n            else:\\n                s=mid+1\\n        return s    "
                    },
                    {
                        "username": "prameshkumarsaha",
                        "content": "with python you can follow this:\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "this is O(n), you\\'re meant to do it in O(log n). You\\'re not passing the problem. "
                    },
                    {
                        "username": "Subh001",
                        "content": "why to use binary search if it can solved by simple for and if else loop , time complexity also same for these two."
                    },
                    {
                        "username": "mputnick",
                        "content": "For loop time complexity is O(n), binary search is O(logN)"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "I would like to know which is more efficient in this case: iterative or recursive binary search?\\nI know that efficiency of binary search (for iterative and recursive) differs according to the problem statement, so for this particular problem, which would be the better approach?"
                    }
                ]
            },
            {
                "id": 1755449,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752606,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751533,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1750429,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1750082,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733736,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733537,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1730568,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728569,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1725703,
                "content": [
                    {
                        "username": "chandan03chandu",
                        "content": "its just flooring of an sorted array"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "himanshukla2003",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int t) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==t){\\n            x= i;\\n            break ;}\\n            else if(nums[i]<t){\\n            x=i+1;\\n            }\\n           \\n\\n           \\n             \\n        \\n        return x;\\n    }\\n};"
                    },
                    {
                        "username": "Nurcann",
                        "content": "Binary Search..."
                    },
                    {
                        "username": "Shashank_008",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index=0;\\n        int flag=0;\\n        if(nums[0]>target){return 0;}\\n        for(int i=0;i<nums.length;i++){\\n               if(nums[i]==target){\\n                   return i;\\n               }\\n               else if(nums[i]<target){\\n                   index=i;\\n               }\\n               else if(nums[i]>target){\\n                   flag=1;\\n                   index++;\\n                  break;\\n               }\\n        }\\n        if(flag==1){\\n        return index;\\n        }\\n        return index+1;\\n    }\\n}\\nBeats 100% !"
                    },
                    {
                        "username": "nishitaverma",
                        "content": "I tried solving this question but only passed 49 out of 64 test cases while submitting:\\n `n=len(nums)\\n        j=0\\n        ans=0\\n        \\n        if target in nums:\\n            ans= nums.index(target)\\n        for i in range (1, n):\\n            if (target not in nums) and  (target<nums[-1]):\\n                if nums[j] < target and nums[i] > target:\\n                    ans= (i+j)//2\\n            elif target >= nums[-1]:\\n                ans= n\\n            else:\\n                j+=1\\n\\n        return ans`\\n\\nany help on where I\\'m going wrong with the code?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "int searchInsert(vector<int>& nums, int target) {\\n        int p;\\n        nums.push_back(target);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                p = i;\\n                break;\\n            }\\n        }\\n        return p;\\n    }"
                    },
                    {
                        "username": "gurpreetsinghthind1001",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n          int e=nums.size()-1;\\n          int s=0;\\n          int mid=s+(e-s)/2;\\n          if(target==0 && target<=nums[s]){\\n              return 0;\\n          }\\n          \\n        \\n          while(s<=e){\\n          \\n\\n           \\n        \\n        \\n        \\n        \\n           if(nums[mid]>=target){\\n               e--;\\n           }else{\\n               s++;\\n           }\\n\\n        mid=s+(e-s)/2;\\n\\n\\n\\n\\n\\n\\n\\n              \\n     }\\n          return s;\\n    }\\n};"
                    },
                    {
                        "username": "sagarverma5754",
                        "content": "35. Search Insert Position\\n `your inline code...your inline code...`\\nclass Solution {\\n    public int searchInsert(int[] nums, int x) {\\n        int ll=0,ul=nums.length-1,index=0;\\n        int mid;\\n        \\n        if(nums[0]>=x){\\n            return 0;\\n        }\\n        \\n        while(ll<=ul){\\n            \\n            mid=ll+(ul-ll)/2;\\n            \\n            if(nums[mid]==x){\\n                return mid;\\n            }\\n          if(nums[mid]>x){\\n             ll=0;\\n             ul=mid-1;\\n        }\\n          else{\\n              ll=mid+1;\\n              index=mid;\\n          }\\n          }\\n          return index+1;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724245,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1723599,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1722163,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1721245,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1714035,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1708803,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1706260,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1699863,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1693967,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1683476,
                "content": [
                    {
                        "username": "ankit_996",
                        "content": "class solution{\\n        public int  searchInsert (int [ ] nums, int target){\\n            int result =0;\\n            for (int i=0; i< nums.length; i++){\\n                if (nums[i]==target){\\n                    result = i;\\n                } else if (nums[i]<target) {\\n                    result = i+1;\\n                }\\n            }\\n            return result;\\n        }\\n    } `\\n"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Why is it that the solution 1 returns the \\'left\\' index instead of the \\'end\\' after the while loop?\\n"
                    },
                    {
                        "username": "limebat",
                        "content": "Hello everyone,\\nI am relatively new to the coding game, and I haven\\'t had much practice unfortunately with unordered maps. Could someone help me spot the error?\\nHere\\'s the code::\\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        for (int l=0; l < nums.size(); l++){\\n            mp[nums[l]] = l;\\n        }\\n        for (auto x : mp){\\n            if (x.first == target)\\n                return x.second;\\n            if (x.first < target)\\n                return (x.second+1);\\n        }    \\n        return 0;\\n    };\\n};\\n\\n\\nThe unfortunate part, however, is this code fails at testcase [62/64];\\n[-5000,-4999,-4996,-4995,-4993,-4992,-4991,-4990,-4986,-4985,-4982,-4981,-4980,-4979,-4978,-4977,-4976,-4975,-4974,-4973,-4972,-4971,-4969,-4968,-4965,-4964,-4963,-4962,-4960,-4955 .. .\\nTarget = \\n5488\\nOutput =\\n6360\\nExpected =\\n6363\\n\\nIf it\\'s not too much of an inconvenience, may some assistance be given to this solution set?\\n\\nBest,\\n\\nlimebat"
                    },
                    {
                        "username": "stefann01",
                        "content": "Using an unordered map is wrong approach with this problem, its unnecessery and time complexity is O(n), which is not good enough. Learn about Binary Search algorithm and then try to use it to solve this problem."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/35_Search_insert_position.cpp"
                    },
                    {
                        "username": "AbuJava",
                        "content": "for (int i = 0; i < nums.length; i++) {\n    if (nums[i] >= target) return i;\n}\nreturn nums.length;"
                    },
                    {
                        "username": "tuandatne",
                        "content": "The easy problem, you should try binary_search of stl c++. It very convenient and very short. \\n\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        auto it =lower_bound(nums.begin(), nums.end(), target);\\n        return it - nums.begin();\\n    }\\n};"
                    },
                    {
                        "username": "KuldeepPrajapati",
                        "content": "Can somebody tell me why it\\'s passing only 9/64 test cases and why it is showing following error while submitting....\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000510 overflowed to 0x60200000050c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n.\\n.\\n.\\ncode is here.....\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        if(nums.size() < 10000){\\n        long int start = 0;\\n        long int end = nums.size()-1;\\n        long int mid = start +(end - start)/2;\\n        if(target > nums[end])\\n            return end+1;\\n        if(target < nums[start])\\n            return start;\\n\\n        while(start <= end){\\n            if(target == nums[mid])\\n                return mid;\\n            else if (target > nums[mid-1] && target < nums[mid]){\\n                return mid;\\n            }\\n            else if (target > nums[mid] && target < nums[mid+1]){\\n                return mid + 1;\\n            }\\n            else if(target < nums[mid])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n            \\n            mid = start +(end - start)/2;\\n        }\\n        }\\n\\n    return -1;    \\n\\n    }\\n};\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "luvbhushan",
                        "content": "class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int ans = 0;\\n        \\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]==target){\\n                ans = i;\\n                return ans;\\n            }\\n            \\n            if (nums[i]>target){\\n                ans = i;\\n                return ans;\\n            }     \\n        }\\n        \\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/g5rKB4DhOBc"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83C\\uDFC6 C++ 1 LINER FAANG\\uD83D\\uDC4C CODE\\uD83D\\uDE28\\nhttps://leetcode.com/problems/search-insert-position/solutions/2248716/c-1-liner-faang-code/"
                    }
                ]
            },
            {
                "id": 1682275,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1679148,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1671307,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1669713,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1666712,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1660123,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1653990,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1648675,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1647949,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            },
            {
                "id": 1641316,
                "content": [
                    {
                        "username": "Locklad",
                        "content": "control reaches end of non-void function [-Werror=return-type] [solution.c]\\n } \\nthis is what it shows everytime i try to run a code \\ni am a newbie and as per my knowledge and dry runs my code is accurate and i don\\'t know why it shows this error\\n"
                    },
                    {
                        "username": "realDEM0N",
                        "content": "I have written the code, and it works just fine, but not here when I Run. When I run the code for myself with any testcase it works perfectly, except for here. It gives me \"heap-buffer-overflow\" even though I can\\'t find where it could occur (and I can\\'t debug it elsewhere because it works just fine). Any suggestions?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C Programming.\\n[https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-search-insert-position-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        if target in nums:\\n            return nums.index(target)\\n        else:\\n            nums.append(target)\\n            nums.sort()\\n            a=nums.index(target)\\n            return a"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int index = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(target==nums[i]){\\n              index=i;\\n            }else{\\n                if(target>nums[i]){\\n                    index=i+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}"
                    },
                    {
                        "username": "da_egg27",
                        "content": "I am a JS guy, i'm trying to simply console log the vector/array (cout << nums) but I am getting 'error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream') and 'vector')'\n\nNot really sure why.\n\nEDIT: I don't really understand the 'vector<int> & nums'. I know the vector is specifying that is it of type int, but I don't get what the '& nums' is doing. I want to think it's creating a vector from the array but it doesn't seem to be working that way. "
                    },
                    {
                        "username": "mixsture",
                        "content": "nums =[1,3] target = 3, Output = 2, Expected = 1\\n\\nRly? Why should i choose exactly left position to insert when 2 same numbers will be in array? Looks like an error in tests (JS)"
                    },
                    {
                        "username": "charonme",
                        "content": "the description says you should return the index of the target if it exists. In [1,3] the target 3 exists on index 1, so the correct answer is 1 even though you could insert a new 3 at index 2 and keep the array sorted"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/search-insert-position-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "Kexon",
                        "content": "Looking at C#: Isn\\'t the lowest runtime solution in submissions O(n)? Doesn\\'t the solution traverse through each element to find its position? "
                    },
                    {
                        "username": "meirbnb",
                        "content": "hint: find lower_bound"
                    }
                ]
            }
        ]
    }
]