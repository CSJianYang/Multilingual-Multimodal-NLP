[
    {
        "title": "The Most Frequently Ordered Products for Each Customer",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570447,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1570376,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1574582,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            },
            {
                "id": 1901712,
                "content": [
                    {
                        "username": "aodish",
                        "content": "with order_counts as (\\nSELECT\\no.customer_id,\\np.product_name,\\np.product_id,\\ncount(o.order_id) as order_count\\nFROM\\norders o\\nINNER JOIN products p ON p.product_id = o.product_id\\nGROUP BY 1,2,3)\\n\\nselect \\noc.customer_id,\\noc.product_id,\\noc.product_name\\nfrom order_counts oc\\nWHERE\\noc.order_count = (select MAX(order_count) from order_counts x where x.customer_id = oc.customer_id)\\n"
                    },
                    {
                        "username": "divy3003",
                        "content": "with ct as (select customer_id, product_id, rank()over(partition by customer_id order by count(product_id) desc) as rnk from orders group by customer_id, product_id)\\nselect c.customer_id, c.product_id, p.product_name\\nfrom ct c left join products p on c.product_id = p.product_id\\nwhere c.rnk = 1;"
                    },
                    {
                        "username": "MelodieHe",
                        "content": "WITH t1 AS (SELECT customer_id, product_id, RANK() OVER (PARTITION BY customer_id ORDER BY COUNT(order_date) DESC) AS rk FROM Orders GROUP BY customer_id, product_id)\\n\\nSELECT t1.customer_id, t1.product_id, P.product_name\\nFROM t1, Products P\\nWHERE rk = 1\\nAND t1.product_id = P.product_id\\nORDER BY t1.customer_id, t1.product_id \\n"
                    },
                    {
                        "username": "vdhyasagr",
                        "content": "A good case where you need to read the question properly. I could swear I read \"most recently\" and not \"most frequently\". That changed the whole dynamic. Straightforward solution otherwise"
                    }
                ]
            }
        ]
    },
    {
        "title": "Build Binary Expression Tree From Infix Expression",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1837823,
                "content": [
                    {
                        "username": "coderinterview",
                        "content": "For the test case : \"(1/2/3)\"\\nExpected output is : [/,/,3,1,2]\\nMy output is : [/,1,/,null,null,2,3]\\nWhen my output is traversed in-order, same string is generated with operands in same order.\\nSo, why is it considered wrong ans?\\nMy Code:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct Node {\\n *     char val;\\n *     Node *left;\\n *     Node *right;\\n *     Node() : val(\\' \\'), left(nullptr), right(nullptr) {}\\n *     Node(char x) : val(x), left(nullptr), right(nullptr) {}\\n *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rank(char c){\\n        if(c == \\'+\\') return 1;\\n        else if(c == \\'-\\') return 2;\\n        else if(c == \\'/\\') return 3;\\n        else if (c == \\'*\\') return 4;\\n        return 5;\\n    }\\n    Node* solve(string &s,int l,int r){\\n        if(l>r) return nullptr;\\n        int mino=l;      \\n        int ob=0;\\n        for(int i=l;i<=r;i++){\\n            if(s[i] == \\'(\\') ob++;\\n            else if(s[i] == \\')\\') ob--;\\n            else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;\\n            \\n        }\\n        if(mino == l && r-l != 0){\\n            ob=-1;\\n            for(int i=l;i<=r;i++){\\n                if(s[i] == \\'(\\') ob++;\\n                else if(s[i] == \\')\\') ob--;\\n                else if(rank(s[i]) < rank(s[mino]) && ob == 0) mino=i;    \\n            }\\n            l++;\\n            r--;\\n        }\\n        Node *t = new Node(s[mino]);\\n        t->left = solve(s,l,mino-1);\\n        t->right = solve(s,mino+1,r);\\n        return t;\\n    }\\n    Node* expTree(string s) {\\n        Node *ans = solve(s,0,s.length()-1);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "I had the same problem in my code.\\n\\nThe output [/,1,/,null,null,2,3] is actually equivalent to \"1/(2/3)\"."
                    }
                ]
            }
        ]
    },
    {
        "title": "Crawler Log Folder",
        "question_content": "<p>The Leetcode file system keeps a log each time some user performs a <em>change folder</em> operation.</p>\n\n<p>The operations are described below:</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> : Move to the parent folder of the current folder. (If you are already in the main folder, <strong>remain in the same folder</strong>).</li>\n\t<li><code>&quot;./&quot;</code> : Remain in the same folder.</li>\n\t<li><code>&quot;x/&quot;</code> : Move to the child folder named <code>x</code> (This folder is <strong>guaranteed to always exist</strong>).</li>\n</ul>\n\n<p>You are given a list of strings <code>logs</code> where <code>logs[i]</code> is the operation performed by the user at the <code>i<sup>th</sup></code> step.</p>\n\n<p>The file system starts in the main folder, then the operations in <code>logs</code> are performed.</p>\n\n<p>Return <em>the minimum number of operations needed to go back to the main folder after the change folder operations.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png\" style=\"width: 775px; height: 151px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>Use this change folder operation &quot;../&quot; 2 times and go back to the main folder.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png\" style=\"width: 600px; height: 270px;\" /></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> contains lowercase English letters, digits, <code>&#39;.&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li><code>logs[i]</code> follows the format described in the statement.</li>\n\t<li>Folder names consist of lowercase English letters and digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 866374,
                "title": "java-simple-o-n-loop",
                "content": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for (String s : logs) {\\n            if (s.equals(\"../\")) res = Math.max(0, --res);\\n            else if (s.equals(\"./\")) continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868439,
                "title": "c-check-for-and",
                "content": "Check whether we go back (`\"../\"`), stay (`\"./\"`) or deeper (otherwise), and update the number of `steps`.\\n```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<string>& logs, int steps = 0) {\\n    for (auto log : logs)\\n        if (log == \"../\")\\n            steps = max(0, steps - 1);\\n        else if (log != \"./\")\\n            ++steps;\\n    return steps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866622,
                "title": "java-python-3-count-the-depth-of-the-folders",
                "content": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\\n1 liner - credit to **@blue_sky5**\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\\nImproved by **@StefanPochmann**:\\nRefer to the [hint](https://leetcode.com/problems/crawler-log-folder/discuss/866374/Java-Simple-O(N)-loop/779657).\\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                depth = Math.max(0, --depth);\\n            }else if (!log.equals(\"./\")) {\\n                ++depth;\\n            }\\n        }\\n        return depth;\\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                depth = max(0, depth - 1)\\n            elif log != \\'./\\':\\n                depth += 1\\n        return depth\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - 1) if folder == \\'../\\' else depth + (folder != \\'./\\'), logs, 0)\\n```\n```java\\n    public int minOperations(String[] logs) {\\n        return Arrays.stream(logs)\\n                     .mapToInt(log -> log.lastIndexOf(\".\"))\\n                     .reduce(0, (depth, index) -> Math.max(0, depth - index));  \\n    }\\n```\n```python\\n    def minOperations(self, logs: List[str]) -> int:\\n        return functools.reduce(lambda depth, folder: max(0, depth - folder.rfind(\\'.\\')), logs, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239366,
                "title": "shortest-c-stack-solution-100-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n\\nIf this solution helped you in any way, then please hit the upvote button.\\nAlso, let me know if you face trouble understanding it.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<string> &logs)\\n    {\\n        stack<string> st;\\n        for (string &s : logs)\\n        {\\n            if (s == \"../\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else if (s == \"./\")\\n                continue;\\n            else\\n                st.push(s);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046552,
                "title": "java-o-n-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }else if(log.equals(\"./\")){\\n\\n            }else{\\n                stack.push(log);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n         var stack = new Stack<String>();\\n        for(var log : logs){\\n            if(log.equals(\"../\")){\\n                if(!stack.empty())\\n                    stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 866343,
                "title": "python3-straightforward",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        for log in logs: \\n            if log == \"./\": continue\\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\\n            else: ans += 1 # child directory \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866722,
                "title": "faster-than-100-00-using-stack-and-without-stack-2-ways",
                "content": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.using stack\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\t\\n        if(logs.size()==0) return 0;\\n\\t\\t\\n        stack<string> st;\\n        for(auto x: logs){\\n            if (x[0] != \\'.\\')  //Move to the child folder so add children\\n                st.push(x);\\n            else if(x==\"../\"){ // Move to the parent folder of the current folder so pop\\n                 if(!st.empty())  st.pop(); \\n                 else continue; //don\\u2019t move the pointer beyond the main folder.\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n         int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") { // go deeper\\n                ans--; \\n                ans = max(ans, 0);\\n            } else if (log != \"./\") // one level up\\n\\t\\t\\t   ans++; \\n        }\\n        return ans;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for (string s : logs) {\\n            if (s==\"../\") res = max(0, --res);\\n            else if (s==\"./\") continue;\\n            else res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871751,
                "title": "java-100-0ms-no-string-compares-explanation",
                "content": "Start at ```level = 0``` in the folder structure.  Move up or down levels in the folder structure, using 3 cases:\\n\\n1. \\t```\"../\"```  Move down a level toward the root:  Level-1, but not below zero.\\n2. \\t```\"./\"```  Do nothing.\\n3. \\t```\"text/\"```  Move upward in the folder structure:  Level+1\\n\\nTo decide on which case, for case 1. if the second character is a ```\\'.\\'``` then move down a level.  Else to decide between case 2. and case 3., if the first character is not a ```\\'.\\'``` then move up a level.  This method uses character comparisons instead of string comparisons, because usually ```char``` operations are faster than ```String``` operations.\\n\\nWhen done with all the folder strings, the resultant ```level``` number is the *number of operations needed to go back to the main folder* which was requested in the problem description.\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\\n\\n**Or using ternary comparisons:**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```level = 0```\n```\"../\"```\n```\"./\"```\n```\"text/\"```\n```\\'.\\'```\n```\\'.\\'```\n```char```\n```String```\n```level```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs) {\\n            if (s.charAt(1) == \\'.\\')\\n                level = Math.max(0, level - 1);\\n            else if (s.charAt(0) != \\'.\\')\\n                level++;\\n        }\\n        return level;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String s : logs)\\n            level = (s.charAt(1) == \\'.\\') ? Math.max(0, level-1) : (s.charAt(0) != \\'.\\') ? level+1 : level;\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102858,
                "title": "python-super-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        \\n        for i in logs:\\n            if i == \\'../\\' and res > 0:\\n                res -= 1\\n            elif i != \\'./\\' and i != \\'../\\':\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866491,
                "title": "without-using-stack-o-1-space-complexity",
                "content": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MinOperations(string[] logs) {\\n        int count = 0;\\n        \\n        foreach(string log in logs){\\n            if(log == \"../\"){\\n                if(count != 0){\\n                    count--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866446,
                "title": "python-easy-using-stack",
                "content": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if not logs:\\n            return 0\\n        \\n        stk = []\\n        \\n        for log in logs:\\n            if log == \\'../\\':\\n                if stk:\\n                    stk.pop()\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                stk.append(log)\\n        \\n        return len(stk)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3403932,
                "title": "c-implementation",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int cnt=0;\\n        for (int i=0; i<logs.size(); i++){\\n            if (logs[i]==\"../\"){\\n                if (cnt>0)cnt--;\\n            }\\n            else if (logs[i]==\"./\"){\\n                // do nothing\\n            }\\n            else{\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193850,
                "title": "easy-python-solution-using-stacks",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if i==\"./\":\\n                continue\\n            elif stack and i==\"../\":\\n                stack.pop()\\n            elif i!=\\'../\\':\\n                stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507874,
                "title": "intuitive-code-and-easily-understandable-in-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for i in logs:\\n            if i == \\'./\\':\\n                continue\\n            elif i == \\'../\\':\\n                if res > 0:\\n                    res -= 1\\n            else:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866466,
                "title": "javascript-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack = []\\n    for (const log of logs){\\n        if (log === \"../\"){\\n            stack.pop();\\n        } else if (log !== \"./\"){\\n            stack.push(log);\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453034,
                "title": "js-runtime-92-91-memory-100-00",
                "content": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n\\tlet level = 0;\\n\\tfor (let i = 0; i < logs.length; i++) {\\n\\t\\tif (logs[i] === \\'./\\') continue;\\n\\t\\tif (logs[i] !== \\'../\\') level++;\\n\\t\\telse level = Math.max(0, level-1);\\n\\t}\\n\\treturn level\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903453,
                "title": "python3-solution-using-stacks",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        m=\\'../\\'\\n        r=\\'./\\'\\n\\t\\t#create an empty stack\\n        stk=[]\\n\\t\\t#iterate through the list\\n        for i in logs:\\n\\t\\t\\t#if Move to the parent folder (../) operator occurs and stack is not empty, pop element from stack\\n            if(i==m):\\n                if(len(stk)>0):\\n                    stk.pop()\\n\\t\\t\\t#else if Remain in the same folder (./) operator occurs, do nothing and move to next element in list\\n            elif(i==r):\\n                continue\\n\\t\\t\\t#else add element to the stack\\n            else:\\n                stk.append(i)\\n\\t\\t#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\\n        return(len(stk))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1529675,
                "title": "c-2-approach-1-with-extra-space-2-without-extra-space",
                "content": "#### WITH EXTRA SPACE \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\\n**WITHOUT USING EXTRA SPACE** \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n         stack<string> st;\\n        \\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(!st.empty() && logs[i] == \"../\")\\n            {\\n                st.pop();\\n            }\\n            else if(st.empty() && logs[i] == \"../\")\\n            {\\n                continue;\\n            }\\n            else if(logs[i] == \"./\")\\n            {\\n                continue;\\n            }\\n            else \\n            {\\n                st.push(logs[i]);\\n            }\\n        }\\n        return st.size();\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int count = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i] != \"./\")\\n            {\\n                if(logs[i] == \"../\")\\n                {\\n                    if(count > 0)\\n                    {\\n                        count--;\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359182,
                "title": "two-simple-java-solutions",
                "content": "Intuition:\\nThere can be three kind of strings possible in logs:\\n\"./\", \"../\", \"d/\"\\nFirst Type  \"./\" :  In this type we don\\'t need to move anywhere so don\\'t do anything.\\nSecond Type \"../\": In this type we need to go back to previous directory so remove last entry from stack(if stack contains any entry).\\nThird Type \"d/\":  In this type we need to move to next directory so push new entry into stack.\\nIn the end return the position of final directory from root directory which is the size of stack.\\n\\nSolution 1 using stack:\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\\n\\n\\n\\n\\nSolution 2: using single variable \\n\\nYou can replace stack with simple variable. When you need to push new directory then just increment variable and when you need to pop then just decrement that variable. finally return the final directory position from root directory.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> s= new Stack<>();\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && !s.isEmpty())  // pop only when \"../\" log is there and there should be some entry in stack.\\n                s.pop();\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\') //directory name can be anything so check for two conditions\\n                s.push(log);\\n        }\\n        return s.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(String log : logs) {\\n            if(log.charAt(1)==\\'.\\' && res>0)\\n                res--;\\n            else if(log.charAt(0)!=\\'/\\' && log.charAt(0)!=\\'.\\')\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346322,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution",
                "content": "Basic idea is to maintain depth of the current folder w.r.t. main folder.\\nAs there are only 3 types of command then interpret and manipulate(+1, -1, 0) depth accordingly.\\n**Type 1** \"./\" : Depth will be same \\n**Type 2** \"../\" : Decrease depth value by 1\\n**Type 3** \"x/\" : Increase depth value by 1\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String cmd : logs) {\\n            depth += interpretCurrentCMD(cmd);\\n            depth = depth < 0 ? 0 : depth;\\n            //Above condition will keep pointer in \\n            //same folder if already in the main folder\\n        }\\n        return depth;\\n    }\\n\\n    private int interpretCurrentCMD(String cmd) {\\n        // CMD Type \"./\"\\n        if (cmd.equals(\"./\")) {\\n            return 0;\\n        }\\n\\n        // CMD Type \"../\"\\n        if (cmd.equals(\"../\")) {\\n            return -1;\\n        }\\n\\n        // CMD Type \"x/\"\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331526,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        s = []\\n        for i in range(len(logs)):\\n            if logs[i] == \"../\":\\n                if len(s) == 0:\\n                    continue\\n                else:\\n                    s.pop(-1)\\n            elif logs[i] == \"./\":\\n                continue\\n            else:\\n                s.append(1)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536067,
                "title": "java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n\\n      \\n\\t\\tList<String> folder = new ArrayList<>();\\n\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(logs[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\"))\\n            {\\n            \\tif(folder.size()>1)\\n                folder.remove(folder.size()-1);\\n            \\telse\\n            \\t\\tfolder.clear();\\n            }\\n            else\\n            folder.add(logs[i]);\\n        }\\n\\n        return folder.size();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361090,
                "title": "crawler-log-folder-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int i, count=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(logs[i]==\"../\" && count>0)\\n                count--;\\n            else if(logs[i]!=\"./\" && logs[i]!=\"../\")\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194915,
                "title": "reduce-switch-case-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    return logs.reduce((acc, log) => {\\n        switch (log) {\\n            case \\'../\\':\\n                return Math.max(acc - 1, 0);\\n            case \\'./\\':\\n                return acc;\\n            default:\\n                return acc + 1;\\n        }\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3037519,
                "title": "python-solution-with-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate through the logs, \\n- if there are two dots and the steps is greater than zero, then step decreases by 1\\n- if there is only one dot, steps doesn\\' change\\n- if it\\'s a folder, steps increase by 1\\n\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\nOr using `match`\\n\\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```\\n\\n**Please upvote if you found if helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                steps -= steps > 0\\n            elif \".\" in log:\\n                continue\\n            else:\\n                steps += 1\\n        return steps if steps > 0 else 0\\n```\n```python\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        steps = 0\\n        for log in logs:\\n            match log.split(\"/\")[0]:\\n                case \"..\":\\n                    steps -= steps > 0\\n                case \".\":\\n                    continue\\n                case d:\\n                    steps += 1\\n        return steps if steps > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961942,
                "title": "100-faster-java-solution-easy-and-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].startsWith(\"..\")) count--;\\n            else if(logs[i].startsWith(\"./\")) continue;\\n            else count++;\\n\\n            if(count < 0) count =0;\\n        }\\n\\n        return count<0? 0 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838141,
                "title": "java-easy-peasy-lemon-squeezy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for (String move : logs) {\\n            switch (move) {\\n                case \"../\": {\\n                    if (count > 0)\\n                        count--;\\n                    break;\\n                }\\n                case \"./\": {\\n                    break;\\n                }\\n                default: {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641602,
                "title": "c-code",
                "content": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/9270a1fb-5c9f-4344-8eea-6e862ae6e403_1664524709.758991.png)\\n// creating stack then simple checking for two conditions , at the last return the size of stack . \\n\\n        stack<string>stk;\\n        for(int i = 0 ; i <logs.size();i++)\\n        {\\n            string str = logs[i];\\n            if(str == \"../\")\\n            {\\n                if(!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else if(str != \"./\")\\n            {\\n                stk.push(str);\\n            }\\n        }\\n        return stk.size();\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2387765,
                "title": "two-solutions-stack-solution-iterative-solution",
                "content": "**Stack solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<int> s;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                s.push(1);\\n            \\n            if(logs[i] ==\"../\" && !s.empty())\\n                s.pop();\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n            \\n        }\\n        return s.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            if(isalpha(logs[i][0]) || isdigit(logs[i][0]))\\n                count++;\\n            \\n            if(logs[i] ==\"../\" && count != 0)\\n                count--;\\n            \\n            if(logs[i] == \"./\")\\n                continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007281,
                "title": "java-modified-stack-approach-beats-96-submissions",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        \\n        for(int i=0; i<logs.length; i++){\\n            if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\")){\\n                c++;\\n            }\\n            else if(c>0 && logs[i].equals(\"../\")){\\n                c--;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490100,
                "title": "java-using-stack-do-checkout",
                "content": "**//Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int len = logs.length;\\n        Stack<String> stack = new Stack<>();\\n        stack.push(\"Main\");\\n        for(int i = 0; i < len; i++) {\\n            if(logs[i].equals(\"./\")) continue; //Remain in same folder\\n            else if(logs[i].equals(\"../\")) {\\n                if(stack.peek().equals(\"Main\")) continue; //Already at parent\\n                else stack.pop(); //Go to one level back of the heirarchy\\n            }\\n            else stack.push(logs[i]); //Go to one level up of the heirarchy\\n        }\\n        int count = 0;\\n        while(!stack.peek().equals(\"Main\")) { //Pop until you reach to Main\\n            stack.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315038,
                "title": "easy-fast-python-solution-faster-than-95-00",
                "content": "# Easy, Fast Python Solution (faster than 95.00%)\\nRuntime: 40 ms, faster than 95.00% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB\\n\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        length = len(logs)\\n        i = 0\\n\\n        while i < length:\\n            if logs[i] == \\'./\\':\\n                del logs[i]\\n                length -= 1\\n            elif logs[i] == \\'../\\':\\n                if i < 1:\\n                    del logs[i]\\n                    length -= 1\\n                else:\\n                    del logs[i]\\n                    del logs[i-1]\\n                    i -= 1\\n                    length -= 2\\n            else:\\n                i += 1\\n\\n        return len(logs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1098198,
                "title": "4-ms-faster-than-95-55-of-c-using-simple-stack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s;\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            string str=logs[i];\\n            if(str==\"../\"){\\n                if(!s.empty()) s.pop();\\n            }\\n            else if(str!=\"./\"){\\n              s.push(str);   \\n            }\\n        }\\n        while(!s.empty()){\\n            s.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065177,
                "title": "java-regex-solution-unique-in-this-discussion",
                "content": "I don\\'t know why these dicuss solutions are so repetitive I felt that this question can also be done using regex, and I am not so good at this, so I though let\\'s look up in the dicuss, sadly all the solutions in Java discuss were a repetitive code. So I had to come up with this code\\n\\n```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int ans=0;\\n        for(String s : logs){\\n            if(s.equals(\"../\")) ans = Math.max(--ans,0);\\n            else if(s.matches(\"[0-9a-z]+/\")) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045008,
                "title": "beats-97-using-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```\\n**Pls upvote my solution if you like it**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string> &logs) {\\n            \\n        stack <int> st;    \\n            \\n        for(string &s : logs){\\n                if(s == \"../\" && !st.empty())\\n                    st.pop();\\n                else if(s != \"./\" && s != \"../\")\\n                    st.push(1);    \\n        }\\n        \\n       return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944864,
                "title": "c-99-faster-code-easy-to-understand-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(ans < 0) ans = 0;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<string>& logs) {\\n\\n\\t\\t\\tint ans = 0; //this will keep track of our position\\n\\t\\t\\t\\t\\t\\t // i.e, how far we are from main folder \\n\\n\\t\\t\\tfor(int i=0;i<logs.size();i++){\\n\\n\\t\\t\\t\\tstring curr = logs[i];\\n\\n\\t\\t\\t\\tif(curr == \"../\")\\n\\t\\t\\t\\t\\tans--; \\n\\t\\t\\t\\telse if(curr == \"./\")\\n\\t\\t\\t\\t\\tans = ans;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans++;\\n\\n\\t\\t\\t\\tif(ans < 0) ans  = 0;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 886987,
                "title": "faster-than-53-36-of-c-memory-usage-10-8-mb-less-than-99-86",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int ops=0;\\n        \\n        for(auto c:logs){\\n            \\n            if(c==\"../\") {\\n                \\n                if(ops>0)\\n                ops--;\\n            }\\n            else {\\n                \\n                if(c==\"./\") continue;\\n                else {\\n                    ops++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return ops;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866489,
                "title": "python-and-c-simple-python-code-o-n",
                "content": "**PYTHON**\\n```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n        res = 0\\n        for val in logs:\\n            if(val  ==  \"../\"):\\n                if res: res-=1\\n            elif(val != \"./\" ) :  # to count for operations such as d1/ , d21/ \\n                res+=1\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(string val :logs){\\n            if(val==\"../\"){\\n                if(res!=0) res--;\\n            }\\n            else  if(val != \"./\") res+=1;  \\n\\t\\t}\\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866437,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        # ans will hold minimum number of operations required\\n        ans = 0\\n        for i in logs:\\n            # when we go up by one directory the operation will decrease by 1\\n            if i==\"../\":\\n                ans-=1\\n            # nothing to do we neither go one directory up or down\\n            elif i==\\'./\\':\\n                pass\\n            # we have gone down by one directory so required operations will increase\\n            else:\\n                ans+=1\\n            # ans<0 means we were in the main directory and we perform ../ which means nothing\\n            if ans<0:\\n                ans = 0\\n        if ans<0:\\n            return 0\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866397,
                "title": "c-simple-few-lines-solution-clean-code",
                "content": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for (string log : logs) {\\n            if (log == \"../\") {\\n                ans--;\\n                ans = max(ans, 0);\\n            } else if (log != \"./\") ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3972434,
                "title": "simple-implementing-with-using-stack-ds",
                "content": "# Intuition\\nThe descriptions is leading us to use the **stack**, that follows LIFO-schema.\\n\\n---\\n\\nIf you don\\'t familiar with **stack**, lets have a look at [wiki page about stack description](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).\\n\\n# Approach\\n1. create `stack` variable, that\\'ll be store all of the elelement, that aren\\'t in this list `folders = [\\'./\\', \\'../\\']`\\n2. iterate over all `logs` and check, if log contains `../`, it\\'s time to **back to the parent folder**, if it\\'s `./`, than do **NOTHING**, otherwise save this dir inside of a stack.\\n3. be sure NOT to **pop from an empty stack, that causes an IndexError**\\n4. **finally check HOW** many dirs are in the stack\\n\\n# Complexity\\n- Time complexity: **O(n)** because of iterating `logs`\\n\\n- Space complexity: **O(n)**, in the worst case, if the folders aren\\'t that list of `folders`\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n\\n        for log in logs:\\n            if log.startswith(\\'../\\'):\\n                if stack:\\n                    stack.pop()\\n            elif log.startswith(\\'./\\'):\\n                continue\\n            else:\\n                stack.append(log)\\n\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882917,
                "title": "no-stack-c-only-5-lines-o-n-beast-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Simple Just **Count** the Number of **Folders** after all the **Operations**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans = 0;\\n        for(int i = 0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"../\" && ans>0) ans-=1;\\n            else if(logs[i]!=\"../\" && logs[i]!=\"./\") ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585614,
                "title": "easy-shit-solution-with-comments-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(string[] logs)\\n    {\\n        List<string> result = new List<string>();\\n        foreach (var item in logs)\\n        {\\n            if (item.Contains(\\'.\\'))\\n            {\\n                if(item.Length - item.Replace(\".\", \"\").Length == 2) \\n                    if(result.Count != 0)\\n                        result.RemoveAt(result.Count - 1);\\n            }\\n            else\\n            {\\n                result.Add(item);\\n            }\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447741,
                "title": "c-solution-stack",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tstack<string> st;\\n\\tfor (const string& s : logs) {\\n\\t\\tif (s == \"../\") {\\n\\t\\t\\tif (!st.empty())\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (s != \"./\")\\n\\t\\t\\tst.push(s);\\n\\t}\\n\\treturn st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364041,
                "title": "js-very-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let step = 0;\\n\\n    for (let i = 0; i < logs.length; i++) {\\n        const log = logs[i];\\n        if (log === \\'../\\') {\\n            if (step > 0) step--;\\n        } else if (log !== \\'./\\') {\\n            step++;\\n        }\\n    }\\n\\n    return step;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328986,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $count = 0;\\n        foreach($logs as $log) {\\n            if ($log == \\'../\\'){\\n                if ($count == 0) {\\n                    $count;\\n                } else {\\n                    $count -= 1;\\n                }\\n            } else if($log == \\'./\\'){\\n                $count;\\n            } else {\\n                $count += 1;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289154,
                "title": "very-simple-self-explanatory-stack-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = [] \\n        for lg in logs:\\n            if lg != \\'./\\':\\n                if lg != \\'../\\':\\n                    stack.append(lg)\\n                else:\\n                    if stack:\\n                        stack.pop()\\n        return len(stack)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240762,
                "title": "simple-python-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        for log in logs:\\n            if log == \"./\":\\n                continue\\n            elif log == \"../\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(log)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227317,
                "title": "solved-using-stacks-with-o-n",
                "content": "# Intuition\\nI see I need to store past elements.So stack can do it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n If else condition is used rather than while Because I just need to pop only 1 thing after comparision. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let stack=[]\\n    for(let i=0;i<logs.length;i++){\\n        if(stack.length!==0 && logs[i]===\\'../\\'){\\n            stack.pop()\\n        }else if(logs[i]===\\'./\\'){\\n            continue;\\n        }else if(logs[i]!==\\'../\\'){\\n            stack.push(logs[i])\\n        }\\n    }\\n    return stack.length\\n       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012115,
                "title": "easy-to-understand-beat-100-and-runtime-is-1ms-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] log) {\\n      int count=0;\\n        for(int i=0; i<log.length; i++)\\n        {\\n            \\n            if(!log[i].equals(\"./\") && !log[i].equals(\"../\"))\\n            {\\n                count++;\\n            }\\n            else if(log[i].equals(\"./\"))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(count!=0)\\n                {\\n                count--;\\n                }\\n            }\\n        }\\n        if(count<=0)\\n        {\\n            return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965693,
                "title": "easiest-c-approach-1ms-time",
                "content": "# Intuition\\nEasy c++ approach\\n\\n# Approach\\ncount the number of directoires else return back\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n=logs.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(logs[i] == \"./\")\\n                continue;\\n            if(logs[i] == \"../\")\\n                    c--;\\n            else\\n                c++;\\n            if(c<0)\\n                c=0;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925804,
                "title": "3-ms-no-stack-c",
                "content": "\\n\\n## Approach 1 : O(1) Space\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## Approach 2 : Stack\\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```       \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        int ans=0;\\n        for(string &it:logs)\\n        {\\n            if(it[it.size()-2]!=\\'.\\')\\n               ans++;\\n            else if(it==\"../\")\\n               ans=(ans==0)?0:ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` \\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>st;\\n        for(string &it:logs)\\n        {\\n            if(!st.empty() && it==\"../\")\\n                st.pop();\\n            else if(it[it.size()-2]!=\\'.\\')\\n                st.push(it);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707580,
                "title": "rust-fold-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter()\\n            .fold(0, |dep, op| {\\n                match op.as_str() {\\n                    // decrease depth (stop at zero)\\n                    \"../\" => {\\n                        match dep {\\n                            0 => dep,\\n                            _ => dep - 1,\\n                        }\\n                    }\\n                    \"./\" => dep, // no change\\n                    _ => dep + 1,  // increase depth\\n                }\\n             })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2688322,
                "title": "python-super-easy-no-stack",
                "content": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ans = 0\\n        \\n        for i in logs:\\n            if i[0] == \".\" and i[1] == \".\":\\n                ans -=1\\n                if ans < 0:\\n                    ans = 0\\n            elif i[0] == \".\" and i[1] == \"/\":\\n                continue\\n            else:\\n                ans +=1\\n        return ans```",
                "codeTag": "Java"
            },
            {
                "id": 2545524,
                "title": "java-easy-solution-99-75-fast",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int c=0;\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            \\n            if(logs[i].equals(\"../\")==true)c-=1;\\n            else if(logs[i].equals(\"./\")==true)continue;\\n            else c+=1;\\n            if(c<=0)c=0;\\n        }\\n        if(c<=0)return 0;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504472,
                "title": "java-easy-solution-by-count-variable",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"../\") && count>0)\\n                count--;\\n            else if(logs[i].equals(\"../\"))\\n                continue;\\n            else if(!logs[i].equals(\"./\"))\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464513,
                "title": "stack-java-simple-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n      Stack<String> stack=new Stack<>();\\n      int max=Integer.MIN_VALUE;\\n      for(int i=0;i<logs.length;i++)\\n      {\\n        if(!stack.isEmpty() && logs[i].equals(\"../\"))\\n          stack.pop();\\n        else if(!logs[i].equals(\"./\") && !logs[i].equals(\"../\"))\\n          stack.push(logs[i]); \\n      } \\n      return stack.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407966,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(auto x:logs){\\n            if(x==\"../\") count==0?0:count--;\\n            else if(x==\"./\") continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312308,
                "title": "very-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> str;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i] == \"./\"){\\n                continue;\\n            }\\n            else if(logs[i] == \"../\"){\\n                if(str.empty()){\\n                    continue;\\n                }\\n                str.pop();\\n            }\\n            else{\\n                str.push(logs[i]);\\n            }\\n        }\\n        return str.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284266,
                "title": "java-2-methods-explained",
                "content": "**Method 1:** Stack\\n* Let there be a stack indicating current state of directory. Moving inside a directory will be a push, and moving out will be push\\n* If log is alphanumeric, then push the log \\n* Else if log is `../` and stack is not empty, pop from stack, since you\\'re moving out from the current directory\\n* Else log is `./` and nothing needs to be done\\n* At the end, the size of stack will indicate how deep we are in the directory\\n>**T/S:** O(n)/O(n), where n = size(logs)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\\n**Method 2:** Space optimized version of method 1\\n* Notice that stack\\'s elements aren\\'t being used themselves, only push/pop/size are being used. \\n* This means we can replace the stack with a count variable and return that at the end\\n>**T/S:** O(n)/O(1)\\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tvar stack = new ArrayDeque<String>();\\n\\t\\n\\tfor (var log : logs)\\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tstack.push(log);\\n\\t\\telse if (!stack.isEmpty() && log.charAt(1) == \\'.\\')\\n\\t\\t\\tstack.pop();\\n\\treturn stack.size();\\n}\\n```\n```\\npublic int minOperations(String[] logs) {\\n\\tvar ops = 0;\\n\\t\\n\\tfor (var log : logs) \\n\\t\\tif (Character.isAlphabetic(log.charAt(0)) || Character.isDigit(log.charAt(0)))\\n\\t\\t\\tops++;\\n\\t\\telse if (ops > 0 && log.charAt(1) == \\'.\\')\\n\\t\\t\\tops--;\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273108,
                "title": "c-stack-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> s;\\n        \\n        for(auto x:logs)\\n        {\\n            if(x==\"../\")\\n            {\\n                if(!s.empty())\\n                    s.pop();// child removed if exist\\n            }\\n            else if(x!=\"./\")\\n                s.push(\"+\");// new child added.\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189303,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < logs.length; i++){\\n            if(logs[i].equals(\"./\")){\\n                continue;\\n            }\\n            else if(logs[i].equals(\"../\") ){\\n                if(count > 0){\\n                    count--;\\n                }\\n                \\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186704,
                "title": "java-easy-solution-100",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```\\n**Please UPVOTE  you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(int i=0;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"../\")){\\n                count--;\\n            }else if(logs[i].equals(\"./\")){\\n                count=count;\\n            }else{\\n                count++;\\n            }\\n            if(count<0) count=0;\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137723,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        c=0\\n        for i in range(len(logs)):\\n            if  logs[i]==\\'../\\' and c>0:\\n                c-=1\\n            elif logs[i]!=\\'../\\' and logs[i]!=\\'./\\' :\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107090,
                "title": "java-easy-faster-than-97",
                "content": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] s) {\\n        int res=0;\\n        for(String c:s){\\n            if(c.equals(\"../\")){\\n                res=Math.max(0,--res);\\n                \\n            }\\n            else if(c.equals(\"./\")){\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022176,
                "title": "crawler-log-folder-python3-solution",
                "content": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minOperations(self, logs: List[str]) -> int:\\n\\tstack =[]\\n\\tfor i in range(len(logs)):\\n\\t\\tif logs[i] ==\"../\":\\n\\t\\t\\tif stack !=[]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\telif logs[i] ==\"./\":\\n\\t\\t\\tcontinue\\n\\t\\telse:\\n\\t\\t\\tstack.append(logs[i])\\n\\treturn len(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2003637,
                "title": "python-easy-and-smart-solution-o-1-space-72ms",
                "content": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```\\nPlease **UPVOTE** if you liked the solution and do consider a follow.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# var for counting directories or depth \\ndirs = 0\\nfor i in logs:\\n\\tif i == \"../\":\\n\\t    # if there is any folder present then remove it and \\n\\t\\t# if no folder present i.e. dirs = 0 then no need to do anything, \\n\\t\\t# you are already in root directory\\n\\t\\tif dirs != 0:\\n\\t\\t\\tdirs -= 1\\n\\t# you have to remain in same directory hence no increment in dirs ..i.e. depth remains same\\n\\telif i == \"./\":\\n\\t\\tcontinue\\n\\telse:\\n\\t# increase the dirs count with 1. because a new directory is encountered and \\n\\t# depth of dirs is increased\\n\\t#   root / a / b / c / d     --- > depth = 4\\n\\t# so if you see everytime we encounter a new directory our depth increases.\\n\\t\\tdirs += 1\\n\\t\\t\\n# if directories left then return count of them \\nif dirs > 0:\\n\\treturn dirs\\n# else if there are 0 directories then return 0\\nelse:\\n\\treturn 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997483,
                "title": "c-simple-o-n",
                "content": "Just check for ../ and ./ and rest will be in else block.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int len = logs.size();\\n        int ans = 0;\\n        \\n        for(int i=0; i<len; i++) {\\n            if(logs[i]==\"../\")\\n            {\\n                ans--;\\n                ans<0?ans=0:ans=ans;\\n            }\\n            else if(logs[i]==\"./\") continue;\\n            else{\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997356,
                "title": "python-and-c-o-1-space",
                "content": "We are guaranteed that every folder will exist when called, so we don\\'t need to worry at all about that.\\n* If `log` is `\"../\"` we\\'ll go back up once (if we can)\\n* If `log` is not `\"../\"` we\\'ll go down once only if we are seeing a folder name, i.e. `log` is not `\"./\"`\\n\\n<hr>\\n\\n# Python solution\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\\n\\n# C++ solution\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        \\n        for log in logs:\\n            if log == \"../\":\\n                if depth > 0:\\n                    depth -= 1\\n            elif log != \"./\":\\n                depth += 1\\n                \\n        return depth\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        \\n        int depth = 0;\\n        \\n        for(auto log: logs){\\n            if(log == \"../\"){\\n                if(depth > 0){\\n                    depth--;\\n                }\\n            }\\n            else if(log != \"./\"){\\n                depth++;\\n            }\\n        }\\n        \\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997227,
                "title": "easy-stack-solution-simple-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& l) {\\n     stack<string> st;\\n     for(int i=0;i<l.size();i++){\\n         if(l[i]==\"./\"){\\n             continue;\\n         }else if(l[i]==\"../\"){\\n             if(st.size())\\n             st.pop();\\n         }else{\\n             st.push(l[i]);\\n         }\\n     }\\n            return st.size();\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965420,
                "title": "javascript",
                "content": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    let count = 0;\\n    for(i=0;i<logs.length;i++){\\n        if(logs[i] === \\'../\\') {\\n            if(count > 0)  count = count - 1;\\n            continue\\n        }\\n        if(logs[i] === \\'./\\') continue;\\n        else count = count + 1;\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943551,
                "title": "easiest-solution-without-using-stack",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let s = 0;\\n    \\n    logs.forEach(step => {\\n        if(step === \\'../\\') s = Math.max(0, --s);\\n        else if(step !== \\'./\\') s++;\\n    });\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933398,
                "title": "java-easy-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }else if (logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                l.add(logs[i]);\\n            }\\n        }\\n        return l.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        List<String> l = new ArrayList();\\n        \\n        for(int i=0;i<=logs.length-1;i++){\\n            if(logs[i].equals(\"../\")){\\n                if(l.size()-1>0)\\n                l.remove(l.size()-1);\\n                else l.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1933326,
                "title": "c-two-approach-with-stack-without-stack-simple-clean-code",
                "content": "**C++ Approach :**\\n\\n**Approach 1 : Space - O(N)**\\n```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\\n**Approach 2 : Space - O(1)**\\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n        stack<int> s;\\n        \\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(!s.empty())\\n                {\\n                    s.pop();\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                s.push(1);\\n            }\\n        }\\n        \\n        return s.size();\\n```\n```\\n\\t\\tint count=0;\\n        for(auto p:logs)\\n        {\\n            if(p==\"../\")\\n            {\\n                if(count>0)\\n                {\\n                    count--;\\n                }\\n            }\\n            else if(p==\"./\")\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932810,
                "title": "java-very-simple-solution-with-100-tc-and-97-space-complexity-solution",
                "content": "If \"../\" encountered return to the parent folder of that child\\nif \"./\" encountered then simply ignore and continue\\nif any other string encountered then simply goes to that file or increment the count\\n\\nAs easy as you thinks buddies ;)\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }\\n            else{\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n        int res=0;\\n        for(int i=0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res>0)res--;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1930803,
                "title": "java-solution-using-stack-faster-than-96-26",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }\\n           else if (log.equals(\"../\")){\\n                if (!stack.empty()){\\n                    stack.pop();\\n                }\\n            }\\n            else {\\n                 stack.push(\"a\");\\n            }\\n            \\n        }\\n        return stack.size();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stack = new Stack();\\n        \\n        for (String log: logs){\\n            \\n            if (log.equals(\"./\")){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1903464,
                "title": "java-solution-using-stack-simplest-you-can-find",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n       Stack<String> stack = new Stack<>();\\n       for(int i=0;i<logs.length;i++){\\n           if(stack.empty()&&(logs[i].contains(\"../\")||logs[i].contains(\"./\")))\\n               continue;\\n         if(logs[i].contains(\"../\"))\\n         {\\n             stack.pop();\\n         }\\n          else if(logs[i].contains(\"./\"))\\n          { \\n              stack.peek();\\n          }\\n           else stack.add(\"d\");\\n      }  \\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556542,
                "title": "short-code-0-n-and-0-1-c-easy-to-understand-100-faster-solution",
                "content": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int minOperations(vector<string>& logs) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]!=\"../\" and logs[i]!=\"./\")\\n                count++;\\n            \\n            else if(logs[i]==\"../\"){\\n                if(count>=2) count--;\\n                else count=0;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        \\n        \\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1540186,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<string>& logs) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]!=\"../\" && logs[i]!=\"./\")\\n            {\\n                stk.push(logs[i]);\\n            }\\n            else if(logs[i]==\"../\" && !stk.empty())\\n            {\\n                stk.pop();\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534807,
                "title": "c-90-fast-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }\\n           return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0; i<logs.size(); i++){\\n            string s=logs[i];\\n            if(s==\"../\") ans--;\\n            else if(s==\"./\") continue;\\n            else ans++;\\n            if(ans<0) ans=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1534633,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String temp:logs){\\n            if(temp.substring(0,2).equals(\"..\"))\\n                count=(count-1)<0?0:(count-1);\\n            else if(!temp.substring(0,2).equals(\"./\"))\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373644,
                "title": "c-simpe-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }else if(logs[i]==\"../\"){\\n                if(count>0){\\n                    count--;\\n                }\\n            }else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"./\"){\\n                count=count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1366348,
                "title": "simple-java-100",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        int depth = 0;\\n        for (String s : logs) {\\n            depth -= s.charAt(0) == \\'.\\' ? depth == 0 || s.charAt(1) == \\'/\\' ? 0 : 1 : -1;\\n        }\\n        return depth;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291927,
                "title": "easy-python-solution-93-94",
                "content": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 40 ms, faster than 93.94% of Python3 online submissions for Crawler Log Folder.\\nMemory Usage: 14.5 MB, less than 22.91% of Python3 online submissions for Crawler Log Folder.\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack=[]\\n        for i in logs:\\n            if(i==\\'../\\' and stack):\\n                stack.pop()\\n            elif(i==\\'./\\'):\\n                continue\\n            elif(i!=\\'../\\' ):\\n                stack.append(i)\\n        return len(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1247348,
                "title": "c-iterative-solution",
                "content": "If logs[i] == \"../\" dercrease the count variable but we can\\'t move beyond main folder so check if (count != 0) than only decrement the count, and we don\\'t have to do anything if we found \"./\" so check if (logs[i] != \"./\") it means logs[i] must be equal to \"x/\" so increment the count variable.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }\\n            else if (logs[i] != \"./\") count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n\\n        int count = 0;\\n        \\n        for (int i =0; i< logs.size(); i++){\\n            if (logs[i] == \"../\") {\\n                if (count != 0) count--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1229983,
                "title": "c-0ms-stack-easy-to-understand-with-explanation",
                "content": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//You can understand easily by understanding that pop is basically one step back, so that \\n//means \"../\" and \"./\" means we are in the same folder so it\\'s obvious continue there (i.e no \\n//pushing in stack) and the reamaining action is getting inside a folder, so pushing in the stack. \\n//So at the end if we simply return the size of stack that means we have to go that much back \\n//to reach the root folder. There are just few edge cases that you need to see carefully, rest it\\'s \\n//pretty easy.\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int n = logs.size();\\n        stack<string> s;\\n        for(int i=0; i<n; i++) {\\n            if(logs[i]==\"../\" && !s.empty()) s.pop();\\n            else if(logs[i]==\"./\") continue;\\n            else if(logs[i]==\"../\" && s.empty()) continue;  //special case\\n            else s.push(logs[i]);\\n        }\\n        \\n        return s.empty() ? 0 : s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221698,
                "title": "java-100-fast-easy-to-understand",
                "content": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(String[] logs) {\\n\\tint ops = 0;\\n\\tfor (String log : logs) {\\n\\t\\tif (log.equals(\"../\")) {\\n\\t\\t\\tif (ops != 0)\\n\\t\\t\\t\\tops--;\\n\\t\\t} else if (log.equals(\"./\")) {\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tops++;\\n\\t\\t}\\n\\t}\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220046,
                "title": "python-a-single-pass-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        counter = 0\\n        for log in logs:\\n            if log == \"../\":\\n                counter = max(0, counter - 1)\\n            elif log != \"./\":\\n                counter += 1\\n        return  counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208698,
                "title": "python-3-one-line",
                "content": "Use `reduce` to keep track of the depth as we iterate through the folders.\\nUse `dict.get` with a default value to calculate the depth change:\\n  * `../` -> depth - 1 (but no lower than 0)\\n  * `./` -> depth\\n  * anything else -> depth + 1 \\n\\n```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def minOperations(self, L: List[str]) -> int:\\n    return reduce(lambda d,l: {\"../\":max(d-1,0), \"./\":d}.get(l, d+1), L, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175717,
                "title": "js-straightforward-solution-with-stack-68ms",
                "content": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```\\nI\\'d love to hear your suggestions, thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(logs) {\\n    const stack = [];\\n\\n    for(let log of logs){\\n        if(log === \"../\") stack.pop();\\n        else if(log === \"./\") continue;\\n        else stack.push(log)\\n    }  \\n\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155639,
                "title": "java-ez-stack",
                "content": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }\\n            else if(!log.equals(\"./\"))\\n                stk.push(log);\\n        }\\n        return stk.size();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(String[] logs) {\\n\\t\\n        Stack<String> stk=new Stack<>();\\n        for(String log:logs)\\n        {\\n            if(log.equals(\"../\"))\\n            {\\n                if(stk.size()>0)\\n                    stk.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1154304,
                "title": "swift-100-no-stack",
                "content": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperations(_ logs: [String]) -> Int {\\n        var steps = 0\\n        for log in logs {\\n            switch log {\\n                case \"../\":\\n                    steps -= 1\\n                    steps = max(steps, 0)\\n                case \"./\":\\n                    break\\n                default:\\n                    steps += 1\\n            }\\n        }\\n        return steps\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131355,
                "title": "rust-clean-match",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_operations(logs: Vec<String>) -> i32 {\\n        logs.iter().fold(0, |acc, log| match log.as_str() {\\n            \"../\" if acc > 0 => acc - 1,\\n            \"../\" | \"./\" => acc,\\n            _ => acc + 1,\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110092,
                "title": "java-simple-solution-0ms-beats-100",
                "content": "If you think of the directory hierarchy as a tree structure, this question is simply to figure out where you stand in the tree (the depth from the root or the main folder in this case) after performing all the operations in the logs array.\\n\\nHaving said that, we start from the main folder, where depth is 0. \\n\\nWhen encounter  \"../\", depth decrease by 1,  unless depth is at 0, then stay at 0; \\n\\nWhen encounter \"./\", do nothing. \\n\\nOtherwise, when encounter any other String, depth increase by one. \\n\\nAt the end, the final depth value will be what it takes to return back to the main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        int depth = 0;\\n        for (String s : logs)\\n        {\\n           if (\"../\".equals(s))\\n           {\\n              depth = depth == 0 ? 0 : depth - 1;\\n           }\\n           else if (\"./\".equals(s));\\n           else\\n           {\\n               depth++;\\n           }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095666,
                "title": "simple-java-solution-no-stack",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int counter = 0;\\n        for(int i =0 ;i<logs.length;i++){\\n            \\n            if(logs[i].equals(\"./\"))\\n                continue;\\n            else if(logs[i].equals(\"../\")){\\n                counter -=1;\\n            }else{\\n                counter++;\\n            }\\n            if(counter <0){\\n                counter = 0;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048167,
                "title": "go-solution-faster-than-100",
                "content": "The else if with `long != \"../\"` is here because in the first if it says if `len(stack) > 0 && log == \"../\"` which means that if `log == \"../\"` and `len(stack)` is smaller than `0` the code will just append `\"../\"`\\n\\n```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperations(logs []string) int {\\n\\tstack := []string{}\\n\\n\\tfor _, log := range logs {\\n\\t\\tif len(stack) > 0 && log == \"../\" {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else if log == \"./\" {\\n\\t\\t\\tcontinue\\n\\t\\t} else if log != \"../\" { \\n\\t\\t\\tstack = append(stack, log)\\n\\t\\t}\\n\\t}\\n\\tfmt.Println(stack)\\n\\treturn len(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896197,
                "title": "c-simple-and-understandable-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count=0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(logs[i]==\"./\")continue;\\n            if(logs[i]==\"../\" && count==0)continue;\\n            if(logs[i]==\"../\" && count!=0)count--;\\n            else count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883835,
                "title": "stack-based-solution-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& A) {\\n        stack<int> st;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(A[i].size() == 3 and A[i][0] == \\'.\\'){\\n                if(st.size() > 0 )  // move up the folder means u can remove it  only if there is an element\\n                    st.pop(); // left in stack\\n            }else if(A[i].size() == 2 and A[i][0] == \\'.\\'){ // do nothing\\n                \\n            }else{\\n                st.push(1);  // increase stack size \\n            }\\n        }\\n        return st.size();  // return size of stack\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883234,
                "title": "easy-python-solution-time-better-than-70-space-better-than-90",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```\\nGITHUB for more solutions: https://github.com/Kushagrabainsla/Leetcode_DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        stack_top = -1\\n        pointer = 0\\n        while pointer < len(logs):\\n            if logs[pointer] == \"../\":\\n                if stack_top != -1:\\n                    stack.pop(-1)\\n                    stack_top-=1\\n                pointer+=1\\n            elif logs[pointer] == \"./\":\\n                pointer+=1\\n            else:\\n                stack.append(logs[pointer])\\n                stack_top+=1\\n                pointer+=1\\n        return len(stack)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 882024,
                "title": "c-4-ms-and-8-ms-solutions-stack-approach-o-1-space",
                "content": "***Runtime: 4 ms, faster than 99.25% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 11 MB, less than 12.36% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\\n\\n***Runtime: 8 ms, faster than 89.41% of C++ online submissions for Crawler Log Folder.\\nMemory Usage: 10.7 MB, less than 71.34% of C++ online submissions for Crawler Log Folder.***\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> path;\\n        for(auto log:logs){\\n            if(log == \"../\" && !path.empty()){\\n                path.pop();\\n            }\\n            if(log != \"../\" && log != \"./\"){\\n                path.push(log);\\n            }\\n        }\\n        return path.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int result = 0;\\n        for(auto log:logs){\\n            if(log == \"../\"){\\n                result = max(0, result-1);\\n            }else if(log != \"./\"){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878901,
                "title": "simple-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int level = 0;\\n        for (String log : logs) {\\n            if (log.equals(\"../\")) {\\n                if (level > 0) level--;\\n            } else if (log.equals(\"./\")) {\\n                \\n            } else {\\n                level++;\\n            }\\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876216,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs,int cnt=0) {\\n        for(auto str:logs){\\n            if(str==\"../\")  cnt = max(0,--cnt);\\n            else if(str!=\"./\") cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872459,
                "title": "a-c-python-3-solution-stack-time-complexity-o-n-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stack = []\\n        n = len(logs)\\n        for i in range(n):\\n            a = logs[i]\\n            print (\"i  = \", i, \" a = \", a)\\n            if (a == \"../\"):\\n                if (len(stack) > 0):\\n                    stack.pop()\\n            elif (a == \"./\"):\\n                continue\\n            else:\\n                stack.append(a)\\n                \\n        print (\"end stack = \", stack)\\n        return len(stack)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 867307,
                "title": "c-easy-solution-o-n",
                "content": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minOperations(vector<string>& logs) {\\n\\tint res = 0;\\n\\tfor (string s : logs) {\\n\\t\\tif (s == \"./\")\\n\\t\\t\\tcontinue;\\n\\t\\telse if (s != \"../\")\\n\\t\\t\\tres++;\\n\\t\\telse if (res)\\n\\t\\t\\tres--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867016,
                "title": "swift-beats-100-simple-solution",
                "content": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc minOperations(_ logs: [String]) -> Int {\\n      var count = 0\\n      for log in logs where log != \"./\" {\\n        count += log == \"../\" ? -1 : 1\\n        count = count < 0 ? 0 : count\\n      }\\n      return count\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866969,
                "title": "100-faster-100-memory-c-c-javascript-java",
                "content": "C\\n```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\\nJavaScript\\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minOperations(char ** logs, int logsSize){\\n    int res = 0;\\n        for(int i =0;i<logsSize;i++){\\n            if(strcmp(logs[i],\"./\") == 0)continue;\\n            else if(strcmp(logs[i],\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.size();i++){\\n            if(logs[i].compare(\"./\") == 0)continue;\\n            else if(logs[i].compare(\"../\") == 0){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i =0;i<logs.length;i++){\\n            if(logs[i].equals(\"./\"))continue;\\n            else if(logs[i].equals(\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```\n```\\nvar minOperations = function(logs) {\\n    var res = 0;\\n        for(var i =0;i<logs.length;i++){\\n            if(logs[i] == (\"./\")){}\\n            else if(logs[i] == (\"../\")){\\n                if(res !=0)res--;\\n            }\\n            else res++;\\n        }\\n        \\n        return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866794,
                "title": "beginner-friendly-solution-with-clean-explanation",
                "content": "Number of operations to get back to main folder is equal to the number of levels we are away from main folder.\\nTo keep track of number of levels (depth) we are in, let us use `res` variable.\\n`res = 0` for main folder.\\n\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int res = 0;\\n        for(int i=0;i<logs.length;i++){\\n            String currOperation = logs[i];\\n\\t\\t\\t//If not home and back operation - We go back one level.\\n            if(res>0 && \"../\".equals(currOperation)) res--; \\n\\t\\t\\t//If ./ or if (main folder and ../) we do nothing.\\n            else if(currOperation.startsWith(\".\")) continue;\\n\\t\\t\\t//If forward operation - We add one level.\\n            else res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866691,
                "title": "c-straightforward-single-pass-with-brief-explanation-o-1-space",
                "content": "**Brief Explanation**\\nIncrement minimum operations required for every move to child folder. Decrement minimum operations required **iff** currently the minimum operations required are greater than **0** (*i.e. we are not at the main folder already*) and current operation is move to parent folder.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int min_ops = 0;\\n        for (const auto& log: logs) {\\n            if (log[0] != \\'.\\') {\\n                min_ops++;\\n            }\\n            else if (log == \"../\" && min_ops > 0) {\\n                min_ops--;\\n            }\\n        }\\n        return min_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866604,
                "title": "python-easy-short-obvious",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        depth=0\\n        for operation in logs:\\n            if operation==\"../\": depth = max(0, depth -1)\\n            if (operation != \"../\") and (operation !=\"./\"): depth += 1\\n                \\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866552,
                "title": "c-1-liner",
                "content": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\\nNormal version:\\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```\\nT: O(n)\\nS: O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minOperations(vector<string>& logs) {\\n    return accumulate(logs.begin(), logs.end(), 0, [](int n, const string &s) { return s == \"../\" ? max(0, n - 1) : (s == \"./\" ? n : n + 1); });\\n}\\n```\n```cpp\\nint minOperations(vector<string>& logs) {\\n    int ans = 0;\\n    for (auto & s : logs) {\\n        if (s == \"../\")\\n            ans = max(0, ans - 1);\\n        else if (s != \"./\")\\n            ++ans;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866537,
                "title": "java-very-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for (String l : logs) {\\n            if (l.charAt(1)==\\'.\\') {\\n                if (depth > 0) {\\n                    depth--;\\n                }\\n            } else if (l.charAt(0)!=\\'.\\') depth++;\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866405,
                "title": "c-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int op = 0;\\n        \\n        for(int i = 0 ; i < logs.size() ; i++)\\n        {\\n            if(logs[i][0] != \\'.\\') // go inside folder\\n            {\\n                op++;\\n            }\\n            else if(logs[i][1] != \\'/\\') // ../\\n            {\\n                op = max(op-1 , 0); \\n            }\\n            else\\n            {\\n                // do nothing\\n            }\\n        }\\n        return max(0,op);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866401,
                "title": "simple-python3-solution-o-n",
                "content": "The approach is very simple. Whenever **\"../\"** is encountered **decrement** ops by one ( only if ops is not zero), if **\"./\"** is encountered do **nothing** ( i.e don\\'t update ops ).\\n\\nFinally if we encounter any other **string** in the list just **increment** the value of ops by one because no matter what it is ( for eg. it can be **\"d1/\"**,**d2/** etc )we are supposed to enter into new child file\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        ops=0\\n        for i in range(len(logs)):\\n            if logs[i]==\\'../\\':\\n                if ops==0:\\n                    continue\\n                ops-=1\\n            elif logs[i]==\\'./\\':\\n                continue\\n            else:\\n                ops+=1\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866395,
                "title": "c-o-n-time-o-1-space",
                "content": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 132 ms\\nMemory Usage: 25.3 MB\\n```\\n    public int MinOperations(string[] logs) {\\n        \\n        int depth = 0;\\n        \\n        foreach(string k in logs)\\n        {\\n            if (k == \"./\") { continue; }\\n            if (k == \"../\") { if (depth > 0) { depth--; } }\\n            else { depth++; }\\n        }\\n        \\n        return depth;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866394,
                "title": "java-efficient-solution-using-map",
                "content": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(String[] logs) {\\n        Map<String, Integer> map = new HashMap<>();\\n        map.put(\"./\", 0);\\n        map.put(\"../\", -1);\\n        \\n        int ans = 0;\\n        for(int i=0;i<logs.length;i++) {\\n            if(map.containsKey(logs[i])) {\\n                ans += map.get(logs[i]);\\n                if(ans < 0) ans = 0;\\n            } else {\\n                ans += 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 866385,
                "title": "go",
                "content": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "solutionTags": [],
                "code": "func minOperations(logs []string) int {\\n    var level int \\n    \\n    for i := range logs {\\n        if logs[i] == \"./\" {\\n            continue\\n        } else if logs[i] == \"../\" {\\n            level = max(level -1 , 0)\\n        } else {\\n            level++\\n        }\\n    }\\n    return level\\n    \\n}\\nfunc max(i,j int) int {\\n    if i >= j {\\n        return i\\n    }\\n     \\n    return j\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 866381,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    let level = 0;\\n    for(let i=0; i<logs.length; i++){\\n        if(logs[i]===\"../\"){\\n            if(level!==0){\\n                level--;\\n            }\\n        }else if(logs[i]===\"./\"){\\n            continue;\\n        }else{\\n            level++;\\n        }\\n    }\\n    return level;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866355,
                "title": "python-easy-sol-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        \\n        for item in logs:\\n            if item == \\'../\\':\\n                if count > 0:\\n                    count -= 1\\n            \\n            elif item == \\'./\\':\\n                pass\\n            \\n            else:\\n                count += 1\\n            \\n            \\n        return count if count > 0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866353,
                "title": "kotlin-o-n",
                "content": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun minOperations(logs: Array<String>): Int {\\n        var counter = 0\\n        \\n        logs.forEach { log ->\\n            when (log) {\\n                \"../\" -> counter = maxOf(0, counter - 1)\\n                \"./\" -> Unit // Do nothing\\n                else -> counter++\\n            }\\n        }\\n        \\n        return counter\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866352,
                "title": "stack-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        \\n        stack=[]\\n        stack.append(\".\")\\n        for operation in logs:\\n            \\n            if operation==\"./\":\\n                continue\\n            elif operation==\"../\":\\n                if len(stack)>1:\\n                    stack.pop()\\n            else:\\n                stack.append(operation)\\n        return len(stack)-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866348,
                "title": "easy-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        vector<string> v;\\n        for(string s : logs){\\n            if(s == \"../\"){\\n                if(v.empty()) continue;\\n                v.pop_back();\\n            }\\n            \\n            else if(s == \"./\"){\\n                continue;\\n            }\\n        \\n            else{\\n                v.push_back(s);\\n            }\\n            \\n        }\\n        return (int)v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866341,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int ans = 0;\\n        for(String s: logs){\\n            ans = s.charAt(0) != \\'.\\' ? ans + 1 : s.charAt(1) == \\'.\\' ? Math.max(0, ans-1) : ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087660,
                "title": "1ms-simple-4-line-approach",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the current directory level.\\n2. Iterate through each string log in the logs array.\\n3. For each log entry:\\n- If it is \"../\" (representing moving up one level in the directory hierarchy), decrement count by 1, but only if count is greater than 0 (to avoid going below the root level).\\n- If it is \"./\" (representing staying in the current directory), skip this log entry and continue to the next one.\\n- For any other log entry, increment count by 1, representing moving into a subdirectory.\\n4. After processing all log entries, count will represent the minimum number of operations required to reach the final directory.\\n5. Return the count as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each log entry in the logs array, so the time complexity is O(n), where n is the number of log entries.\\n\\n- Space complexity:\\nThe code uses a single integer variable count, so the space complexity is O(1), as it doesn\\'t depend on the size of the input.\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count=0;\\n        for(String log: logs){\\n            if(log.equals(\"../\")) count=count==0?0:count-1;\\n            else if(log.equals(\"./\")) continue;\\n            else count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083989,
                "title": "96-89-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function(logs) {\\n    const stack = []\\n    logs.forEach((each)=>{\\n        if(each === \"../\"){\\n            stack.pop()\\n        }else if( each == \\'./\\'){}\\n        else{\\n            stack.push(each)\\n        }\\n    })\\n\\n    return stack.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072573,
                "title": "no-stack-no-problem",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        level = 0\\n        for log in logs:\\n            if log == \\'../\\':\\n                level -= 1 if level > 0 else 0\\n            elif log == \\'./\\':\\n                continue\\n            else:\\n                level += 1\\n        return level\\n\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064511,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int ans=0;\\n        for(int i=0;i<logs.size();i++){\\n            if(logs[i]==\"../\"){\\n                if(ans>0){\\n                    ans--;\\n                }\\n            }else{\\n                    if(logs[i]!=\"./\"){\\n                        ans++;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062491,
                "title": "simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nvar minOperations = function (logs) {\\n    console.log(logs);\\n    var ct = 0;\\n    for (var i = 0; i < logs.length; i++) {\\n        if (logs[i] == \"../\" ) {\\n            if( ct != 0)\\n            {\\n                ct--;\\n            }\\n        }\\n        if (logs[i] != \"./\" && logs[i] != \"../\") {\\n            ct++;\\n        }\\n    }\\n    if (ct <= 0) {\\n        return 0;\\n    }\\n    return ct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058241,
                "title": "beginner-friendly-just-a-linear-traversal-optimize-solution-100-beats-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int depth=0;\\n        for(String log : logs){\\n            if(log.equals(\"./\")) continue;\\n            else if(log.equals(\"../\")){\\n                depth--;\\n                if(depth < 0) depth = 0;\\n            }\\n            else depth++;\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052451,
                "title": "java-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        for(String c: logs){\\n            if(c.equals(\"../\")){\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }\\n            }\\n            else if (c.equals(\"./\")){\\n                  continue;\\n            }\\n            else{\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050431,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> st = new Stack<>();\\n        for(int i=0;i<logs.length;i++){\\n            if(st.size()== 0 && logs[i].equals(\"../\")){\\n                continue;\\n            }\\n            if(st.size()>0 && logs[i].equals(\"../\")){\\n                st.pop();\\n            }\\n            else if(logs[i].equals(\"./\")){\\n                continue;\\n            }else{\\n                st.push(logs[i]);\\n            }\\n        }\\n      \\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043161,
                "title": "java-simple-approach-using-stack",
                "content": "# Intuition\\nStack used\\n\\n# Approach\\npush :- For the folder\\npop :- \"../\" \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String> stack = new Stack<>();\\n        int ans = 0;\\n        for (String log : logs) {\\n            if (!stack.isEmpty() && log.equals(\"../\")) {\\n                stack.pop();\\n            } else if (log.equals(\"./\")) {\\n                continue;\\n            } else if (!log.equals(\"../\")) {\\n                stack.push(log);\\n            }\\n        }\\n        ans = stack.size();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032650,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        depth = 0\\n        for log in logs:\\n            if \"..\" in log:\\n                if depth:\\n                    depth -= 1\\n            elif \".\" not in log:\\n                depth += 1\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029933,
                "title": "fastest-response-time-say-hii-amit-flutter",
                "content": "# Intuition\\n1. Remove \"./\" from list becase there is no effect of it so it will save loop time and memory\\n2. if i found \"../\" then minStep counter will decrese it means back to main but if we are alredy on main then do notheing (if minStep == 0 no need --)\\n3. if there are any folder name then we will increse steps\\n\\n# Code\\n```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```\\n\\n*need **memory usage is still 50%** need help to improve it drop your comment below\\n\\n## Connect with me here : \\nhttps://linktr.ee/amit.flutter",
                "solutionTags": [
                    "Dart",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  int minOperations(List<String> logs) {\\n    int minStep = 0;\\n    logs.removeWhere((item) => item == \"./\");\\n    \\n    for (int i = 0; i < logs.length; i++) {\\n      if (logs[i] == \"../\") {\\n        if (minStep > 0) minStep--;\\n      } else\\n        minStep++;\\n    }\\n    return minStep;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024271,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(string[] logs)\\n    {\\n        var depth = 0;\\n        foreach (var log in logs)\\n        {\\n            if (log == \"../\")\\n            {\\n                if (depth > 0)\\n                {\\n                    depth--;\\n                }\\n            }\\n            else if (log != \"./\")\\n            {\\n                depth++;\\n            }\\n        }\\n\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014791,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction minOperations(logs: string[]): number {\\n    let count: number = 0;\\n    for(let dir of logs){\\n        if(dir === \\'./\\') continue;\\n        if(dir === \\'../\\') {\\n            count = count == 0 ? 0 : --count;\\n             continue;\\n        }\\n        ++count;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013882,
                "title": "c-stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid push(int stack[],int *t,int val,int l)\\n{\\n    if(*t==l-1) return;\\n    else\\n    stack[++(*t)];\\n}\\nvoid pop(int *t)\\n{\\n    if(*t==-1) return;\\n    else\\n    (*t)--;\\n}\\nint minOperations(char ** logs, int logsSize){\\n  char stack[logsSize];\\n  int top=-1;\\n  for(int i=0;i<logsSize;i++)\\n  {\\n      if(strcmp(logs[i],\"../\")==0) pop(&top);\\n      else if(strcmp(logs[i],\"./\")==0) continue;\\n      else push(stack,&top,i+1,logsSize);\\n  }\\n  int m=0;\\n  while(top>=0)\\n  {\\n      m++;\\n      top--;\\n  }\\n  return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008572,
                "title": "easy-cpp-solution-beats-90-70-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/682a1150-642f-40f6-8880-81f5d4c4b631_1693982120.7181227.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string> st;\\n        int sz = logs.size();\\n        \\n        for(int i=0; i<sz; i++){\\n            if(logs[i] == \"../\"){\\n                if(st.size()) st.pop();\\n            }\\n            else if(logs[i] != \"./\"){\\n                st.push(logs[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003760,
                "title": "using-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply by using if else\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        count = 0\\n        for i in range(0,len(logs)):\\n            if logs[i] == \"./\":\\n                count+=0\\n            elif logs[i] == \"../\":\\n                if count>0:\\n                    count-=1\\n                else:\\n                    count\\n            else:\\n                count+=1\\n        if count>0:\\n            return count\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996617,
                "title": "c-solution-using-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have used iterative approach here. But if you want, you can also use stack to solve it.\\n\\n# Approach\\nIterative approach\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        int count = 0;\\n\\n        for (int i = 0; i < logs.size(); i++) {\\n            if (logs[i] == \"./\") {\\n                // Do nothing, stay in the same folder\\n            } else if (logs[i] == \"../\") {\\n                // Go up to the parent folder\\n                if (count > 0) {\\n                    count--;\\n                }\\n            } else {\\n                // Move to a child folder\\n                count++;\\n            }\\n        }\\n\\n        return max(0, count);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988567,
                "title": "easy-to-understand-better-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n        stack<string>s1;\\n        for(string s : logs){\\n            if(s == \"./\"){\\n                continue;\\n            }\\n            else if(s == \"../\"){\\n                if(s1.size() != 0){\\n                   s1.pop();\\n                }   \\n            }\\n            else{\\n                s1.push(s);\\n            }\\n        }\\n        return s1.size();\\n    }\\n}; // please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988503,
                "title": "php-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $logs\\n     * @return Integer\\n     */\\n    function minOperations($logs) {\\n        $steps = 0;\\n        foreach ($logs as $log) {\\n            if ($log === \\'./\\') {\\n                continue;\\n            }\\n\\n            if ($log === \\'../\\') {\\n                $steps = $steps > 0 ? $steps - 1 : $steps;\\n            } else {\\n                $steps++;\\n            }\\n        }\\n        return $steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984841,
                "title": "java-and-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Java\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\\n\\n# Python\\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int main = 0;\\n        for(String log: logs){\\n            if(log.endsWith(\"../\") && main > 0){\\n                main -= 1;\\n            }else if(log.endsWith(\"./\")){\\n                main += 0;\\n            }else{\\n                main += 1;\\n            }\\n        }\\n        return main;\\n    }\\n}\\n```\n```\\n def minOperations(self, logs: List[str]) -> int:\\n        step = 0\\n        for log in logs:\\n            print(log)\\n            if log.endswith(\"../\") and step > 0:\\n                step -= 1\\n            elif log.endswith(\"./\"):\\n                step += 0\\n            elif log.endswith(\"/\"):\\n                step += 1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984665,
                "title": "c-easy-constant-memory-solution",
                "content": "# Intuition\\nNo need to record the events/directories in a stack.\\n\\n# Approach\\nMaintain a counter which tracks how far we are from the main folder at any point\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Time: O(N)\\n    // Space: O(1)\\n    int minOperations(vector<string>& A) {\\n        int op_count = 0;\\n        for (string& s : A) {\\n            if (s == \"../\") {\\n                if (op_count != 0)\\n                    op_count--;\\n            }\\n            else if (s == \"./\") continue;\\n            else op_count++;\\n        }\\n\\n        return op_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984278,
                "title": "python-stack-easy-beginner-friendly",
                "content": "# Please upvote if you find it useful\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, logs: List[str]) -> int:\\n        stk = []\\n        for operation in logs:\\n            if operation == \"../\":\\n                if stk:\\n                    stk.pop()\\n            elif operation != \"./\":\\n                stk.append(operation)\\n        return len(stk)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982099,
                "title": "simple-solution-using-stack-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We can use a stack to record the number of files away from main we are.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> We will pop from the stack when we need to go back and we can push to the stack when we move forwards.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        \\n        // we will use a stack to keep track of our distance from the main file\\n        Stack<Integer> stack = new Stack<>();\\n\\n        // we will check each operation and convert it to an \"action\"\\n        for(String op: logs) {\\n            \\n            // if operation is \"go back\" then we will pop a value of the stack\\n            if(op.equals(\"../\")) {\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n            // if the operation is not \"stay in place\" and not \"go back\" then we will add to the top of the stack    \\n            } else if(!op.equals(\"./\")) {\\n                stack.push(1);\\n            }\\n        }\\n        \\n        // we will return the size of the stack as that is the number of operations away from main we are.\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981476,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} logs\\n * @return {number}\\n */\\nconst minOperations = function(logs) {\\n\\n    let result = 0\\n\\n    for (let i = 0; i < logs.length; i++) {\\n\\n        let curr = logs[i]\\n\\n        if (curr === \\'./\\') {\\n            result = result\\n        } else if (curr === \\'../\\' && result > 0) {\\n            result--\\n        } else if (curr === \\'../\\' && result === 0) {\\n            result = result\\n        } else {\\n            result++\\n        }\\n\\n    }\\n\\n    return result\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979514,
                "title": "easy-and-fast-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - to check if the file vistited and this movement is into the child of this file do `if(a[0]==act[o]&&a[length-2]==act[length-3]`\\n - for example d12 and d121  \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<string>& logs) {\\n     stack<string>st;\\n     for(string act:logs){\\n         if(act==\"../\"){\\n             if(!st.empty())\\n              st.pop();\\n         }\\n        else if(act==\"./\")\\n           continue;\\n        else{\\n          if(!st.empty()){\\n           string a=st.top();\\n            if(a[0]==act[0]&&a[a.length()-2]==act[act.length()-3])\\n               continue;\\n          }\\n          st.push(act);\\n        }\\n     }\\n     int op=0;\\n     while(!st.empty()){ \\n      op++;\\n     st.pop();\\n     }\\n     return op;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978876,
                "title": "clean-concise-readable-and-easy-to-understand-code",
                "content": "# Intuition\\n  Simple approach dude : If we encounter \"x/\" folder then simply we have to push it into the stack and as soon as we encounter \"../\" this string then simply we have to pop the last folder from the stack because this is how the folder works , as suppose firstly I am in the D drive then i move to it\\'s child E drive so when I write \"../\" so when I pop E from the stack then I will reach back to the D drive again . That\\'s why I have pushed \"x/\" named folder in the Stack and when I countered \"../\" this string so I have popped the last folder from the stack. No need to check for the string \"./\" because it means that we should remain sit in the same folder means we don\\'t have to perform any operation so there is no point to check for it as we don\\' have do anything in such cases .\\n\\nIn the end simply return the size of the stack because the element present in the stack took us to came out from that folder to main folder.\\n\\n# Approach\\n  LIFO based approach .\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        Stack<String>stack = new Stack<>();\\n        for(String s:logs){\\n            if(!s.equals(\"../\") && !s.equals(\"./\")) stack.push(s);\\n            else if(s.equals(\"../\") && !stack.isEmpty()) stack.pop();\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975874,
                "title": "kotlin-simple-solution-with-when",
                "content": "# Intuition\\nClarity of code, one cycle.\\n\\n# Approach\\nCycle for the input array, \"when\" for founded actions in array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(logs: Array<String>): Int {\\n        var countDownDirectories = 0\\n\\n        for (i in logs){\\n            when (i){\\n                \"./\" -> continue\\n                \"../\" -> {\\n                    if (countDownDirectories > 0) countDownDirectories --\\n                }\\n                else -> countDownDirectories ++\\n            }\\n        }\\n\\n        return countDownDirectories\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967403,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(String[] logs) {\\n        int count = 0;\\n        for(int i=0; i<logs.length; i++){\\n            // if first character of log is digit or character then increment the count.\\n            char ch = logs[i].charAt(0);\\n            if((ch >= \\'a\\' && ch <= \\'z\\') || Character.isDigit(ch)){\\n                count++;\\n            }\\n            // if log is equals to \"../\" and count is less than or equals to 0 then don\\'t increment count.\\n            else if(logs[i].equals(\"../\")){\\n                if(count<=0) continue;\\n                else count--;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(count < 0) count = 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1798209,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1980281,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2022316,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 2019251,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1979113,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1968836,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            },
            {
                "id": 1930046,
                "content": [
                    {
                        "username": "fuc-",
                        "content": "The 2 hints provided are the same, kindly look into it! Cheers!"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The question setter went out of Hints. :3"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "The guy who used Stack for solving this question should be declared as the most hardworking person on this planet after ChatGPT."
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "haha\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "The solution is simple.\\n->create count varable\\n->If first char of log[i] is digit or charcter i.e(d2/, h21/) etc. Then increment count\\n->if you face \"../\" decrement count.\\n-> if you encounter \"./\" leave it \\n\\nSorry for my bad English.\\n"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "when there is a stack, there is always a +1, -1.\\nconstant space\\uD83D\\uDE43"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "just create a stack and append or pop folders to the stack based on the operations... then return the length of the stack"
                    },
                    {
                        "username": "jtoumi",
                        "content": "the description is misleading !!!\\nThis might help: think about how to get the final depth (after all operations have been performed)  "
                    },
                    {
                        "username": "anmol_8862",
                        "content": "The description is tricky.\\nyou need to give the minimum operation required to go back to main folder after performing whole operations of the given logs array"
                    }
                ]
            }
        ]
    }
]