[
    {
        "title": "Maximum Subsequence Score",
        "question_content": "You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\n\tThe sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\n\tIt can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\nOutput: 12\nExplanation: \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\n\nExample 2:\n\nInput: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\nOutput: 30\nExplanation: \nChoosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t1 <= n <= 105\n\t0 <= nums1[i], nums2[j] <= 105\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 3082106,
                "title": "java-c-python-priority-queue",
                "content": "# **Intuition**\\nAlmost exactly same as\\n[1383. Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/discuss/539687/JavaC%2B%2BPython-Priority-Queue).\\n<br>\\n\\n# **Explanation**\\nWe iterate all pairs `(A[i], B[i])` with `B[i]` from big to small,\\nWe keep the priority queue with maximum size of `k`.\\nEach time when we introduce a new pair of `(A[i], B[i])`,\\nthe current minimum value on B is `B[i]`\\nthe current sum value on A is `sum(priority queue)`\\n\\nIf the size of queue > k,\\nwe pop the minimum `A[i]`.\\nalso update total `sum -= A[i]`\\n\\nIf the size of queue == k,\\nwe update `res = res = max(res, sum * B[i])`\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maxScore(int[] speed, int[] efficiency, int k) {\\n        int n = speed.length;\\n        int[][] ess = new int[n][2];\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = new int[] {efficiency[i], speed[i]};\\n        Arrays.sort(ess, (a, b) -> b[0] - a[0]);\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> a - b);\\n        long res = 0, sumS = 0;\\n        for (int[] es : ess) {\\n            pq.add(es[1]);\\n            sumS = (sumS + es[1]);\\n            if (pq.size() > k) sumS -= pq.poll();\\n            if (pq.size() == k) res = Math.max(res, (sumS * es[0]));\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long maxScore(vector<int>& speed, vector<int>& efficiency, int k) {\\n        int n = speed.size();\\n        vector<pair<int, int>> ess(n);\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = {efficiency[i], speed[i]};\\n        sort(rbegin(ess), rend(ess));\\n        long long sumS = 0, res = 0;\\n        priority_queue <int, vector<int>, greater<int>> pq; //min heap\\n        for (auto& [e, s] : ess) {\\n            pq.emplace(s);\\n            sumS += s;\\n            if (pq.size() > k) {\\n                sumS -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k)\\n                res = max(res, sumS * e);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxScore(self, A, B, k):\\n        total = res = 0\\n        h = []\\n        for a,b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]):\\n            heappush(h, a)\\n            total += a\\n            if len(h) > k:\\n                total -= heappop(h)\\n            if len(h) == k:\\n                res = max(res, total * b)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long maxScore(int[] speed, int[] efficiency, int k) {\\n        int n = speed.length;\\n        int[][] ess = new int[n][2];\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = new int[] {efficiency[i], speed[i]};\\n        Arrays.sort(ess, (a, b) -> b[0] - a[0]);\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> a - b);\\n        long res = 0, sumS = 0;\\n        for (int[] es : ess) {\\n            pq.add(es[1]);\\n            sumS = (sumS + es[1]);\\n            if (pq.size() > k) sumS -= pq.poll();\\n            if (pq.size() == k) res = Math.max(res, (sumS * es[0]));\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long maxScore(vector<int>& speed, vector<int>& efficiency, int k) {\\n        int n = speed.size();\\n        vector<pair<int, int>> ess(n);\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = {efficiency[i], speed[i]};\\n        sort(rbegin(ess), rend(ess));\\n        long long sumS = 0, res = 0;\\n        priority_queue <int, vector<int>, greater<int>> pq; //min heap\\n        for (auto& [e, s] : ess) {\\n            pq.emplace(s);\\n            sumS += s;\\n            if (pq.size() > k) {\\n                sumS -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k)\\n                res = max(res, sumS * e);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maxScore(self, A, B, k):\\n        total = res = 0\\n        h = []\\n        for a,b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]):\\n            heappush(h, a)\\n            total += a\\n            if len(h) > k:\\n                total -= heappop(h)\\n            if len(h) == k:\\n                res = max(res, total * b)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082737,
                "title": "c-easiest-solution-using-priority-queue-with-explanation",
                "content": "# Intuition\\nThe idea is to consider for each element of array of nums2[i] as minimum once and check for maximum possible values available in nums1 keeping in mind nums2[i] as minimum .\\n\\n# Approach\\n- First we sort the nums2 array in decreasing order and as we need to know the mapping of nums2[i] to nums1[i]  so for that we make their pairs and then we sort.\\n\\n- Now we we will iterate through p array one by one and let p[i].first as the minimum for an instance then all the elements to left of p array can be considered for sum part.\\n\\n- But we can make priority queue for knowing top k elements to left of p array \\n\\n- And we will only keep k maximum elements at a time in priority queue and keep the tab of their sum .\\n\\n- Now please read the code and you will understand it . Upvotes are appreciated  \\n\\n# Complexity\\n- Time complexity: O( N * Log(N) + (N-k) * Log(k) )\\n\\n- Space complexity: O(N) + O(k) = O(N+K)\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n       vector<pair<int, int>> p ;\\n        \\n        for(int i = 0 ; i<nums1.size() ; i++)\\n        {\\n            p.push_back({nums2[i] , nums1[i]});\\n        }\\n        \\n        sort(p.rbegin() , p.rend());\\n        \\n        long long ans  = 0;\\n        long long sum  = 0;\\n        priority_queue<int> pq;\\n        for(int i = 0 ; i<k-1 ; i++)\\n        {\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n        }\\n\\n        for(int i = k-1 ; i<nums1.size() ; i++)\\n        {\\n\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n            \\n            ans = max(ans, sum * p[i].first );\\n\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n       vector<pair<int, int>> p ;\\n        \\n        for(int i = 0 ; i<nums1.size() ; i++)\\n        {\\n            p.push_back({nums2[i] , nums1[i]});\\n        }\\n        \\n        sort(p.rbegin() , p.rend());\\n        \\n        long long ans  = 0;\\n        long long sum  = 0;\\n        priority_queue<int> pq;\\n        for(int i = 0 ; i<k-1 ; i++)\\n        {\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n        }\\n\\n        for(int i = k-1 ; i<nums1.size() ; i++)\\n        {\\n\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n            \\n            ans = max(ans, sum * p[i].first );\\n\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083376,
                "title": "easy-c-with-intuition-and-detailed-explanation-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith the given constraints, we can\\'t find all possible subsequences and find out the maximum score as it will lead to TLE O(2^n). \\nTherefore, there has to be a way to optimally find the solution.\\n\\nNow, we know that:\\n\\n```\\nScore = Sum of selected elements from nums1 * \\n        min of corresponding selected elements from nums2\\n```\\n\\nTo maximize score we need to maximize both the sum and the multiplier\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will maintain 2 heaps:\\n1. Maxheap to maintain the maximum elements from nums1 \\n2. Minheap to find the minimum element amongst the k elements chosen (which will be our multiplier)\\n\\nNow, maxheap will help us by providing next better for our sum and minheap will help us find the limiting value for our score. \\n\\nSo, initially will consider the scenario where we have the best sum (we don\\'t know about the multiplier yet. It may be the worst for our score). We will calculate the sum of top k elements from maxheap and push the corresponding elements from nums2 to minheap. \\n\\nNow, the top element from minheap is our multipler. If we think carefully, we have no scope of making our sum better since we have chosen the top k elements. So, the only limiting factor here could be the multiplier (which is the min value of the corresponding nums2). \\n\\nSo, what to do next? We will subtract the corresonding element from nums1 for which the multipilier is minimum and find the next greater element from nums2 (using maxheap). Add the element to sum and push the corresponding element in nums2 to minheap. We will continue this till we exhaust all elements in the maxheap.\\n\\nLet\\'s look at it with the help of an example:\\n\\nGiven: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\\n\\n1. MaxHeap (value, index): [<3,1>,<3,2>,<2,3>,<1,0>]\\n2. Take the sum of top 3 elements: 3+3+2 = 8 and remove all k elements MaxHeap (value, index): [<1,0>]\\n3. Push all the corresponding k elements from nums2 to MinHeap i.e. we will push elements at indices 1,2,3 which are 1,3,4.\\n4. MinHeap (value, index): [<1,1>,<3,2>,<4,3>]\\n5. Multiplier = top element = 1\\n6. Score = sum * multiplier = 8*1=8\\n\\nNow, here since the minimum element in min heap is 1, it is our limiting factor. We should see if we can somehow get a better multiplier but ensuring that sum is not compromised. \\n\\nSo, we will remove the top element from our MinHeap and reduce the correspondinng sum. \\n\\n1. Remove (value, index) : <1,1> from MinHeap. \\nMinHeap (value, index): [<3,2>,<4,3>].\\nAlso subtract element at index 1 for nums1 from sum. The element is 3. \\n2. Sum = 8-3 = 5\\n3. Pick next top element from MaxHeap (value, index): [<1,0>] and add it to sum\\n4. Sum = 5+1 = 6\\n5. Push corresponding element (index 0) from nums2 to MinHeap to find multiplier\\n6. MinHeap (value, index): [<2,0>,<3,2>,<4,3>]\\n7. Multiplier = top element = 2\\n8. Score = sum * multiplier = 6*2=12\\n\\nSince, we don\\'t have any more elements in maxHeap this is our best ans.\\n\\n# Code\\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // stores <value,index> from nums1 in decreasing order of values \\n        priority_queue<pii> maxHeap;\\n        // stores <value,index> from nums2 in increasing order of values \\n        priority_queue<pii,vector<pii>,greater<pii>> minHeap;\\n\\n        long long ans=INT_MIN;\\n        long long score=0;\\n        long long sum=0;\\n        \\n        // push all the elements from nums1 into maxheap\\n        for(int i=0;i<nums1.size();i++) {\\n            maxHeap.push({nums1[i],i});\\n        }\\n        \\n        // sum the max k elements of nums1 and push the corresponding elements from nums2 into\\n        // minHeap\\n        while(!maxHeap.empty() && k>0) {\\n            pii top = maxHeap.top();\\n            sum+=top.first;\\n            minHeap.push({nums2[top.second],top.second});\\n            maxHeap.pop();\\n            k--;\\n        }\\n\\n        // the top element from minHeap will give us the multiplier (min ele) to be multiplied\\n        // with the sum\\n        int minmul=minHeap.top().first;\\n\\n        // calculate score for the top k elements and update ans\\n        score=sum*minmul;\\n        ans=max(ans,score);\\n         \\n        while(!maxHeap.empty()) {\\n            // get the minimum element from minHeap. This is our current multiplier\\n            // that is limiting our score. So, we will try to find a better ele to get max\\n            // score\\n            pii mintop=minHeap.top();\\n            // subtract the corresponding ele from nums1\\n            sum-=nums1[mintop.second];\\n            minHeap.pop();\\n\\n            // get the next max element from the maxHeap to be added to sum\\n            pii maxtop=maxHeap.top();\\n            // add the element to sum\\n            sum+=maxtop.first;\\n            // push the correspoding ele to minHeap\\n            minHeap.push({nums2[maxtop.second],maxtop.second});\\n            maxHeap.pop();\\n\\n            // get the limiting (min) value from minHeap\\n            minmul=minHeap.top().first;\\n            // update score and ans\\n            score=sum*minmul;\\n            ans=max(ans,score);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nScore = Sum of selected elements from nums1 * \\n        min of corresponding selected elements from nums2\\n```\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // stores <value,index> from nums1 in decreasing order of values \\n        priority_queue<pii> maxHeap;\\n        // stores <value,index> from nums2 in increasing order of values \\n        priority_queue<pii,vector<pii>,greater<pii>> minHeap;\\n\\n        long long ans=INT_MIN;\\n        long long score=0;\\n        long long sum=0;\\n        \\n        // push all the elements from nums1 into maxheap\\n        for(int i=0;i<nums1.size();i++) {\\n            maxHeap.push({nums1[i],i});\\n        }\\n        \\n        // sum the max k elements of nums1 and push the corresponding elements from nums2 into\\n        // minHeap\\n        while(!maxHeap.empty() && k>0) {\\n            pii top = maxHeap.top();\\n            sum+=top.first;\\n            minHeap.push({nums2[top.second],top.second});\\n            maxHeap.pop();\\n            k--;\\n        }\\n\\n        // the top element from minHeap will give us the multiplier (min ele) to be multiplied\\n        // with the sum\\n        int minmul=minHeap.top().first;\\n\\n        // calculate score for the top k elements and update ans\\n        score=sum*minmul;\\n        ans=max(ans,score);\\n         \\n        while(!maxHeap.empty()) {\\n            // get the minimum element from minHeap. This is our current multiplier\\n            // that is limiting our score. So, we will try to find a better ele to get max\\n            // score\\n            pii mintop=minHeap.top();\\n            // subtract the corresponding ele from nums1\\n            sum-=nums1[mintop.second];\\n            minHeap.pop();\\n\\n            // get the next max element from the maxHeap to be added to sum\\n            pii maxtop=maxHeap.top();\\n            // add the element to sum\\n            sum+=maxtop.first;\\n            // push the correspoding ele to minHeap\\n            minHeap.push({nums2[maxtop.second],maxtop.second});\\n            maxHeap.pop();\\n\\n            // get the limiting (min) value from minHeap\\n            minmul=minHeap.top().first;\\n            // update score and ans\\n            score=sum*minmul;\\n            ans=max(ans,score);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092528,
                "title": "easiest-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow should we approach this problem?\\n- We want to maximize sum * min of subsequence pair\\n- At most, there can be **n-k+1** min values no matter how are you going to chose the sub-sequence, right? This is key!!!!\\n- For each of the n-k+1 min values, we want the max sum (when there\\'s duplicates)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We create pair of both array into a new array (you could also create an sorted index array, same idea)\\n- Sort the new pair array by second array value in descending order\\n- use an priorityqueue/minHeap of exact size k to maintain top k of all values you met so far from array for max sum of each min value\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note\\nCredit to [@yinyu0430](https://leetcode.com/yinyu0430/), who suggested to initialized priorityqueue with size k+1 instead of k, great suggestion!\\n\\n# [85 ms](https://leetcode.com/problems/maximum-subsequence-score/submissions/884758697/)\\n```java\\nclass Solution {\\n    record Pair(int a, int b) {}\\n    public long maxScore(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; ++i) pairs[i] = new Pair(a[i], b[i]);\\n        Arrays.sort(pairs, (x, y) -> y.b - x.b);\\n        Queue<Integer> q = new PriorityQueue<>(k+1);\\n        long res = 0, sum = 0;\\n        for (var p : pairs) {\\n            q.add(p.a);\\n            sum += p.a;\\n            if (q.size() > k) sum -= q.poll();\\n            if (q.size() == k) res = Math.max(res, sum * p.b);\\n        }\\n        return res;\\n    }\\n}\\n```\\n# [83 ms](https://leetcode.com/problems/maximum-subsequence-score/submissions/884758198/)\\nslight optimization, slightly faster, longer code, avoid of size checks\\n```java\\nclass Solution {\\n    record Pair(int a, int b) {}\\n    public long maxScore(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; ++i) pairs[i] = new Pair(a[i], b[i]);\\n        Arrays.sort(pairs, (x, y) -> y.b - x.b);\\n        Queue<Integer> q = new PriorityQueue<>(k+1);\\n        long res = 0, sum = 0;\\n\\n        int i = 0;\\n        for (; i < k; i++) {\\n            int x = pairs[i].a;\\n            sum += x;\\n            q.add(x);\\n        }\\n        res = Math.max(res, sum * pairs[i-1].b);\\n\\n        for (; i < n; i++) {\\n            q.add(pairs[i].a);\\n            sum += pairs[i].a;\\n            sum -= q.poll();\\n            res = Math.max(res, sum * pairs[i].b);\\n        }\\n        return res;\\n    }\\n}\\n```\\nPLEASE UPVOTE IF YOU FIND THIS POST HELPFUL, THANK YOU!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    record Pair(int a, int b) {}\\n    public long maxScore(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; ++i) pairs[i] = new Pair(a[i], b[i]);\\n        Arrays.sort(pairs, (x, y) -> y.b - x.b);\\n        Queue<Integer> q = new PriorityQueue<>(k+1);\\n        long res = 0, sum = 0;\\n        for (var p : pairs) {\\n            q.add(p.a);\\n            sum += p.a;\\n            if (q.size() > k) sum -= q.poll();\\n            if (q.size() == k) res = Math.max(res, sum * p.b);\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    record Pair(int a, int b) {}\\n    public long maxScore(int[] a, int[] b, int k) {\\n        int n = a.length;\\n        Pair[] pairs = new Pair[n];\\n        for (int i = 0; i < n; ++i) pairs[i] = new Pair(a[i], b[i]);\\n        Arrays.sort(pairs, (x, y) -> y.b - x.b);\\n        Queue<Integer> q = new PriorityQueue<>(k+1);\\n        long res = 0, sum = 0;\\n\\n        int i = 0;\\n        for (; i < k; i++) {\\n            int x = pairs[i].a;\\n            sum += x;\\n            q.add(x);\\n        }\\n        res = Math.max(res, sum * pairs[i-1].b);\\n\\n        for (; i < n; i++) {\\n            q.add(pairs[i].a);\\n            sum += pairs[i].a;\\n            sum -= q.poll();\\n            res = Math.max(res, sum * pairs[i].b);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557261,
                "title": "python3-heap-similar-questions-beats-98",
                "content": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res, prefixSum, minHeap = 0, 0, []\\n        \\n        for a, b in sorted(list(zip(nums1, nums2)), key=itemgetter(1), reverse=True):\\n            prefixSum += a\\n            heappush(minHeap, a)\\n            if len(minHeap) == k:\\n                res = max(res, prefixSum * b)\\n                prefixSum -= heappop(minHeap)                               \\n        \\n        return res\\n```\\n[857. Minimum Cost to Hire K Workers](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/description/)\\n\\n```\\nclass Solution:\\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\\n        res, qualitySum, maxHeap = float(\\'inf\\'), 0, []\\n\\n        for ration, q in sorted([(w / q, q) for w, q in zip(wage, quality)]):\\n            qualitySum += q\\n            heappush(maxHeap, -q)\\n            if len(maxHeap) == k:\\n                res = min(res, qualitySum * ration)\\n                qualitySum -= -heappop(maxHeap)\\n        \\n        return res\\n```\\n[1383. Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/description/)\\n\\n```\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        res, speedSum, minHeap = 0, 0, []\\n        \\n        for ef, sp in sorted(zip(efficiency, speed), reverse=True):\\n            speedSum += sp\\n            heappush(minHeap, sp)\\n            res = max(res, speedSum * ef)\\n            if len(minHeap) == k:\\n                speedSum -= heappop(minHeap)\\n        \\n        return res % (10**9 + 7)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res, prefixSum, minHeap = 0, 0, []\\n        \\n        for a, b in sorted(list(zip(nums1, nums2)), key=itemgetter(1), reverse=True):\\n            prefixSum += a\\n            heappush(minHeap, a)\\n            if len(minHeap) == k:\\n                res = max(res, prefixSum * b)\\n                prefixSum -= heappop(minHeap)                               \\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\\n        res, qualitySum, maxHeap = float(\\'inf\\'), 0, []\\n\\n        for ration, q in sorted([(w / q, q) for w, q in zip(wage, quality)]):\\n            qualitySum += q\\n            heappush(maxHeap, -q)\\n            if len(maxHeap) == k:\\n                res = min(res, qualitySum * ration)\\n                qualitySum -= -heappop(maxHeap)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        res, speedSum, minHeap = 0, 0, []\\n        \\n        for ef, sp in sorted(zip(efficiency, speed), reverse=True):\\n            speedSum += sp\\n            heappush(minHeap, sp)\\n            res = max(res, speedSum * ef)\\n            if len(minHeap) == k:\\n                speedSum -= heappop(minHeap)\\n        \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082373,
                "title": "min-heap",
                "content": "It\\'s tricky to figure out data structures for this problem.\\n\\nWe use the index array `id`, and sort it so that indices are in the decreasing order of `n1`.\\n\\nUsing that index array, we sum elements in `n1` (going from largest to smallest), tracking the corresponding `{n2[i], n1[i]}` pair in the min heap `pq`.\\n\\nWhen we got `k` elements, we compute the score by multiplying the sum by the `n2` value on top of the min heap (smallest among all included elements).\\n\\nWe then pop the smallest `n2` value from the heap, and subtract the corresponding `n1` value from the sum.\\n\\n**Why is this the optimal strategy?**\\n\\nIf we do not remove the smallest `n2` value from the current list of elements, the score can only decrease:\\n- Multiplier from `n1` will not change (still the smallest one).\\n- The sum will not increase as we process elements in `n1` from largest to smallest.\\n\\n**C++**\\n```cpp\\nlong long maxScore(vector<int>& n1, vector<int>& n2, int k) {\\n    long long res = 0, sum = 0;\\n    vector<int> id(n1.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){ return n1[i] > n1[j]; });\\n    priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for (int i : id) {\\n        sum += n1[i];\\n        pq.push({ n2[i], n1[i] });\\n        if (pq.size() >= k) {\\n            res = max(res, pq.top().first * sum);\\n            sum -= pq.top().second;\\n            pq.pop();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maxScore(vector<int>& n1, vector<int>& n2, int k) {\\n    long long res = 0, sum = 0;\\n    vector<int> id(n1.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){ return n1[i] > n1[j]; });\\n    priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    for (int i : id) {\\n        sum += n1[i];\\n        pq.push({ n2[i], n1[i] });\\n        if (pq.size() >= k) {\\n            res = max(res, pq.top().first * sum);\\n            sum -= pq.top().second;\\n            pq.pop();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082539,
                "title": "sort-priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long n = nums1.size(), s = 0, ans = 0;\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums2[i], nums1[i]});\\n        sort(v.begin(), v.end());\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            pq.push(v[i].second);\\n            s += v[i].second;\\n            if(pq.size() > k) {\\n                s -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size() == k) ans = max(ans, v[i].first * s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long n = nums1.size(), s = 0, ans = 0;\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums2[i], nums1[i]});\\n        sort(v.begin(), v.end());\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            pq.push(v[i].second);\\n            s += v[i].second;\\n            if(pq.size() > k) {\\n                s -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size() == k) ans = max(ans, v[i].first * s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557464,
                "title": "java-naive-recursion-brute-force-approach",
                "content": "```\\n// Approach 1:  Naive Recursion (Brute Force Approach) - TLE\\n\\n// Time complexity: O(2^n)\\n// Space complexity: O(2^n)\\n\\nclass Solution {\\n    int[] nums1, nums2;\\n \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        return helper(0, 0, Integer.MAX_VALUE, k);\\n    }\\n    \\n     private int helper(int i, int sum, int min, int k) {\\n        if (k == 0) \\n            return sum * min;\\n         \\n        if (i >= nums1.length) \\n            return 0;\\n\\t\\t\\n\\t\\tint picked = helper(i + 1, sum + nums1[i], Math.min(min, nums2[i]), k - 1);\\n        int notPicked = helper(i + 1, sum, min, k);\\n\\t\\t\\n        return Math.max(picked, notPicked); \\n    }\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Approach 1:  Naive Recursion (Brute Force Approach) - TLE\\n\\n// Time complexity: O(2^n)\\n// Space complexity: O(2^n)\\n\\nclass Solution {\\n    int[] nums1, nums2;\\n \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        \\n        return helper(0, 0, Integer.MAX_VALUE, k);\\n    }\\n    \\n     private int helper(int i, int sum, int min, int k) {\\n        if (k == 0) \\n            return sum * min;\\n         \\n        if (i >= nums1.length) \\n            return 0;\\n\\t\\t\\n\\t\\tint picked = helper(i + 1, sum + nums1[i], Math.min(min, nums2[i]), k - 1);\\n        int notPicked = helper(i + 1, sum, min, k);\\n\\t\\t\\n        return Math.max(picked, notPicked); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557369,
                "title": "c-line-by-line-explanation-sorting-easy-to-understand",
                "content": "# Approach\\n\\nThe question is asking to return the maximum score of all the k size subsequeces, where the score is product of sum of elements selected elements of nums1 and the minimu element of corresponding indices element of nums2.\\n\\nHere we have been asked to multiply the sum with the minimum of the corrosponding nums2 element. So we can store the nums1 and nums2 elements in a **vector pair and sort based on the nums2 elements** so that we can get minimum of each and every subsequences in one go.\\n\\nNow we will traverse **all the window of size k** form end (if we have sorted the pair array in ascending order) and store the  maximum result. \\n\\nAfter traversing first window we will go on for the next window and will remove the minimum nums1 element from the selected one as we need to maximize the score abd the nums2 is sorted so we need to maximize the sum. For this we need one **priority queue (min heap)** \\n\\nFor examle: If we  have nums1=[2,1,14,12] and nums2=[11,7,13,6] with k=3.\\n\\nWe will first make vector pair and the sort based on num2 element\\ni.e vec=[[11,2],[7,1],[13,14],[6,12]] --> [[6,12],[7,1],[11,2],[13,14]] (after sorting)\\nafter this we will traverse k size with a min heap:-\\ni.e first iteration will be currSum=14+2+1=17 and the score will be currSum * min=17 * 7=119 with heap {1,2,14} in it.\\n\\nAfter first iteration we will go on for the rest elements i.e. index 0\\nfor this we will remove the least selected element (top of the min heap) and add the current element (to make the window of size k only)\\nso our currSum will be 17-1(removing the min elemnt) and then add the current nums1 element i.e. currSum will be 16+12=28\\nSo the score for this window will be 28*6=168\\n\\nHence answer of this example will be 168\\n\\n**Time Complexity:** *nlogn* where n is the size of array\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>>vec;\\n        for(int i=0; i<n; i++)\\n            vec.push_back({nums2[i],nums1[i]});//store nums2[i] and nums1[i] as pair to sort according to nums2[i]\\n        \\n        sort(vec.begin(),vec.end());//will give sorted array in ascending order basred on the nums2[i]\\n        \\n        long long res=0,currSum=0;\\n        priority_queue<int, vector<int>, greater<int>>pq;//we need priority queue (min heap) so that we can remove the minimum element from the selected element as we are bound to take only k elements \\n        \\n        for(int i=n-1; i>n-1-k; i--)\\n        {\\n            pq.push(vec[i].second);//push nums1[i] in the min heap\\n            currSum+=vec[i].second;//store the sum of all those numbers\\n        }\\n        \\n        res=max(res,currSum*vec[n-k].first);//and the score will be sum*(minimum of selected index of nums2[i])\\n        \\n        for(int i=n-1-k; i>=0; i--)//now we will run the loop over all the starting form the last selected index to get the naximum score(if any)\\n        {\\n            int mini=pq.top();\\n            pq.pop();\\n            currSum-=mini;//we will remove the smallest number of all the taken numbers till now and will add the current number\\n            \\n            currSum+=vec[i].second;\\n            pq.push(vec[i].second);\\n            \\n            res=max(res,currSum*vec[i].first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**cout<<Please Upvote! \\uD83D\\uDE4F<<endl;**",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>>vec;\\n        for(int i=0; i<n; i++)\\n            vec.push_back({nums2[i],nums1[i]});//store nums2[i] and nums1[i] as pair to sort according to nums2[i]\\n        \\n        sort(vec.begin(),vec.end());//will give sorted array in ascending order basred on the nums2[i]\\n        \\n        long long res=0,currSum=0;\\n        priority_queue<int, vector<int>, greater<int>>pq;//we need priority queue (min heap) so that we can remove the minimum element from the selected element as we are bound to take only k elements \\n        \\n        for(int i=n-1; i>n-1-k; i--)\\n        {\\n            pq.push(vec[i].second);//push nums1[i] in the min heap\\n            currSum+=vec[i].second;//store the sum of all those numbers\\n        }\\n        \\n        res=max(res,currSum*vec[n-k].first);//and the score will be sum*(minimum of selected index of nums2[i])\\n        \\n        for(int i=n-1-k; i>=0; i--)//now we will run the loop over all the starting form the last selected index to get the naximum score(if any)\\n        {\\n            int mini=pq.top();\\n            pq.pop();\\n            currSum-=mini;//we will remove the smallest number of all the taken numbers till now and will add the current number\\n            \\n            currSum+=vec[i].second;\\n            pq.push(vec[i].second);\\n            \\n            res=max(res,currSum*vec[i].first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557445,
                "title": "java-solution-for-maximum-subsequence-score-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to select the top k pairs with the highest nums2 values and calculate the maximum possible score based on the given formula.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a 2D array pairs to store pairs of elements from nums1 and nums2.\\n1. Sort the pairs array in descending order based on the nums2 values.\\n1. Use a min-heap (PriorityQueue) topKHeap to maintain the top k elements from nums1.\\n1. Initialize topKSum to store the sum of the top k elements from nums1 and calculate it while adding elements to the heap.\\n1. Calculate the initial score using the last element in the top k pairs.\\n1. Iterate from k to n in pairs array.\\n- Remove the smallest element from the topKHeap and update topKSum by subtracting the removed element.\\n- Add the current element from pairs to the topKHeap and update topKSum by adding the current element.\\n- Update the answer by comparing the current score with the maximum score so far.\\n7. Return the answer, which represents the maximum possible score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n log n), where n is the length of nums1. The main time-consuming step is the sorting of pairs, which takes O(n log n) time. The subsequent iteration from k to n takes O(n) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) because we are using additional space to store the pairs array and the min-heap (PriorityQueue).\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        // Sort pair (nums1[i], nums2[i]) by nums2[i] in decreasing order.\\n        int n = nums1.length;\\n        int[][] pairs = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n\\n        // Use a min-heap to maintain the top k elements.\\n        PriorityQueue<Integer> topKHeap = new PriorityQueue<>();\\n        long topKSum = 0;\\n        for (int i = 0; i < k; ++i) {\\n            topKSum += pairs[i][0];\\n            topKHeap.add(pairs[i][0]);\\n        }\\n\\n        // The score of the first k pairs.\\n        long answer = topKSum * pairs[k - 1][1];\\n\\n        // Iterate over every nums2[i] as minimum from nums2.\\n        for (int i = k; i < n; ++i) {\\n            // Remove the smallest integer from the previous top k elements\\n            // then add nums1[i] to the top k elements.\\n            topKSum += pairs[i][0] - topKHeap.poll();\\n            topKHeap.add(pairs[i][0]);\\n\\n            // Update answer as the maximum score.\\n            answer = Math.max(answer, topKSum * pairs[i][1]);\\n        }\\n\\n        return answer;\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        // Sort pair (nums1[i], nums2[i]) by nums2[i] in decreasing order.\\n        int n = nums1.length;\\n        int[][] pairs = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n\\n        // Use a min-heap to maintain the top k elements.\\n        PriorityQueue<Integer> topKHeap = new PriorityQueue<>();\\n        long topKSum = 0;\\n        for (int i = 0; i < k; ++i) {\\n            topKSum += pairs[i][0];\\n            topKHeap.add(pairs[i][0]);\\n        }\\n\\n        // The score of the first k pairs.\\n        long answer = topKSum * pairs[k - 1][1];\\n\\n        // Iterate over every nums2[i] as minimum from nums2.\\n        for (int i = k; i < n; ++i) {\\n            // Remove the smallest integer from the previous top k elements\\n            // then add nums1[i] to the top k elements.\\n            topKSum += pairs[i][0] - topKHeap.poll();\\n            topKHeap.add(pairs[i][0]);\\n\\n            // Update answer as the maximum score.\\n            answer = Math.max(answer, topKSum * pairs[i][1]);\\n        }\\n\\n        return answer;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082024,
                "title": "priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        priority_queue<pair<int,int>> nums2_max;\\n        // lets push all the elements of nums2 along with idxs into priority queue to get largest elements of nums2\\n        for(int i=0;i<n;i++){\\n            nums2_max.push({nums2[i] , i});\\n        }\\n        long long curr_sum = 0 , mini = INT_MAX , ans = 0;\\n        priority_queue<int,vector<int>,greater<int>>temp;\\n        // \\'temp\\' priority queue stores the elements of nums1 that are contibuting curr_sum\\n        \\n        // let\\'s get the top k elements from nums2 and the minimum of those elements will be stored in \\'mini\\'\\n        // also the sum of corresponding element\\'s nums1 we will store in \\'curr_sum\\'\\n        while(k--){\\n            auto top = nums2_max.top();\\n            nums2_max.pop();\\n            mini = top.first;\\n            curr_sum+= nums1[top.second];\\n            temp.push( nums1[top.second]);\\n        }\\n        ans = curr_sum*mini; // setting the curr_sum*mini as answer considering k top indices of nums2        \\n        // Now we will remove that element/index which is contributing least in sum\\n        // and add a element which will be corresponding the next(k+1 for first iteration) element\\n        while(nums2_max.size()){\\n            curr_sum-=temp.top();    temp.pop();       // removing a element which is contributing least to curr_sum\\n            auto top = nums2_max.top();     nums2_max.pop();\\n            mini = top.first;\\n            curr_sum+= nums1[top.second];\\n            ans = max(ans , curr_sum*mini);\\n            temp.push(nums1[top.second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        priority_queue<pair<int,int>> nums2_max;\\n        // lets push all the elements of nums2 along with idxs into priority queue to get largest elements of nums2\\n        for(int i=0;i<n;i++){\\n            nums2_max.push({nums2[i] , i});\\n        }\\n        long long curr_sum = 0 , mini = INT_MAX , ans = 0;\\n        priority_queue<int,vector<int>,greater<int>>temp;\\n        // \\'temp\\' priority queue stores the elements of nums1 that are contibuting curr_sum\\n        \\n        // let\\'s get the top k elements from nums2 and the minimum of those elements will be stored in \\'mini\\'\\n        // also the sum of corresponding element\\'s nums1 we will store in \\'curr_sum\\'\\n        while(k--){\\n            auto top = nums2_max.top();\\n            nums2_max.pop();\\n            mini = top.first;\\n            curr_sum+= nums1[top.second];\\n            temp.push( nums1[top.second]);\\n        }\\n        ans = curr_sum*mini; // setting the curr_sum*mini as answer considering k top indices of nums2        \\n        // Now we will remove that element/index which is contributing least in sum\\n        // and add a element which will be corresponding the next(k+1 for first iteration) element\\n        while(nums2_max.size()){\\n            curr_sum-=temp.top();    temp.pop();       // removing a element which is contributing least to curr_sum\\n            auto top = nums2_max.top();     nums2_max.pop();\\n            mini = top.first;\\n            curr_sum+= nums1[top.second];\\n            ans = max(ans , curr_sum*mini);\\n            temp.push(nums1[top.second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557264,
                "title": "heap-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are given two  `0-indexed integer` arrays `nums1` and `nums2` of equal length n and a positive integer `k`. You must choose a subsequence of indices from `nums1` of length `k`.\\n\\nOur score can be defined as:\\n\\n1) The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\\n\\n2) It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\\n\\nWe want to return the `maximum` possible score\\n\\n## Explanation\\n\\nOur goal is to choose a subseqeuence of indices from `nums1` of length `k` and calculate the maximum possible score based on the provided formula for defined as score.\\n\\nWe can use  `min heap` approach to maintain sorted list of elements from `nums1`. By using `min heap`, we will be able to keep track of the `k` largest element from `nums1` in a sorted manner. This will ensure that we always have the largest element available to construct our subseqeuences.\\n\\nWe can consider the minimum values from `nums2` first. We can merge `nums1` and `nums2` into a single list and sort it in decreasing order based on the values of `nums2`. This will ensure that the minimum value from `nums2` are considered first. Since our score will be determined by multiplying the sum of selected elements from `nums1` with the minimum value from `nums2`. Since we are considering the minimum value first, we have increased the chnace of obtaining a `maximum` score\\n\\nKeeping a running sum called `total_sum` so that we can keep track of the sum of elements in the current subsequence. \\n \\n\\nWe will iterate through the merged element based on the maximum value of `nums2` and corresponding value from `nums1` respectiviely \\n\\nCheck if the heap is filled with `k` elements, the `smallest element` will be `removed` from the heap and subtracted from `total_sum` as this will update the sum by excluding the smallest element and adding a new element onto the subsequence and ensure the heap only constains `k` smallest element at any given time\\n\\nContinuously update `total_sum` by adding current values of `nums1` to calculate the current subsequence and push `nums1` values into min heap \\n\\nAgain, check if the heap is filled with `k` elements, this time instead of popping from heap and subtracting from total sum, we calculate our result as `total_sum * maxOf2` as we will multiply the sum of the current subsequecne by the maximum value of `nums2` corresponding with that subsequence and update our result based on which one is greater `total_sum * maxOf2` or `result`\\n\\nWe then return result\\n\\n\\n# Code\\n**Python**\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        result = 0\\n        total_sum = 0 \\n        heap = [] \\n       \\n        merged = [(nums2[i], nums1[i]) for i in range(len(nums1))]\\n        merged.sort(reverse=True)\\n\\n        for maxOf2, num1Val in merged: \\n            if len(heap) == k: \\n                total_sum -= heapq.heappop(heap)  \\n\\n            total_sum += num1Val\\n            heapq.heappush(heap, num1Val)  \\n           \\n            if len(heap) == k:\\n                result = max(result, total_sum * maxOf2) \\n        return result\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxScore = function(nums1, nums2, k) {\\n\\n    let result = 0;\\n    let totalSum = 0;\\n    let heap = new MinPriorityQueue({priority: (element) => element})\\n\\n    const merged = nums1.map((nums1Val, i) => [nums2[i], nums1Val])\\n    merged.sort((a,b) => b[0] - a[0])\\n\\n    for (const [maxOf2, num1Val] of merged){\\n        if(heap.size() === k){\\n            totalSum -= heap.dequeue().element\\n        }\\n\\n        totalSum += num1Val\\n        heap.enqueue(num1Val)\\n\\n        if(heap.size() === k){\\n            result = Math.max(result, totalSum * maxOf2)\\n        }\\n\\n    }\\n\\nreturn result\\n};\\n```\\n\\n\\n### Time Complexity: O(n log(k))\\n### Space Complexity: O(k)\\n\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        result = 0\\n        total_sum = 0 \\n        heap = [] \\n       \\n        merged = [(nums2[i], nums1[i]) for i in range(len(nums1))]\\n        merged.sort(reverse=True)\\n\\n        for maxOf2, num1Val in merged: \\n            if len(heap) == k: \\n                total_sum -= heapq.heappop(heap)  \\n\\n            total_sum += num1Val\\n            heapq.heappush(heap, num1Val)  \\n           \\n            if len(heap) == k:\\n                result = max(result, total_sum * maxOf2) \\n        return result\\n```\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxScore = function(nums1, nums2, k) {\\n\\n    let result = 0;\\n    let totalSum = 0;\\n    let heap = new MinPriorityQueue({priority: (element) => element})\\n\\n    const merged = nums1.map((nums1Val, i) => [nums2[i], nums1Val])\\n    merged.sort((a,b) => b[0] - a[0])\\n\\n    for (const [maxOf2, num1Val] of merged){\\n        if(heap.size() === k){\\n            totalSum -= heap.dequeue().element\\n        }\\n\\n        totalSum += num1Val\\n        heap.enqueue(num1Val)\\n\\n        if(heap.size() === k){\\n            result = Math.max(result, totalSum * maxOf2)\\n        }\\n\\n    }\\n\\nreturn result\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557189,
                "title": "java-sorting-priorityqueue-15-lines-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To simplify the problem we can first sort both arrays in descending order of the values of `nums2`. This way, as we traverse the arrays from beginning to end, we know that the current `nums2` value is the minimum so far.\\n2. Now all we need to do is to figure out the `k` largest values within `nums1` so far within the arrays. If we multiply the sum of all those by the current value of `nums2` we should get a possible answer.\\n3. To figure out the `k` largest values we can use a min heap and keep removing the root node (the minimum value) when the size of the heap exceeds `k`.\\n4. We can calculate all possible answers using the above strategy and keep computing the maximum out of those.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxScore(int[] nums1, int[] nums2, int k) {\\n    var n = nums1.length;\\n    var arr = new int[n][2];\\n\\n    for (var i=0; i<n; i++)\\n      arr[i] = new int[] {nums1[i], nums2[i]};\\n\\n    Arrays.sort(arr, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n    long ans = 0, sum = 0;\\n    var heap = new PriorityQueue<Integer>();\\n\\n    for (var i=0; i<n; i++) {\\n      heap.offer(arr[i][0]);\\n      sum += arr[i][0];\\n\\n      if (i >= k)\\n        sum -= heap.poll();\\n      \\n      if (i >= k-1)\\n        ans = Math.max(ans, sum * arr[i][1]);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public long maxScore(int[] nums1, int[] nums2, int k) {\\n    var n = nums1.length;\\n    var arr = new int[n][2];\\n\\n    for (var i=0; i<n; i++)\\n      arr[i] = new int[] {nums1[i], nums2[i]};\\n\\n    Arrays.sort(arr, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n    long ans = 0, sum = 0;\\n    var heap = new PriorityQueue<Integer>();\\n\\n    for (var i=0; i<n; i++) {\\n      heap.offer(arr[i][0]);\\n      sum += arr[i][0];\\n\\n      if (i >= k)\\n        sum -= heap.poll();\\n      \\n      if (i >= k-1)\\n        ans = Math.max(ans, sum * arr[i][1]);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558134,
                "title": "step-by-step-explanation-beginner-friendly-c-simple-solution-fastest",
                "content": "# Intuition\\nThe aim is to find the maximum score by pairing elements from two arrays (nums1 and nums2) and selecting a specified number of pairs \\'k\\'. We prioritize larger elements from nums2 and calculate the score by multiplying the sum of selected elements from nums1 with their corresponding elements from nums2. We use sorting and a rolling window approach to efficiently compute the maximum score.\\n\\n# Approach\\n1) Create a vector of pairs (v) to store the elements from nums1 and nums2. Each pair consists of an element from nums2 as the first value and the corresponding element from nums1 as the second value.\\n\\n2) Sort the vector v in non-increasing order using sort(v.rbegin(), v.rend()). This sorts the vector based on the first element of each pair in descending order.\\n\\n3) Initialize variables res and curr to 0. These variables will hold the maximum score and the current sum, respectively.\\n\\n4) Create a priority queue (pq) using priority_queue<int, vector<int>, greater<int>>. This creates a min-heap that will store the second values of the pairs in ascending order.\\n\\n5) Initialize variable i to 0. This will be used as an index to iterate through the elements of v.\\n\\n6) Enter a while loop that iterates while i is less than the size of nums1.\\n\\n7) Inside the loop, add v[i].second (the current second value of the pair) to curr to update the current sum.\\n\\n8) Push v[i].second into the priority queue pq.\\n\\n9) Check if i is greater than or equal to k-1, which means we have processed enough elements to form a subarray of length k.\\n\\n10) If the condition is true, calculate the product of curr and v[i].first (the current first value of the pair). Update res with the maximum value between the current res and the calculated product.\\n\\n11) Subtract the top element of pq from curr to remove the smallest element from the current sum.\\n\\n12) Pop the top element from pq.\\n\\n13) Increment i to move to the next element in v.\\n\\nReturn the maximum score stored in res.\\n\\n# Complexity\\n- Time complexity: The code involves sorting the v vector, which has a time complexity of O(N log N), where N is the size of nums1. The subsequent loop iterates over nums1, which takes O(N) time. Therefore, the overall time complexity is O(N log N).\\n\\n\\n- Space complexity:The code uses additional space to store the v vector and the priority queue pq, both of which can have a maximum size of N. Hence, the space complexity is O(N).\\n\\nUPVOTE. Glad to help.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        } \\n        sort(v.rbegin(),v.rend());\\n        long long res = 0;\\n        long long curr = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        int i=0;\\n        while(i<nums1.size()){\\n            curr+=v[i].second;\\n            pq.push(v[i].second);\\n            if(i>=k-1){\\n                res=max(res,curr*v[i].first);\\n                curr-=pq.top();\\n                pq.pop();\\n            }\\n            i++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<nums1.size();i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        } \\n        sort(v.rbegin(),v.rend());\\n        long long res = 0;\\n        long long curr = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        int i=0;\\n        while(i<nums1.size()){\\n            curr+=v[i].second;\\n            pq.push(v[i].second);\\n            if(i>=k-1){\\n                res=max(res,curr*v[i].first);\\n                curr-=pq.top();\\n                pq.pop();\\n            }\\n            i++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557236,
                "title": "diagram-image-explaination-c-full-optimized-priority-queue-well-explained",
                "content": "# Diagram\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![code2flow_4fd67K (3).png](https://assets.leetcode.com/users/images/c86e81d1-efc4-4bcd-b523-8a6f1214dd3f_1684892657.758895.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function maxScore takes three arguments: nums1, nums2, and k. nums1 and nums2 are vectors of integers, and k is an integer.\\n\\nThe code creates a vector of pairs v, where each pair contains an element from nums2 and its index. This is done to keep track of the original indices of the elements in nums2 after sorting.\\n\\nThe vector v is sorted in descending order based on the first element of each pair (i.e., the elements from nums2).\\n\\nThe code initializes a variable sum to 0, which will be used to keep track of the sum of the elements in nums1 that correspond to the elements in nums2 that are currently being considered.\\n\\nThe code initializes a variable maxi to 0, which will be used to keep track of the maximum score seen so far.\\n\\nThe code creates a priority queue pq, which will be used to keep track of the k-1 largest elements from nums1 that correspond to the elements in nums2 that are currently being considered.\\n\\nThe code iterates over the elements in v. For each element, it adds the corresponding element from nums1 to sum, and pushes it onto the priority queue pq.\\n\\nIf the size of pq is equal to k, the code calculates the score for the current set of elements by multiplying sum by the first element of the current pair (i.e., the element from nums2). If this score is greater than maxi, it updates maxi.\\n\\nIf the size of pq is greater than k-1, the code removes the smallest element from pq and subtracts it from sum.\\n\\nAfter iterating over all the elements in v, the code returns maxi.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        int n=nums2.size();\\n        // to track indexs after sorting\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        long long sum=0;\\n        long long maxi=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            auto &[a,b]=v[i];\\n            sum+=nums1[b];\\n            pq.push(nums1[b]);\\n            //update maxi if the heap size is k\\n            if(pq.size()==k)maxi=max(maxi,sum*a);       \\n            //maintaining the k-1 maximum element\\n            if(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/c4863bee-cbb0-4232-a514-099fb43aef0f_1684892832.3537347.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        int n=nums2.size();\\n        // to track indexs after sorting\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        long long sum=0;\\n        long long maxi=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            auto &[a,b]=v[i];\\n            sum+=nums1[b];\\n            pq.push(nums1[b]);\\n            //update maxi if the heap size is k\\n            if(pq.size()==k)maxi=max(maxi,sum*a);       \\n            //maintaining the k-1 maximum element\\n            if(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557152,
                "title": "c-solution-using-sorting-and-priority-queue-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Sort the pairs p[i]={nums2[i],nums1[i]}; of elements from the arrays based on the first element in ascending order and the second element in ascending order if the first elements are equal. \\n2. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \\n3. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $O(n \\\\log n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n# Code with comment explanation\\n```\\nclass Solution {\\npublic:\\n    // Define a shorthand for pair<int, int>\\n    using int2 = pair<int, int>;\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        \\n        // Create a vector of pairs to store the elements from nums1 and nums2\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i] = {nums2[i], nums1[i]};\\n        }\\n        \\n        // Create a min heap using a priority queue to store the k smallest elements\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        // Sort the vector of pairs based on the first element in ascending order\\n        // If the first elements are equal, sort based on the second element in ascending order\\n        sort(p.begin(), p.end(), [](int2& x, int2& y){\\n            if(x.first == y.first)\\n                return x.second < y.second;\\n            return x.first < y.first;\\n        });\\n\\n        long long ans = 0, sum = 0;\\n\\n        // Iterate over the sorted vector of pairs in reverse order\\n        for(int i = n - 1; i >= 0; i--){\\n            auto& [x, y] = p[i];\\n            \\n            // Add the second element of the current pair to the sum\\n            sum += y;\\n            \\n            // Push the second element of the current pair to the priority queue\\n            pq.push(y);\\n            \\n            // Once i < n - k + 1, we have encountered k elements\\n            if(i < n - k + 1){     \\n                // If the priority queue size exceeds k, remove the smallest element\\n                if(pq.size() > k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                \\n                // Calculate the product of the sum and the first element of the current pair\\n                // Update the maximum score (ans) if necessary\\n                ans = max(ans, sum * x);\\n            }\\n        }\\n        \\n        // Return the maximum score\\n        return ans;\\n    }\\n};\\n\\n```\\n#Code\\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i]={nums2[i],nums1[i]};\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n\\n        sort(p.begin(),p.end(), [](int2& x, int2&y){\\n            if(x.first==y.first)\\n                return x.second<y.second;\\n            return x.first<y.first;\\n        });\\n\\n        long long  ans = 0, sum = 0;\\n\\n        for(int i = n-1; i >= 0; i--){\\n            auto& [x,y]=p[i];\\n            sum += y;\\n            pq.push(y);\\n            if(i < n-k+1){     \\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nSecond solution removing unnecessary if-branches\\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i]={nums2[i],nums1[i]};\\n        }\\n        priority_queue<int,vector<int>, greater<int>> pq;\\n\\n        sort(p.begin(),p.end(), [](int2& x, int2&y){\\n            if(x.first==y.first)\\n                return x.second>y.second;\\n            return x.first>y.first;\\n        });\\n\\n        long long  sum = 0;\\n        for(int i=0; i<k; i++){\\n            int y=p[i].second;          \\n            sum += y;  \\n            pq.push(y);\\n        }\\n        long long ans=sum*p[k-1].first;\\n\\n        for(int i = k; i <n; i++){\\n            auto& [x,y]=p[i];\\n            sum += y;  \\n            pq.push(y);         \\n           // if(pq.size()>k){\\n                sum -= pq.top();\\n                pq.pop();\\n            //}\\n            //if (pq.size()==k)\\n            ans = max(ans,sum*x);   \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a shorthand for pair<int, int>\\n    using int2 = pair<int, int>;\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        \\n        // Create a vector of pairs to store the elements from nums1 and nums2\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i] = {nums2[i], nums1[i]};\\n        }\\n        \\n        // Create a min heap using a priority queue to store the k smallest elements\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        // Sort the vector of pairs based on the first element in ascending order\\n        // If the first elements are equal, sort based on the second element in ascending order\\n        sort(p.begin(), p.end(), [](int2& x, int2& y){\\n            if(x.first == y.first)\\n                return x.second < y.second;\\n            return x.first < y.first;\\n        });\\n\\n        long long ans = 0, sum = 0;\\n\\n        // Iterate over the sorted vector of pairs in reverse order\\n        for(int i = n - 1; i >= 0; i--){\\n            auto& [x, y] = p[i];\\n            \\n            // Add the second element of the current pair to the sum\\n            sum += y;\\n            \\n            // Push the second element of the current pair to the priority queue\\n            pq.push(y);\\n            \\n            // Once i < n - k + 1, we have encountered k elements\\n            if(i < n - k + 1){     \\n                // If the priority queue size exceeds k, remove the smallest element\\n                if(pq.size() > k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                \\n                // Calculate the product of the sum and the first element of the current pair\\n                // Update the maximum score (ans) if necessary\\n                ans = max(ans, sum * x);\\n            }\\n        }\\n        \\n        // Return the maximum score\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i]={nums2[i],nums1[i]};\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n\\n        sort(p.begin(),p.end(), [](int2& x, int2&y){\\n            if(x.first==y.first)\\n                return x.second<y.second;\\n            return x.first<y.first;\\n        });\\n\\n        long long  ans = 0, sum = 0;\\n\\n        for(int i = n-1; i >= 0; i--){\\n            auto& [x,y]=p[i];\\n            sum += y;\\n            pq.push(y);\\n            if(i < n-k+1){     \\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<int2> p(n);\\n        for(int i = 0; i < n; i++){\\n            p[i]={nums2[i],nums1[i]};\\n        }\\n        priority_queue<int,vector<int>, greater<int>> pq;\\n\\n        sort(p.begin(),p.end(), [](int2& x, int2&y){\\n            if(x.first==y.first)\\n                return x.second>y.second;\\n            return x.first>y.first;\\n        });\\n\\n        long long  sum = 0;\\n        for(int i=0; i<k; i++){\\n            int y=p[i].second;          \\n            sum += y;  \\n            pq.push(y);\\n        }\\n        long long ans=sum*p[k-1].first;\\n\\n        for(int i = k; i <n; i++){\\n            auto& [x,y]=p[i];\\n            sum += y;  \\n            pq.push(y);         \\n           // if(pq.size()>k){\\n                sum -= pq.top();\\n                pq.pop();\\n            //}\\n            //if (pq.size()==k)\\n            ans = max(ans,sum*x);   \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082154,
                "title": "java-explained-line-by-line-sorting-priorityqueue-o-nlogn-time",
                "content": "## Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(2*n)\\n\\n## Code\\n* Form items from two arrays.\\n* Let\\'s call nums1 values as sum values and nums2 as product values.\\n\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] a = new int[nums1.length][2]; \\n\\n        //combining the two arrays to form items.\\n        for(int i=0;i<nums1.length;i++){\\n            //nums1 is the array from which we have to take the sum of k items.\\n            a[i][0]=nums1[i]; //let\\'s call it sum value.\\n            //nums2 is the array from which we have to take the minimum value of k items.\\n            a[i][1]=nums2[i]; //let\\'s call it product value.\\n        }\\n        \\n        //Sort items on the basis of product values in descending order\\n        //if two items have same product values, sort them on the basis of sum value in descending order.\\n        Arrays.sort(a,(a1,b1) -> b1[1]==a1[1]?Integer.compare(b1[0],a1[0]):Integer.compare(b1[1],a1[1]));\\n        \\n        //head of priority queue will be the item with smallest sum value and\\n        // there will be exactly k items in the queue at a time while calculating result.\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a1,b1)->Integer.compare(a1[0],b1[0]));\\n    \\n        int min=Integer.MAX_VALUE;\\n        long sum=0, res=0;\\n        //add k items with largest product value in queue\\n        for(int i=0;i<k;i++){\\n            min=Math.min(min,a[i][1]);  //updating minimum for each selected item.\\n            sum+=a[i][0];  //adding sum value of ith item to sum\\n            queue.add(a[i]); //adding ith item to queue\\n        }\\n        res=Math.max(res,sum*min);\\n\\n        // if sum value of ith(i->[k,a.length-1]) item is greater than sum value of head item,\\n        // then remove the head item and add ith item in the queue.\\n        // compute max res from all computations done. \\n    \\n        for(int i=k;i<a.length;i++){\\n            if(queue.peek()[0]<a[i][0]){\\n              sum-=queue.remove()[0]; //removing head item && subtracting sum value of head item from sum.\\n              sum+=a[i][0];  //adding sum value of ith item to sum\\n              queue.add(a[i]); //adding ith tem to queue\\n              min=Math.min(min,a[i][1]); //updating minimum for each selected item.\\n            }\\n            res=Math.max(res,sum*min); //updating result.\\n        }\\n        return res; //maximum result\\n    }\\n}\\n```\\n### Code without Comments\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] a = new int[nums1.length][2];\\n        for(int i=0;i<nums1.length;i++){\\n            a[i][0]=nums1[i]; \\n            a[i][1]=nums2[i];\\n        }\\n        Arrays.sort(a,(a1,b1) -> b1[1]==a1[1]?Integer.compare(b1[0],a1[0]):Integer.compare(b1[1],a1[1]));\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a1,b1)->Integer.compare(a1[0],b1[0]));\\n    \\n        int min=Integer.MAX_VALUE;\\n        long sum=0, res=0;\\n        for(int i=0;i<k;i++){\\n            min=Math.min(min,a[i][1]);  \\n            sum+=a[i][0]; \\n            queue.add(a[i]); \\n        }\\n        res=Math.max(res,sum*min);\\n    \\n        for(int i=k;i<a.length;i++){\\n            if(queue.peek()[0]<a[i][0]){\\n              sum-=queue.remove()[0];\\n              sum+=a[i][0];\\n              queue.add(a[i]);\\n              min=Math.min(min,a[i][1]); \\n            }\\n            res=Math.max(res,sum*min); \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] a = new int[nums1.length][2]; \\n\\n        //combining the two arrays to form items.\\n        for(int i=0;i<nums1.length;i++){\\n            //nums1 is the array from which we have to take the sum of k items.\\n            a[i][0]=nums1[i]; //let\\'s call it sum value.\\n            //nums2 is the array from which we have to take the minimum value of k items.\\n            a[i][1]=nums2[i]; //let\\'s call it product value.\\n        }\\n        \\n        //Sort items on the basis of product values in descending order\\n        //if two items have same product values, sort them on the basis of sum value in descending order.\\n        Arrays.sort(a,(a1,b1) -> b1[1]==a1[1]?Integer.compare(b1[0],a1[0]):Integer.compare(b1[1],a1[1]));\\n        \\n        //head of priority queue will be the item with smallest sum value and\\n        // there will be exactly k items in the queue at a time while calculating result.\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a1,b1)->Integer.compare(a1[0],b1[0]));\\n    \\n        int min=Integer.MAX_VALUE;\\n        long sum=0, res=0;\\n        //add k items with largest product value in queue\\n        for(int i=0;i<k;i++){\\n            min=Math.min(min,a[i][1]);  //updating minimum for each selected item.\\n            sum+=a[i][0];  //adding sum value of ith item to sum\\n            queue.add(a[i]); //adding ith item to queue\\n        }\\n        res=Math.max(res,sum*min);\\n\\n        // if sum value of ith(i->[k,a.length-1]) item is greater than sum value of head item,\\n        // then remove the head item and add ith item in the queue.\\n        // compute max res from all computations done. \\n    \\n        for(int i=k;i<a.length;i++){\\n            if(queue.peek()[0]<a[i][0]){\\n              sum-=queue.remove()[0]; //removing head item && subtracting sum value of head item from sum.\\n              sum+=a[i][0];  //adding sum value of ith item to sum\\n              queue.add(a[i]); //adding ith tem to queue\\n              min=Math.min(min,a[i][1]); //updating minimum for each selected item.\\n            }\\n            res=Math.max(res,sum*min); //updating result.\\n        }\\n        return res; //maximum result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] a = new int[nums1.length][2];\\n        for(int i=0;i<nums1.length;i++){\\n            a[i][0]=nums1[i]; \\n            a[i][1]=nums2[i];\\n        }\\n        Arrays.sort(a,(a1,b1) -> b1[1]==a1[1]?Integer.compare(b1[0],a1[0]):Integer.compare(b1[1],a1[1]));\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a1,b1)->Integer.compare(a1[0],b1[0]));\\n    \\n        int min=Integer.MAX_VALUE;\\n        long sum=0, res=0;\\n        for(int i=0;i<k;i++){\\n            min=Math.min(min,a[i][1]);  \\n            sum+=a[i][0]; \\n            queue.add(a[i]); \\n        }\\n        res=Math.max(res,sum*min);\\n    \\n        for(int i=k;i<a.length;i++){\\n            if(queue.peek()[0]<a[i][0]){\\n              sum-=queue.remove()[0];\\n              sum+=a[i][0];\\n              queue.add(a[i]);\\n              min=Math.min(min,a[i][1]); \\n            }\\n            res=Math.max(res,sum*min); \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559337,
                "title": "greedy-parents-and-kicking-kids-approach-greedy-approach-solution-pair-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe read the line select from the question which should click in our mind combine operation is needed use your brain and make a data structure using both at the the same time and also keep track such that only we take those values from nums1 for which nums2[j]>=minval which we chose at a particular operation \\n\\nFor eg first testcase we see that :\\nnums1 = 1 3 3 2\\nnums2 = 2 1 3 4\\n\\nso if i choose 2 in nums2 then I have to blindly take 1 from nums1 as it corresponds to the nums2[i] and also can take k-1 terms from nums1 where nums2[j] >= nums2[i]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the vector based on the second value \\nnums1: 3 1 3 2\\nnums2: 1 2 3 4\\n\\nNow see when i is 3 \\n4 is the minval only for 2 which means it cant get k-1 kids very sad life he is leading single and lonely\\n\\ni is 2 minval is 3 ohh i have one 3 from nums1 and also a kid because his daddy is according to this question powerless against me i kidnap it also but i only have 2 members question asks for 3\\n\\ni is 1 minval is 2 now it gets fun i finally have gang with minval 2 and members 1+3+2 with a value of (1+3+2)*2 =12\\n\\ni is 0 minval is 1 now i have one possible group of (1+3+2)*1=6 or (3+2+3)*1=7 as minheap storing these elements they will kick poor 1 in greed of profit \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) as we need to perform deletion and insertion operation in our priority queue which takes O(logn) time and we will have to do this operation for average of each particular node as we have to get all the subsequeunce which is inserting and popping basically.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*n) as we will store all the numbers of arrays nums1 of size n and nums2 of size n in a pairs auxillary vector for getting rid of hustle of useless tracking of index\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int,int>&a,const pair<int,int>&b){\\n        return a.second<b.second;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>pairs;\\n        for(int i=0;i<nums1.size();i++){\\n            pairs.push_back({nums1[i],nums2[i]});\\n        }\\n        sort(pairs.begin(),pairs.end(),comp);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        long long sum=0;\\n        long long max_sum=0;\\n        int n=nums1.size();\\n        for(int i=n-1;i>=0;i--){\\n            int minval=pairs[i].second;\\n            while(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            sum+=pairs[i].first;\\n            pq.push(pairs[i].first);\\n            if(pq.size()==k){\\n                max_sum=max(max_sum,sum*minval);\\n            }\\n\\n        }\\n        return max_sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const pair<int,int>&a,const pair<int,int>&b){\\n        return a.second<b.second;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>pairs;\\n        for(int i=0;i<nums1.size();i++){\\n            pairs.push_back({nums1[i],nums2[i]});\\n        }\\n        sort(pairs.begin(),pairs.end(),comp);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        long long sum=0;\\n        long long max_sum=0;\\n        int n=nums1.size();\\n        for(int i=n-1;i>=0;i--){\\n            int minval=pairs[i].second;\\n            while(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            sum+=pairs[i].first;\\n            pq.push(pairs[i].first);\\n            if(pq.size()==k){\\n                max_sum=max(max_sum,sum*minval);\\n            }\\n\\n        }\\n        return max_sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085232,
                "title": "python-clean-solution-using-minheap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    \\n        z=[]\\n        \\n        for a,b in zip(nums1,nums2):\\n            z.append([a,b])\\n        \\n        z.sort(key=lambda x:-x[1])\\n        \\n        heap=[]\\n        best=total=0\\n        \\n        for a,b in z:\\n            heappush(heap,a)\\n            total+=a\\n            if len(heap)==k:\\n                best=max(best,total*b)\\n                total-=heappop(heap)\\n\\n        return best\\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    \\n        z=[]\\n        \\n        for a,b in zip(nums1,nums2):\\n            z.append([a,b])\\n        \\n        z.sort(key=lambda x:-x[1])\\n        \\n        heap=[]\\n        best=total=0\\n        \\n        for a,b in z:\\n            heappush(heap,a)\\n            total+=a\\n            if len(heap)==k:\\n                best=max(best,total*b)\\n                total-=heappop(heap)\\n\\n        return best\\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082163,
                "title": "python-c-greedy-sorting-priority-queue",
                "content": "Basically we are using greedy algorithm, we want to ask, for each `x` in` nums2`, if `x` is the minimum of the sequence, then what is the best `sum*x` i can achieve? well, since the minimum is `x`, we should only consider indicies where `nums2[index] >= x`, otherwise we would get `nums2[index] < x` which means `x` is not the minimum. \\nso we can greedily pick the `(k-1)` best elements from `nums1` to pair with that `x` as long as their counterpart in `nums2` doesnt go over `x.`\\n\\nso we can pick `nums1[index]` to be in the sequence only if `nums2[index] <= x`, as we said before.\\nto do that we **can sort both arrays** by `nums2` values, and iterate from the biggest minimum to the smallest one, and pick the best `k` elements that we can each time, using a **min heap** to get rid of the \"worst values\" that we have seen so far, update the result and we are done.\\n\\ntime complexity - `O(nlogn)` for the sort + the traversal of the array with heap of size at most `k`, still `O(nlogn)`.\\nspace complexity -` O(n + k)` for the combined list and the heap\\n\\t**Python**\\n\\t\\t\\n\\tclass Solution:\\n\\t\\tdef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\t\\t\\t#sort by nums2 values in reverse order\\n\\t\\t\\tlst = sorted([(b , a) for a, b in zip(nums1, nums2)], reverse=True)\\n\\n\\t\\t\\t#init res, sum, minimum value and length of the sequence\\n\\t\\t\\tres = 0\\n\\t\\t\\ts = lst[0][1]\\n\\t\\t\\tm = lst[0][0]\\n\\t\\t\\tlength = 1\\n\\n\\t\\t\\t#small edge case\\n\\t\\t\\tif length == k:\\n\\t\\t\\t\\tres = max(res, s * m)\\n\\n\\t\\t\\t#init min heap\\n\\t\\t\\theap = []\\n\\t\\t\\theappush(heap, s)\\n\\n\\t\\t\\tfor index in range(1, len(lst)):\\n\\t\\t\\t\\t#update min and sum\\n\\t\\t\\t\\tm = lst[index][0]\\n\\t\\t\\t\\ts += lst[index][1]\\n\\n\\t\\t\\t\\t#insert to heap and increase sequence size\\n\\t\\t\\t\\theappush(heap, lst[index][1])\\n\\t\\t\\t\\tlength += 1\\n\\n\\t\\t\\t\\t#if the length is greater than k, pop the minimum value out of the heap\\n\\t\\t\\t\\tif length > k:\\n\\t\\t\\t\\t\\ts -= heapq.heappop(heap)\\n\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\t#update the result\\n\\t\\t\\t\\tif length == k:\\n\\t\\t\\t\\t\\tres = max(res, s*m)\\n\\n\\t\\t\\treturn res\\n\\t\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int, int>> nums(n);\\n        for (int index = 0; index < n; index++) {\\n            nums[index] = {nums2[index], nums1[index]};\\n        }\\n        \\n        //sort by nums2 values in reverse order\\n        sort(nums.rbegin(), nums.rend());\\n        \\n        //init res, sum, minimum value and length of the sequence\\n        long long sum = nums[0].second, mn = nums[0].first, res = 0;\\n        int len = 1;\\n        \\n        //small edge case\\n        if (len == k)\\n            res = max(res, sum*mn);\\n        \\n        //init min heap\\n        priority_queue<int, vector<int>, greater<>> pq;\\n        pq.push(sum);\\n        \\n        for (int index = 1; index < n; index++) {\\n            //update sum and min\\n            mn = nums[index].first;\\n            sum += nums[index].second;\\n            \\n            //insert to heap and increase window size\\n            pq.push(nums[index].second);\\n            len++;\\n            \\n            //if the length is greater than k, pop the min value out of the heap\\n            if (len > k) {\\n                sum -= pq.top(); \\n                pq.pop();\\n                len--;\\n            }\\n            \\n            //update the result\\n            if (len == k) {\\n                res = max(res, sum*mn);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution:\\n\\t\\tdef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\t\\t\\t#sort by nums2 values in reverse order\\n\\t\\t\\tlst = sorted([(b , a) for a, b in zip(nums1, nums2)], reverse=True)\\n\\n\\t\\t\\t#init res, sum, minimum value and length of the sequence\\n\\t\\t\\tres = 0\\n\\t\\t\\ts = lst[0][1]\\n\\t\\t\\tm = lst[0][0]\\n\\t\\t\\tlength = 1\\n\\n\\t\\t\\t#small edge case\\n\\t\\t\\tif length == k:\\n\\t\\t\\t\\tres = max(res, s * m)\\n\\n\\t\\t\\t#init min heap\\n\\t\\t\\theap = []\\n\\t\\t\\theappush(heap, s)\\n\\n\\t\\t\\tfor index in range(1, len(lst)):\\n\\t\\t\\t\\t#update min and sum\\n\\t\\t\\t\\tm = lst[index][0]\\n\\t\\t\\t\\ts += lst[index][1]\\n\\n\\t\\t\\t\\t#insert to heap and increase sequence size\\n\\t\\t\\t\\theappush(heap, lst[index][1])\\n\\t\\t\\t\\tlength += 1\\n\\n\\t\\t\\t\\t#if the length is greater than k, pop the minimum value out of the heap\\n\\t\\t\\t\\tif length > k:\\n\\t\\t\\t\\t\\ts -= heapq.heappop(heap)\\n\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\t#update the result\\n\\t\\t\\t\\tif length == k:\\n\\t\\t\\t\\t\\tres = max(res, s*m)\\n\\n\\t\\t\\treturn res\\n\\t\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int, int>> nums(n);\\n        for (int index = 0; index < n; index++) {\\n            nums[index] = {nums2[index], nums1[index]}",
                "codeTag": "Java"
            },
            {
                "id": 3082099,
                "title": "c-solution-priority-queue-sorting-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, vector<int>& b, int k) {\\n        \\n        int n = a.size() ;\\n        long long sum =0 , ans = INT_MIN;\\n        priority_queue<pair<int,int>> mx;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mn;\\n        pair<int,int> p;\\n        \\n        for(int i=0;i<n;i++) mx.push({a[i],i});\\n        \\n        while(k--){\\n            p = mx.top();\\n            mx.pop();\\n            sum += p.first;\\n            mn.push({b[p.second],p.second});\\n        }\\n        \\n        ans = max(ans,sum*(long long)mn.top().first);\\n        \\n        while(!mx.empty()){\\n            sum -= a[mn.top().second];\\n            mn.pop();\\n            p = mx.top();\\n            mx.pop();\\n            sum += p.first;\\n            mn.push({b[p.second],p.second});\\n            ans = max(ans,sum*(long long)mn.top().first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, vector<int>& b, int k) {\\n        \\n        int n = a.size() ;\\n        long long sum =0 , ans = INT_MIN;\\n        priority_queue<pair<int,int>> mx;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mn;\\n        pair<int,int> p;\\n        \\n        for(int i=0;i<n;i++) mx.push({a[i],i});\\n        \\n        while(k--){\\n            p = mx.top();\\n            mx.pop();\\n            sum += p.first;\\n            mn.push({b[p.second],p.second});\\n        }\\n        \\n        ans = max(ans,sum*(long long)mn.top().first);\\n        \\n        while(!mx.empty()){\\n            sum -= a[mn.top().second];\\n            mn.pop();\\n            p = mx.top();\\n            mx.pop();\\n            sum += p.first;\\n            mn.push({b[p.second],p.second});\\n            ans = max(ans,sum*(long long)mn.top().first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082076,
                "title": "sorting-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        using ll = long long;\\n        using pll = pair<ll, ll>;\\n        int n = nums1.size();\\n        \\n        vector<pll> arr;\\n        \\n        for(int i=0; i<n; i++) {\\n            arr.push_back({nums2[i], nums1[i]});\\n        }\\n        \\n        // sort arr in decreasing order based on nums2 values\\n        sort(arr.begin(), arr.end(), greater<pll>());\\n        \\n        // min-heap\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        // sum of elements in the priority queue\\n        ll sum=0;\\n        \\n        // add the first k elements to the priority queue\\n        for(int i=0; i<k; i++) {\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n        \\n        ll result = sum*arr[k-1].first;\\n        \\n        // now try each element if it is the element\\n        // with smallest nums2 value\\n        for(int i=k; i<n; i++) {\\n            // remove the smallest element\\n            sum -= pq.top();\\n            pq.pop();\\n            \\n            // add the current element\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n            \\n            // find the result when the current element has\\n            // the smallest nums2 value\\n            result = max(result, sum*arr[i].first);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        using ll = long long;\\n        using pll = pair<ll, ll>;\\n        int n = nums1.size();\\n        \\n        vector<pll> arr;\\n        \\n        for(int i=0; i<n; i++) {\\n            arr.push_back({nums2[i], nums1[i]});\\n        }\\n        \\n        // sort arr in decreasing order based on nums2 values\\n        sort(arr.begin(), arr.end(), greater<pll>());\\n        \\n        // min-heap\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        // sum of elements in the priority queue\\n        ll sum=0;\\n        \\n        // add the first k elements to the priority queue\\n        for(int i=0; i<k; i++) {\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n        \\n        ll result = sum*arr[k-1].first;\\n        \\n        // now try each element if it is the element\\n        // with smallest nums2 value\\n        for(int i=k; i<n; i++) {\\n            // remove the smallest element\\n            sum -= pq.top();\\n            pq.pop();\\n            \\n            // add the current element\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n            \\n            // find the result when the current element has\\n            // the smallest nums2 value\\n            result = max(result, sum*arr[i].first);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560998,
                "title": "100-faster-priority-queue-sorting-c-well-explained-with-comments-easy-to-understand",
                "content": "# Screenshot of Submission: \\n\\nBeats 100% in Runtime\\n\\n![Screenshot 2023-05-25 at 12.23.44 PM.png](https://assets.leetcode.com/users/images/124f7947-fb7b-4c51-b7d6-443e44e63b1c_1684997647.4564464.png)\\n\\nBeats 95.8% in Memory\\n\\n![Screenshot 2023-05-25 at 12.23.53 PM.png](https://assets.leetcode.com/users/images/5966d0c5-4785-4cd9-8f27-2374736807b7_1684997684.2430131.png)\\n\\n\\n# Please Like and Upvote\\n\\n# Intuition:\\nThe approach uses a greedy strategy to select the top k values with the highest efficiency. By sorting the pairs array based on efficiency in descending order, we prioritize pairs with higher efficiency values.\\n\\nWe maintain a priority queue (minh) to track the top k values encountered so far. The priority queue keeps the smallest value at the top. Whenever the size of pq exceeds k, we remove the smallest value to ensure we only keep the top k values.\\n\\nBy iterating over the sorted pairs array, we add each value to the priority queue and update the totalSum. Whenever the size of pq reaches k, we calculate the current score by multiplying the totalSum with the efficiency value of the pair. We update the answer (ans) with the maximum score encountered so far.\\n\\nThe intuition behind this approach is that by selecting the highest efficiency pairs and considering the top k values, we maximize the overall score calculation. The priority queue helps in maintaining the top k values efficiently, allowing us to compute the maximum score in a single pass.\\n\\n# Approach:\\n1. Create pairs of (nums2[i], nums1[i]) for each corresponding element in nums1 and nums2. This pairs array will represent the efficiency and values of each pair.\\n\\n2. Sort the pairs array in descending order based on the efficiency value. This step ensures that pairs with higher efficiency values are considered first.\\n\\n3. Initialize a priority queue (min heap), minh, to track the top k values.\\n\\n4. Initialize variables ans (answer) and kSum to 0.\\n\\n5. Iterate over each pair in the sorted pairs array.\\n\\n6. Add the value (pair[1]) to the priority queue minh and update the kSum by adding the value.\\n\\n7. If the size of minh exceeds k, remove the smallest value from minh and subtract it from the kSum.\\n\\n8. If the size of minh is equal to k, calculate the current score by multiplying the kSum with the efficiency value (pair[0]). Update the ans (answer) with the maximum score.\\n\\n9. Return the maximum score (ans) as the final answer.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity:\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n=nums1.size();\\n        vector<pair<int,int>>vec(n);//creating an array which is mix of two\\n\\n        for(int i=0;i<n;++i){\\n            vec[i]={nums2[i],nums1[i]};\\n        }\\n\\n        //sorting the mix of two arrays based on second array in descending order\\n        auto lambda=[&](auto &p1, auto &p2){\\n            return p1.first>p2.first;\\n        };\\n\\n        sort(vec.begin(),vec.end(),lambda);\\n\\n        long long kSum=0;\\n\\n        priority_queue<int,vector<int>,greater<int>>minh;//min heap\\n\\n        //storing sum of first k elements\\n        for(int i=0;i<k;++i){\\n            kSum+=vec[i].second;\\n            minh.push(vec[i].second);\\n        }\\n\\n        long long ans=kSum*vec[k-1].first;\\n\\n        //Looping through nums2 and computing the max product given the minimum is nums2[i]. \\n        //and Updating the answer accordingly.\\n        for(int i=k;i<n;++i){\\n            kSum+=vec[i].second-minh.top();\\n            minh.pop();\\n            minh.push(vec[i].second);\\n            ans=max(ans,kSum*vec[i].first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n=nums1.size();\\n        vector<pair<int,int>>vec(n);//creating an array which is mix of two\\n\\n        for(int i=0;i<n;++i){\\n            vec[i]={nums2[i],nums1[i]};\\n        }\\n\\n        //sorting the mix of two arrays based on second array in descending order\\n        auto lambda=[&](auto &p1, auto &p2){\\n            return p1.first>p2.first;\\n        };\\n\\n        sort(vec.begin(),vec.end(),lambda);\\n\\n        long long kSum=0;\\n\\n        priority_queue<int,vector<int>,greater<int>>minh;//min heap\\n\\n        //storing sum of first k elements\\n        for(int i=0;i<k;++i){\\n            kSum+=vec[i].second;\\n            minh.push(vec[i].second);\\n        }\\n\\n        long long ans=kSum*vec[k-1].first;\\n\\n        //Looping through nums2 and computing the max product given the minimum is nums2[i]. \\n        //and Updating the answer accordingly.\\n        for(int i=k;i<n;++i){\\n            kSum+=vec[i].second-minh.top();\\n            minh.pop();\\n            minh.push(vec[i].second);\\n            ans=max(ans,kSum*vec[i].first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3559966,
                "title": "python-3-8-lines-heap-t-m-100-40",
                "content": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n \\n        nums = sorted(zip(nums1, nums2), key = lambda x:-x[1])\\n            \\n        heap = []\\n\\n        for n1,n2 in nums[:k]: heappush(heap,n1)\\n\\n        ans = (sm:= sum(heap))*n2\\n       \\n        for n1,n2 in nums[k:]:\\n            sm+= n1 - heappushpop(heap,n1)\\n            ans = max(ans,sm * n2)\\n                \\n        return ans\\n```\\n[https://leetcode.com/problems/maximum-subsequence-score/submissions/956611152/](http://)\\n\\n    \\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*K*) and space complexity is *O*(*K*) in which *N* ~`len(nums1)` and *K* ~`k`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n \\n        nums = sorted(zip(nums1, nums2), key = lambda x:-x[1])\\n            \\n        heap = []\\n\\n        for n1,n2 in nums[:k]: heappush(heap,n1)\\n\\n        ans = (sm:= sum(heap))*n2\\n       \\n        for n1,n2 in nums[k:]:\\n            sm+= n1 - heappushpop(heap,n1)\\n            ans = max(ans,sm * n2)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558698,
                "title": "c-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\nThe intuition is to consider each element that can be minimum if we take k element fron nums2 and to find the corresponding maximum sum from nums1 that can be made.\\n\\n# Approach\\n- Make a **vector of pair** whose first element is from nums1 and second from nums 2.\\n- Sort the vector and reverse it so that we get the decreasing order in terms of nums1\\n- Make a **min-heap** of pair to get the minimum of elements fron nums2.\\n- Now start pushing the elements in min heap in reverse order of the pair i.e {v[i].second,v[i].first} :{nums2,nums1}. As we want the minimum of elements of nums2 array\\n- As we are already traversing in decreasing order of nums1 if we have the max sum possible which we store in a variable.\\n- When the **min heap reaches size=k** i.e we have taken k elements in consideration we get the minimum element of nums2 from min heap and see if that element multiplied by current sum is greater than answer or not, if yes then store it in the answer and pop out that pair and subtract it\\'s element from nums1 from current sum and now we will keep doing it for all the elements and check whenever we get k elements and find the maximum of all.\\n\\n  ***I hope you find this helpful. If you do please upvote!\\u2B06\\uFE0F***\\n\\n# Complexity\\n- Time complexity: O(N*log(k))\\n\\n- Space complexity: O(2*N+K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> v;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums1[i],nums2[i]});\\n        }\\n        // sorting and reversing the vector in terms of nums1\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        // to store final answer\\n        long long ans=-1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // sum to track the total sum of elemnts from nums1 that we have picked till now\\n        long long sum=0; \\n        for(int i=0;i<n;i++)\\n        {\\n           // push the pair after reversing it as we need the minimum of nums2 on the top\\n           pq.push({v[i].second,v[i].first});\\n           sum+=v[i].first;\\n           // when we have selected k elements check if the current case can be our answer or not\\n           if(pq.size()==k)\\n           {\\n                int s=pq.top().second;\\n                int m=pq.top().first;\\n                pq.pop();\\n                if(sum*1LL*m>ans)\\n                 ans=sum*1LL*m;\\n                sum-=s;\\n\\n           }   \\n        }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> v;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums1[i],nums2[i]});\\n        }\\n        // sorting and reversing the vector in terms of nums1\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        // to store final answer\\n        long long ans=-1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // sum to track the total sum of elemnts from nums1 that we have picked till now\\n        long long sum=0; \\n        for(int i=0;i<n;i++)\\n        {\\n           // push the pair after reversing it as we need the minimum of nums2 on the top\\n           pq.push({v[i].second,v[i].first});\\n           sum+=v[i].first;\\n           // when we have selected k elements check if the current case can be our answer or not\\n           if(pq.size()==k)\\n           {\\n                int s=pq.top().second;\\n                int m=pq.top().first;\\n                pq.pop();\\n                if(sum*1LL*m>ans)\\n                 ans=sum*1LL*m;\\n                sum-=s;\\n\\n           }   \\n        }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558292,
                "title": "python-elegant-short-sliding-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], muls: List[int], k: int) -> int:\\n        total_score = max_score = 0\\n        heap = []\\n\\n        for mul, num in sorted(zip(muls, nums), reverse=True):\\n            heappush(heap, num)\\n\\n            # Enlarge the window\\n            total_score += num\\n\\n            # Reduce the window\\n            if len(heap) > k:\\n                total_score -= heappop(heap)\\n\\n            # The current answer will be equal to the sum of the window multiplied by the current number,\\n            # since due to sorting it is now the smallest from all taken\\n            if len(heap) == k:\\n                max_score = max(max_score, total_score * mul)\\n\\n        return max_score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], muls: List[int], k: int) -> int:\\n        total_score = max_score = 0\\n        heap = []\\n\\n        for mul, num in sorted(zip(muls, nums), reverse=True):\\n            heappush(heap, num)\\n\\n            # Enlarge the window\\n            total_score += num\\n\\n            # Reduce the window\\n            if len(heap) > k:\\n                total_score -= heappop(heap)\\n\\n            # The current answer will be equal to the sum of the window multiplied by the current number,\\n            # since due to sorting it is now the smallest from all taken\\n            if len(heap) == k:\\n                max_score = max(max_score, total_score * mul)\\n\\n        return max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557256,
                "title": "complete-explanation-explained-intuition",
                "content": "![image](https://assets.leetcode.com/users/images/1ca0692f-d41b-4b12-919b-84a108ead730_1684893294.797481.png)\\n![image](https://assets.leetcode.com/users/images/4355d4cb-bcaa-4cc0-8a97-113ff39453d3_1684893301.978652.png)\\n\\n## CODE\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n = nums1.size();\\n        vector<pair<int, int>>v;\\n        for (int i = 0; i < n; i++) v.push_back({nums2[i], nums1[i]});\\n        sort(v.begin(), v.end()); //sort in ascending order of \"nums2\" value\\n        //===============================================================================\\n        priority_queue<int, vector<int>, greater<int>>pq; //Min PQ for nums1 values\\n        long long  sum = 0;\\n        //directly add the largest (considering nums2 value) k values in PQ\\n        for (int i = n - 1; i >= (n - k); i--) \\n        {\\n            pq.push(v[i].second);\\n            sum += v[i].second;\\n        }\\n        long long mxScore = v[n - k].first * sum; //best till now\\n        //=================================================================================\\n        for (int i = n - k - 1; i >= 0; i--)\\n        {\\n            int minNum1 = pq.top(); //minimum nums1 value\\n            pq.pop(); //first remove smallest nums1 Value, PQ size = k - 1\\n            \\n            sum += v[i].second; //compulsory to take\\n            sum -= minNum1;\\n            \\n            pq.push(v[i].second); //now push the num1 Value, PQ size = k\\n            long long score = v[i].first * sum;\\n            mxScore = max(mxScore, score);\\n        }\\n        //=========================================================================================\\n        return mxScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n = nums1.size();\\n        vector<pair<int, int>>v;\\n        for (int i = 0; i < n; i++) v.push_back({nums2[i], nums1[i]});\\n        sort(v.begin(), v.end()); //sort in ascending order of \"nums2\" value\\n        //===============================================================================\\n        priority_queue<int, vector<int>, greater<int>>pq; //Min PQ for nums1 values\\n        long long  sum = 0;\\n        //directly add the largest (considering nums2 value) k values in PQ\\n        for (int i = n - 1; i >= (n - k); i--) \\n        {\\n            pq.push(v[i].second);\\n            sum += v[i].second;\\n        }\\n        long long mxScore = v[n - k].first * sum; //best till now\\n        //=================================================================================\\n        for (int i = n - k - 1; i >= 0; i--)\\n        {\\n            int minNum1 = pq.top(); //minimum nums1 value\\n            pq.pop(); //first remove smallest nums1 Value, PQ size = k - 1\\n            \\n            sum += v[i].second; //compulsory to take\\n            sum -= minNum1;\\n            \\n            pq.push(v[i].second); //now push the num1 Value, PQ size = k\\n            long long score = v[i].first * sum;\\n            mxScore = max(mxScore, score);\\n        }\\n        //=========================================================================================\\n        return mxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550989,
                "title": "heap-sort-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--){\\n            if(i>=nums1.size()-k+1){\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }else{\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--){\\n            if(i>=nums1.size()-k+1){\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }else{\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082559,
                "title": "java-accepted-heap-and-tle-dp",
                "content": "# ***Accepted***\\n# Approach\\nSorting and Priority Queue\\n\\n# Complexity\\n- nlog(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        pair arr[] = new pair[n];\\n        for(int i = 0;i<n;i++) {\\n            arr[i] = new pair(nums1[i] , nums2[i]);\\n        }\\n        Arrays.sort(arr , (a , b)->b.i - a.i);\\n        long sum = 0;\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a , b)->a.j - b.j);\\n        long ans = 0;\\n        for(int i = 0;i<n;i++) {\\n            pq.offer(arr[i]);\\n            sum += arr[i].i;\\n            if(pq.size() > k) {\\n                pair p = pq.poll();\\n                sum -= p.i;\\n            }\\n            if(pq.size() == k) {\\n            long a = sum * pq.peek().j;\\n            ans = Math.max(ans  , a);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\nclass pair {\\n    int i ; int j;\\n    public pair(int i , int j) {\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\\n# *# **TLE***\\n# Approach\\nDP\\n\\n# Complexity\\n- n^2\\n\\n```\\nclass Solution {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    Long dp[][];\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        dp = new Long[nums1.length][100001];\\n        \\n        long a = score(nums1 , nums2 , k , 0 , 0 , 0 , 0 , nums1.length);\\n        return a;\\n    }\\n    public long score(int[] nums1 , int[] nums2 , int k , long sum , int min , int i , int count , int n) {\\n       \\n       \\n        if(count == k) {\\n            return sum * min;\\n        }\\n         if(i >= n) {\\n            return 0;\\n        }\\n        if(dp[i][min] != null && count == k) {\\n            return dp[i][min];\\n        }\\n        pq.offer(nums2[i]);\\n        count++;\\n        \\n        long a = score(nums1 , nums2 , k , sum + nums1[i] , pq.peek(), i+1 , count , n);\\n        count--;\\n        pq.remove(nums2[i]);\\n        long b = score(nums1 , nums2 , k , sum, min, i+1 , count , n);\\n        return dp[i][min] = Math.max(a , b);\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        pair arr[] = new pair[n];\\n        for(int i = 0;i<n;i++) {\\n            arr[i] = new pair(nums1[i] , nums2[i]);\\n        }\\n        Arrays.sort(arr , (a , b)->b.i - a.i);\\n        long sum = 0;\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a , b)->a.j - b.j);\\n        long ans = 0;\\n        for(int i = 0;i<n;i++) {\\n            pq.offer(arr[i]);\\n            sum += arr[i].i;\\n            if(pq.size() > k) {\\n                pair p = pq.poll();\\n                sum -= p.i;\\n            }\\n            if(pq.size() == k) {\\n            long a = sum * pq.peek().j;\\n            ans = Math.max(ans  , a);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\nclass pair {\\n    int i ; int j;\\n    public pair(int i , int j) {\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    Long dp[][];\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        dp = new Long[nums1.length][100001];\\n        \\n        long a = score(nums1 , nums2 , k , 0 , 0 , 0 , 0 , nums1.length);\\n        return a;\\n    }\\n    public long score(int[] nums1 , int[] nums2 , int k , long sum , int min , int i , int count , int n) {\\n       \\n       \\n        if(count == k) {\\n            return sum * min;\\n        }\\n         if(i >= n) {\\n            return 0;\\n        }\\n        if(dp[i][min] != null && count == k) {\\n            return dp[i][min];\\n        }\\n        pq.offer(nums2[i]);\\n        count++;\\n        \\n        long a = score(nums1 , nums2 , k , sum + nums1[i] , pq.peek(), i+1 , count , n);\\n        count--;\\n        pq.remove(nums2[i]);\\n        long b = score(nums1 , nums2 , k , sum, min, i+1 , count , n);\\n        return dp[i][min] = Math.max(a , b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082071,
                "title": "rust-sort-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_score(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n        let mut data = vec![];\\n        for i in 0 .. nums1.len() { data.push((nums2[i] as i64, nums1[i] as i64)); }\\n        data.sort();\\n        \\n        let mut pq = BinaryHeap::new();\\n        let (mut sum, mut ret) = (0, 0);\\n        while let Some((a, b)) = data.pop() {\\n            sum += b;\\n            pq.push(Reverse(b));\\n            \\n            if pq.len() > k as usize {\\n                if let Some(Reverse(c)) = pq.pop() { sum -= c; }\\n            }\\n            if pq.len() == k as usize { ret = ret.max(sum * a); }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_score(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n        let mut data = vec![];\\n        for i in 0 .. nums1.len() { data.push((nums2[i] as i64, nums1[i] as i64)); }\\n        data.sort();\\n        \\n        let mut pq = BinaryHeap::new();\\n        let (mut sum, mut ret) = (0, 0);\\n        while let Some((a, b)) = data.pop() {\\n            sum += b;\\n            pq.push(Reverse(b));\\n            \\n            if pq.len() > k as usize {\\n                if let Some(Reverse(c)) = pq.pop() { sum -= c; }\\n            }\\n            if pq.len() == k as usize { ret = ret.max(sum * a); }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3561313,
                "title": "complete-handwritten-explanation-fully-commented",
                "content": "# Intuition and Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot 2023-05-25 141127.png](https://assets.leetcode.com/users/images/ac426449-ac15-49ca-8217-b7b369d40798_1685004372.3904212.png)\\n![Screenshot 2023-05-25 141150.png](https://assets.leetcode.com/users/images/542c9c40-cef3-4e31-94e9-e9ff29d27852_1685004400.1157753.png)\\n![Screenshot 2023-05-25 141202.png](https://assets.leetcode.com/users/images/58c74860-c45c-4b26-8e92-d7a835d8c539_1685004416.520923.png)\\n![Screenshot 2023-05-25 141214.png](https://assets.leetcode.com/users/images/185ff8f5-7ffd-49d4-85fe-0f0fd23d3c58_1685004428.7226484.png)\\n![Screenshot 2023-05-25 141233.png](https://assets.leetcode.com/users/images/204cba11-3269-49ca-af86-33110ae8cf66_1685004463.3350651.png)\\n![Screenshot 2023-05-25 141246.png](https://assets.leetcode.com/users/images/0b9910d9-3b73-43f5-bf83-edcc05e9d611_1685004470.4490538.png)\\n![Screenshot 2023-05-25 141255.png](https://assets.leetcode.com/users/images/91966c92-bab3-4311-b4fd-627b16d3266a_1685004488.0461254.png)\\n\\n# Complexity\\n- Time complexity: O(NlogN) for Sorting + O(NlogK) for heap\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N) for comb array + O(K) for heap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing ll = long long;\\n#define mpq(type) priority_queue<type, vector<type>, greater<type>>\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& arr1, vector<int>& arr2, int k) \\n    {\\n        int size=arr1.size();\\n        //Creating a 2D vector->{arr2[i],arr1[i]}\\n        vector<vector<int>>comb;\\n        for(int i=0;i<size;i++)\\n            comb.push_back({arr2[i],arr1[i]});\\n\\n        //Sort the array in descending order of the arr2 ie the first element\\n        sort(comb.rbegin(),comb.rend());\\n\\n        //We can do a sliding window approach to check all the combinations\\n        int i=0,j=0;\\n        ll sum=0,mult=0,ans=0;\\n        mpq(int)minh;\\n        while(j<size)\\n        {\\n            //Add the jth element in the heap and add it to the sum\\n            sum+=comb[j][1];\\n            minh.push(comb[j][1]);\\n            if(j-i+1==k)\\n            {\\n                int mult=comb[j][0];\\n                ll temp=(ll)mult*sum;\\n                //Update the answer\\n                ans=max(ans,temp);\\n                //We have to remove the min element from the window to update it for the next itr\\n                if(minh.size())\\n                {\\n                    sum-=minh.top();\\n                    minh.pop();\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote if the solution helped you **\\uD83E\\uDD7A\\uD83E\\uDD7A\\uD83E\\uDD29\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing ll = long long;\\n#define mpq(type) priority_queue<type, vector<type>, greater<type>>\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& arr1, vector<int>& arr2, int k) \\n    {\\n        int size=arr1.size();\\n        //Creating a 2D vector->{arr2[i],arr1[i]}\\n        vector<vector<int>>comb;\\n        for(int i=0;i<size;i++)\\n            comb.push_back({arr2[i],arr1[i]});\\n\\n        //Sort the array in descending order of the arr2 ie the first element\\n        sort(comb.rbegin(),comb.rend());\\n\\n        //We can do a sliding window approach to check all the combinations\\n        int i=0,j=0;\\n        ll sum=0,mult=0,ans=0;\\n        mpq(int)minh;\\n        while(j<size)\\n        {\\n            //Add the jth element in the heap and add it to the sum\\n            sum+=comb[j][1];\\n            minh.push(comb[j][1]);\\n            if(j-i+1==k)\\n            {\\n                int mult=comb[j][0];\\n                ll temp=(ll)mult*sum;\\n                //Update the answer\\n                ans=max(ans,temp);\\n                //We have to remove the min element from the window to update it for the next itr\\n                if(minh.size())\\n                {\\n                    sum-=minh.top();\\n                    minh.pop();\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559415,
                "title": "easy-and-simple-solution-in-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nby using paired vector \\n-min heap sort\\n-max function\\n# Time complexity:\\n- for sorting vector $O(nlogn)$\\n- for creating heap sort $O(klogk)$\\n- At last $O(k-n)$\\n- total complexity is $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity:\\n-for heap $O(1)$\\n-for paired vector $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>u;\\n        for(int i=0;i<nums1.size();i++)\\n        u.push_back(make_pair(nums2[i],nums1[i]));\\n        sort(u.rbegin(),u.rend());\\n        long long cursum=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            pq.push(u[i].second);\\n            cursum+=u[i].second;\\n        }\\n        long long ans=0;\\n        for(int i=k-1;i<nums1.size();i++)\\n        {\\n            pq.push(u[i].second);\\n            cursum+=u[i].second;\\n            ans=max(ans,cursum*u[i].first);\\n            cursum-=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me if you like the solution comment if any doubts\\n![e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png](https://assets.leetcode.com/users/images/e4eb5083-f907-4ac8-8608-498ed07c8fa1_1684947521.8148217.png)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>u;\\n        for(int i=0;i<nums1.size();i++)\\n        u.push_back(make_pair(nums2[i],nums1[i]));\\n        sort(u.rbegin(),u.rend());\\n        long long cursum=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            pq.push(u[i].second);\\n            cursum+=u[i].second;\\n        }\\n        long long ans=0;\\n        for(int i=k-1;i<nums1.size();i++)\\n        {\\n            pq.push(u[i].second);\\n            cursum+=u[i].second;\\n            ans=max(ans,cursum*u[i].first);\\n            cursum-=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557998,
                "title": "heap-sort-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--){\\n            if(i>=nums1.size()-k+1){\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }else{\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--){\\n            if(i>=nums1.size()-k+1){\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }else{\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k){\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557678,
                "title": "c-solution-priorityqueue-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.Length;\\n        Num[] nums = new Num[n];\\n\\n        for(int i=0; i<n; i++){\\n            nums[i] = new Num(nums1[i], nums2[i]);\\n        }\\n\\n        Array.Sort(nums, (a, b) => {\\n            return b.num2 - a.num2;\\n        });\\n\\n        PriorityQueue<int, int> pq = new();\\n        long res = 0, sum = 0;\\n\\n        for(int i=0; i<n; i++){\\n            pq.Enqueue(nums[i].num1, nums[i].num1);\\n            sum += nums[i].num1;\\n\\n            if(pq.Count > k) sum -= pq.Dequeue();\\n            if(pq.Count == k) res = Math.Max(res, sum*nums[i].num2);\\n        }\\n\\n        return res;\\n    }\\n\\n    public class Num {\\n        public int num1;\\n        public int num2;\\n\\n        public Num(int num1, int num2){\\n            this.num1 = num1;\\n            this.num2 = num2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.Length;\\n        Num[] nums = new Num[n];\\n\\n        for(int i=0; i<n; i++){\\n            nums[i] = new Num(nums1[i], nums2[i]);\\n        }\\n\\n        Array.Sort(nums, (a, b) => {\\n            return b.num2 - a.num2;\\n        });\\n\\n        PriorityQueue<int, int> pq = new();\\n        long res = 0, sum = 0;\\n\\n        for(int i=0; i<n; i++){\\n            pq.Enqueue(nums[i].num1, nums[i].num1);\\n            sum += nums[i].num1;\\n\\n            if(pq.Count > k) sum -= pq.Dequeue();\\n            if(pq.Count == k) res = Math.Max(res, sum*nums[i].num2);\\n        }\\n\\n        return res;\\n    }\\n\\n    public class Num {\\n        public int num1;\\n        public int num2;\\n\\n        public Num(int num1, int num2){\\n            this.num1 = num1;\\n            this.num2 = num2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557642,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    static bool it(pair<int, int> a, pair<int, int> b)\\n    {\\n        return a.second > b.second;\\n    }\\n    long long maxScore(vector<int> &nums1, vector<int> &nums2, int k)\\n    {\\n        vector<pair<int, int>> vec;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; i++)\\n            vec.push_back({nums1[i], nums2[i]});\\n        sort(vec.begin(), vec.end(), it);\\n        long long totalSum = 0;\\n        long long result = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < k - 1; i++)\\n        {\\n            pq.push(vec[i].first);\\n            totalSum += vec[i].first;\\n        }\\n        for (int i = k - 1; i < n; i++)\\n        {\\n            result = max(result, (long long)((totalSum + vec[i].first) * vec[i].second));\\n            pq.push(vec[i].first);\\n            totalSum += vec[i].first;\\n            if (pq.size() == k)\\n            {\\n                totalSum -= pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    static bool it(pair<int, int> a, pair<int, int> b)\\n    {\\n        return a.second > b.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3557301,
                "title": "swift-cfbinaryheap-beats-100",
                "content": "# Approach\\nThe idea is to use a heap from CoreFoundation (instead of implementing a custom priority queue). The algorithm is the same as in the official solution.\\n\\n# Complexity\\n- Time complexity: $$O(n*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        let n = nums1.count\\n        let heap = MinHeap()\\n        var pairs = [(Int, Int)]()\\n\\n        for i in 0..<n {\\n            pairs.append((nums1[i], nums2[i]))\\n        }\\n\\n        pairs.sort() { $0.1 > $1.1 }\\n\\n        var topKSum = 0\\n        for i in 0..<k {\\n            topKSum += pairs[i].0\\n            heap.append(pairs[i].0)\\n        }\\n        \\n        var answer = topKSum * pairs[k-1].1\\n        for i in k..<n {\\n            topKSum += pairs[i].0 - heap.pop()\\n            heap.append(pairs[i].0)\\n            answer = max(answer, topKSum * pairs[i].1)\\n        }\\n        return answer\\n    }\\n}\\n\\nimport CoreFoundation\\nclass MinHeap {\\n    typealias Element = Int\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { lp, rp, _ in\\n            let (lhs, rhs) = (lp!.load(as: Element.self), rp!.load(as: Element.self))\\n            return lhs == rhs ? .compareEqualTo : lhs < rhs ? .compareLessThan : .compareGreaterThan\\n        }\\n        return CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n    }()\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        let n = nums1.count\\n        let heap = MinHeap()\\n        var pairs = [(Int, Int)]()\\n\\n        for i in 0..<n {\\n            pairs.append((nums1[i], nums2[i]))\\n        }\\n\\n        pairs.sort() { $0.1 > $1.1 }\\n\\n        var topKSum = 0\\n        for i in 0..<k {\\n            topKSum += pairs[i].0\\n            heap.append(pairs[i].0)\\n        }\\n        \\n        var answer = topKSum * pairs[k-1].1\\n        for i in k..<n {\\n            topKSum += pairs[i].0 - heap.pop()\\n            heap.append(pairs[i].0)\\n            answer = max(answer, topKSum * pairs[i].1)\\n        }\\n        return answer\\n    }\\n}\\n\\nimport CoreFoundation\\nclass MinHeap {\\n    typealias Element = Int\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { lp, rp, _ in\\n            let (lhs, rhs) = (lp!.load(as: Element.self), rp!.load(as: Element.self))\\n            return lhs == rhs ? .compareEqualTo : lhs < rhs ? .compareLessThan : .compareGreaterThan\\n        }\\n        return CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n    }()\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293080,
                "title": "kotlin-solution-for-maximum-subsequence-score-using-sort-priorityqueue-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we want to maximize the sum of integers in nums1 (sumArr) multiplied with minimum integer from num2 (productArr) for subsequence of size k.\\n\\nSince this is subsequence, we can choose any number in any order we choose.\\n\\nTo maximize the result, we would need to make sure that we get min value from productArr as big as possible. \\n\\nAlso, to maximize the result, while looping through the array, we will consider the first k elements for sum. And then we can remove/discard the minimum value to get maximum sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor getting value from productArr as big as possible, we will sort our index queue in descending order so that we would pick the bigger value of productArr as eary as possible. Due to this, we would not need to calculate the minimum value from productArr in every loop, since the indexQueue is already sorted.\\n\\nWe will loop through the indexQueue to calculate the sum and will use PriorityQueue for sliding window. This priorityQueue will help us to keep the numbers of sumArr in sorted manner. For each number in the sumArr, we will add that value in our priorityQueue and add it to the sum.\\nOnce the window size is reached, we will remove the minimum value from priorityQueue and subtract the removed value from current sum. This way we would make sure that the currentSum would always have max value.\\n\\n# Complexity\\n- Time complexity:\\nO(n logn) [For sorting] + O(n logn) [For looping through the array and calculating the result]\\n\\n- Space complexity:\\nO(n) [For storing indexQueue] + O(k) [For PriorityQueue]\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxScore(sumArr: IntArray, productArr: IntArray, k: Int): Long {\\n        val indexQueue = Array<Int>(sumArr.size) { it }\\n        indexQueue.sortWith(compareBy({ -productArr[it] }))\\n\\n        var sum = 0L\\n        var result = -1L\\n        var sumPriorityQueue = PriorityQueue<Int>(compareBy({ it }))\\n        for (index in 0 until sumArr.size) {\\n            sumPriorityQueue.add(sumArr[indexQueue[index]])\\n            sum += sumArr[indexQueue[index]]\\n\\n            if (sumPriorityQueue.size > k) {\\n                sum -= sumPriorityQueue.poll()\\n            }\\n            if (sumPriorityQueue.size == k) {\\n                result = Math.max(result, sum * productArr[indexQueue[index]])\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sort",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun maxScore(sumArr: IntArray, productArr: IntArray, k: Int): Long {\\n        val indexQueue = Array<Int>(sumArr.size) { it }\\n        indexQueue.sortWith(compareBy({ -productArr[it] }))\\n\\n        var sum = 0L\\n        var result = -1L\\n        var sumPriorityQueue = PriorityQueue<Int>(compareBy({ it }))\\n        for (index in 0 until sumArr.size) {\\n            sumPriorityQueue.add(sumArr[indexQueue[index]])\\n            sum += sumArr[indexQueue[index]]\\n\\n            if (sumPriorityQueue.size > k) {\\n                sum -= sumPriorityQueue.poll()\\n            }\\n            if (sumPriorityQueue.size == k) {\\n                result = Math.max(result, sum * productArr[indexQueue[index]])\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087454,
                "title": "c-with-explanation-greedy",
                "content": "# Intuition\\nTo get the maximum subsequence, we use a greedy approach on 1st array. But, we need to combine it with an eye on getting a minimum value in the 2nd array.\\n\\n# Approach\\nTo combine these two approaches, we need to use a priority queue as min heap to get the smallest value at the top. At the same time, we need to keep adding the elements of the 1st array to get the maximum subsequence. That is possible by sorting initially. Try working out the sorted array to understand better.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> v(n);\\n        for (int i=0;i<n;++i) {\\n            v[i] = {nums2[i], nums1[i]};\\n        }\\n        sort(v.begin(), v.end());\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long s = 0, ans = 0;\\n        for (int i=n-1;i>=0;--i) {\\n            pq.push(v[i].second);\\n            s += v[i].second;\\n            if (pq.size() > k) {\\n                s -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k) {\\n                ans = max(ans, s*(v[i].first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> v(n);\\n        for (int i=0;i<n;++i) {\\n            v[i] = {nums2[i], nums1[i]};\\n        }\\n        sort(v.begin(), v.end());\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long s = 0, ans = 0;\\n        for (int i=n-1;i>=0;--i) {\\n            pq.push(v[i].second);\\n            s += v[i].second;\\n            if (pq.size() > k) {\\n                s -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k) {\\n                ans = max(ans, s*(v[i].first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084235,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        long long h=INT_MIN;\\n        if(k==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(h<nums1[i]*nums2[i])\\n                    h=nums1[i]*nums2[i];\\n            }\\n            return h;\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        vector<long long> dp(n);\\n        long long sum=0, ans=-1;\\n        vector<pair<int, int>> v;\\n        for(int i=0;i<nums1.size();i++)\\n            v.push_back({nums2[i], nums1[i]});\\n        \\n        sort(v.begin(), v.end());\\n        int l=k-1, i=n-1;\\n        while(l--)\\n        {\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n            int f=v[i].second;\\n            i--;\\n        }\\n        dp[n-k+1]=sum;\\n        for(int i=n-k;i>=0;i--)\\n        {\\n            if(v[i].second>pq.top())\\n            {\\n                int y=v[i].second-pq.top();\\n                sum+=y;\\n                dp[i]=sum;\\n                pq.pop();\\n                \\n                pq.push(v[i].second);\\n                continue;\\n            }\\n            dp[i]=dp[i+1];\\n        }\\n        long long my=INT_MIN;\\n        int g=n-k;\\n        for(int i=g;i>=0;i--)\\n        {\\n            if(my<(dp[i+1]+v[i].second)*v[i].first)\\n                my=(dp[i+1]+v[i].second)*v[i].first;\\n        }\\n        return my;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        long long h=INT_MIN;\\n        if(k==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(h<nums1[i]*nums2[i])\\n                    h=nums1[i]*nums2[i];\\n            }\\n            return h;\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        vector<long long> dp(n);\\n        long long sum=0, ans=-1;\\n        vector<pair<int, int>> v;\\n        for(int i=0;i<nums1.size();i++)\\n            v.push_back({nums2[i], nums1[i]});\\n        \\n        sort(v.begin(), v.end());\\n        int l=k-1, i=n-1;\\n        while(l--)\\n        {\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n            int f=v[i].second;\\n            i--;\\n        }\\n        dp[n-k+1]=sum;\\n        for(int i=n-k;i>=0;i--)\\n        {\\n            if(v[i].second>pq.top())\\n            {\\n                int y=v[i].second-pq.top();\\n                sum+=y;\\n                dp[i]=sum;\\n                pq.pop();\\n                \\n                pq.push(v[i].second);\\n                continue;\\n            }\\n            dp[i]=dp[i+1];\\n        }\\n        long long my=INT_MIN;\\n        int g=n-k;\\n        for(int i=g;i>=0;i--)\\n        {\\n            if(my<(dp[i+1]+v[i].second)*v[i].first)\\n                my=(dp[i+1]+v[i].second)*v[i].first;\\n        }\\n        return my;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082788,
                "title": "sliding-window-priority-queue-and-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> a(n);\\n        for(int i=0;i<n;i++) a[i] = {nums2[i], nums1[i]};\\n        sort(a.begin(), a.end());\\n        reverse(a.begin(), a.end());\\n        long long ans = 0, sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push(a[i].second);\\n            sum += a[i].second;\\n            if(i >= k - 1) {\\n                ans = max(ans, a[i].first * sum);\\n                sum -= p.top();                \\n                p.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> a(n);\\n        for(int i=0;i<n;i++) a[i] = {nums2[i], nums1[i]};\\n        sort(a.begin(), a.end());\\n        reverse(a.begin(), a.end());\\n        long long ans = 0, sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push(a[i].second);\\n            sum += a[i].second;\\n            if(i >= k - 1) {\\n                ans = max(ans, a[i].first * sum);\\n                sum -= p.top();                \\n                p.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949329,
                "title": "hard-problem-easily-understandable-solution-c",
                "content": "# Intuition\\nThe problem requires finding the maximum score that can be obtained by performing the following operations:\\n1. Selecting up to \\'k\\' elements from \\'nums1\\'.\\n2. Selecting the remaining elements from \\'nums2\\'.\\nThe score of an operation is calculated as the sum of the selected elements from \\'nums1\\' multiplied by the corresponding element from \\'nums2\\'.\\n\\nTo maximize the score, we should choose the \\'k\\' largest elements from \\'nums1\\' and multiply them with the \\'k\\' largest elements from \\'nums2\\'. We can use a priority_queue to efficiently maintain the \\'k\\' largest elements from \\'nums1\\'.\\n\\n# Approach\\n1. Create a vector of pairs \\'pairs\\' to store pairs (nums2[i], nums1[i]) for each corresponding element from \\'nums1\\' and \\'nums2\\'.\\n2. Sort the \\'pairs\\' vector in descending order based on the first element of each pair (nums2 values) using the greater<pair<int, int>> comparator. This way, we have the largest nums2 values at the beginning of the \\'pairs\\' vector.\\n3. Initialize a min-heap (priority_queue) \\'pq\\' to maintain the \\'k\\' largest elements from \\'nums1\\'.\\n4. Initialize variables \\'n1sum\\' and \\'res\\' to keep track of the sum of selected elements from \\'nums1\\' and the maximum score, respectively.\\n5. Iterate through the \\'pairs\\' vector:\\n   a. Push the second element of each pair (nums1 values) onto \\'pq\\'.\\n   b. Add the corresponding nums1 value to \\'n1sum\\'.\\n   c. If \\'pq\\' size exceeds \\'k\\', pop the smallest element from \\'pq\\' and subtract it from \\'n1sum\\'.\\n   d. If \\'pq\\' size becomes \\'k\\', calculate the score as \\'n1sum\\' multiplied by the current nums2 value (first element of the pair). Update \\'res\\' with the maximum score encountered so far.\\n6. After the loop, \\'res\\' contains the maximum score.\\n\\n# Complexity\\n- Time complexity:\\n  - Constructing the \\'pairs\\' vector takes O(n) time, where \\'n\\' is the size of \\'nums1\\' or \\'nums2\\'.\\n  - Sorting the \\'pairs\\' vector takes O(n * log(n)) time.\\n  - Iterating through the \\'pairs\\' vector takes O(n) time.\\n  - Overall time complexity is dominated by sorting, which is O(n * log(n)).\\n- Space complexity:\\n  - The space complexity is O(n) due to the \\'pairs\\' vector.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>pairs;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            pairs.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(pairs.begin(),pairs.end(),greater<pair<int,int>>());\\n        // for(auto elm: pairs)\\n        // {\\n        //     cout<<elm.first<<\" \"<<elm.second<<endl;\\n        // }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long n1sum=0;\\n        long long res=0;\\n        for(auto elm: pairs)\\n        {\\n            pq.push(elm.second);\\n            n1sum+=elm.second;\\n            if(pq.size()>k)\\n            {\\n                n1sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n            {\\n                res=max(res,n1sum*elm.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>pairs;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            pairs.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(pairs.begin(),pairs.end(),greater<pair<int,int>>());\\n        // for(auto elm: pairs)\\n        // {\\n        //     cout<<elm.first<<\" \"<<elm.second<<endl;\\n        // }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long n1sum=0;\\n        long long res=0;\\n        for(auto elm: pairs)\\n        {\\n            pq.push(elm.second);\\n            n1sum+=elm.second;\\n            if(pq.size()>k)\\n            {\\n                n1sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n            {\\n                res=max(res,n1sum*elm.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3559117,
                "title": "swift-min-heap-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n> You must choose a subsequence of indices from nums1 of length k.\\n\\nThe length of the subsequence must equal to `k`,\\nit\\'s kind of sliding window with variation allow jumps\\n\\n>  multiplied with the minimum of the selected elements from nums2.\\n\\nSorting `nums2` at first to avoid **O(N)** for finding the minimum value every time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse MinHeap instead of MaxHeap, to get the insertion time complexity of **O(K)** instead of **O(N)**\\n\\nExtract the Heap to individual object, avoid mixing in within the solution codes, they\\'re at different level (foundation and application)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log n)$$ for sorint at beginning\\n$$O(n log k)$$ for heap append and pop\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for additional nums\\n$$O(K)$$ for heap\\n\\n# Code\\n```\\nclass Solution {\\n    typealias Num = (num1: Int, num2: Int)\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var nums = [Num]()\\n        for i in 0..<nums1.count {\\n            nums.append((nums1[i], nums2[i]))\\n        }\\n        nums.sort { $0.num2 > $1.num2 }\\n\\n        var minHeap = MinHeap()\\n        var result = 0\\n        var sum = 0\\n        for i in 0..<nums.count {\\n            minHeap.append(nums[i].num1)\\n            sum += nums[i].num1\\n            if i + 1 >= k {\\n                result = max(result, sum * nums[i].num2)\\n                let pop = minHeap.pop()\\n                sum -= pop\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nimport CoreFoundation\\nclass MinHeap {\\n    typealias Element = Int\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { (a, b, _) in\\n            let x: Element = a!.load(as: Element.self), y: Element = b!.load(as: Element.self)\\n            return x < y ? CFComparisonResult.compareLessThan : CFComparisonResult.compareGreaterThan\\n        }\\n        var heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        return heap!\\n    }()\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    typealias Num = (num1: Int, num2: Int)\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var nums = [Num]()\\n        for i in 0..<nums1.count {\\n            nums.append((nums1[i], nums2[i]))\\n        }\\n        nums.sort { $0.num2 > $1.num2 }\\n\\n        var minHeap = MinHeap()\\n        var result = 0\\n        var sum = 0\\n        for i in 0..<nums.count {\\n            minHeap.append(nums[i].num1)\\n            sum += nums[i].num1\\n            if i + 1 >= k {\\n                result = max(result, sum * nums[i].num2)\\n                let pop = minHeap.pop()\\n                sum -= pop\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nimport CoreFoundation\\nclass MinHeap {\\n    typealias Element = Int\\n    var pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n    \\n    deinit {\\n        pointer.deinitialize(count: 1)\\n        pointer.deallocate()\\n    }\\n\\n    lazy var binaryHeap: CFBinaryHeap = {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { (a, b, _) in\\n            let x: Element = a!.load(as: Element.self), y: Element = b!.load(as: Element.self)\\n            return x < y ? CFComparisonResult.compareLessThan : CFComparisonResult.compareGreaterThan\\n        }\\n        var heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        return heap!\\n    }()\\n\\n    func append(_ element: Element) {\\n        pointer = UnsafeMutablePointer<Element>.allocate(capacity: 1)\\n        pointer.initialize(to: (element))\\n        CFBinaryHeapAddValue(binaryHeap, pointer)\\n    }\\n\\n    func pop() -> Element {\\n        let popped: Element = CFBinaryHeapGetMinimum(binaryHeap).load(as: Element.self)\\n        CFBinaryHeapRemoveMinimumValue(binaryHeap)\\n        return popped\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558558,
                "title": "c-c-clean-solution-using-only-standard-c-library",
                "content": "# Approach\\nThe solution is roughly the same as in the editorial.\\n1. Create a sorted array of pairs.\\n2. Calculate the max_score for a set of indices (with k greatest values from the second array).\\n3. Add one vertex that happens to be the min vertex of the entire set and adjust (while maximizing) the sum of values from the first array.\\n4. Check if the inclusion of the new vertex makes the score greater, if so update the max_score.\\n\\nThing to look out for is the implementation of a priority queue using a min binary heap which is a reasonably efficient implementation.\\n\\n# Time complexity\\nInsert O(logn)\\nExtract_min O(logn)\\nBuild_heap O(n)\\n\\n# Code\\n```\\n#define LEFT(i) (2 * (i) + 1)\\n#define RIGHT(i) (2 * (i) + 2)\\n#define PARENT(i) (i > 0 ? (((i) - 1) / 2) : 0)\\n\\n// Implementation of a priority queue using a min-heap.\\ntypedef struct {\\n    int *arr;\\n    int capacity; // number of memory allocated for elements\\n    int size; // number of elements\\n} Min_heap;\\n\\nvoid heapify(Min_heap *heap, int i) {\\n    int l = LEFT(i);\\n    int r = RIGHT(i);\\n    int min_i = i;\\n\\n    if (l < heap->size && heap->arr[l] < heap->arr[min_i]) {\\n        min_i = l;\\n    }\\n    if (r < heap->size && heap->arr[r] < heap->arr[min_i]) {\\n        min_i = r;\\n    }\\n\\n    if (min_i != i) {\\n        int temp = heap->arr[min_i];\\n        heap->arr[min_i] = heap->arr[i];\\n        heap->arr[i] = temp;\\n\\n        heapify(heap, min_i);\\n    }\\n}\\n\\nvoid build_heap(Min_heap *heap) {\\n    for (int i = PARENT(heap->size - 1); i >= 0; --i) {\\n        heapify(heap, i);\\n    }\\n}\\n\\nint insert(Min_heap *heap, int elem) {\\n    if (heap->size == heap->capacity) {\\n        return 1;\\n    }\\n\\n    heap->arr[heap->size] = elem;\\n    heap->size++;\\n\\n    int i = heap->size - 1;\\n\\n    while (i > 0) {\\n        i = PARENT(i);\\n        heapify(heap, i);\\n    }\\n\\n    return 0;\\n}\\n\\nint extract_min(Min_heap *heap, int *result) {\\n    if (heap->size == 0) {\\n        return 1;\\n    }\\n\\n    *result = heap->arr[0];\\n    heap->arr[0] = heap->arr[heap->size - 1];\\n    heap->size--;\\n    heapify(heap, 0);\\n\\n    return 0;\\n}\\n\\nint min_heap_init(Min_heap *heap, int capacity, int *inits, int n) {\\n    heap->arr = malloc(capacity * sizeof(int));\\n\\n    if (heap->arr == NULL) {\\n        return 1;\\n    }\\n\\n    heap->size = 0;\\n    heap->capacity = capacity;\\n\\n    if (n > 0) {\\n        int i = 0;\\n        for (; i < n && i < capacity; ++i) {\\n            heap->arr[i] = inits[i];\\n        }\\n        heap->size = i;\\n\\n        build_heap(heap);\\n    }\\n\\n    return 0;\\n}\\n\\nint min_heap_destroy(Min_heap *heap) {\\n    if (heap->arr == NULL) {\\n        return 1;\\n    }\\n\\n    free(heap->arr);\\n\\n    return 0;\\n}\\n\\nlong long min_heap_sum(Min_heap *heap) {\\n    long long result = 0;\\n\\n    for (int i = 0; i < heap->size; ++i) {\\n        result += heap->arr[i];\\n    }\\n\\n    return result;\\n}\\n\\n// Implementation of the algorithm.\\ntypedef struct {\\n    int first;\\n    int second;\\n} pair;\\n\\nint cmp(const void *lhs, const void *rhs) {\\n    const pair *lhs_pair = (const pair *) lhs;\\n    const pair *rhs_pair = (const pair *) rhs;\\n\\n    if (lhs_pair->second < rhs_pair->second) {\\n        return 1;\\n    }\\n    else if (lhs_pair->second > rhs_pair->second) {\\n        return -1;\\n    }\\n    else {\\n        return 0;\\n    }\\n}\\n\\n// nums1Size == nums2Size\\nlong long maxScore(int *nums1, int nums1Size, int *nums2, int nums2Size, int k){\\n    // Create a sorted pair array.\\n    pair *pairs = malloc(nums1Size * sizeof(pair));\\n\\n    if (pairs == NULL) {\\n        fprintf(stderr, \"Failed to allocate memory for pairs.\\\\n\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    for (int i = 0; i < nums1Size; ++i) {\\n        pairs[i].first = nums1[i];\\n        pairs[i].second = nums2[i];\\n    }\\n\\n    qsort(pairs, nums1Size, sizeof(pair), cmp);\\n\\n    // Create a priority queue and gradually expand a set of indices used\\n    // for computing max_score.\\n    int *initializer = malloc(k * sizeof(pair));\\n\\n    if (initializer == NULL) {\\n        fprintf(stderr, \"Failed to allocate memory for initializer.\\\\n\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    for (int i = 0; i < k; ++i) {\\n        initializer[i] = pairs[i].first;\\n    }\\n\\n    Min_heap prio_queue;\\n    min_heap_init(&prio_queue, k, initializer, k);\\n\\n    long long cur_sum = min_heap_sum(&prio_queue);\\n    long long max_score = pairs[k - 1].second * cur_sum;\\n    \\n    // At this point we have an array of pairs that are sorted\\n    // in decreasing order according to the second member.\\n    for (int i = k; i < nums1Size; ++i) {\\n        int result = 0;\\n        extract_min(&prio_queue, &result);\\n        cur_sum -= result;\\n        cur_sum += pairs[i].first;\\n        insert(&prio_queue, pairs[i].first);\\n\\n        long long new_score = pairs[i].second * cur_sum;\\n\\n        if (new_score > max_score) {\\n            max_score = new_score;\\n        }\\n    }\\n\\n\\n    free(pairs);\\n    free(initializer);\\n    min_heap_destroy(&prio_queue);\\n\\n    return max_score;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define LEFT(i) (2 * (i) + 1)\\n#define RIGHT(i) (2 * (i) + 2)\\n#define PARENT(i) (i > 0 ? (((i) - 1) / 2) : 0)\\n\\n// Implementation of a priority queue using a min-heap.\\ntypedef struct {\\n    int *arr;\\n    int capacity; // number of memory allocated for elements\\n    int size; // number of elements\\n} Min_heap;\\n\\nvoid heapify(Min_heap *heap, int i) {\\n    int l = LEFT(i);\\n    int r = RIGHT(i);\\n    int min_i = i;\\n\\n    if (l < heap->size && heap->arr[l] < heap->arr[min_i]) {\\n        min_i = l;\\n    }\\n    if (r < heap->size && heap->arr[r] < heap->arr[min_i]) {\\n        min_i = r;\\n    }\\n\\n    if (min_i != i) {\\n        int temp = heap->arr[min_i];\\n        heap->arr[min_i] = heap->arr[i];\\n        heap->arr[i] = temp;\\n\\n        heapify(heap, min_i);\\n    }\\n}\\n\\nvoid build_heap(Min_heap *heap) {\\n    for (int i = PARENT(heap->size - 1); i >= 0; --i) {\\n        heapify(heap, i);\\n    }\\n}\\n\\nint insert(Min_heap *heap, int elem) {\\n    if (heap->size == heap->capacity) {\\n        return 1;\\n    }\\n\\n    heap->arr[heap->size] = elem;\\n    heap->size++;\\n\\n    int i = heap->size - 1;\\n\\n    while (i > 0) {\\n        i = PARENT(i);\\n        heapify(heap, i);\\n    }\\n\\n    return 0;\\n}\\n\\nint extract_min(Min_heap *heap, int *result) {\\n    if (heap->size == 0) {\\n        return 1;\\n    }\\n\\n    *result = heap->arr[0];\\n    heap->arr[0] = heap->arr[heap->size - 1];\\n    heap->size--;\\n    heapify(heap, 0);\\n\\n    return 0;\\n}\\n\\nint min_heap_init(Min_heap *heap, int capacity, int *inits, int n) {\\n    heap->arr = malloc(capacity * sizeof(int));\\n\\n    if (heap->arr == NULL) {\\n        return 1;\\n    }\\n\\n    heap->size = 0;\\n    heap->capacity = capacity;\\n\\n    if (n > 0) {\\n        int i = 0;\\n        for (; i < n && i < capacity; ++i) {\\n            heap->arr[i] = inits[i];\\n        }\\n        heap->size = i;\\n\\n        build_heap(heap);\\n    }\\n\\n    return 0;\\n}\\n\\nint min_heap_destroy(Min_heap *heap) {\\n    if (heap->arr == NULL) {\\n        return 1;\\n    }\\n\\n    free(heap->arr);\\n\\n    return 0;\\n}\\n\\nlong long min_heap_sum(Min_heap *heap) {\\n    long long result = 0;\\n\\n    for (int i = 0; i < heap->size; ++i) {\\n        result += heap->arr[i];\\n    }\\n\\n    return result;\\n}\\n\\n// Implementation of the algorithm.\\ntypedef struct {\\n    int first;\\n    int second;\\n} pair;\\n\\nint cmp(const void *lhs, const void *rhs) {\\n    const pair *lhs_pair = (const pair *) lhs;\\n    const pair *rhs_pair = (const pair *) rhs;\\n\\n    if (lhs_pair->second < rhs_pair->second) {\\n        return 1;\\n    }\\n    else if (lhs_pair->second > rhs_pair->second) {\\n        return -1;\\n    }\\n    else {\\n        return 0;\\n    }\\n}\\n\\n// nums1Size == nums2Size\\nlong long maxScore(int *nums1, int nums1Size, int *nums2, int nums2Size, int k){\\n    // Create a sorted pair array.\\n    pair *pairs = malloc(nums1Size * sizeof(pair));\\n\\n    if (pairs == NULL) {\\n        fprintf(stderr, \"Failed to allocate memory for pairs.\\\\n\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    for (int i = 0; i < nums1Size; ++i) {\\n        pairs[i].first = nums1[i];\\n        pairs[i].second = nums2[i];\\n    }\\n\\n    qsort(pairs, nums1Size, sizeof(pair), cmp);\\n\\n    // Create a priority queue and gradually expand a set of indices used\\n    // for computing max_score.\\n    int *initializer = malloc(k * sizeof(pair));\\n\\n    if (initializer == NULL) {\\n        fprintf(stderr, \"Failed to allocate memory for initializer.\\\\n\");\\n        exit(EXIT_FAILURE);\\n    }\\n\\n    for (int i = 0; i < k; ++i) {\\n        initializer[i] = pairs[i].first;\\n    }\\n\\n    Min_heap prio_queue;\\n    min_heap_init(&prio_queue, k, initializer, k);\\n\\n    long long cur_sum = min_heap_sum(&prio_queue);\\n    long long max_score = pairs[k - 1].second * cur_sum;\\n    \\n    // At this point we have an array of pairs that are sorted\\n    // in decreasing order according to the second member.\\n    for (int i = k; i < nums1Size; ++i) {\\n        int result = 0;\\n        extract_min(&prio_queue, &result);\\n        cur_sum -= result;\\n        cur_sum += pairs[i].first;\\n        insert(&prio_queue, pairs[i].first);\\n\\n        long long new_score = pairs[i].second * cur_sum;\\n\\n        if (new_score > max_score) {\\n            max_score = new_score;\\n        }\\n    }\\n\\n\\n    free(pairs);\\n    free(initializer);\\n    min_heap_destroy(&prio_queue);\\n\\n    return max_score;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3558353,
                "title": "golang-minheap",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN) + O(NlogK) -> O(NlogN), since N > k\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc maxScore(nums1 []int, nums2 []int, k int) int64 {\\n    arr := [][]int{}\\n    for i := 0; i < len(nums1); i++ {\\n        arr = append(arr, []int{nums1[i], nums2[i]})\\n    }\\n\\n    // O(NlogN)\\n    // Sort in decreasing order of nums2\\n    sort.Slice(arr, func (i, j int) bool {\\n        return arr[i][1] > arr[j][1]\\n    })\\n\\n    minHeap := &MinHeap{}\\n    sum := 0\\n    // O(KlogK)\\n    for i := 0; i < k; i++ {\\n        // O(logK)\\n        heap.Push(minHeap, arr[i])\\n        sum += arr[i][0]\\n    }\\n\\n    res := sum * arr[k-1][1]\\n\\n    // O(NlogK)\\n    for i := k; i < len(arr); i++ {\\n        // Remove element with smallest nums1\\n        // O(logK)\\n        smallNum := heap.Pop(minHeap).([]int)\\n        sum += arr[i][0] - smallNum[0]\\n\\n        // O(logK)\\n        heap.Push(minHeap, arr[i])\\n\\n        res = max(res, sum * arr[i][1])\\n    }\\n\\n    return int64(res)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int           { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxScore(nums1 []int, nums2 []int, k int) int64 {\\n    arr := [][]int{}\\n    for i := 0; i < len(nums1); i++ {\\n        arr = append(arr, []int{nums1[i], nums2[i]})\\n    }\\n\\n    // O(NlogN)\\n    // Sort in decreasing order of nums2\\n    sort.Slice(arr, func (i, j int) bool {\\n        return arr[i][1] > arr[j][1]\\n    })\\n\\n    minHeap := &MinHeap{}\\n    sum := 0\\n    // O(KlogK)\\n    for i := 0; i < k; i++ {\\n        // O(logK)\\n        heap.Push(minHeap, arr[i])\\n        sum += arr[i][0]\\n    }\\n\\n    res := sum * arr[k-1][1]\\n\\n    // O(NlogK)\\n    for i := k; i < len(arr); i++ {\\n        // Remove element with smallest nums1\\n        // O(logK)\\n        smallNum := heap.Pop(minHeap).([]int)\\n        sum += arr[i][0] - smallNum[0]\\n\\n        // O(logK)\\n        heap.Push(minHeap, arr[i])\\n\\n        res = max(res, sum * arr[i][1])\\n    }\\n\\n    return int64(res)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int           { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MinHeap) Push(x interface{}) {\\n    *h = append(*h, x.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558322,
                "title": "java-51ms-100-fast-sort-then-priorityqueue-heap",
                "content": "This code is optimized for speed.  Many other solutions combine corresponding values from `nums1[]` and `nums2[]` to a `Pair`, a new class, or some other object, then sort the objects.  This code gets it biggest speed improvement by combining corresponding values from `nums1[]` and `nums2[]` into a `long` value in an array of `long`, then sorting the array of `long`.  Since `long` is a primitive data type in Java, the array of `long` is more simply stored in memory than an array of objects from most other solutions.  In Java, it is much faster to sort an array of primitive data types, than it is to sort an array of objects.\\n\\nUsing an array of `long` to sort the `nums1` and `nums2` values is faster, but the code is poorer coding practices, unless speed is required from the code.  Other coding solutions for this leetcode problem are generally simpler, more readable, and usually better coding practices.  Some software projects to have fixed timing requirements, where the speed requirements may override good programming practices, if the good programming practices do not produce the required speed.\\n\\nThe code below ran as fast as 51ms in May 2023.\\n```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final long MASK = 0xF_FFFFL;\\n    \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        \\n        // Simultaneous sort of nums1 and nums2, sorting ascending \\n        // by nums2.  Pack both nums1 and corresponding nums2 value \\n        // into a single long, in an array of long, then sort that \\n        // array of long.\\n        long[] nums21 = new long[n];\\n        for (int i = n - 1; i >= 0; i--) \\n            nums21[i] = ((long)nums2[i] << SHIFT) | nums1[i];\\n        Arrays.sort(nums21);\\n        \\n        // Build a priority queue with lowest first, containing the \\n        // k highest values from nums2.  Calculate a sum of the \\n        // values in the priority queue.  The index of the highest \\n        // possible min value from nums2, will be at index idx2 in \\n        // the sorted nums21 array.  The highest k-1 values in nums2 \\n        // will never be a min value from nums2, so skip the highest \\n        // k-1 values in nums2, and start min value testing at \\n        // highest possible min value, which is at index n-k in the \\n        // sorted nums21 array.\\n        PriorityQueue<Integer> kNumFromNums1 = new PriorityQueue(k + 1);\\n        long sumFromNums1 = 0;\\n        int idx21 = n - k;\\n        for (int i = idx21; i < n; i++) {\\n            sumFromNums1 += (nums21[i] & MASK);\\n            kNumFromNums1.add((int)(nums21[i] & MASK));\\n        }\\n\\n        // For each possible min value from nums1 (index n-k...0 in nums21), \\n        // test to see if the sum of the k highest available nums1 values \\n        // will resultin the highest score.\\n        long result = sumFromNums1 * (nums21[idx21] >> SHIFT);\\n        while (--idx21 >= 0) {\\n            sumFromNums1 += (nums21[idx21] & MASK) - kNumFromNums1.poll();\\n            kNumFromNums1.add((int)(nums21[idx21] & MASK));\\n            result = Math.max(result, sumFromNums1 * (nums21[idx21] >> SHIFT));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int SHIFT = 20;\\n    static final long MASK = 0xF_FFFFL;\\n    \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        \\n        // Simultaneous sort of nums1 and nums2, sorting ascending \\n        // by nums2.  Pack both nums1 and corresponding nums2 value \\n        // into a single long, in an array of long, then sort that \\n        // array of long.\\n        long[] nums21 = new long[n];\\n        for (int i = n - 1; i >= 0; i--) \\n            nums21[i] = ((long)nums2[i] << SHIFT) | nums1[i];\\n        Arrays.sort(nums21);\\n        \\n        // Build a priority queue with lowest first, containing the \\n        // k highest values from nums2.  Calculate a sum of the \\n        // values in the priority queue.  The index of the highest \\n        // possible min value from nums2, will be at index idx2 in \\n        // the sorted nums21 array.  The highest k-1 values in nums2 \\n        // will never be a min value from nums2, so skip the highest \\n        // k-1 values in nums2, and start min value testing at \\n        // highest possible min value, which is at index n-k in the \\n        // sorted nums21 array.\\n        PriorityQueue<Integer> kNumFromNums1 = new PriorityQueue(k + 1);\\n        long sumFromNums1 = 0;\\n        int idx21 = n - k;\\n        for (int i = idx21; i < n; i++) {\\n            sumFromNums1 += (nums21[i] & MASK);\\n            kNumFromNums1.add((int)(nums21[i] & MASK));\\n        }\\n\\n        // For each possible min value from nums1 (index n-k...0 in nums21), \\n        // test to see if the sum of the k highest available nums1 values \\n        // will resultin the highest score.\\n        long result = sumFromNums1 * (nums21[idx21] >> SHIFT);\\n        while (--idx21 >= 0) {\\n            sumFromNums1 += (nums21[idx21] & MASK) - kNumFromNums1.poll();\\n            kNumFromNums1.add((int)(nums21[idx21] & MASK));\\n            result = Math.max(result, sumFromNums1 * (nums21[idx21] >> SHIFT));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558298,
                "title": "python-simple-and-clean-beats-99-79",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem involves finding the maximum score given two lists of integers and an integer k. The first thought is to find pairs of integers from the two lists and sort them based on the second element of each pair.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create pairs of integers from the two lists using the `zip` function.\\n1. Sort the pairs in descending order based on the second element of each pair.\\n1. Initialize a minimum heap, a variable to keep track of the sum of the first elements of the pairs, and a variable to keep track of the result.\\n1. Iterate over the sorted pairs.\\n1. Add the first element of each pair to the sum and push it onto the minimum heap.\\n1. If the size of the minimum heap is greater than `k`, pop an element from it and subtract it from the sum.\\n1. If the size of the minimum heap is equal to `k`, update the result with the maximum value between the current result and the product of the sum and the second element of the current pair.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = [(n1,n2) for n1, n2 in zip(nums1,nums2)]\\n        pairs = sorted(pairs, key=lambda p: p[1], reverse = True)\\n        minHeap = []\\n        n1Sum = 0\\n        res = 0\\n\\n        for n1, n2 in pairs:\\n            n1Sum+=n1\\n            heapq.heappush(minHeap,n1)\\n\\n            if len(minHeap)>k:\\n                n1Pop = heapq.heappop(minHeap)\\n                n1Sum -= n1Pop\\n            if len(minHeap)==k:\\n                res = max(res,n1Sum*n2)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = [(n1,n2) for n1, n2 in zip(nums1,nums2)]\\n        pairs = sorted(pairs, key=lambda p: p[1], reverse = True)\\n        minHeap = []\\n        n1Sum = 0\\n        res = 0\\n\\n        for n1, n2 in pairs:\\n            n1Sum+=n1\\n            heapq.heappush(minHeap,n1)\\n\\n            if len(minHeap)>k:\\n                n1Pop = heapq.heappop(minHeap)\\n                n1Sum -= n1Pop\\n            if len(minHeap)==k:\\n                res = max(res,n1Sum*n2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557285,
                "title": "c-sort-vector-pair-priority-queue",
                "content": "# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<LL,LL>> v;\\n        for(int i=0;i<(int)nums1.size();i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        priority_queue<LL,vector<LL>,greater<LL>> pq;\\n        LL ans=0,curr=0;\\n        for(int i=(int)nums1.size()-1;i>=0;i--){\\n            if(pq.size()<k){\\n                curr+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n            else{\\n                if(pq.top()<v[i].second){\\n                    curr-=pq.top();\\n                    pq.pop();\\n                    pq.push(v[i].second);\\n                    curr+=v[i].second;\\n                }\\n            }\\n            if(pq.size()==k){\\n                ans=max(ans,curr*v[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<LL,LL>> v;\\n        for(int i=0;i<(int)nums1.size();i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        priority_queue<LL,vector<LL>,greater<LL>> pq;\\n        LL ans=0,curr=0;\\n        for(int i=(int)nums1.size()-1;i>=0;i--){\\n            if(pq.size()<k){\\n                curr+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n            else{\\n                if(pq.top()<v[i].second){\\n                    curr-=pq.top();\\n                    pq.pop();\\n                    pq.push(v[i].second);\\n                    curr+=v[i].second;\\n                }\\n            }\\n            if(pq.size()==k){\\n                ans=max(ans,curr*v[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3557140,
                "title": "daily-leetcoding-challenge-may-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subsequence-score/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-subsequence-score/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3101975,
                "title": "simple-code-with-explanation-beats-90-easiest-heap-sorting-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe complete logic is described in the comments of the code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to use a Heap and sort nums2 to get the max result. Check the code for proper explanation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N + K)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res = 0 #for storing the max final result (The Answer)\\n        sum = 0 #for calculating the sum of each subsequence\\n        h = []  #heapq for storing the elements from nums1 in a sorted manner, so that we can remove the smallest value in a single step and append to it the next element and hence make modifications to the sum variable along with it. \\n        for max2,n1 in sorted(zip(nums2,nums1), reverse=True) :#Merge the two arrays and sort it in decreasing order based on the values of nums2, as we would like to multiply the max subsequence sum with the min value from nums2 to get the max possible result.\\n            if len(h)==k : #if the heap is already filled then remove the smallest element out of it, and add a element to get the max result. The sum is also reduced along the process , coz we are excluding the the value from the subsequence. \\n                sum -= heapq.heappop(h)\\n            sum += n1\\n            heapq.heappush(h,n1) #Add the next element from nums1 to the sum to form the new subsequence , also push it into the heap to maintain the track of the subsequence we are using.\\n            if len(h)==k :\\n                res = max(res,sum*max2) #Finally calculate the result by multiplying the max possible sum and the min element of nums2 from that subsequence and as we have sorted it in decreasing order,hence we will get the max result.We will continue this process for every subsequence possible.\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res = 0 #for storing the max final result (The Answer)\\n        sum = 0 #for calculating the sum of each subsequence\\n        h = []  #heapq for storing the elements from nums1 in a sorted manner, so that we can remove the smallest value in a single step and append to it the next element and hence make modifications to the sum variable along with it. \\n        for max2,n1 in sorted(zip(nums2,nums1), reverse=True) :#Merge the two arrays and sort it in decreasing order based on the values of nums2, as we would like to multiply the max subsequence sum with the min value from nums2 to get the max possible result.\\n            if len(h)==k : #if the heap is already filled then remove the smallest element out of it, and add a element to get the max result. The sum is also reduced along the process , coz we are excluding the the value from the subsequence. \\n                sum -= heapq.heappop(h)\\n            sum += n1\\n            heapq.heappush(h,n1) #Add the next element from nums1 to the sum to form the new subsequence , also push it into the heap to maintain the track of the subsequence we are using.\\n            if len(h)==k :\\n                res = max(res,sum*max2) #Finally calculate the result by multiplying the max possible sum and the min element of nums2 from that subsequence and as we have sorted it in decreasing order,hence we will get the max result.We will continue this process for every subsequence possible.\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094546,
                "title": "c-multiset-easy-to-understand",
                "content": "```\\nlong long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<long long int,long long int>>v;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(rbegin(v),rend(v)); //sort vector v on basis of nums2 \\n        multiset<int>st;\\n        long long int sum=0;\\n        for(int i=0;i<(k);i++){\\n            st.insert(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        long long int res=sum*v[k-1].first;\\n        for(int i=k;i<n;i++){\\n            \\n            st.insert(v[i].second);\\n            \\n            if(v[i].second>*st.begin())\\n            {\\n                sum+=v[i].second;\\n                sum-=*st.begin();//Each time erasing the smallest value as it will decrease the value of res\\n            }\\n            st.erase(st.begin());\\n            res=max(res,sum*v[i].first);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nlong long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<long long int,long long int>>v;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(rbegin(v),rend(v)); //sort vector v on basis of nums2 \\n        multiset<int>st;\\n        long long int sum=0;\\n        for(int i=0;i<(k);i++){\\n            st.insert(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        long long int res=sum*v[k-1].first;\\n        for(int i=k;i<n;i++){\\n            \\n            st.insert(v[i].second);\\n            \\n            if(v[i].second>*st.begin())\\n            {\\n                sum+=v[i].second;\\n                sum-=*st.begin();//Each time erasing the smallest value as it will decrease the value of res\\n            }\\n            st.erase(st.begin());\\n            res=max(res,sum*v[i].first);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086018,
                "title": "python-meanheap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe result depends of two components:\\n- sum of `k` elements of `nums1`, and\\n- min of correspondent `k` elements of `nums2`\\n\\nIf `k == len(nums1)` the answer is straightforward: `ans = sum(nums1) * min(nums2)`, but what if `k < len(nums1)`?\\n\\nTo maximize the first component we can select `k` largest elements of `nums1`. There is no way to make the first component larger by substituting any of the selected elements with any `nums1[i]` outside of this group. The only chance to imrpove the result is to get rid of the minimum `nums2[j]` (and of corrspondent `nums1[j]`, respectively), where `j` corresponds to the indices of `k` elements of `nums1` we selected, and substitute it with another element of `nums2` (which is hopefully > `nums2[j]`).\\n\\nTo find the minimum `nums2[j]` corresponding to `k` selected `nums1` elements the meanheap can be used. Beside the value of the minimum `nums2[j]` we also need to know correspondent `nums1[j]` (or its index) to be subtracted from the sum. Therefore, we push to the heap either the pair `(nums2[j], j)` or `(nums2[j], nums1[j])`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsidering the above, the following algorithm can be implemented:\\n1. Sort `(nums1[i], nums2[i])` pairs by `nums1` in reverse order (from largest to smallest)\\n2. Initialize `ans = 0`, `k_sum = 0` (sum of current k-elements of `nums1` ) and `heap = []`\\n3. For each pair `(num1, num2)` in the sorted list:\\n- update `k_sum += num1`\\n- push `(num2, num1)` into `heap`\\n- if `len(heap) == k`:\\n&nbsp;&nbsp;&nbsp;&nbsp;- pop `(num2, num1)` from heap\\n&nbsp;&nbsp;&nbsp;&nbsp;- calculate current `ans = max(ans, k_sum * num2)`\\n&nbsp;&nbsp;&nbsp;&nbsp;- update `k_sum -= num1`\\n4. Return `ans`\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == len(nums1):\\n            return (sum(nums1) * min(nums2))\\n\\n        k_sum = 0   # sum of current selected nums1 elements \\n        ans = 0\\n        heap: List[Tuple[int, int]] = []\\n        for num1, num2 in sorted(zip(nums1, nums2), reverse = True):\\n            k_sum += num1\\n            heapq.heappush(heap, (num2, num1))\\n            if len(heap) == k:\\n                num2, num1 = heapq.heappop(heap)\\n                ans = max(ans, k_sum * num2)\\n                k_sum -= num1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == len(nums1):\\n            return (sum(nums1) * min(nums2))\\n\\n        k_sum = 0   # sum of current selected nums1 elements \\n        ans = 0\\n        heap: List[Tuple[int, int]] = []\\n        for num1, num2 in sorted(zip(nums1, nums2), reverse = True):\\n            k_sum += num1\\n            heapq.heappush(heap, (num2, num1))\\n            if len(heap) == k:\\n                num2, num1 = heapq.heappop(heap)\\n                ans = max(ans, k_sum * num2)\\n                k_sum -= num1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083270,
                "title": "c-java-python3-priority-queue-sorting",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7c339707e031611c80809107e7a667b2c6b6f7f0) for solutions of biweekly 96. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> aug; \\n        for (int i = 0; i < nums1.size(); ++i)\\n            aug.push_back({nums2[i], nums1[i]}); \\n        sort(aug.begin(), aug.end(), greater<>()); \\n        priority_queue<int, vector<int>, greater<>> pq; \\n        long long ans = 0, total = 0; \\n        for (int i = 0; i < aug.size(); ++i) {\\n            total += aug[i][1]; \\n            pq.push(aug[i][1]); \\n            if (i >= k) { total -= pq.top(); pq.pop(); }\\n            if (i >= k-1) ans = max(ans, total * aug[i][0]); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length; \\n        int[][] aug = new int[n][2]; \\n        for (int i = 0; i < n; ++i) {\\n            aug[i][0] = nums1[i]; \\n            aug[i][1] = nums2[i]; \\n        }\\n        Arrays.sort(aug, new Comparator<int[]>(){\\n            public int compare(int[] lhs, int[] rhs) {\\n                return -Integer.compare(lhs[1], rhs[1]); \\n            }\\n        }); \\n        PriorityQueue<Integer> pq = new PriorityQueue(); \\n        long ans = 0, total = 0; \\n        for (int i = 0; i < aug.length; ++i) {\\n            total += aug[i][0]; \\n            pq.add(aug[i][0]); \\n            if (i >= k) total -= pq.poll(); \\n            if (i >= k-1) ans = Math.max(ans, total * aug[i][1]); \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        nums2, nums1 = zip(*sorted(zip(nums2, nums1), reverse=True))\\n        pq = [] \\n        ans = total = 0 \\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            total += x \\n            heappush(pq, x)\\n            if i >= k: total -= heappop(pq)\\n            if i >= k-1: ans = max(ans, total * y)\\n        return ans \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> aug; \\n        for (int i = 0; i < nums1.size(); ++i)\\n            aug.push_back({nums2[i], nums1[i]}); \\n        sort(aug.begin(), aug.end(), greater<>()); \\n        priority_queue<int, vector<int>, greater<>> pq; \\n        long long ans = 0, total = 0; \\n        for (int i = 0; i < aug.size(); ++i) {\\n            total += aug[i][1]; \\n            pq.push(aug[i][1]); \\n            if (i >= k) { total -= pq.top(); pq.pop(); }\\n            if (i >= k-1) ans = max(ans, total * aug[i][0]); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length; \\n        int[][] aug = new int[n][2]; \\n        for (int i = 0; i < n; ++i) {\\n            aug[i][0] = nums1[i]; \\n            aug[i][1] = nums2[i]; \\n        }\\n        Arrays.sort(aug, new Comparator<int[]>(){\\n            public int compare(int[] lhs, int[] rhs) {\\n                return -Integer.compare(lhs[1], rhs[1]); \\n            }\\n        }); \\n        PriorityQueue<Integer> pq = new PriorityQueue(); \\n        long ans = 0, total = 0; \\n        for (int i = 0; i < aug.length; ++i) {\\n            total += aug[i][0]; \\n            pq.add(aug[i][0]); \\n            if (i >= k) total -= pq.poll(); \\n            if (i >= k-1) ans = Math.max(ans, total * aug[i][1]); \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        nums2, nums1 = zip(*sorted(zip(nums2, nums1), reverse=True))\\n        pq = [] \\n        ans = total = 0 \\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            total += x \\n            heappush(pq, x)\\n            if i >= k: total -= heappop(pq)\\n            if i >= k-1: ans = max(ans, total * y)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082854,
                "title": "codeforces-1600-rated-question-priority-queue",
                "content": "```\\nhttps://codeforces.com/contest/1140/problem/C\\n```\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& A, vector<int>& B, int k) {\\n        int n = A.size();\\n        vector<pair<int, int>> bt(n);\\n        for (int i = 0; i < n; i++){\\n            int t, b;\\n            b = B[i];\\n            t = A[i];\\n            bt[i] = make_pair(b, t);\\n        }\\n        sort(bt.begin(), bt.end());\\n        reverse(bt.begin(), bt.end());\\n        long long ans = 0;\\n        long long sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> Q;\\n        for (int i = 0; i < n; i++){\\n            if (Q.size() == k){\\n                sum -= Q.top();\\n                Q.pop();\\n            }\\n            Q.push(bt[i].second);\\n            sum += bt[i].second;\\n            if(Q.size() == k) {\\n                ans = max(ans, sum * bt[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nhttps://codeforces.com/contest/1140/problem/C\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& A, vector<int>& B, int k) {\\n        int n = A.size();\\n        vector<pair<int, int>> bt(n);\\n        for (int i = 0; i < n; i++){\\n            int t, b;\\n            b = B[i];\\n            t = A[i];\\n            bt[i] = make_pair(b, t);\\n        }\\n        sort(bt.begin(), bt.end());\\n        reverse(bt.begin(), bt.end());\\n        long long ans = 0;\\n        long long sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> Q;\\n        for (int i = 0; i < n; i++){\\n            if (Q.size() == k){\\n                sum -= Q.top();\\n                Q.pop();\\n            }\\n            Q.push(bt[i].second);\\n            sum += bt[i].second;\\n            if(Q.size() == k) {\\n                ans = max(ans, sum * bt[i].first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082245,
                "title": "c-priority-queue-time-o-nlogn-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor every element in nums2 consider it as smallest and then solve\\ndo this for all and find max\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n=nums1.size();\\n        \\n        long long ans=0;\\n        \\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n    \\n        \\n        \\n        vector<long long> su(n,0);\\n        \\n        multiset<int> s;\\n        \\n        long long sum=0;\\n        \\n        for(int i=n-1;i>=n-k;i--)\\n        {\\n            s.insert(v[i].second);\\n            sum = sum + v[i].second;\\n        }\\n        su[n-k]=sum;\\n        \\n        \\n        \\n        for(int i=n-k-1;i>=0;i--)\\n        {\\n            sum=sum-*s.begin();\\n            s.erase(s.begin());\\n            \\n            s.insert(v[i].second);\\n            \\n            sum = sum + v[i].second;\\n            \\n            \\n            su[i]=sum;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max( ans , su[i]*v[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n=nums1.size();\\n        \\n        long long ans=0;\\n        \\n        \\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n    \\n        \\n        \\n        vector<long long> su(n,0);\\n        \\n        multiset<int> s;\\n        \\n        long long sum=0;\\n        \\n        for(int i=n-1;i>=n-k;i--)\\n        {\\n            s.insert(v[i].second);\\n            sum = sum + v[i].second;\\n        }\\n        su[n-k]=sum;\\n        \\n        \\n        \\n        for(int i=n-k-1;i>=0;i--)\\n        {\\n            sum=sum-*s.begin();\\n            s.erase(s.begin());\\n            \\n            s.insert(v[i].second);\\n            \\n            sum = sum + v[i].second;\\n            \\n            \\n            su[i]=sum;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ans = max( ans , su[i]*v[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082167,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long maxScore(vector<int>& speed, vector<int>& efficiency, int k) {\\n        int n = speed.size();\\n        vector<pair<int, int>> ess(n);\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = {efficiency[i], speed[i]};\\n        sort(rbegin(ess), rend(ess));\\n        long long sumS = 0, res = 0;\\n        priority_queue <int, vector<int>, greater<int>> pq; //min heap\\n        for (auto& [e, s] : ess) {\\n            pq.emplace(s);\\n            sumS += s;\\n            if (pq.size() > k) {\\n                sumS -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k)\\n                res = max(res, sumS * e);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long maxScore(vector<int>& speed, vector<int>& efficiency, int k) {\\n        int n = speed.size();\\n        vector<pair<int, int>> ess(n);\\n        for (int i = 0; i < n; ++i)\\n            ess[i] = {efficiency[i], speed[i]};\\n        sort(rbegin(ess), rend(ess));\\n        long long sumS = 0, res = 0;\\n        priority_queue <int, vector<int>, greater<int>> pq; //min heap\\n        for (auto& [e, s] : ess) {\\n            pq.emplace(s);\\n            sumS += s;\\n            if (pq.size() > k) {\\n                sumS -= pq.top();\\n                pq.pop();\\n            }\\n            if (pq.size() == k)\\n                res = max(res, sumS * e);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082120,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        nums=[]\\n        for x,y in zip(nums1,nums2):\\n            nums.append((x,y))\\n            \\n        nums.sort(key=lambda x:-x[1])\\n        h=[]\\n        best=0\\n        total=0\\n        for x,y in nums:\\n            heapq.heappush(h,x)\\n            total+=x\\n            if len(h)>k:\\n                t=heapq.heappop(h)\\n                total-=t\\n            if len(h)==k:\\n                \\n                best=max(best,total*y)\\n                \\n        return best         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        nums=[]\\n        for x,y in zip(nums1,nums2):\\n            nums.append((x,y))\\n            \\n        nums.sort(key=lambda x:-x[1])\\n        h=[]\\n        best=0\\n        total=0\\n        for x,y in nums:\\n            heapq.heappush(h,x)\\n            total+=x\\n            if len(h)>k:\\n                t=heapq.heappop(h)\\n                total-=t\\n            if len(h)==k:\\n                \\n                best=max(best,total*y)\\n                \\n        return best         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082114,
                "title": "used-recursion-but-gives-tle-anyone-help-to-optimize",
                "content": "Approach: Pick and Non Pick Approach. This code gives TLE. \\nAnyone please help\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long ans = INT_MIN;\\n    void helper(int idx,long long sum,priority_queue <long long, vector<long long>, greater<long long>> pq,\\n                     vector<int>& nums1, vector<int>& nums2, int k,vector<long long> &dp){\\n        \\n        if(k==0){\\n            ans = max(ans,(pq.top()*sum));\\n            return;\\n        }\\n        if(idx<0){\\n            return;\\n        }\\n        helper(idx-1,sum,pq,nums1,nums2,k,dp);\\n        if(pq.size()!=0 && nums2[idx]==pq.top()) pq.pop();\\n        pq.push(nums2[idx]);\\n        helper(idx-1,sum+nums1[idx],pq,nums1,nums2,k-1,dp);\\n        \\n    }\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue <long long, vector<long long>, greater<long long>> pq;\\n        \\n        vector<long long> dp(nums1.size(),-1);\\n        \\n        helper(nums1.size()-1,0,pq,nums1,nums2,k,dp);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long ans = INT_MIN;\\n    void helper(int idx,long long sum,priority_queue <long long, vector<long long>, greater<long long>> pq,\\n                     vector<int>& nums1, vector<int>& nums2, int k,vector<long long> &dp){\\n        \\n        if(k==0){\\n            ans = max(ans,(pq.top()*sum));\\n            return;\\n        }\\n        if(idx<0){\\n            return;\\n        }\\n        helper(idx-1,sum,pq,nums1,nums2,k,dp);\\n        if(pq.size()!=0 && nums2[idx]==pq.top()) pq.pop();\\n        pq.push(nums2[idx]);\\n        helper(idx-1,sum+nums1[idx],pq,nums1,nums2,k-1,dp);\\n        \\n    }\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue <long long, vector<long long>, greater<long long>> pq;\\n        \\n        vector<long long> dp(nums1.size(),-1);\\n        \\n        helper(nums1.size()-1,0,pq,nums1,nums2,k,dp);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082111,
                "title": "c-fastest-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<ll,ll>>v;\\n        ll n=(long)nums1.size();\\n        for(ll i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end());\\n         priority_queue<ll, vector<ll>, greater<ll> > pq;\\n        ll sum=0;\\n        for(ll i=n-1;i>=n-k+1;i--){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        ll ans=-1;\\n        for(ll i=n-k;i>=0;i--){\\n            ll cu_sum=v[i].second+sum;\\n            //cout << cu_sum <<  \" \" <<  i <<  \" \" << v[i].second << endl;\\n            ans=max(ans,v[i].first*(cu_sum));\\n            //cout << pq.top() << \" \" << sum << endl;\\n            if(k>1 && v[i].second>pq.top()){\\n                \\n                sum-=pq.top();\\n                pq.pop();\\n                sum+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n            //cout << pq.top() <<  \" \" << sum << endl;\\n        }\\n        //cout << ans << endl;\\n   \\xA0\\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<ll,ll>>v;\\n        ll n=(long)nums1.size();\\n        for(ll i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end());\\n         priority_queue<ll, vector<ll>, greater<ll> > pq;\\n        ll sum=0;\\n        for(ll i=n-1;i>=n-k+1;i--){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        ll ans=-1;\\n        for(ll i=n-k;i>=0;i--){\\n            ll cu_sum=v[i].second+sum;\\n            //cout << cu_sum <<  \" \" <<  i <<  \" \" << v[i].second << endl;\\n            ans=max(ans,v[i].first*(cu_sum));\\n            //cout << pq.top() << \" \" << sum << endl;\\n            if(k>1 && v[i].second>pq.top()){\\n                \\n                sum-=pq.top();\\n                pq.pop();\\n                sum+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n            //cout << pq.top() <<  \" \" << sum << endl;\\n        }\\n        //cout << ans << endl;\\n   \\xA0\\xA0\\xA0\\xA0\\xA0return\\xA0ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3970203,
                "title": "using-minheap",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = [(n1,n2) for n1,n2 in zip(nums1,nums2)]\\n        pairs = sorted(pairs,key = lambda p : p[1], reverse = True)\\n\\n        minHeap,n1Sum = [],0\\n        res = 0\\n\\n        for n1,n2 in pairs:\\n            n1Sum += n1\\n            heapq.heappush(minHeap,n1)\\n\\n            if len(minHeap) > k:\\n                n1Pop = heapq.heappop(minHeap)\\n                n1Sum -= n1Pop\\n\\n            if len(minHeap) == k:\\n                res = max(res,n1Sum*n2)\\n\\n        return res\\n\\n# time complexity - O(nlogk)\\n# space - O(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = [(n1,n2) for n1,n2 in zip(nums1,nums2)]\\n        pairs = sorted(pairs,key = lambda p : p[1], reverse = True)\\n\\n        minHeap,n1Sum = [],0\\n        res = 0\\n\\n        for n1,n2 in pairs:\\n            n1Sum += n1\\n            heapq.heappush(minHeap,n1)\\n\\n            if len(minHeap) > k:\\n                n1Pop = heapq.heappop(minHeap)\\n                n1Sum -= n1Pop\\n\\n            if len(minHeap) == k:\\n                res = max(res,n1Sum*n2)\\n\\n        return res\\n\\n# time complexity - O(nlogk)\\n# space - O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945993,
                "title": "clean-code-easy-approach-beginner-friendly-priority-queue",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\n    \\npublic:\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n       int n = nums1.size();\\n        \\n        vector<pair<int,int>> vec(n);\\n        \\n        for(int i = 0; i<n; i++) {\\n            vec[i] = {nums1[i], nums2[i]};\\n        }\\n        \\n        auto lambda = [&](auto &P1, auto &P2) {\\n            return P1.second > P2.second;\\n        };\\n        \\n        sort(begin(vec), end(vec), lambda);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq; //min_heap\\n        \\n        long long Ksum = 0;\\n        \\n        for(int i = 0; i<=k-1; i++) {\\n            \\n            Ksum += vec[i].first;\\n            pq.push(vec[i].first);\\n            \\n        }\\n        \\n        long long result = Ksum * vec[k-1].second;\\n        \\n        for(int i = k; i<n; i++) {\\n            \\n            //taking minimum as vec[i].second\\n            Ksum += vec[i].first - pq.top();\\n            pq.pop();\\n            \\n            pq.push(vec[i].first);\\n            \\n            result = max(result, Ksum * vec[i].second);\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\npublic:\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n       int n = nums1.size();\\n        \\n        vector<pair<int,int>> vec(n);\\n        \\n        for(int i = 0; i<n; i++) {\\n            vec[i] = {nums1[i], nums2[i]};\\n        }\\n        \\n        auto lambda = [&](auto &P1, auto &P2) {\\n            return P1.second > P2.second;\\n        };\\n        \\n        sort(begin(vec), end(vec), lambda);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq; //min_heap\\n        \\n        long long Ksum = 0;\\n        \\n        for(int i = 0; i<=k-1; i++) {\\n            \\n            Ksum += vec[i].first;\\n            pq.push(vec[i].first);\\n            \\n        }\\n        \\n        long long result = Ksum * vec[k-1].second;\\n        \\n        for(int i = k; i<n; i++) {\\n            \\n            //taking minimum as vec[i].second\\n            Ksum += vec[i].first - pq.top();\\n            pq.pop();\\n            \\n            pq.push(vec[i].first);\\n            \\n            result = max(result, Ksum * vec[i].second);\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821782,
                "title": "o-nlogn-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nscore = sum (k max elements from nums1) * min (k elements from nums2)\\n\\nTo maximize the score, maximize the sum and the multiplier. For this, select k maximum values from nums1 and k minimum from nums2.\\n\\nUse a min heap to track the k largest elements in nums1. For minimum of nums2, pair nums1 and nums2 elements and sort the pairs in descending order based on the values in num2. The highest value in num2 will be at the start of the sorted pairs and when we get k elements from nums1, the kth element in num2 will be the smallest one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- make pairs and sort the pairs in descending order\\n- create a min heap to store k largest elements from nums1\\n- set result res = 0 to track the max score\\n- set sum_n1 = 0 to track sum of current k nums1 elements\\n- Traverse the pairs\\n    - add nums1 elements to sum_n1 \\n    - push the nums1 element to the heap\\n    - if the size of heap > k, remove the smallest nums1 element from heap and also subtract it from sum_n1\\n    - if there are k elements in the heap, update res by taking max of the current score and the previous max score\\n- return res\\n\\n\\n# Complexity\\n- Time complexity: O(sort + n-k heap push pop) \\u2192 O(nlogn + (n-k)logk)\\n\\u2192 O(nlogn)\\n    - heap push pop time = log(heap size)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(sort + heap size) \\u2192 O(n + k) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = sorted([(n2, n1) for n1, n2 in zip(nums1, nums2)], reverse=True)\\n        min_heap = []\\n        res = 0\\n        sum_n1 = 0\\n        for n2, n1 in pairs:\\n            sum_n1 += n1\\n            heapq.heappush(min_heap, n1)\\n            if len(min_heap) > k:\\n                sum_n1 -= heapq.heappop(min_heap)\\n            if len(min_heap) == k:\\n                res = max(res, sum_n1 * n2)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = sorted([(n2, n1) for n1, n2 in zip(nums1, nums2)], reverse=True)\\n        min_heap = []\\n        res = 0\\n        sum_n1 = 0\\n        for n2, n1 in pairs:\\n            sum_n1 += n1\\n            heapq.heappush(min_heap, n1)\\n            if len(min_heap) > k:\\n                sum_n1 -= heapq.heappop(min_heap)\\n            if len(min_heap) == k:\\n                res = max(res, sum_n1 * n2)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636869,
                "title": "single-min-heap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple min heap solution \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs explained in earlier posts we will sort the array of pairs in decreasing order a/c to the second and keep k-1 elements in our min heap\\n1.Push the k-1 elements and store in sum.\\n2.for every element in range k-1 index to n we assume it as the minimum of k elements and keep track of all previous elements for which it will be minimum and pop the minimum of previous elements and decreament it from sum.\\n3.In this way we can keep track of maximum in ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N LOGN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N+k)-storing pairs,k elements in min heap;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans=0;\\n        int n=nums1.size();\\n        vector<pair<int,int>> arr(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]={nums2[i],nums1[i]};\\n        }\\n        sort(arr.rbegin(),arr.rend());\\n        long long sum=0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i=0;i<k-1;i++){\\n            sum+=arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n        for(int i=k-1;i<n;i++){\\n            sum+=arr[i].second;\\n            ans=max(ans,sum*arr[i].first);\\n            pq.push(arr[i].second);\\n            sum-=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans=0;\\n        int n=nums1.size();\\n        vector<pair<int,int>> arr(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]={nums2[i],nums1[i]};\\n        }\\n        sort(arr.rbegin(),arr.rend());\\n        long long sum=0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(int i=0;i<k-1;i++){\\n            sum+=arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n        for(int i=k-1;i<n;i++){\\n            sum+=arr[i].second;\\n            ans=max(ans,sum*arr[i].first);\\n            pq.push(arr[i].second);\\n            sum-=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559935,
                "title": "c-java-easy-and-clean-code-priority-queue-beats",
                "content": "# Please Upvote if you like my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity \\n- Time complexity: $$O(N*logN)$$ where `N` is size of array `nums1`. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(K)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> arr;\\n        for(int i=0; i<nums1.size(); i++) arr.push_back({nums2[i], nums1[i]});\\n        sort(arr.rbegin(), arr.rend());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq; \\n        long long ans = 0, sumSeq = 0;\\n        for(auto &pr : arr){\\n            pq.push(pr.second);\\n            sumSeq += pr.second;\\n            if( pq.size() > k ) sumSeq -= pq.top(), pq.pop();\\n            if( pq.size() == k ) ans = max(ans, sumSeq*1ll*pr.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        List<int[]> arr = new ArrayList<>();\\n        for(int i=0; i<nums1.length; i++)\\n            arr.add(new int[]{nums2[i], nums1[i]});\\n        Collections.sort(arr, (x,y)->y[0] - x[0]);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long sumSeq = 0, ans = 0;\\n        for(int[] pr : arr){\\n            pq.add(pr[1]);\\n            sumSeq += pr[1];\\n            if( pq.size() > k ) sumSeq -= pq.remove();\\n            if( pq.size() == k ) ans = Math.max(ans, sumSeq*pr[0]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> arr;\\n        for(int i=0; i<nums1.size(); i++) arr.push_back({nums2[i], nums1[i]});\\n        sort(arr.rbegin(), arr.rend());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq; \\n        long long ans = 0, sumSeq = 0;\\n        for(auto &pr : arr){\\n            pq.push(pr.second);\\n            sumSeq += pr.second;\\n            if( pq.size() > k ) sumSeq -= pq.top(), pq.pop();\\n            if( pq.size() == k ) ans = max(ans, sumSeq*1ll*pr.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        List<int[]> arr = new ArrayList<>();\\n        for(int i=0; i<nums1.length; i++)\\n            arr.add(new int[]{nums2[i], nums1[i]});\\n        Collections.sort(arr, (x,y)->y[0] - x[0]);\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long sumSeq = 0, ans = 0;\\n        for(int[] pr : arr){\\n            pq.add(pr[1]);\\n            sumSeq += pr[1];\\n            if( pq.size() > k ) sumSeq -= pq.remove();\\n            if( pq.size() == k ) ans = Math.max(ans, sumSeq*pr[0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559923,
                "title": "simple-c-solution-using-priority-queue-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long maxScore=0, sum=0;\\n        // declaring min heap\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        // vector of pair to store corresponding values\\n        vector<pair<int,int>> vp;\\n        \\n        // inserting all value in vector of pair\\n        for(int i=0;i<nums1.size();i++){\\n            vp.push_back({nums2[i],nums1[i]});\\n        }\\n        // sorting the vector in decreasing order\\n        sort(vp.begin(),vp.end(),greater<>());\\n        for(int i=0;i<nums1.size();i++){\\n            sum+=vp[i].second;\\n            pq.push(vp[i].second);\\n            // when the size of priority queue is equal to k\\n            // then perform required operation\\n            if(pq.size()==k){\\n                maxScore = max(maxScore,sum*vp[i].first);\\n                // removing lowest score to increase overall score\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long maxScore=0, sum=0;\\n        // declaring min heap\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        // vector of pair to store corresponding values\\n        vector<pair<int,int>> vp;\\n        \\n        // inserting all value in vector of pair\\n        for(int i=0;i<nums1.size();i++){\\n            vp.push_back({nums2[i],nums1[i]});\\n        }\\n        // sorting the vector in decreasing order\\n        sort(vp.begin(),vp.end(),greater<>());\\n        for(int i=0;i<nums1.size();i++){\\n            sum+=vp[i].second;\\n            pq.push(vp[i].second);\\n            // when the size of priority queue is equal to k\\n            // then perform required operation\\n            if(pq.size()==k){\\n                maxScore = max(maxScore,sum*vp[i].first);\\n                // removing lowest score to increase overall score\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559841,
                "title": "solved-using-min-heap-and-sorting-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpon analyzing the problem, we observe that the score is determined by the sum of selected elements from `nums1` multiplied by the minimum value from the corresponding elements in `nums2`. To maximize the score, we need to strategically choose the elements from both arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a 2D array pair to store pairs of corresponding elements from nums1 and nums2.\\n2. Sort the pair array in descending order based on the second element (nums2) using a lambda expression.\\n3. Initialize variables ans and curr_sum to store the maximum score and the current sum, respectively.\\n4. Use a priority queue (pq) to keep track of the k-1 smallest elements from nums1.\\n5. Iterate from 0 to k-1 and add the elements to pq, updating curr_sum accordingly.\\n6. Iterate from k-1 to the end of the arrays and perform the following:\\n    - Add the current element from nums1 to pq and update curr_sum.\\n    - Calculate the score for the current pair and update ans if necessary.\\n    - Remove the smallest element from pq and subtract it from curr_sum.\\n7. Return the maximum score ans.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$, where n is the length of `nums1` and `nums2`. This complexity arises from sorting the pair array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n$$O(n)$$, where n is the length of `nums1` and `nums2`. The space is used to store the pair array and the priority queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] pair = new int[nums1.length][2];\\n\\n        for(int i = 0; i < nums1.length; i++) {\\n            pair[i][0] = nums2[i];\\n            pair[i][1] = nums1[i];\\n        }\\n\\n        Arrays.sort(pair, (a, b) -> b[0] - a[0]);\\n        // compare the second element of each pair using lambda expression\\n        long ans = 0, curr_sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        // Pushing the elements of nums1 in a min heap of size k-1\\n        for(int i = 0; i < k-1; i++) {\\n            curr_sum += pair[i][1];\\n            pq.add(pair[i][1]);\\n        }\\n\\n        //looping for the rest of array\\n        for(int i = k-1; i < nums1.length; i++) {\\n            curr_sum += pair[i][1];\\n            pq.add(pair[i][1]);\\n            ans = Math.max(curr_sum*pair[i][0], ans);\\n\\n            curr_sum -= pq.peek();\\n            pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int[][] pair = new int[nums1.length][2];\\n\\n        for(int i = 0; i < nums1.length; i++) {\\n            pair[i][0] = nums2[i];\\n            pair[i][1] = nums1[i];\\n        }\\n\\n        Arrays.sort(pair, (a, b) -> b[0] - a[0]);\\n        // compare the second element of each pair using lambda expression\\n        long ans = 0, curr_sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        // Pushing the elements of nums1 in a min heap of size k-1\\n        for(int i = 0; i < k-1; i++) {\\n            curr_sum += pair[i][1];\\n            pq.add(pair[i][1]);\\n        }\\n\\n        //looping for the rest of array\\n        for(int i = k-1; i < nums1.length; i++) {\\n            curr_sum += pair[i][1];\\n            pq.add(pair[i][1]);\\n            ans = Math.max(curr_sum*pair[i][0], ans);\\n\\n            curr_sum -= pq.peek();\\n            pq.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559556,
                "title": "2542-maximum-subsequence-score-java",
                "content": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        ArrayList<Pair<Integer,Integer>> al=new ArrayList();\\n        int n=nums2.length;\\n        for(int i=0;i<n;i++)\\n        al.add(new Pair (nums2[i],nums1[i]));\\n        Collections.sort(al,Collections.reverseOrder((a,b)->a.getKey()-b.getKey()));\\n        long cursum=0,ans=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue(k);\\n        for(int i=0;i<n;i++)\\n        {\\n            Pair<Integer,Integer> help=al.get(i);\\n            pq.offer(help.getValue());\\n            cursum+=help.getValue();\\n            if(pq.size()==k)\\n            {\\n                ans=Math.max(ans,cursum*help.getKey());\\n                cursum-=pq.poll();      \\n            }   \\n        }       \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        ArrayList<Pair<Integer,Integer>> al=new ArrayList();\\n        int n=nums2.length;\\n        for(int i=0;i<n;i++)\\n        al.add(new Pair (nums2[i],nums1[i]));\\n        Collections.sort(al,Collections.reverseOrder((a,b)->a.getKey()-b.getKey()));\\n        long cursum=0,ans=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue(k);\\n        for(int i=0;i<n;i++)\\n        {\\n            Pair<Integer,Integer> help=al.get(i);\\n            pq.offer(help.getValue());\\n            cursum+=help.getValue();\\n            if(pq.size()==k)\\n            {\\n                ans=Math.max(ans,cursum*help.getKey());\\n                cursum-=pq.poll();      \\n            }   \\n        }       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559493,
                "title": "it-is-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> v;\\n        int n = nums1.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        long long int summ = 0,res = 0;\\n        for(auto &i: v)\\n        {\\n            summ+=i.second;\\n            pq.push(i.second);\\n            \\n            while(pq.size()>k)\\n            {\\n                summ-=pq.top();\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() == k)\\n            {\\n                res = max(summ * i.first,res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> v;\\n        int n = nums1.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        long long int summ = 0,res = 0;\\n        for(auto &i: v)\\n        {\\n            summ+=i.second;\\n            pq.push(i.second);\\n            \\n            while(pq.size()>k)\\n            {\\n                summ-=pq.top();\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() == k)\\n            {\\n                res = max(summ * i.first,res);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559469,
                "title": "c-solution-using-priority-queue-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n\\n           vector<pair<int,int>> v;\\n\\n           for(int i=0;i<nums1.size();i++)\\n             v.push_back({nums2[i],nums1[i]});\\n\\n           sort(v.rbegin(),v.rend());\\n\\n           long long ans = 0;\\n           long long currSum = 0;\\n\\n           priority_queue<int,vector<int>,greater<int>> pq;\\n\\n           for(int i=0;i<k-1;i++){\\n               currSum += v[i].second;\\n               pq.push(v[i].second);\\n           }\\n\\n           for(int i = k-1;i<nums1.size();i++){\\n               currSum += v[i].second;\\n               pq.push(v[i].second);\\n               ans = max(ans,currSum*v[i].first);\\n\\n               currSum -= pq.top();\\n               pq.pop();\\n           } \\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n\\n           vector<pair<int,int>> v;\\n\\n           for(int i=0;i<nums1.size();i++)\\n             v.push_back({nums2[i],nums1[i]});\\n\\n           sort(v.rbegin(),v.rend());\\n\\n           long long ans = 0;\\n           long long currSum = 0;\\n\\n           priority_queue<int,vector<int>,greater<int>> pq;\\n\\n           for(int i=0;i<k-1;i++){\\n               currSum += v[i].second;\\n               pq.push(v[i].second);\\n           }\\n\\n           for(int i = k-1;i<nums1.size();i++){\\n               currSum += v[i].second;\\n               pq.push(v[i].second);\\n               ans = max(ans,currSum*v[i].first);\\n\\n               currSum -= pq.top();\\n               pq.pop();\\n           } \\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559389,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        List<(int,int)> lst = new();\\n        for(int i=0;i<nums1.Length;i++) \\n            lst.Add((nums1[i], nums2[i]));\\n        \\n        PriorityQueue<int, int> pq = new();\\n        lst = lst.OrderByDescending(x => x.Item2).ToList();\\n\\n        long sum = 0;\\n        int min = 0;\\n        for(int i=0; i<k; i++) {\\n            pq.Enqueue(lst[i].Item1, lst[i].Item1);\\n            sum += lst[i].Item1;\\n            min = lst[i].Item2;\\n        }\\n\\n        long res = sum * min;\\n        for(int i=k; i<lst.Count; i++) {\\n            sum += lst[i].Item1 - pq.Dequeue();\\n            pq.Enqueue(lst[i].Item1, lst[i].Item1);\\n            min = lst[i].Item2;\\n            res = Math.Max(res, sum * min);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        List<(int,int)> lst = new();\\n        for(int i=0;i<nums1.Length;i++) \\n            lst.Add((nums1[i], nums2[i]));\\n        \\n        PriorityQueue<int, int> pq = new();\\n        lst = lst.OrderByDescending(x => x.Item2).ToList();\\n\\n        long sum = 0;\\n        int min = 0;\\n        for(int i=0; i<k; i++) {\\n            pq.Enqueue(lst[i].Item1, lst[i].Item1);\\n            sum += lst[i].Item1;\\n            min = lst[i].Item2;\\n        }\\n\\n        long res = sum * min;\\n        for(int i=k; i<lst.Count; i++) {\\n            sum += lst[i].Item1 - pq.Dequeue();\\n            pq.Enqueue(lst[i].Item1, lst[i].Item1);\\n            min = lst[i].Item2;\\n            res = Math.Max(res, sum * min);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559238,
                "title": "php-minheap-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    /**\\n     * @param int[] $nums1\\n     * @param int[] $nums2\\n     * @param int $k\\n     * @return int\\n     */\\n    public function maxScore(array $nums1, array $nums2, int $k): int {\\n        $n = count($nums1);\\n\\n        $pairs = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $pairs[$i] = [$nums1[$i], $nums2[$i]];\\n        }\\n\\n        usort($pairs, fn($a, $b) => $b[1] - $a[1]);\\n\\n        $topKHeap = new SplMinHeap();\\n\\n        $topKSum = 0;\\n        for ($i = 0; $i < $k; $i++) {\\n            $topKSum += $pairs[$i][0];\\n            $topKHeap->insert($pairs[$i][0]);\\n        }\\n\\n        $answer = $topKSum * $pairs[$k - 1][1];\\n\\n        for ($i = $k; $i < $n; $i++) {\\n            $topKSum += $pairs[$i][0] - $topKHeap->extract();\\n            $topKHeap->insert($pairs[$i][0]);\\n\\n            $answer = max($answer, $topKSum * $pairs[$i][1]);\\n        }\\n\\n        return $answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param int[] $nums1\\n     * @param int[] $nums2\\n     * @param int $k\\n     * @return int\\n     */\\n    public function maxScore(array $nums1, array $nums2, int $k): int {\\n        $n = count($nums1);\\n\\n        $pairs = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $pairs[$i] = [$nums1[$i], $nums2[$i]];\\n        }\\n\\n        usort($pairs, fn($a, $b) => $b[1] - $a[1]);\\n\\n        $topKHeap = new SplMinHeap();\\n\\n        $topKSum = 0;\\n        for ($i = 0; $i < $k; $i++) {\\n            $topKSum += $pairs[$i][0];\\n            $topKHeap->insert($pairs[$i][0]);\\n        }\\n\\n        $answer = $topKSum * $pairs[$k - 1][1];\\n\\n        for ($i = $k; $i < $n; $i++) {\\n            $topKSum += $pairs[$i][0] - $topKHeap->extract();\\n            $topKHeap->insert($pairs[$i][0]);\\n\\n            $answer = max($answer, $topKSum * $pairs[$i][1]);\\n        }\\n\\n        return $answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559150,
                "title": "maximum-subsequence-score-c",
                "content": "\\n# Complexity\\n- Time complexity:\\nO( N * Log(N) + (N-k) * Log(k) )\\n\\n- Space complexity:\\nO(N) + O(k) = O(N+K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> p;\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            p.push_back(make_pair(nums2[i],nums1[i]));\\n        }\\n\\n        sort(p.rbegin(),p.rend());\\n\\n        long long ans=0;\\n        long long sum=0;\\n        priority_queue<int> pq;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            sum+=p[i].second;\\n         pq.push(-p[i].second); // So that largest elements always stays in queue.\\n\\n        }\\n\\n        for(int i=k-1;i<nums1.size();i++)\\n        {\\n            sum+=p[i].second;\\n            pq.push(-p[i].second);\\n\\n            ans=max(ans,p[i].first*sum);\\n\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> p;\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            p.push_back(make_pair(nums2[i],nums1[i]));\\n        }\\n\\n        sort(p.rbegin(),p.rend());\\n\\n        long long ans=0;\\n        long long sum=0;\\n        priority_queue<int> pq;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            sum+=p[i].second;\\n         pq.push(-p[i].second); // So that largest elements always stays in queue.\\n\\n        }\\n\\n        for(int i=k-1;i<nums1.size();i++)\\n        {\\n            sum+=p[i].second;\\n            pq.push(-p[i].second);\\n\\n            ans=max(ans,p[i].first*sum);\\n\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558858,
                "title": "swift-heap-solution",
                "content": "*Note: CFBinaryHeap is used in the solution as unfortunately leetocode doesn\\'t support Swift Collections just yet!!*\\n```\\nimport CoreFoundation\\n\\nclass Solution {\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var prefixSum = 0\\n        var res = 0\\n        var heap = Heap<Int>()\\n\\n        for (n1, n2) in zip(nums1, nums2).sorted { $0.1 > $1.1 } {\\n            prefixSum += n1\\n            heap.insert(n1)\\n            if heap.count == k {\\n                res = max(res, prefixSum * n2)\\n                prefixSum -= heap.popMin()!\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n\\nstruct Heap<T> {\\n    var heap: CFBinaryHeap\\n    var count: Int {\\n        CFBinaryHeapGetCount(heap)\\n    }\\n    init(_ elements: [T] = []) {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { lp, rp, _ in\\n            let (lhs, rhs) = (lp!.load(as: Int.self), rp!.load(as: Int.self))\\n            return lhs == rhs ? .compareEqualTo : lhs < rhs ? .compareLessThan : .compareGreaterThan\\n        }\\n        heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        for element in elements {\\n            self.insert(element)\\n        }\\n    }\\n    \\n    func insert(_ val: T) {\\n        let pointer = UnsafeMutablePointer<T>.allocate(capacity: 1)\\n        pointer.initialize(to: val)\\n        CFBinaryHeapAddValue(heap, pointer)\\n    }\\n\\n    func popMin() -> T? {\\n        guard let minPointer = CFBinaryHeapGetMinimum(heap) else { return nil }\\n        let minValue = minPointer.load(as: T.self)\\n        CFBinaryHeapRemoveMinimumValue(heap)\\n        minPointer.deallocate()\\n        return minValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport CoreFoundation\\n\\nclass Solution {\\n    func maxScore(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var prefixSum = 0\\n        var res = 0\\n        var heap = Heap<Int>()\\n\\n        for (n1, n2) in zip(nums1, nums2).sorted { $0.1 > $1.1 } {\\n            prefixSum += n1\\n            heap.insert(n1)\\n            if heap.count == k {\\n                res = max(res, prefixSum * n2)\\n                prefixSum -= heap.popMin()!\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n\\nstruct Heap<T> {\\n    var heap: CFBinaryHeap\\n    var count: Int {\\n        CFBinaryHeapGetCount(heap)\\n    }\\n    init(_ elements: [T] = []) {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { lp, rp, _ in\\n            let (lhs, rhs) = (lp!.load(as: Int.self), rp!.load(as: Int.self))\\n            return lhs == rhs ? .compareEqualTo : lhs < rhs ? .compareLessThan : .compareGreaterThan\\n        }\\n        heap = CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n        for element in elements {\\n            self.insert(element)\\n        }\\n    }\\n    \\n    func insert(_ val: T) {\\n        let pointer = UnsafeMutablePointer<T>.allocate(capacity: 1)\\n        pointer.initialize(to: val)\\n        CFBinaryHeapAddValue(heap, pointer)\\n    }\\n\\n    func popMin() -> T? {\\n        guard let minPointer = CFBinaryHeapGetMinimum(heap) else { return nil }\\n        let minValue = minPointer.load(as: T.self)\\n        CFBinaryHeapRemoveMinimumValue(heap)\\n        minPointer.deallocate()\\n        return minValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558847,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> req ;\\n        int n=nums1.size() ;\\n        for(int i=0 ; i<n ; i++){\\n            req.push_back({nums2[i],nums1[i]}) ;\\n        }\\n        sort(req.begin(),req.end()) ;\\n        reverse(req.begin(),req.end()) ;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long sum=0 ;\\n        for(int i=0 ; i<k-1 ; i++){\\n            pq.push(req[i].second) ;\\n            sum+=req[i].second ;\\n        }\\n        long long ans=0 ;\\n        for(int i=k-1 ; i<n ; i++){\\n            ans=max(ans,(long long)(sum+req[i].second)*req[i].first) ;\\n            if(pq.size() && pq.top()<req[i].second){\\n                sum-=pq.top() ;\\n                sum+=req[i].second ;\\n                pq.pop() ;\\n                pq.push(req[i].second) ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> req ;\\n        int n=nums1.size() ;\\n        for(int i=0 ; i<n ; i++){\\n            req.push_back({nums2[i],nums1[i]}) ;\\n        }\\n        sort(req.begin(),req.end()) ;\\n        reverse(req.begin(),req.end()) ;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long sum=0 ;\\n        for(int i=0 ; i<k-1 ; i++){\\n            pq.push(req[i].second) ;\\n            sum+=req[i].second ;\\n        }\\n        long long ans=0 ;\\n        for(int i=k-1 ; i<n ; i++){\\n            ans=max(ans,(long long)(sum+req[i].second)*req[i].first) ;\\n            if(pq.size() && pq.top()<req[i].second){\\n                sum-=pq.top() ;\\n                sum+=req[i].second ;\\n                pq.pop() ;\\n                pq.push(req[i].second) ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558765,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vp;\\n        int n = nums1.size();\\n        for(int i = 0; i<n; i++){\\n            vp.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        reverse(vp.begin(),vp.end());\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        long long sum = 0;\\n        for(int i = 0; i<k; i++){\\n            sum+=vp[i].second;\\n            pq.push(vp[i].second);\\n        }\\n        long long maxi = sum*vp[k-1].first;\\n        for(int i = k; i<n; i++){\\n            if(sum-pq.top()+vp[i].second > sum){\\n                sum = sum-pq.top()+vp[i].second;\\n                pq.pop();\\n                pq.push(vp[i].second);\\n            }\\n            long long x = sum*vp[i].first;\\n            maxi = max(maxi,x);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vp;\\n        int n = nums1.size();\\n        for(int i = 0; i<n; i++){\\n            vp.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        reverse(vp.begin(),vp.end());\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        long long sum = 0;\\n        for(int i = 0; i<k; i++){\\n            sum+=vp[i].second;\\n            pq.push(vp[i].second);\\n        }\\n        long long maxi = sum*vp[k-1].first;\\n        for(int i = k; i<n; i++){\\n            if(sum-pq.top()+vp[i].second > sum){\\n                sum = sum-pq.top()+vp[i].second;\\n                pq.pop();\\n                pq.push(vp[i].second);\\n            }\\n            long long x = sum*vp[i].first;\\n            maxi = max(maxi,x);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558748,
                "title": "c-easy-implemention",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n// STORE THEM ACCORDING TO DEC ORDER!!\\nvector<pair<int,int>>v;\\n// 1 2  3  4 --> nums2\\n// 3  1 3  2  --> nums1\\nfor(int i = 0 ; i<nums1.size();i++)\\n{\\n    v.push_back({nums2[i],nums1[i]});\\n}\\nsort(v.rbegin(),v.rend());\\n// AFTER SORTING\\n// 4 3  2  1 --> nums2\\n// 2  1 3  4  --> nums1\\nlong long ans=0;\\nlong long cur_s = 0;\\n// MIN HEAP\\npriority_queue<int,vector<int>,greater<int>>pq;\\n\\n// \\nfor(int i = 0;i<k-1;i++)\\n{\\n    cur_s += v[i].second;\\n    pq.push(v[i].second);\\n\\n}\\nfor(int i = k-1;i<nums1.size();i++)\\n{\\n    cur_s += v[i].second;\\n    pq.push(v[i].second);\\n    ans = max(ans,cur_s*v[i].first);\\n    cur_s -= pq.top();\\n    pq.pop();\\n\\n}\\nreturn ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n// STORE THEM ACCORDING TO DEC ORDER!!\\nvector<pair<int,int>>v;\\n// 1 2  3  4 --> nums2\\n// 3  1 3  2  --> nums1\\nfor(int i = 0 ; i<nums1.size();i++)\\n{\\n    v.push_back({nums2[i],nums1[i]});\\n}\\nsort(v.rbegin(),v.rend());\\n// AFTER SORTING\\n// 4 3  2  1 --> nums2\\n// 2  1 3  4  --> nums1\\nlong long ans=0;\\nlong long cur_s = 0;\\n// MIN HEAP\\npriority_queue<int,vector<int>,greater<int>>pq;\\n\\n// \\nfor(int i = 0;i<k-1;i++)\\n{\\n    cur_s += v[i].second;\\n    pq.push(v[i].second);\\n\\n}\\nfor(int i = k-1;i<nums1.size();i++)\\n{\\n    cur_s += v[i].second;\\n    pq.push(v[i].second);\\n    ans = max(ans,cur_s*v[i].first);\\n    cur_s -= pq.top();\\n    pq.pop();\\n\\n}\\nreturn ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558606,
                "title": "oriority-queue-sorting-very-simple-way-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vp;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n          ll ans=0,sum=0;\\n        for(int i=0;i<nums1.size();i++){\\n             vp.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vp.begin(),vp.end(),greater<>());\\n         for(int j=0;j<nums1.size();j++){\\n              sum+=vp[j].second;\\n              pq.push(vp[j].second);\\n             if(pq.size()<k){\\n                  continue;\\n             }\\n            if(pq.size()==k){\\n               ans=max(ans,sum*vp[j].first);\\n               sum-=pq.top();\\n               pq.pop();\\n            }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vp;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n          ll ans=0,sum=0;\\n        for(int i=0;i<nums1.size();i++){\\n             vp.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vp.begin(),vp.end(),greater<>());\\n         for(int j=0;j<nums1.size();j++){\\n              sum+=vp[j].second;\\n              pq.push(vp[j].second);\\n             if(pq.size()<k){\\n                  continue;\\n             }\\n            if(pq.size()==k){\\n               ans=max(ans,sum*vp[j].first);\\n               sum-=pq.top();\\n               pq.pop();\\n            }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558507,
                "title": "sorting-and-priorityqueue-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**BruteForce**\\nfix the k indexes by k loops and calculate max score of all the combinations. This will be $$O(n^k)$$ TC.\\n\\n**Idea 1**\\nNormally in cases like this, we have to fix one variable and then try to see if this lowers the complexity.\\n\\nIn this case , an idea can be to fix the min value of the k selected indexes in nums2.\\n\\nTo further extend this idea, we can declare nums[i] -> {nums1[i],nums2[i]}\\nand sort nums based on nums2[i]. This will enable us to select an element with index j as min value and helps us narrow the k selected indexes in 0 to j. \\n\\nAs we can see the above problem can be seen as the max k elements for a stream which can be resolved by priority queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare nums[i] -> {nums1[i],nums2[i]} \\n2. Sort nums based on nums2[i]\\n3. Select j = k-1 to n can be min values \\n4. Use priority Queue to select k-1 largest values with 1 element already fixed being nums[j][0]\\n5. Select max score out of all these cases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(nlogn)$$ -> Sort\\n$$O(n)$$ -> loop with priority queue selecting largest k elements\\n\\n$$O(nlogn)$$ -> effective TC\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        //Brute force : write k loops and select k indexes and get maximum of the scores calculated\\n        //Idea 2 : There is no relation between nums1[i] and nums2[i] so we will have to fix one of them \\n        //i.e. one way is to fix the min of k nums2[j] and find the max sum for that case.\\n\\n        int n = nums2.Length;\\n\\n        int[][] nums = new int[n][];\\n\\n        for(int i=0;i<n;i++){\\n            nums[i] = new int[2];\\n            nums[i][0] = nums1[i];\\n            nums[i][1] = nums2[i];\\n        }\\n\\n        //Console.WriteLine(\"Here\");\\n\\n        Array.Sort(nums,(x,y)=>y[1].CompareTo(x[1]));\\n\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>();\\n\\n        long sum =0;\\n\\n        //Console.WriteLine(\"Here\");\\n\\n        //select nums[k-1][1] as min value of the selected elements i0,i1,...,ik-1\\n        for(int i=0;i<k;i++){\\n            sum += nums[i][0];\\n            pq.Enqueue(nums[i][0],nums[i][0]);\\n        }\\n\\n        long ans = sum*nums[k-1][1];\\n        //Console.WriteLine(ans);\\n\\n        for(int i=k;i<n;i++){\\n            //if nums[i][1] is the min and the selected bunch are in the range of 0 , i\\n            sum += nums[i][0]-pq.Dequeue();\\n            pq.Enqueue(nums[i][0],nums[i][0]);\\n\\n            ans = Math.Max(ans,sum*nums[i][1]);\\n            //Console.WriteLine($\"{sum*nums[i][1]} , {ans}\");\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n        //Brute force : write k loops and select k indexes and get maximum of the scores calculated\\n        //Idea 2 : There is no relation between nums1[i] and nums2[i] so we will have to fix one of them \\n        //i.e. one way is to fix the min of k nums2[j] and find the max sum for that case.\\n\\n        int n = nums2.Length;\\n\\n        int[][] nums = new int[n][];\\n\\n        for(int i=0;i<n;i++){\\n            nums[i] = new int[2];\\n            nums[i][0] = nums1[i];\\n            nums[i][1] = nums2[i];\\n        }\\n\\n        //Console.WriteLine(\"Here\");\\n\\n        Array.Sort(nums,(x,y)=>y[1].CompareTo(x[1]));\\n\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>();\\n\\n        long sum =0;\\n\\n        //Console.WriteLine(\"Here\");\\n\\n        //select nums[k-1][1] as min value of the selected elements i0,i1,...,ik-1\\n        for(int i=0;i<k;i++){\\n            sum += nums[i][0];\\n            pq.Enqueue(nums[i][0],nums[i][0]);\\n        }\\n\\n        long ans = sum*nums[k-1][1];\\n        //Console.WriteLine(ans);\\n\\n        for(int i=k;i<n;i++){\\n            //if nums[i][1] is the min and the selected bunch are in the range of 0 , i\\n            sum += nums[i][0]-pq.Dequeue();\\n            pq.Enqueue(nums[i][0],nums[i][0]);\\n\\n            ans = Math.Max(ans,sum*nums[i][1]);\\n            //Console.WriteLine($\"{sum*nums[i][1]} , {ans}\");\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558406,
                "title": "greedy-approach-with-priorityqueue-in-java",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] nums2Indexed = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            nums2Indexed[i] = new int[]{nums2[i], i};\\n        }\\n        Arrays.sort(nums2Indexed, (a, b) -> b[0] - a[0]);\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long su = 0;\\n        for (int i = 0; i < k; i++) {\\n            int index = nums2Indexed[i][1];\\n            int val = nums1[nums2Indexed[i][1]];\\n            su += val;\\n            pq.offer(val);\\n        }\\n        long res = su * nums2Indexed[k - 1][0];\\n        for (int i = k; i < n; i++) {\\n            int index = nums2Indexed[i][1];\\n            int val = nums1[nums2Indexed[i][1]];\\n            if (val <= pq.peek()) continue;\\n            su -= pq.remove();\\n            pq.offer(val);\\n            su += val;\\n            res = Math.max(res, su * nums2Indexed[i][0]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] nums2Indexed = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            nums2Indexed[i] = new int[]{nums2[i], i};\\n        }\\n        Arrays.sort(nums2Indexed, (a, b) -> b[0] - a[0]);\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long su = 0;\\n        for (int i = 0; i < k; i++) {\\n            int index = nums2Indexed[i][1];\\n            int val = nums1[nums2Indexed[i][1]];\\n            su += val;\\n            pq.offer(val);\\n        }\\n        long res = su * nums2Indexed[k - 1][0];\\n        for (int i = k; i < n; i++) {\\n            int index = nums2Indexed[i][1];\\n            int val = nums1[nums2Indexed[i][1]];\\n            if (val <= pq.peek()) continue;\\n            su -= pq.remove();\\n            pq.offer(val);\\n            su += val;\\n            res = Math.max(res, su * nums2Indexed[i][0]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558389,
                "title": "easy-understandable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<ll,ll>>v;\\n        ll n=(long)nums1.size();\\n        for(ll i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end());\\n         priority_queue<ll, vector<ll>, greater<ll> > pq;\\n        ll sum=0;\\n        for(ll i=n-1;i>=n-k+1;i--){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        ll ans=-1;\\n        for(ll i=n-k;i>=0;i--){\\n            ll cu_sum=v[i].second+sum;\\n            ans=max(ans,v[i].first*(cu_sum));\\n            if(k>1 && v[i].second>pq.top()){\\n                \\n                sum-=pq.top();\\n                pq.pop();\\n                sum+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<ll,ll>>v;\\n        ll n=(long)nums1.size();\\n        for(ll i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end());\\n         priority_queue<ll, vector<ll>, greater<ll> > pq;\\n        ll sum=0;\\n        for(ll i=n-1;i>=n-k+1;i--){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n        }\\n        ll ans=-1;\\n        for(ll i=n-k;i>=0;i--){\\n            ll cu_sum=v[i].second+sum;\\n            ans=max(ans,v[i].first*(cu_sum));\\n            if(k>1 && v[i].second>pq.top()){\\n                \\n                sum-=pq.top();\\n                pq.pop();\\n                sum+=v[i].second;\\n                pq.push(v[i].second);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558372,
                "title": "java-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length; \\n        int[][] aug = new int[n][2]; \\n        for (int i = 0; i < n; ++i) {\\n            aug[i][0] = nums1[i]; \\n            aug[i][1] = nums2[i]; \\n        }\\n        Arrays.sort(aug, new Comparator<int[]>(){\\n            public int compare(int[] lhs, int[] rhs) {\\n                return -Integer.compare(lhs[1], rhs[1]); \\n            }\\n        }); \\n        PriorityQueue<Integer> pq = new PriorityQueue(); \\n        long ans = 0, total = 0; \\n        for (int i = 0; i < aug.length; ++i) {\\n            total += aug[i][0]; \\n            pq.add(aug[i][0]); \\n            if (i >= k) total -= pq.poll(); \\n            if (i >= k-1) ans = Math.max(ans, total * aug[i][1]); \\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length; \\n        int[][] aug = new int[n][2]; \\n        for (int i = 0; i < n; ++i) {\\n            aug[i][0] = nums1[i]; \\n            aug[i][1] = nums2[i]; \\n        }\\n        Arrays.sort(aug, new Comparator<int[]>(){\\n            public int compare(int[] lhs, int[] rhs) {\\n                return -Integer.compare(lhs[1], rhs[1]); \\n            }\\n        }); \\n        PriorityQueue<Integer> pq = new PriorityQueue(); \\n        long ans = 0, total = 0; \\n        for (int i = 0; i < aug.length; ++i) {\\n            total += aug[i][0]; \\n            pq.add(aug[i][0]); \\n            if (i >= k) total -= pq.poll(); \\n            if (i >= k-1) ans = Math.max(ans, total * aug[i][1]); \\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558043,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n     vector<pair<int, int>> p ;\\n        \\n        for(int i = 0 ; i<nums1.size() ; i++)\\n        {\\n            p.push_back({nums2[i] , nums1[i]});\\n        }\\n        \\n        sort(p.rbegin() , p.rend());\\n        \\n        long long ans  = 0;\\n        long long sum  = 0;\\n        priority_queue<int> pq;\\n        for(int i = 0 ; i<k-1 ; i++)\\n        {\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n        }\\n\\n        for(int i = k-1 ; i<nums1.size() ; i++)\\n        {\\n\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n            \\n            ans = max(ans, sum * p[i].first );\\n\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n     vector<pair<int, int>> p ;\\n        \\n        for(int i = 0 ; i<nums1.size() ; i++)\\n        {\\n            p.push_back({nums2[i] , nums1[i]});\\n        }\\n        \\n        sort(p.rbegin() , p.rend());\\n        \\n        long long ans  = 0;\\n        long long sum  = 0;\\n        priority_queue<int> pq;\\n        for(int i = 0 ; i<k-1 ; i++)\\n        {\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n        }\\n\\n        for(int i = k-1 ; i<nums1.size() ; i++)\\n        {\\n\\n            sum += p[i].second;\\n            pq.push(-p[i].second);\\n            \\n            ans = max(ans, sum * p[i].first );\\n\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557796,
                "title": "java-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public long maxScore(int[] nums1, int[] nums2, int k) {\\napproach 1\\n//     //   int n = nums1.length;\\n//     //     int[][] pairs = new int[n][2];\\n//     //     for (int i = 0; i < n; i++) {\\n//     //         pairs[i] = new int[] { nums2[i], nums1[i] };\\n//     //     }\\n//     //     Arrays.sort(pairs, (a, b) -> b[0] - a[0]);\\n//     //     PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> a - b);\\n//     //     long res = 0, totalSum = 0;\\n//     //     for (int[] pair : pairs) {\\n//     //         pq.add(pair[1]);\\n//     //         totalSum += pair[1];\\n//     //         if (pq.size() > k) {\\n//     //             totalSum -= pq.poll();\\n//     //         }\\n//     //         if (pq.size() == k) {\\n//     //             res = Math.max(res, totalSum * pair[0]);\\n//     //         }\\n//     //     }\\n//     //     return res;  \\n\\n\\nApproach 2\\n//       int n = nums1.length;\\n//         int[][] pairs = new int[n][2];\\n//         for (int i = 0; i < n; ++i) {\\n//             pairs[i] = new int[]{nums1[i], nums2[i]};\\n//         }\\n//         Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        \\n//         // Use a min-heap to maintain the top k elements.\\n//         PriorityQueue<Integer> topKHeap = new PriorityQueue<>(k, (a, b) -> a - b);\\n//         long topKSum = 0;\\n//         for (int i = 0; i < k; ++i) {\\n//             topKSum += pairs[i][0];\\n//             topKHeap.add(pairs[i][0]); \\n//                 }\\n        \\n//         // The score of the first k pairs.\\n//         long answer = topKSum * pairs[k - 1][1];\\n        \\n//         // Iterate over every nums2[i] as minimum from nums2.\\n//         for (int i = k; i < n; ++i) {\\n//             // Remove the smallest integer from the previous top k elements\\n//             // then ddd nums1[i] to the top k elements.\\n//             topKSum += pairs[i][0] - topKHeap.poll();\\n//             topKHeap.add(pairs[i][0]);\\n            \\n//             // Update answer as the maximum score.\\n//             answer = Math.max(answer, topKSum * pairs[i][1]);\\n//         }\\n        \\n//         return answer;\\n//     }\\n// }\\n\\nApproach 3\\nimport java.util.Arrays;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    // Nested Pair class\\n    class Pair {\\n        public int a, b;\\n\\n        public Pair(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        Pair[] arrp = new Pair[n];\\n        \\n        // Create pairs from nums1 and nums2\\n        for (int i = 0; i < n; i++)\\n            arrp[i] = new Pair(nums1[i], nums2[i]);\\n        \\n        // Sort pairs in descending order of \\'a\\'\\n        Arrays.sort(arrp, (p1, p2) -> -Integer.compare(p1.a, p2.a));\\n        \\n        // Create a priority queue to store pairs based on \\'b\\'\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((p1, p2) -> Integer.compare(p1.b, p2.b));\\n        \\n        long sum = 0;\\n        \\n        // Select \\'k\\' pairs with maximum \\'a\\' values and add them to the priority queue\\n        for (int i = 0; i < k; i++) {\\n            sum += arrp[i].a;\\n            pq.add(arrp[i]);\\n        }\\n        \\n        // Calculate the initial maximum score\\n        long max = pq.peek().b * sum;\\n        \\n        // Process remaining pairs\\n        for (int i = k; i < n; i++) {\\n            if (pq.peek().b < arrp[i].b) {\\n                // Remove the pair with the minimum \\'b\\' value\\n                sum -= (long) pq.remove().a;\\n                \\n                int min = arrp[i].b;\\n                \\n                // Get the minimum \\'b\\' value among the remaining pairs\\n                if (pq.size() > 0)\\n                    min = Integer.min(pq.peek().b, min);\\n                \\n                // Add the current pair to the priority queue\\n                pq.add(arrp[i]);\\n                \\n                // Update the sum and calculate the maximum score\\n                sum += arrp[i].a;\\n                max = Long.max(max, min * sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// class Solution {\\n//     public long maxScore(int[] nums1, int[] nums2, int k) {\\napproach 1\\n//     //   int n = nums1.length;\\n//     //     int[][] pairs = new int[n][2];\\n//     //     for (int i = 0; i < n; i++) {\\n//     //         pairs[i] = new int[] { nums2[i], nums1[i] };\\n//     //     }\\n//     //     Arrays.sort(pairs, (a, b) -> b[0] - a[0]);\\n//     //     PriorityQueue<Integer> pq = new PriorityQueue<>(k, (a, b) -> a - b);\\n//     //     long res = 0, totalSum = 0;\\n//     //     for (int[] pair : pairs) {\\n//     //         pq.add(pair[1]);\\n//     //         totalSum += pair[1];\\n//     //         if (pq.size() > k) {\\n//     //             totalSum -= pq.poll();\\n//     //         }\\n//     //         if (pq.size() == k) {\\n//     //             res = Math.max(res, totalSum * pair[0]);\\n//     //         }\\n//     //     }\\n//     //     return res;  \\n\\n\\nApproach 2\\n//       int n = nums1.length;\\n//         int[][] pairs = new int[n][2];\\n//         for (int i = 0; i < n; ++i) {\\n//             pairs[i] = new int[]{nums1[i], nums2[i]};\\n//         }\\n//         Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        \\n//         // Use a min-heap to maintain the top k elements.\\n//         PriorityQueue<Integer> topKHeap = new PriorityQueue<>(k, (a, b) -> a - b);\\n//         long topKSum = 0;\\n//         for (int i = 0; i < k; ++i) {\\n//             topKSum += pairs[i][0];\\n//             topKHeap.add(pairs[i][0]); \\n//                 }\\n        \\n//         // The score of the first k pairs.\\n//         long answer = topKSum * pairs[k - 1][1];\\n        \\n//         // Iterate over every nums2[i] as minimum from nums2.\\n//         for (int i = k; i < n; ++i) {\\n//             // Remove the smallest integer from the previous top k elements\\n//             // then ddd nums1[i] to the top k elements.\\n//             topKSum += pairs[i][0] - topKHeap.poll();\\n//             topKHeap.add(pairs[i][0]);\\n            \\n//             // Update answer as the maximum score.\\n//             answer = Math.max(answer, topKSum * pairs[i][1]);\\n//         }\\n        \\n//         return answer;\\n//     }\\n// }\\n\\nApproach 3\\nimport java.util.Arrays;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    // Nested Pair class\\n    class Pair {\\n        public int a, b;\\n\\n        public Pair(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        Pair[] arrp = new Pair[n];\\n        \\n        // Create pairs from nums1 and nums2\\n        for (int i = 0; i < n; i++)\\n            arrp[i] = new Pair(nums1[i], nums2[i]);\\n        \\n        // Sort pairs in descending order of \\'a\\'\\n        Arrays.sort(arrp, (p1, p2) -> -Integer.compare(p1.a, p2.a));\\n        \\n        // Create a priority queue to store pairs based on \\'b\\'\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((p1, p2) -> Integer.compare(p1.b, p2.b));\\n        \\n        long sum = 0;\\n        \\n        // Select \\'k\\' pairs with maximum \\'a\\' values and add them to the priority queue\\n        for (int i = 0; i < k; i++) {\\n            sum += arrp[i].a;\\n            pq.add(arrp[i]);\\n        }\\n        \\n        // Calculate the initial maximum score\\n        long max = pq.peek().b * sum;\\n        \\n        // Process remaining pairs\\n        for (int i = k; i < n; i++) {\\n            if (pq.peek().b < arrp[i].b) {\\n                // Remove the pair with the minimum \\'b\\' value\\n                sum -= (long) pq.remove().a;\\n                \\n                int min = arrp[i].b;\\n                \\n                // Get the minimum \\'b\\' value among the remaining pairs\\n                if (pq.size() > 0)\\n                    min = Integer.min(pq.peek().b, min);\\n                \\n                // Add the current pair to the priority queue\\n                pq.add(arrp[i]);\\n                \\n                // Update the sum and calculate the maximum score\\n                sum += arrp[i].a;\\n                max = Long.max(max, min * sum);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557787,
                "title": "min-heap-with-greedy-approach-beats-81-77",
                "content": "# Intuition\\nSorting and also using Priority quesue to conclude to a Greedy approch.\\n\\n# Approach\\n1. Storing the arrays as pairs (nums2 as the first)\\n2. Sorting in decending according to nums2\\n3. Pushing the nums1 elements to min heap till size is k and keep a sum of them\\n4. Now check for every element including kth\\n5. Each time size>k remove the smallest nums1[i] which is the top element of heap also decrease the sum acordingly\\n6. For every i>=k-1 Keep record of the answer required.\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>>v;\\n        for(int i=0; i<n; i++)v.push_back({nums2[i],nums1[i]});\\n        //as we want to remove the pair with largest nums2[i] each time \\n        //and priority queue sorts on the first element\\n        sort(rbegin(v),rend(v));//sort in decending order\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        //vector part remains empty but that is needed to make a min heap\\n        long long sum=0,res=0;\\n        for(int i=0; i<n; i++){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n            if(pq.size()>k){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k){\\n                res=max(res,sum*v[i].first);\\n                //as the kth nums2[i] value will be smallest \\n                //according to priority queue\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>>v;\\n        for(int i=0; i<n; i++)v.push_back({nums2[i],nums1[i]});\\n        //as we want to remove the pair with largest nums2[i] each time \\n        //and priority queue sorts on the first element\\n        sort(rbegin(v),rend(v));//sort in decending order\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        //vector part remains empty but that is needed to make a min heap\\n        long long sum=0,res=0;\\n        for(int i=0; i<n; i++){\\n            pq.push(v[i].second);\\n            sum+=v[i].second;\\n            if(pq.size()>k){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k){\\n                res=max(res,sum*v[i].first);\\n                //as the kth nums2[i] value will be smallest \\n                //according to priority queue\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557732,
                "title": "typescript-priorityqueue",
                "content": "# Code\\n```\\ninterface pair<T, U> {\\n    first: T;\\n    second: U;\\n};\\nfunction maxScore(nums1: number[], nums2: number[], k: number): number {\\n    type number2 = pair<number, number>;\\n    function comparator(a: number2, b: number2): number {\\n        if (a.first === b.first) return a.second - b.second;\\n        else return b.first - a.first;\\n    }\\n    const n: number = nums1.length;\\n    const p: number2[] = new Array(n);\\n    const pq = new MinPriorityQueue();\\n    let res: number = 0, sum: number = 0;\\n    for (let i = 0; i < n; i++) p[i] = { first: nums2[i], second: nums1[i] };\\n    p.sort(comparator);\\n    for (let i = 0; i < n; i++) {\\n        const { first: a, second: b } = p[i];\\n        sum += b;\\n        pq.enqueue(b);\\n        if (i < k - 1) continue;\\n        if (pq.size() > k) sum -= pq.dequeue().element;\\n        res = Math.max(res, sum * a);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface pair<T, U> {\\n    first: T;\\n    second: U;\\n};\\nfunction maxScore(nums1: number[], nums2: number[], k: number): number {\\n    type number2 = pair<number, number>;\\n    function comparator(a: number2, b: number2): number {\\n        if (a.first === b.first) return a.second - b.second;\\n        else return b.first - a.first;\\n    }\\n    const n: number = nums1.length;\\n    const p: number2[] = new Array(n);\\n    const pq = new MinPriorityQueue();\\n    let res: number = 0, sum: number = 0;\\n    for (let i = 0; i < n; i++) p[i] = { first: nums2[i], second: nums1[i] };\\n    p.sort(comparator);\\n    for (let i = 0; i < n; i++) {\\n        const { first: a, second: b } = p[i];\\n        sum += b;\\n        pq.enqueue(b);\\n        if (i < k - 1) continue;\\n        if (pq.size() > k) sum -= pq.dequeue().element;\\n        res = Math.max(res, sum * a);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557712,
                "title": "easy-python-soln-using-sorting-and-heap-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        lst=list(zip(nums2,nums1))\\n        lst.sort(key=lambda x:(-x[0],-x[1]))\\n        flst=[]\\n        heapq.heapify(flst)\\n        i=0\\n        sm=0\\n        ef=float(\"infinity\")\\n        prd=float(\"-infinity\")\\n        while i<k:\\n            x=lst.pop(0)\\n            heapq.heappush(flst,x[1])\\n            ef=min(ef,x[0])\\n            sm+=x[1]\\n            i+=1\\n        prd=max(prd,sm*ef)\\n        while lst:\\n            x=heapq.heappop(flst)\\n            sm-=x\\n            y=lst.pop(0)\\n            heapq.heappush(flst,y[1])\\n            ef=min(ef,y[0])\\n            sm+=y[1]\\n            prd=max(prd,sm*ef)\\n        return prd\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        lst=list(zip(nums2,nums1))\\n        lst.sort(key=lambda x:(-x[0],-x[1]))\\n        flst=[]\\n        heapq.heapify(flst)\\n        i=0\\n        sm=0\\n        ef=float(\"infinity\")\\n        prd=float(\"-infinity\")\\n        while i<k:\\n            x=lst.pop(0)\\n            heapq.heappush(flst,x[1])\\n            ef=min(ef,x[0])\\n            sm+=x[1]\\n            i+=1\\n        prd=max(prd,sm*ef)\\n        while lst:\\n            x=heapq.heappop(flst)\\n            sm-=x\\n            y=lst.pop(0)\\n            heapq.heappush(flst,y[1])\\n            ef=min(ef,y[0])\\n            sm+=y[1]\\n            prd=max(prd,sm*ef)\\n        return prd\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557632,
                "title": "c-simple-solution-easy-to-understand",
                "content": "# Intuition\\nThe idea is to consider for each element of array of nums2[i] as minimum once and check for maximum possible values available in nums1 keeping in mind nums2[i] as minimum .\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- First we sort the nums2 array in decreasing order and as we need to know the mapping of nums2[i] to nums1[i] so for that we make their pairs and then we sort.\\n\\n- Now we we will iterate through p array one by one and let p[i].first as the minimum for an instance then all the elements to left of p array can be considered for sum part.\\n\\n- But we can make priority queue for knowing top k elements to left of p array\\n\\n- And we will only keep k maximum elements at a time in priority queue and keep the tab of their sum .\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O( N * Log(N) + (N-k) * Log(k) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans=0, sum=0, n=nums1.size();\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<n;i++)\\n            vp.push_back({nums2[i],nums1[i]});\\n        sort(vp.begin(),vp.end());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=n-1;i>=0;i--){\\n            pq.push(vp[i].second);\\n            sum += vp[i].second;\\n            if(pq.size() > k){\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size() == k) ans = max(ans,vp[i].first*sum);\\n        }     \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans=0, sum=0, n=nums1.size();\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<n;i++)\\n            vp.push_back({nums2[i],nums1[i]});\\n        sort(vp.begin(),vp.end());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=n-1;i>=0;i--){\\n            pq.push(vp[i].second);\\n            sum += vp[i].second;\\n            if(pq.size() > k){\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size() == k) ans = max(ans,vp[i].first*sum);\\n        }     \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557512,
                "title": "python-3-greedy-with-heap",
                "content": "# Intuition\\nYou can\\'t go for dp because TC is too large.\\n\\nThere is a hint in question statement: multiplied with the minimum of the selected elements from nums2 -> you have to do sorting somehow base on nums2 and do the question bases on this order (greedy)\\n\\nIf you do reverse sorting on nums2, you need to remove the min number from nums1 and do max ans check -> since you need to interact with min value very quickly, heap should be used.\\n\\nLeading to greedy with heap solution\\n\\n# Approach\\ngreedy with heap\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) -> sorting\\n\\n- Space complexity:\\nO(n) -> nn list for sorting\\n\\nn = len(nums1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        import heapq\\n\\n        nn = list() # list of [n2, n1]\\n        ans = 0\\n\\n        for i in range(len(nums1)):\\n            nn.append([nums2[i], nums1[i]])\\n        \\n        nn.sort(reverse = True)\\n\\n        heap = list() # heap of n1\\n        total = 0\\n        ans = 0\\n\\n        for i in range(len(nums1)):\\n            n2, n1 = nn[i]\\n            total += n1\\n            heapq.heappush(heap, n1)\\n\\n            if len(heap) > k:\\n                total -= heapq.heappop(heap)\\n            \\n            if len(heap) == k:\\n                ans = max(ans, total * n2)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        import heapq\\n\\n        nn = list() # list of [n2, n1]\\n        ans = 0\\n\\n        for i in range(len(nums1)):\\n            nn.append([nums2[i], nums1[i]])\\n        \\n        nn.sort(reverse = True)\\n\\n        heap = list() # heap of n1\\n        total = 0\\n        ans = 0\\n\\n        for i in range(len(nums1)):\\n            n2, n1 = nn[i]\\n            total += n1\\n            heapq.heappush(heap, n1)\\n\\n            if len(heap) > k:\\n                total -= heapq.heappop(heap)\\n            \\n            if len(heap) == k:\\n                ans = max(ans, total * n2)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557422,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k)\\n     {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--)\\n        {\\n            if(i>=nums1.size()-k+1)\\n            {\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }\\n            else\\n            {\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k)\\n                {\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[0]==b[0])return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k)\\n     {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0;\\n        long long int sum = 0;\\n        int j = 0;\\n        for(int i = nums1.size()-1; i >= 0; i--)\\n        {\\n            if(i>=nums1.size()-k+1)\\n            {\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n            }\\n            else\\n            {\\n                sum += v[i][1];\\n                pq.push(v[i][1]);\\n                if(pq.size()>k)\\n                {\\n                    sum -= pq.top();\\n                    pq.pop();\\n                }\\n                ans = max(ans,sum*1LL*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557410,
                "title": "java-solution-using-sorting-and-priorityqueue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0;\\n        int N = nums1.length;\\n\\n        if (k == 1) {\\n            for (int i = 0; i < N; i++) {\\n                long cur = (long) nums1[i] * nums2[i];\\n                ans = Math.max(ans, cur);\\n            }\\n            return ans;\\n        }\\n\\n        int[][] arr = new int[N][];\\n        for (int i = 0; i < N; i++) {\\n            arr[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(arr, (a, b) -> a[1] - b[1]);\\n        Queue<Integer> queue = new PriorityQueue<>();\\n        long sum = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            int num1 = arr[i][0];\\n            if (i <= N - k) {\\n                long cur = (sum + num1) * arr[i][1];\\n                ans = Math.max(ans, cur);\\n            }\\n            if (queue.size() < k - 1) {\\n                queue.add(num1);\\n                sum += num1;\\n            } else if (num1 > queue.peek()) {\\n                sum -= queue.poll();\\n                sum += num1;\\n                queue.add(num1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0;\\n        int N = nums1.length;\\n\\n        if (k == 1) {\\n            for (int i = 0; i < N; i++) {\\n                long cur = (long) nums1[i] * nums2[i];\\n                ans = Math.max(ans, cur);\\n            }\\n            return ans;\\n        }\\n\\n        int[][] arr = new int[N][];\\n        for (int i = 0; i < N; i++) {\\n            arr[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(arr, (a, b) -> a[1] - b[1]);\\n        Queue<Integer> queue = new PriorityQueue<>();\\n        long sum = 0;\\n        for (int i = N - 1; i >= 0; i--) {\\n            int num1 = arr[i][0];\\n            if (i <= N - k) {\\n                long cur = (sum + num1) * arr[i][1];\\n                ans = Math.max(ans, cur);\\n            }\\n            if (queue.size() < k - 1) {\\n                queue.add(num1);\\n                sum += num1;\\n            } else if (num1 > queue.peek()) {\\n                sum -= queue.poll();\\n                sum += num1;\\n                queue.add(num1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557368,
                "title": "c-double-heap-vs-sorting-heap-98-time-324ms-100-space-84-3-mb",
                "content": "This is a bit tricky, as my first instinct would have been to go and tackle it with DP, but that would hardly work with such a large range, I guess.\\n\\nWe can do better and just try to greedily build our result taking all the greatest values of `n2` first until we have `k` of them and check if we can build a bigger result with all the rest.\\n\\nFor example, with `n1 == {2, 1, 14, 18, 12}`, `n2 == {11, 7, 13, 5, 6}` and `k == 3`, we will have:\\n\\n```cpp\\n// k largest values in n2 are at indexes 2, 0, 1\\n// so we compute currSum as n1[2] + n1[0] + n1[1];\\ncurrSum = 14 + 2 + 1; // 17\\n// the minimum value we saw so far in n2 was at index 1, so\\nminVal2 = 7;\\n// thus, our score so far is\\nres = 17 * 7; // 119\\n```\\n\\nNow we can check the other two values in `n2` to see if we would get a better result; the next bigger value in `n2` is at index `4`, so we try to add that one and remove the smaller value we added so far from `n1` (we don\\'t care which value matched in `n2`, since we are sure that the value we are considering now will be smaller or at least equal to it):\\n\\n```cpp\\n// updating currSum with the new matching value\\ncurrSum += n1[4]; // currSum = 29\\n// removing the smaller value from n1 we added before\\ncurrSum -= 1; // currsum = 28\\n// the minimum value we saw so far in n2 is now at index 4, so\\nminVal2 = 6;\\n// updating res to be the maximum between its previous value and the current\\nres = max(res, 28 * 6); // res = max(119, 168) => res = 168\\n```\\n\\nFinally we consider the last smallest value in `n2` at index `3` and we have:\\n\\n```cpp\\n// updating currSum with the new matching value\\ncurrSum += n1[3]; // currSum = 46\\n// removing the smaller value from n1 we added before\\ncurrSum -= 2; // currsum = 44\\n// the minimum value we saw so far in n2 is now at index 4, so\\nminVal2 = 5;\\n// updating res to be the maximum between its previous value and the current\\nres = max(res, 44 * 5); // res = max(168, 220) => res = 220\\n```\\n\\nNow, to turn all of this into code, we shall start declaring some support variables first:\\n* `len` will store the length of our input vectors;\\n* `minVal2` will store the value of the lowest element of `n2` we saw so far;\\n* `currVal1` will store the current value of `n1` we are now parsing;\\n* `currSum` will store the current sum of our elements, initially set to be `0`;\\n* `res` will store the best product we found so far, initially set to `0` too;\\n* `currPair` is the pair made of a value from `n2` and its original index we will be using as we go parsing all the elements in both vectors;\\n* `pq` is our base priority queue matching values of `n2` and their indexes, from larger to smaller as explained above;\\n* `usedN1s` will store all the elements of `n1` we already employed, to give us the smaller ones at each step we will have to update `currSum`.\\n\\nWe will then simply populate `pq` as mentioned, pushing into it all the value and index pairs from `n2` (ie: `{n2[i], i}`).\\n\\nThen, for `k` times, we will:\\n* extract the top of `pq` as `currPair`;\\n* pop it out of `pq`;\\n* assign the value of the matching elements in `n1` (ie: `n1[currPair.second]`) to `currVal1`;\\n* update `minVal2` to be `currPair.first`;\\n* push the used value `currVal1` in `usedN1s`.\\n\\nAfter this first loop, we can update `res` with our first attempt, made as the product of `currSum` and `minVal2`.\\n\\nWe will then keep looping until we are done parsing all the pairs (ie: `while (pq.size())`) and repeat the previous logic, plus three extra steps:\\n* we will decrease `currsum` by the smaller value we added before (ie: `usedN1s.top()`);\\n* pop said element our of `usedN1s`;\\n* update `res` to be the maximum between its current value and the new product `currSum * minVal2`.\\n\\nOnce done, we can safely `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int> &n1, vector<int> &n2, int k) {\\n        // support variables\\n        int len = n1.size(), minVal2, currVal1;\\n        long long currSum = 0, res = 0;\\n        pair<int, int> currPair;\\n        priority_queue<pair<int,int>> pq;\\n        priority_queue<int, vector<int>, greater<int>> usedN1s;\\n        // populating pq\\n        for (int i = 0; i < len; i++) pq.push({n2[i], i});\\n        // getting the k highest values in n2\\n        while (k--) {\\n            currPair = pq.top(), pq.pop();\\n            currVal1 = n1[currPair.second];\\n            currSum += currVal1;\\n            minVal2 = currPair.first;\\n            usedN1s.push(currVal1);\\n        }\\n        // base res computed with the first highest k n2 elements\\n        res = currSum * minVal2;\\n        // parsing the rest of pq to find anything better\\n        while (pq.size()) {\\n            // removing the least element previously added in currSum\\n            currSum -= usedN1s.top(), usedN1s.pop();\\n            // following the same logic of the previous loop\\n            currPair = pq.top(), pq.pop();\\n            currVal1 = n1[currPair.second];\\n            currSum += currVal1;\\n            minVal2 = currPair.first;\\n            usedN1s.push(currVal1);\\n            // updating res\\n            res = max(res, currSum * minVal2);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait: we don\\'t really need the first heap, do we?\\n\\nWe can just create an array of indexes (way cheaper!), sort and read them with a pointer (`r`) and, while at it, also avoid to constantly update `minVal2` - no longer needed.\\n\\nThe updated code shaves off ~7MB and a over 100ms!\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int> &n1, vector<int> &n2, int k) {\\n        // support variables\\n        int len = n1.size(), currVal1, idx[len], r = 0, currIdx;\\n        long long currSum = 0, res = 0;\\n        priority_queue<int, vector<int>, greater<int>> usedN1s;\\n        // populating idx\\n        iota(idx, idx + len, 0);\\n        sort(idx, idx + len, [&n2](int a, int b){return n2[a] > n2[b];});\\n        // getting the k highest values in n2\\n        while (k--) {\\n            currIdx = idx[r++];\\n            currVal1 = n1[currIdx];\\n            currSum += currVal1;\\n            usedN1s.push(currVal1);\\n        }\\n        // base res computed with the first highest k n2 elements\\n        res = currSum * n2[idx[r - 1]];\\n        // parsing the rest of pq to find anything better\\n        while (r < len) {\\n            // removing the least element previously added in currSum\\n            currSum -= usedN1s.top(), usedN1s.pop();\\n            // following the same logic of the previous loop\\n            currIdx = idx[r++];\\n            currVal1 = n1[currIdx];\\n            currSum += currVal1;\\n            usedN1s.push(currVal1);\\n            // updating res\\n            res = max(res, currSum * n2[currIdx]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n// k largest values in n2 are at indexes 2, 0, 1\\n// so we compute currSum as n1[2] + n1[0] + n1[1];\\ncurrSum = 14 + 2 + 1; // 17\\n// the minimum value we saw so far in n2 was at index 1, so\\nminVal2 = 7;\\n// thus, our score so far is\\nres = 17 * 7; // 119\\n```\n```cpp\\n// updating currSum with the new matching value\\ncurrSum += n1[4]; // currSum = 29\\n// removing the smaller value from n1 we added before\\ncurrSum -= 1; // currsum = 28\\n// the minimum value we saw so far in n2 is now at index 4, so\\nminVal2 = 6;\\n// updating res to be the maximum between its previous value and the current\\nres = max(res, 28 * 6); // res = max(119, 168) => res = 168\\n```\n```cpp\\n// updating currSum with the new matching value\\ncurrSum += n1[3]; // currSum = 46\\n// removing the smaller value from n1 we added before\\ncurrSum -= 2; // currsum = 44\\n// the minimum value we saw so far in n2 is now at index 4, so\\nminVal2 = 5;\\n// updating res to be the maximum between its previous value and the current\\nres = max(res, 44 * 5); // res = max(168, 220) => res = 220\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int> &n1, vector<int> &n2, int k) {\\n        // support variables\\n        int len = n1.size(), minVal2, currVal1;\\n        long long currSum = 0, res = 0;\\n        pair<int, int> currPair;\\n        priority_queue<pair<int,int>> pq;\\n        priority_queue<int, vector<int>, greater<int>> usedN1s;\\n        // populating pq\\n        for (int i = 0; i < len; i++) pq.push({n2[i], i});\\n        // getting the k highest values in n2\\n        while (k--) {\\n            currPair = pq.top(), pq.pop();\\n            currVal1 = n1[currPair.second];\\n            currSum += currVal1;\\n            minVal2 = currPair.first;\\n            usedN1s.push(currVal1);\\n        }\\n        // base res computed with the first highest k n2 elements\\n        res = currSum * minVal2;\\n        // parsing the rest of pq to find anything better\\n        while (pq.size()) {\\n            // removing the least element previously added in currSum\\n            currSum -= usedN1s.top(), usedN1s.pop();\\n            // following the same logic of the previous loop\\n            currPair = pq.top(), pq.pop();\\n            currVal1 = n1[currPair.second];\\n            currSum += currVal1;\\n            minVal2 = currPair.first;\\n            usedN1s.push(currVal1);\\n            // updating res\\n            res = max(res, currSum * minVal2);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int> &n1, vector<int> &n2, int k) {\\n        // support variables\\n        int len = n1.size(), currVal1, idx[len], r = 0, currIdx;\\n        long long currSum = 0, res = 0;\\n        priority_queue<int, vector<int>, greater<int>> usedN1s;\\n        // populating idx\\n        iota(idx, idx + len, 0);\\n        sort(idx, idx + len, [&n2](int a, int b){return n2[a] > n2[b];});\\n        // getting the k highest values in n2\\n        while (k--) {\\n            currIdx = idx[r++];\\n            currVal1 = n1[currIdx];\\n            currSum += currVal1;\\n            usedN1s.push(currVal1);\\n        }\\n        // base res computed with the first highest k n2 elements\\n        res = currSum * n2[idx[r - 1]];\\n        // parsing the rest of pq to find anything better\\n        while (r < len) {\\n            // removing the least element previously added in currSum\\n            currSum -= usedN1s.top(), usedN1s.pop();\\n            // following the same logic of the previous loop\\n            currIdx = idx[r++];\\n            currVal1 = n1[currIdx];\\n            currSum += currVal1;\\n            usedN1s.push(currVal1);\\n            // updating res\\n            res = max(res, currSum * n2[currIdx]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557323,
                "title": "c-sorting-heap-ranges-beats-100",
                "content": "# Intuition\\nSorting the arrays around ```nums2``` descending lets us always know what the min value is in our subsequence that ends at index ```i```. \\n\\nWe will use a PriortyQueue ```heap``` to keep track of the best subsequence sum for a subsequence ending at index ```i```.\\n\\nWe build our subsequence of size ```k``` by adding to ```sum``` and our ```heap```. Then we run the rest of the array by reducing ```sum``` by our min value in ```heap``` and adding the next element to our ```sum``` and ```heap```\\n\\n# Approach\\nWe use the default ascending sort and do the remaining logic in reverse order. \\n\\n# Complexity\\n- Time: Sorting & Heap => $$O(nlogn + nlogk)$$ => $$O(nlogn)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long result = 0;\\n        long sum = 0;\\n        PriorityQueue<int, int> heap = new();\\n        \\n        Array.Sort(nums2, nums1);\\n\\n        for (int i = 1; i <= k; i++)  {\\n            sum += nums1[^i];\\n            heap.Enqueue(nums1[^i], nums1[^i]);\\n        }\\n        result = sum * nums2[^k];\\n\\n        for (int i = k + 1; i <= nums1.Length; i++) {\\n            sum = sum + nums1[^i] - heap.EnqueueDequeue(nums1[^i], nums1[^i]);\\n            result = Math.Max(result, result = sum * nums2[^i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```nums2```\n```i```\n```heap```\n```i```\n```k```\n```sum```\n```heap```\n```sum```\n```heap```\n```sum```\n```heap```\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long result = 0;\\n        long sum = 0;\\n        PriorityQueue<int, int> heap = new();\\n        \\n        Array.Sort(nums2, nums1);\\n\\n        for (int i = 1; i <= k; i++)  {\\n            sum += nums1[^i];\\n            heap.Enqueue(nums1[^i], nums1[^i]);\\n        }\\n        result = sum * nums2[^k];\\n\\n        for (int i = k + 1; i <= nums1.Length; i++) {\\n            sum = sum + nums1[^i] - heap.EnqueueDequeue(nums1[^i], nums1[^i]);\\n            result = Math.Max(result, result = sum * nums2[^i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557271,
                "title": "maximum-subsequence-score-easy-sol",
                "content": "\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] res = new int[n][2];\\n        for(int i=0; i<n; i++){\\n            res[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n\\n        Arrays.sort(res, (a, b) -> b[1] - a[1]);\\n\\n        long ans=0;\\n        long sum=0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0; i<n; i++){\\n            sum += res[i][0];\\n            pq.offer(res[i][0]);\\n            if(pq.size() == k){\\n                ans = Math.max(ans, sum*res[i][1]);\\n                sum -= pq.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] res = new int[n][2];\\n        for(int i=0; i<n; i++){\\n            res[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n\\n        Arrays.sort(res, (a, b) -> b[1] - a[1]);\\n\\n        long ans=0;\\n        long sum=0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0; i<n; i++){\\n            sum += res[i][0];\\n            pq.offer(res[i][0]);\\n            if(pq.size() == k){\\n                ans = Math.max(ans, sum*res[i][1]);\\n                sum -= pq.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557167,
                "title": "c-easy-solution-priority-queue-min-heap-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intuition behind this approach is to consider the pairs with higher elements from `nums2` first, as they will have a greater impact on the score. By keeping track of the `k-1` largest elements from `nums1` using a priority queue, we can efficiently calculate the maximum score by multiplying the current sum of selected elements from nums1 with the current element from `nums2`. The approach is greedy, as it selects the pairs that contribute the most to the maximum score.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Create a vector of pairs, v, by pairing elements from nums1 and nums2.\\n* Sort the v vector in reverse order based on the elements from nums2. This step ensures that pairs with higher elements from nums2 come first.\\n* Initialize variables ans and currSum to 0.\\n* Create a priority queue, pq, to keep track of the k-1 largest elements from nums1.\\n* Iterate over the elements of v:\\n\\n1) Add the current element from nums1 to currSum.\\n2) Push the current element from nums1 to pq.\\n3) If the current index is less than k-1, continue to the next iteration.\\n4) Calculate the score by multiplying currSum with the current element from nums2.\\n5) Update ans by taking the maximum between ans and the calculated score.\\n6) Subtract the smallest element from pq (top element) from currSum.\\n* Return the value of ans, which represents the maximum score.\\n# Complexity\\n- Time complexity: $$O(NLogN) +(N-K)LogK$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size();\\n\\n        vector<pair<int,int>> v;\\n        for(int i=0; i<n1; i++){\\n            v.push_back(make_pair(nums2[i], nums1[i]));\\n        }\\n        sort(v.rbegin(), v.rend());\\n        \\n        long long int ans = 0;\\n        long long int currSum = 0;\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=0; i<k-1; i++){\\n            currSum += v[i].second;\\n            pq.push(v[i].second);\\n        }\\n\\n        for(int i=k-1; i<n1; i++){\\n            currSum += v[i].second;\\n            pq.push(v[i].second);\\n            ans = max(ans, currSum * v[i].first);\\n            currSum -= pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/4f3f2cb9-5209-439e-92f8-6ea6cebb52f8_1684889251.6334999.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size();\\n\\n        vector<pair<int,int>> v;\\n        for(int i=0; i<n1; i++){\\n            v.push_back(make_pair(nums2[i], nums1[i]));\\n        }\\n        sort(v.rbegin(), v.rend());\\n        \\n        long long int ans = 0;\\n        long long int currSum = 0;\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i=0; i<k-1; i++){\\n            currSum += v[i].second;\\n            pq.push(v[i].second);\\n        }\\n\\n        for(int i=k-1; i<n1; i++){\\n            currSum += v[i].second;\\n            pq.push(v[i].second);\\n            ans = max(ans, currSum * v[i].first);\\n            currSum -= pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557162,
                "title": "python-much-simpler-than-official-solution",
                "content": "# Same idea, but much more concise code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\\n        nums = sorted(((b, a) for a, b in zip(nums1, nums2)), reverse = True)\\n\\n        heap = [num[1] for num in nums[:k]]\\n        ksum = sum(heap)\\n        heapq.heapify(heap)\\n\\n        maxResult = ksum * nums[k-1][0]\\n\\n        for num2, num1 in nums[k:]:\\n            \\n            ksum += num1 - heapq.heappushpop(heap, num1)\\n\\n            maxResult = max(maxResult, ksum * num2)\\n\\n        return maxResult\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\\n        nums = sorted(((b, a) for a, b in zip(nums1, nums2)), reverse = True)\\n\\n        heap = [num[1] for num in nums[:k]]\\n        ksum = sum(heap)\\n        heapq.heapify(heap)\\n\\n        maxResult = ksum * nums[k-1][0]\\n\\n        for num2, num1 in nums[k:]:\\n            \\n            ksum += num1 - heapq.heappushpop(heap, num1)\\n\\n            maxResult = max(maxResult, ksum * num2)\\n\\n        return maxResult\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299582,
                "title": "short-sweet-c-code-priority-queue-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]) a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        int i=0,n=nums1.size();\\n        for(i = 0; i < n; i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0, tmp = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(i = 0; i < n; i++){\\n            if(i<k){\\n                tmp += v[i][1];\\n                pq.push(v[i][1]);\\n                if(i==k-1){\\n                    ans = max(ans,tmp*v[i][0]);\\n                }\\n            }else{\\n                tmp += v[i][1];\\n                pq.push(v[i][1]);\\n                tmp -= pq.top();\\n                pq.pop();\\n                ans = max(ans,tmp*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]) a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        int i=0,n=nums1.size();\\n        for(i = 0; i < n; i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans = 0, tmp = 0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(i = 0; i < n; i++){\\n            if(i<k){\\n                tmp += v[i][1];\\n                pq.push(v[i][1]);\\n                if(i==k-1){\\n                    ans = max(ans,tmp*v[i][0]);\\n                }\\n            }else{\\n                tmp += v[i][1];\\n                pq.push(v[i][1]);\\n                tmp -= pq.top();\\n                pq.pop();\\n                ans = max(ans,tmp*v[i][0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222185,
                "title": "c-sorting-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n=nums1.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=0,ans=0;\\n        for(auto&[p2,p1]:v)\\n        {\\n            sum+=p1;\\n            pq.push(p1);\\n            if(pq.size()>k)\\n            {\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n            ans=max(ans,sum*(long long)p2);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n=nums1.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=0,ans=0;\\n        for(auto&[p2,p1]:v)\\n        {\\n            sum+=p1;\\n            pq.push(p1);\\n            if(pq.size()>k)\\n            {\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n            ans=max(ans,sum*(long long)p2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113861,
                "title": "c-sorting-priority-queue-faster-easy-to-understand",
                "content": "* ***Using Sorting***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // comapres two pairs on the basis of first value\\n    \\n    static bool compare(pair<int, int>& a, pair<int, int>& b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second > b.second;\\n        }\\n        else\\n        {\\n            return a.first > b.first;\\n        }\\n    }\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size();\\n        \\n        // declare an array of pairs\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        // initialize arr\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {nums2[i], nums1[i]};\\n        }\\n        \\n        // sort the arr\\n        \\n        sort(arr.begin(), arr.end(), compare);\\n        \\n        // declare a min. heap\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        // curr_sum will keep track of sum of all the elements of pq\\n        \\n        long long curr_sum = 0;\\n        \\n        long long maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i].second);\\n            \\n            // update curr_sum\\n            \\n            curr_sum += arr[i].second;\\n            \\n            // if size of pq is > k\\n            \\n            if(pq.size() > k)\\n            {\\n                int top = pq.top();\\n                \\n                pq.pop();\\n                \\n                curr_sum -= top;\\n            }\\n            \\n            // if size of pq == k, then update maxi\\n            \\n            if(pq.size() == k)\\n            {\\n                long long temp_max = (curr_sum * arr[i].first);\\n                \\n                maxi = max(maxi, temp_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // comapres two pairs on the basis of first value\\n    \\n    static bool compare(pair<int, int>& a, pair<int, int>& b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second > b.second;\\n        }\\n        else\\n        {\\n            return a.first > b.first;\\n        }\\n    }\\n    \\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size();\\n        \\n        // declare an array of pairs\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        // initialize arr\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {nums2[i], nums1[i]};\\n        }\\n        \\n        // sort the arr\\n        \\n        sort(arr.begin(), arr.end(), compare);\\n        \\n        // declare a min. heap\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        // curr_sum will keep track of sum of all the elements of pq\\n        \\n        long long curr_sum = 0;\\n        \\n        long long maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push(arr[i].second);\\n            \\n            // update curr_sum\\n            \\n            curr_sum += arr[i].second;\\n            \\n            // if size of pq is > k\\n            \\n            if(pq.size() > k)\\n            {\\n                int top = pq.top();\\n                \\n                pq.pop();\\n                \\n                curr_sum -= top;\\n            }\\n            \\n            // if size of pq == k, then update maxi\\n            \\n            if(pq.size() == k)\\n            {\\n                long long temp_max = (curr_sum * arr[i].first);\\n                \\n                maxi = max(maxi, temp_max);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107654,
                "title": "priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<int>pq1;\\n        priority_queue<pair<int,int>>pq2;\\n       \\n        for(int i=0;i<nums2.size();i++){\\n            pq2.push({nums2[i],i});\\n        }\\n        int temp=k;\\n        long long ans=0;\\n        long long sum=0;\\n        long long x=INT_MAX;\\n         while(temp--){\\n\\n             auto j=pq2.top();\\n             pq2.pop();\\n             x=j.first;\\n             sum+=nums1[j.second];\\n             pq1.push(-nums1[j.second]);\\n         }\\n         long long ml = sum*x;\\n         ans=max(ans,ml);\\n         while(!pq2.empty()){\\n             auto j=pq2.top();\\n             pq2.pop();\\n             x=j.first;\\n             sum+=pq1.top();\\n             pq1.pop();\\n             sum+=nums1[j.second];\\n             pq1.push(-nums1[j.second]);\\n            ans=max(ans,sum*x);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<int>pq1;\\n        priority_queue<pair<int,int>>pq2;\\n       \\n        for(int i=0;i<nums2.size();i++){\\n            pq2.push({nums2[i],i});\\n        }\\n        int temp=k;\\n        long long ans=0;\\n        long long sum=0;\\n        long long x=INT_MAX;\\n         while(temp--){\\n\\n             auto j=pq2.top();\\n             pq2.pop();\\n             x=j.first;\\n             sum+=nums1[j.second];\\n             pq1.push(-nums1[j.second]);\\n         }\\n         long long ml = sum*x;\\n         ans=max(ans,ml);\\n         while(!pq2.empty()){\\n             auto j=pq2.top();\\n             pq2.pop();\\n             x=j.first;\\n             sum+=pq1.top();\\n             pq1.pop();\\n             sum+=nums1[j.second];\\n             pq1.push(-nums1[j.second]);\\n            ans=max(ans,sum*x);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092255,
                "title": "key-idea-fully-explained-python",
                "content": "**Intuition**\\nThe sum is multiplied by **one** of the values in `nums2`.\\nSo why not consider every value in `nums2` to be that **one**?\\n\\n**Approach**\\nConsider each element at index `i` to be the minimum of the k selected elements.\\n\\nFor each element at `i`,\\nwe want `k` largest elements from `nums1` at `j` such that `nums2[j] >= nums2[i]`\\n\\nSo for all the elements in `nums2` that are greater or equal to `nums2[i]`, we want the sum of the largest `k` from their corresponsing `nums1` values.\\n\\nSince we are considering each element as the multiplicative factor, it is guaranteed that we must have also considered the correct solution set.\\n\\nThis can be implemeneted by iterating through revese sorted `nums2` and using a min-heap to keep track of `k` largest `nums1` vals.\\n\\n**Time: O(n log n)\\nSpace: O(n)**\\n```\\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    n = len(nums1)\\n    pairs = list(sorted(zip(nums2, nums1), reverse=True))\\n    \\n    c_elements = []\\n    c_sum = res = 0\\n    for factor, val in pairs:\\n        heappush(c_elements, val)\\n        c_sum += val\\n\\n        if len(c_elements) > k:\\n            c_sum -= heappop(c_elements)\\n        \\n        if len(c_elements) == k:\\n            res = max(res, c_sum*factor)\\n    \\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    n = len(nums1)\\n    pairs = list(sorted(zip(nums2, nums1), reverse=True))\\n    \\n    c_elements = []\\n    c_sum = res = 0\\n    for factor, val in pairs:\\n        heappush(c_elements, val)\\n        c_sum += val\\n\\n        if len(c_elements) > k:\\n            c_sum -= heappop(c_elements)\\n        \\n        if len(c_elements) == k:\\n            res = max(res, c_sum*factor)\\n    \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3089358,
                "title": "easy-priority-queue-with-some-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nyou have to fix an element from nums2 to get it as minimum and the indexs of nums2 which are greater than fixed minimum value are eligible for participate as the can not change minimum,now sum all of these values from selected indexs from nums1 and update ans; \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow you can see there are more than k values exists for a selected minimum value but you have to take k-1 largest value from them as you have to select that index as minimim for these we take a priority queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        int n=nums2.size();\\n        // to track indexs after sorting\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        long long sum=0;\\n        long long maxi=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            auto &[a,b]=v[i];\\n            sum+=nums1[b];\\n            pq.push(nums1[b]);\\n            //update maxi if the heap size is k\\n            if(pq.size()==k)maxi=max(maxi,sum*a);       \\n            //maintaining the k-1 maximum element\\n            if(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        int n=nums2.size();\\n        // to track indexs after sorting\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        long long sum=0;\\n        long long maxi=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<v.size();i++){\\n            auto &[a,b]=v[i];\\n            sum+=nums1[b];\\n            pq.push(nums1[b]);\\n            //update maxi if the heap size is k\\n            if(pq.size()==k)maxi=max(maxi,sum*a);       \\n            //maintaining the k-1 maximum element\\n            if(pq.size()>k-1){\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088649,
                "title": "min-heap-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++) pq.push({nums2[i],nums1[i]});\\n        priority_queue<int,vector<int>,greater<int>> min_heap;\\n        long long  curr_sum=0;\\n        int mini=1e9;\\n        long long ans=0;\\n        while(!pq.empty()){\\n            auto p=pq.top();\\n            pq.pop();\\n            mini=p.first;\\n            curr_sum+=p.second;\\n            min_heap.push(p.second);\\n            if(min_heap.size()==k){\\n                ans=max(ans,mini*1LL*curr_sum);\\n            }\\n            if(min_heap.size()>k){\\n                curr_sum-=min_heap.top();\\n                min_heap.pop();\\n                ans=max(ans,mini*1LL*curr_sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++) pq.push({nums2[i],nums1[i]});\\n        priority_queue<int,vector<int>,greater<int>> min_heap;\\n        long long  curr_sum=0;\\n        int mini=1e9;\\n        long long ans=0;\\n        while(!pq.empty()){\\n            auto p=pq.top();\\n            pq.pop();\\n            mini=p.first;\\n            curr_sum+=p.second;\\n            min_heap.push(p.second);\\n            if(min_heap.size()==k){\\n                ans=max(ans,mini*1LL*curr_sum);\\n            }\\n            if(min_heap.size()>k){\\n                curr_sum-=min_heap.top();\\n                min_heap.pop();\\n                ans=max(ans,mini*1LL*curr_sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084929,
                "title": "maximise-sum-and-multiply-minimum-element-easy-understand-c-solution",
                "content": "\\t\\t\\t```\\n\\t\\t\\tclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        \\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums2.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long int ans = 0, sum = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(i<k-1){\\n                pq.push(v[i][1]);\\n                sum += v[i][1];\\n            }else{\\n                pq.push(v[i][1]);\\n                sum += v[i][1];\\n                ans = max(ans,sum*v[i][0]);\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t\\t\\tclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        \\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> v;\\n        for(int i = 0; i < nums2.size(); i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long int ans = 0, sum = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(i<k-1){\\n                pq.push(v[i][1]);\\n                sum += v[i][1];\\n            }else{\\n                pq.push(v[i][1]);\\n                sum += v[i][1];\\n                ans = max(ans,sum*v[i][0]);\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083585,
                "title": "python-3-beats-100-memory-36-2-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res = s = 0\\n\\n        pq = []\\n\\n        for a, b in sorted(list(zip(nums1, nums2)), key=lambda ab: -ab[1]):\\n            s += a\\n            heappush(pq, a)\\n\\n            if len(pq) > k:\\n                s -= heappop(pq)\\n            \\n            if len(pq) == k:\\n                res = max(res, s * b)\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        res = s = 0\\n\\n        pq = []\\n\\n        for a, b in sorted(list(zip(nums1, nums2)), key=lambda ab: -ab[1]):\\n            s += a\\n            heappush(pq, a)\\n\\n            if len(pq) > k:\\n                s -= heappop(pq)\\n            \\n            if len(pq) == k:\\n                res = max(res, s * b)\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083578,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[1] == B[1])\\n        return A[0] - B[0] ;\\n    return A[1] - B[1] ;\\n}\\n\\nint cmp1(const void * a, const void* b){\\n    return *(int*)a - *(int*)b ;\\n}\\n\\nvoid insert(int* heap, int k, int val ,long long* sum){    \\n    if(val <= heap[0]){   \\n        return  ;\\n    }\\n    int f = 0 ;\\n     *sum = *sum + val - heap[0] ;\\n    heap[0] = val ;\\n   \\n    while(1){\\n        int son1 = 2*f + 1 ; \\n        int son2 = 2*f + 2 ; \\n        if(son2 < k){\\n            if(heap[son1] <= heap[son2] ){\\n                if(heap[son1] < heap[f]){\\n                    //swap \\n                    int tmp = heap[son1]  ;\\n                    heap[son1]  = heap[f] ;\\n                    heap[f] = tmp ;   \\n                    f = son1 ;\\n                }    \\n                else\\n                    break ;\\n            }\\n            else{\\n                if(heap[son2] < heap[f]){\\n                    //swap \\n                    int tmp = heap[son2]  ;\\n                    heap[son2]  = heap[f] ;\\n                    heap[f] = tmp ;  \\n                    f = son2 ;\\n                }    \\n                else\\n                    break ;                \\n            }\\n        }\\n        else if(son1 < k){\\n            if(heap[son1] < heap[f]){\\n                //swap \\n                int tmp = heap[son1]  ;\\n                heap[son1]  = heap[f] ;\\n                heap[f] = tmp ;   \\n                f = son1 ;\\n            }    \\n            else\\n                break ;\\n        }\\n        else\\n            break;\\n    }    \\n}\\n\\nlong long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\\n    long long ans = 0;\\n    long long sum = 0 ;\\n    int n = nums1Size ;\\n    int** tmp = malloc(n * sizeof(int*) ) ;\\n    int* heap = malloc(2*k * sizeof(int) ) ;\\n    for(int i = 0; i < n; i++){\\n        tmp[i] = malloc(2 * sizeof(int) ) ;\\n        tmp[i][0] = nums1[i] ;\\n        tmp[i][1] = nums2[i] ;\\n    }\\n    qsort(tmp, n ,sizeof(int*), cmp ) ;\\n    \\n    //get heap k items \\n    for(int i = 0; i < k; i++){\\n        heap[i] = tmp[n-1-i][0] ;\\n        sum += tmp[n-1-i][0] ; \\n    }\\n    ans = sum * (long long)tmp[n-k][1] ;\\n    qsort(heap, k, sizeof(int), cmp1) ;\\n    \\n    for(int i = n-k-1; i >=0 ; i--){\\n        insert(heap, k, tmp[i][0] , &sum) ;\\n        ans = fmax(ans , sum * tmp[i][1] ) ;\\n    }\\n    return ans ;\\n}\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[1] == B[1])\\n        return A[0] - B[0] ;\\n    return A[1] - B[1] ;\\n}\\n\\nint cmp1(const void * a, const void* b){\\n    return *(int*)a - *(int*)b ;\\n}\\n\\nvoid insert(int* heap, int k, int val ,long long* sum){    \\n    if(val <= heap[0]){   \\n        return  ;\\n    }\\n    int f = 0 ;\\n     *sum = *sum + val - heap[0] ;\\n    heap[0] = val ;\\n   \\n    while(1){\\n        int son1 = 2*f + 1 ; \\n        int son2 = 2*f + 2 ; \\n        if(son2 < k){\\n            if(heap[son1] <= heap[son2] ){\\n                if(heap[son1] < heap[f]){\\n                    //swap \\n                    int tmp = heap[son1]  ;\\n                    heap[son1]  = heap[f] ;\\n                    heap[f] = tmp ;   \\n                    f = son1 ;\\n                }    \\n                else\\n                    break ;\\n            }\\n            else{\\n                if(heap[son2] < heap[f]){\\n                    //swap \\n                    int tmp = heap[son2]  ;\\n                    heap[son2]  = heap[f] ;\\n                    heap[f] = tmp ;  \\n                    f = son2 ;\\n                }    \\n                else\\n                    break ;                \\n            }\\n        }\\n        else if(son1 < k){\\n            if(heap[son1] < heap[f]){\\n                //swap \\n                int tmp = heap[son1]  ;\\n                heap[son1]  = heap[f] ;\\n                heap[f] = tmp ;   \\n                f = son1 ;\\n            }    \\n            else\\n                break ;\\n        }\\n        else\\n            break;\\n    }    \\n}\\n\\nlong long maxScore(int* nums1, int nums1Size, int* nums2, int nums2Size, int k){\\n    long long ans = 0;\\n    long long sum = 0 ;\\n    int n = nums1Size ;\\n    int** tmp = malloc(n * sizeof(int*) ) ;\\n    int* heap = malloc(2*k * sizeof(int) ) ;\\n    for(int i = 0; i < n; i++){\\n        tmp[i] = malloc(2 * sizeof(int) ) ;\\n        tmp[i][0] = nums1[i] ;\\n        tmp[i][1] = nums2[i] ;\\n    }\\n    qsort(tmp, n ,sizeof(int*), cmp ) ;\\n    \\n    //get heap k items \\n    for(int i = 0; i < k; i++){\\n        heap[i] = tmp[n-1-i][0] ;\\n        sum += tmp[n-1-i][0] ; \\n    }\\n    ans = sum * (long long)tmp[n-k][1] ;\\n    qsort(heap, k, sizeof(int), cmp1) ;\\n    \\n    for(int i = n-k-1; i >=0 ; i--){\\n        insert(heap, k, tmp[i][0] , &sum) ;\\n        ans = fmax(ans , sum * tmp[i][1] ) ;\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083371,
                "title": "c-heap",
                "content": "```\\n\\tpublic long MaxScore(int[] nums1, int[] nums2, int k) {\\n        var nums = new long[nums1.Length][];\\n        for (int i = 0; i < nums.Length; i++)\\n            nums[i] = new long[] { nums1[i], nums2[i] };\\n        nums = nums.OrderBy(x => x[1]).ToArray();\\n        var heap = new PriorityQueue<long, long>();\\n        long res = 0, sum = 0;\\n        for (int i = nums.Length - 1; i >= 0; i--)\\n        {\\n            sum += nums[i][0];\\n            heap.Enqueue(nums[i][0], nums[i][0]);\\n            if (heap.Count > k)\\n                sum -= heap.Dequeue();\\n            nums[i][0] = sum;\\n        }\\n        for (int i = 0; i <= nums.Length - k; i++)\\n            res = Math.Max(res, nums[i][0] * nums[i][1]);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MaxScore(int[] nums1, int[] nums2, int k) {\\n        var nums = new long[nums1.Length][];\\n        for (int i = 0; i < nums.Length; i++)\\n            nums[i] = new long[] { nums1[i], nums2[i] };\\n        nums = nums.OrderBy(x => x[1]).ToArray();\\n        var heap = new PriorityQueue<long, long>();\\n        long res = 0, sum = 0;\\n        for (int i = nums.Length - 1; i >= 0; i--)\\n        {\\n            sum += nums[i][0];\\n            heap.Enqueue(nums[i][0], nums[i][0]);\\n            if (heap.Count > k)\\n                sum -= heap.Dequeue();\\n            nums[i][0] = sum;\\n        }\\n        for (int i = 0; i <= nums.Length - k; i++)\\n            res = Math.Max(res, nums[i][0] * nums[i][1]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082857,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> arr;\\n        long long sum = 0,ans ;\\n        for(int i = 0; i < n; ++i)\\n        arr.push_back({nums2[i], nums1[i]});\\n        sort(arr.rbegin(), arr.rend());\\n        priority_queue<int, vector<int>, greater<int>> pq;//min\\n        for(int i = 0; i < k; ++i)\\n        {\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n\\n        ans = (arr[k-1].first)*sum;\\n        for(int i = k; i < n; ++i)\\n        {\\n            sum -= pq.top();\\n            pq.pop();\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n            res = max(res, sum*(arr[i].first));\\n        }\\n                      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int,int>> arr;\\n        long long sum = 0,ans ;\\n        for(int i = 0; i < n; ++i)\\n        arr.push_back({nums2[i], nums1[i]});\\n        sort(arr.rbegin(), arr.rend());\\n        priority_queue<int, vector<int>, greater<int>> pq;//min\\n        for(int i = 0; i < k; ++i)\\n        {\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n        }\\n\\n        ans = (arr[k-1].first)*sum;\\n        for(int i = k; i < n; ++i)\\n        {\\n            sum -= pq.top();\\n            pq.pop();\\n            sum += arr[i].second;\\n            pq.push(arr[i].second);\\n            res = max(res, sum*(arr[i].first));\\n        }\\n                      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082735,
                "title": "heap-sort-one-step-check",
                "content": "# Intuition\\nimprove a little after reading lee215\\'s solution https://leetcode.com/problems/maximum-subsequence-score/solutions/3082106/java-c-python-priority-queue/?orderBy=most_votes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nheap + sort, but adding a check to see whether we are heap poping the element we just heap pushed. If we are, then take the second smallest nums2[i] instead since the current smallest one nums2[i] is not usable anymoe\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        array = []\\n        for b, a in zip(nums2, nums1):\\n            array.append([b, a])\\n\\n        array.sort(reverse = True)\\n        \\n        heap = []\\n        total = 0\\n        ans = 0\\n        candidB = []\\n        for i, (b, a) in enumerate(array):\\n            heapq.heappush(heap, a)\\n            \\n            total += a\\n\\n            check = False\\n            insertB = True\\n            if len(heap) > k:\\n                aa = heapq.heappop(heap)\\n                total -= aa\\n                if aa == a and len(heap) == k:\\n                    insertB = False\\n                    ans = max(ans, total * candidB[0])\\n                    check = True\\n\\n            if not check and len(heap) == k:\\n                ans = max(ans, total * b)\\n            if insertB:\\n                heapq.heappush(candidB, b)\\n\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        array = []\\n        for b, a in zip(nums2, nums1):\\n            array.append([b, a])\\n\\n        array.sort(reverse = True)\\n        \\n        heap = []\\n        total = 0\\n        ans = 0\\n        candidB = []\\n        for i, (b, a) in enumerate(array):\\n            heapq.heappush(heap, a)\\n            \\n            total += a\\n\\n            check = False\\n            insertB = True\\n            if len(heap) > k:\\n                aa = heapq.heappop(heap)\\n                total -= aa\\n                if aa == a and len(heap) == k:\\n                    insertB = False\\n                    ans = max(ans, total * candidB[0])\\n                    check = True\\n\\n            if not check and len(heap) == k:\\n                ans = max(ans, total * b)\\n            if insertB:\\n                heapq.heappush(candidB, b)\\n\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082664,
                "title": "javascript-heap-based-solution",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxScore = function(nums1, nums2, k) {\\n    //START of heap class\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return b[0]-a[0];\\n                }else{\\n                    return b-a;\\n                }\\n            }else{\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return a[0]-b[0];\\n                }else{\\n                    return a-b;\\n                }\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    //END of heap class\\n    \\n    let arr2=[];\\n    for(let i=0;i<nums2.length;i++){\\n        arr2.push([i,nums2[i]]);\\n    }\\n    arr2.sort(function(a,b){return b[1]-a[1]});\\n    \\n    let currentRate,sum=0,max=0;\\n    let minHeap = new Heap(\\'min\\');\\n    for(let i=0;i<nums2.length;i++){\\n        let index = arr2[i][0];\\n        currentRate = nums2[index];//This is the minimum number from nums2 so far\\n        sum += nums1[index];\\n        minHeap.insert(nums1[index]);\\n        if(minHeap.getSize()>k){\\n            let top = minHeap.removeTop();\\n            sum -= top;\\n        }\\n        if(minHeap.getSize()===k){//We have choosen k elements\\n            max = Math.max(max,sum*currentRate);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxScore = function(nums1, nums2, k) {\\n    //START of heap class\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return b[0]-a[0];\\n                }else{\\n                    return b-a;\\n                }\\n            }else{\\n                if(Array.isArray(a) && Array.isArray(b)){\\n                    return a[0]-b[0];\\n                }else{\\n                    return a-b;\\n                }\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    //END of heap class\\n    \\n    let arr2=[];\\n    for(let i=0;i<nums2.length;i++){\\n        arr2.push([i,nums2[i]]);\\n    }\\n    arr2.sort(function(a,b){return b[1]-a[1]});\\n    \\n    let currentRate,sum=0,max=0;\\n    let minHeap = new Heap(\\'min\\');\\n    for(let i=0;i<nums2.length;i++){\\n        let index = arr2[i][0];\\n        currentRate = nums2[index];//This is the minimum number from nums2 so far\\n        sum += nums1[index];\\n        minHeap.insert(nums1[index]);\\n        if(minHeap.getSize()>k){\\n            let top = minHeap.removeTop();\\n            sum -= top;\\n        }\\n        if(minHeap.getSize()===k){//We have choosen k elements\\n            max = Math.max(max,sum*currentRate);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082402,
                "title": "same-problem-as-1383-maximum-performance-of-a-team",
                "content": "1383. Maximum Performance of a Team",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3082228,
                "title": "c-priority-queue",
                "content": "\\n```\\n    long long maxScore(vector<int> &nums1, vector<int> &nums2, int k)\\n{\\n    int n1=nums1.size();\\n    int n2=nums2.size();\\n    long long int ans=0;\\n\\n    pair<int,int> arr1[nums1.size()];\\n    for(int i=0;i<n1;i++)\\n    {\\n        arr1[i]={nums1[i],i};\\n    }\\n    sort(arr1,arr1+n1);\\n\\n    priority_queue <pair<int,int> , vector<pair<int,int> >, greater<pair<int,int> > > pq;\\n\\n    // unordered_map<int,int> mp;\\n    long long int sum=0;\\n    int i=n1-1;\\n    for(;i>n1-1-k;i--)\\n    {\\n        pq.push({nums2[arr1[i].second],arr1[i].second});\\n        sum+=arr1[i].first;\\n    }\\n    ans=max(ans,sum*(pq.top().first));\\n\\n    for(;i>=0;i--)\\n    {\\n        int index=pq.top().second;\\n        sum-=nums1[index];\\n        pq.pop();\\n\\n        pq.push({nums2[arr1[i].second],arr1[i].second});\\n        sum+=arr1[i].first;\\n\\n        ans=max(ans,sum*(pq.top().first));\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    long long maxScore(vector<int> &nums1, vector<int> &nums2, int k)\\n{\\n    int n1=nums1.size();\\n    int n2=nums2.size();\\n    long long int ans=0;\\n\\n    pair<int,int> arr1[nums1.size()];\\n    for(int i=0;i<n1;i++)\\n    {\\n        arr1[i]={nums1[i],i};\\n    }\\n    sort(arr1,arr1+n1);\\n\\n    priority_queue <pair<int,int> , vector<pair<int,int> >, greater<pair<int,int> > > pq;\\n\\n    // unordered_map<int,int> mp;\\n    long long int sum=0;\\n    int i=n1-1;\\n    for(;i>n1-1-k;i--)\\n    {\\n        pq.push({nums2[arr1[i].second],arr1[i].second});\\n        sum+=arr1[i].first;\\n    }\\n    ans=max(ans,sum*(pq.top().first));\\n\\n    for(;i>=0;i--)\\n    {\\n        int index=pq.top().second;\\n        sum-=nums1[index];\\n        pq.pop();\\n\\n        pq.push({nums2[arr1[i].second],arr1[i].second});\\n        sum+=arr1[i].first;\\n\\n        ans=max(ans,sum*(pq.top().first));\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095223,
                "title": "maximum-subsequence-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion -> TLE\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExponential\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRecursion Stack\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solve(int index, vector<int>& nums1, vector<int>& nums2, int k, int sum, int mini, int& ans, int count)\\n    {\\n        if(index==nums1.size() || count==k)\\n        {\\n            if(count==k)\\n            {\\n                // cout<<sum<<endl<<mini<<endl;\\n                sum = sum*mini;\\n                ans = max(ans, sum);\\n            }\\n            return;\\n        }\\n\\n        // include part\\n        sum += nums1[index];\\n        count++;\\n        solve(index+1, nums1, nums2, k, sum, min(mini, nums2[index]), ans, count);\\n\\n        // backtracking\\n        sum -= nums1[index];\\n        count--;\\n\\n        // exclude part\\n        solve(index+1, nums1, nums2, k, sum, mini, ans, count);\\n\\n        return;\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int ans=0;\\n        int mini = INT_MAX;\\n        int sum=0;\\n        int count=0;\\n\\n        solve(0, nums1, nums2, k, sum, mini, ans, count);\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\nPriority Queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        vector<pair<int,int>> arr;\\n        for(int i=0 ; i<nums1.size() ; i++){\\n            arr.push_back({nums2[i], nums1[i]});\\n            // we are keeping nums2[i] before, because it will have higher impact on our    answer as it is getting multiplied with the nums1 sum\\n        }\\n\\n        sort(arr.begin(), arr.end(), greater<pair<int,int>>());\\n        long long sum=0, ans=0;\\n\\n        // min heap\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for(int i=0 ; i<arr.size() ; i++){\\n            pq.push(arr[i].second);\\n            sum += arr[i].second;\\n\\n            if(pq.size()>k){\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n                ans = max(ans, sum*arr[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/9d7ec8f3-8976-4123-a251-bf91b3a03210_1695792211.4616528.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(int index, vector<int>& nums1, vector<int>& nums2, int k, int sum, int mini, int& ans, int count)\\n    {\\n        if(index==nums1.size() || count==k)\\n        {\\n            if(count==k)\\n            {\\n                // cout<<sum<<endl<<mini<<endl;\\n                sum = sum*mini;\\n                ans = max(ans, sum);\\n            }\\n            return;\\n        }\\n\\n        // include part\\n        sum += nums1[index];\\n        count++;\\n        solve(index+1, nums1, nums2, k, sum, min(mini, nums2[index]), ans, count);\\n\\n        // backtracking\\n        sum -= nums1[index];\\n        count--;\\n\\n        // exclude part\\n        solve(index+1, nums1, nums2, k, sum, mini, ans, count);\\n\\n        return;\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int ans=0;\\n        int mini = INT_MAX;\\n        int sum=0;\\n        int count=0;\\n\\n        solve(0, nums1, nums2, k, sum, mini, ans, count);\\n\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        vector<pair<int,int>> arr;\\n        for(int i=0 ; i<nums1.size() ; i++){\\n            arr.push_back({nums2[i], nums1[i]});\\n            // we are keeping nums2[i] before, because it will have higher impact on our    answer as it is getting multiplied with the nums1 sum\\n        }\\n\\n        sort(arr.begin(), arr.end(), greater<pair<int,int>>());\\n        long long sum=0, ans=0;\\n\\n        // min heap\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for(int i=0 ; i<arr.size() ; i++){\\n            pq.push(arr[i].second);\\n            sum += arr[i].second;\\n\\n            if(pq.size()>k){\\n                sum -= pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==k)\\n                ans = max(ans, sum*arr[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4086136,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- PriorityQueue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        // pair up values in nums1 and nums2 with same index\\n        int[][] pair = new int[nums1.length][2];\\n        for(int i = 0; i < pair.length; i++){\\n            pair[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        // sort pair using nums2 values\\n        Arrays.sort(pair, (a, b) -> b[1] - a[1]);\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a,b) -> a - b);\\n        long runningSum = 0l;\\n        long res = 0l;\\n        for(int i = 0; i < pair.length; i++){\\n            minHeap.add(pair[i][0]); // add current nums1 value to minHeap\\n            runningSum += pair[i][0]; // keep a runningSum of nums1 values\\n            if(i == k - 1){\\n                // when i == k - 1 it means we have enough values to \\n                // multiply sum of values from i0 to ik-1 with min(i0 \\n                // to ik-1)\\n                // be greedy by choosing the value of pair[i][1] to be min\\n                // since pair[i][1] is a value from nums2 sorted in \\n                // decsending order\\n                int min = pair[i][1];\\n                res = Math.max(res, min * runningSum); // save to res\\n            }else if(i > k - 1){\\n                // i > k-1 means we have to remove smallest added \\n                // value from running sum since we want to \\n                // maximize runningSum\\n                // get the smallest value we have seen so far and \\n                // remove it from runningsum \\n                runningSum -= minHeap.poll(); \\n                int min = pair[i][1];\\n                res = Math.max(res, min * runningSum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        // pair up values in nums1 and nums2 with same index\\n        int[][] pair = new int[nums1.length][2];\\n        for(int i = 0; i < pair.length; i++){\\n            pair[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        // sort pair using nums2 values\\n        Arrays.sort(pair, (a, b) -> b[1] - a[1]);\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a,b) -> a - b);\\n        long runningSum = 0l;\\n        long res = 0l;\\n        for(int i = 0; i < pair.length; i++){\\n            minHeap.add(pair[i][0]); // add current nums1 value to minHeap\\n            runningSum += pair[i][0]; // keep a runningSum of nums1 values\\n            if(i == k - 1){\\n                // when i == k - 1 it means we have enough values to \\n                // multiply sum of values from i0 to ik-1 with min(i0 \\n                // to ik-1)\\n                // be greedy by choosing the value of pair[i][1] to be min\\n                // since pair[i][1] is a value from nums2 sorted in \\n                // decsending order\\n                int min = pair[i][1];\\n                res = Math.max(res, min * runningSum); // save to res\\n            }else if(i > k - 1){\\n                // i > k-1 means we have to remove smallest added \\n                // value from running sum since we want to \\n                // maximize runningSum\\n                // get the smallest value we have seen so far and \\n                // remove it from runningsum \\n                runningSum -= minHeap.poll(); \\n                int min = pair[i][1];\\n                res = Math.max(res, min * runningSum);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080483,
                "title": "c-solution-using-heap-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to check with a range of k size . So we can check from the least element from 2nd array till the kth largest element of 2nd array.\\nAs a result it does not matter the order of any array . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Putting both the array into one vector will help to know the corresponding element of both vector.\\n- Now from the k-th largest element we need to move till the least element of 2nd vector.\\n- We can use a priority queue to make sure we have the largest sum for the k size of element when we consider the element from 2nd array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog n) -> We are sorting the array\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Pair of vector\\n\\n# Code\\n```\\nclass Solution {\\n\\n    using ll = long long;\\n\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<nums1.size();i++){\\n            vec.push_back({nums1[i],nums2[i]});\\n        }\\n\\n        sort(vec.begin(),vec.end(),[](pair<int,int>&a,pair<int,int>&b){\\n            return a.second>b.second;\\n        });\\n\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n\\n        ll sum{};\\n        for(int i=0;i<k;i++){\\n            sum+=vec[i].first;\\n            pq.push(vec[i].first);\\n        }\\n\\n        ll ans=sum*vec[k-1].second;\\n\\n        for(int i=k;i<nums1.size();i++){\\n            int s=vec[i].second;\\n            int nos = pq.top();\\n            pq.pop();\\n            sum-=nos;\\n            sum+=vec[i].first;\\n            pq.push(vec[i].first);\\n            ans=max(ans,sum*s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    using ll = long long;\\n\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<nums1.size();i++){\\n            vec.push_back({nums1[i],nums2[i]});\\n        }\\n\\n        sort(vec.begin(),vec.end(),[](pair<int,int>&a,pair<int,int>&b){\\n            return a.second>b.second;\\n        });\\n\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n\\n        ll sum{};\\n        for(int i=0;i<k;i++){\\n            sum+=vec[i].first;\\n            pq.push(vec[i].first);\\n        }\\n\\n        ll ans=sum*vec[k-1].second;\\n\\n        for(int i=k;i<nums1.size();i++){\\n            int s=vec[i].second;\\n            int nos = pq.top();\\n            pq.pop();\\n            sum-=nos;\\n            sum+=vec[i].first;\\n            pq.push(vec[i].first);\\n            ans=max(ans,sum*s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078951,
                "title": "c-clean-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int n = nums1.size();\\n    long long ans = 0;\\n    vector<pair<int, int>> nums;\\n    for (int i = 0; i < n; i++)\\n      nums.push_back({nums1[i], nums2[i]});\\n    struct Cmp {\\n      bool operator()(pair<int, int>& lhs, pair<int, int>& rhs) {\\n        return lhs.second > rhs.second;\\n      }\\n      bool operator()(int lhs, int rhs) {\\n        return lhs > rhs;\\n      }\\n    };\\n    sort(nums.begin(), nums.end(), Cmp{});\\n\\n    priority_queue<int, vector<int>, Cmp> pq;\\n    long long s = 0;\\n    for (int i = 0; i < n; i++) {\\n      if (pq.size() == k - 1) {\\n        ans = max(ans, (s + nums[i].first) * nums[i].second);\\n        pq.push(nums[i].first);\\n        s -= pq.top();  // evict min for next loop\\n        pq.pop();\\n      } else {\\n        pq.push(nums[i].first);\\n      }\\n      s += nums[i].first;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n    int n = nums1.size();\\n    long long ans = 0;\\n    vector<pair<int, int>> nums;\\n    for (int i = 0; i < n; i++)\\n      nums.push_back({nums1[i], nums2[i]});\\n    struct Cmp {\\n      bool operator()(pair<int, int>& lhs, pair<int, int>& rhs) {\\n        return lhs.second > rhs.second;\\n      }\\n      bool operator()(int lhs, int rhs) {\\n        return lhs > rhs;\\n      }\\n    };\\n    sort(nums.begin(), nums.end(), Cmp{});\\n\\n    priority_queue<int, vector<int>, Cmp> pq;\\n    long long s = 0;\\n    for (int i = 0; i < n; i++) {\\n      if (pq.size() == k - 1) {\\n        ans = max(ans, (s + nums[i].first) * nums[i].second);\\n        pq.push(nums[i].first);\\n        s -= pq.top();  // evict min for next loop\\n        pq.pop();\\n      } else {\\n        pq.push(nums[i].first);\\n      }\\n      s += nums[i].first;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074530,
                "title": "make-no-mistake-this-is-a-hard-problem-python-solution-with-clear-steps-and-no-magic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each i, you want to use nums2[$i$], and nums1[$i$] + nums1[$j_1$] + ... + nums1[$j_{k-1}$] to compute a score. This means:\\n    (i)  You want all nums2[$j_1$],...,nums2[$j_{k-1}$] > $nums2[i]$.\\n    (ii) You want to use indices $j_l$ such that the sum of nums1[$j_1$],...,nums1[$j_{k-1}$] is maximal.\\n\\n# Approach\\nStep 1: Sort the indices of nums2, based on the values of nums2.\\nI call this sort tau.\\n\\nStep 2: start with i = n-k and consider nums2[$\\\\tau[i]$], this forces you to use \\nH = [nums1[$\\\\tau[i+1]$],...,nums1[$\\\\tau[n]$]] to compute the score.\\n\\nHeapify H. I use a variable current_max to update the maximum score found. Here is how you compute the scores\\n\\nStep 3: Iterate from n-k all the way down to 0. At every step, you push nums1[$\\\\tau[i]$] to H, update the maximum score by computing\\nscore = nums2[$\\\\tau[i]$]*sum(H)\\n\\nPop the minimum from H (now it has k-1 elements), decrement i and repeat.\\n\\nIn my implementation, I use a variable sum_ to compute update sum(H) at every step.\\n\\n\\nI hope this helps.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\text{log}(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    import heapq\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n = len(nums1)\\n        # Sort nums2 based on their indices\\n        tau = sorted(range(n) , key = lambda i : nums2[i])\\n\\n        current_max = 0  # To compute maximal score\\n        i = n - k # Chosen so that H below has exactly k-1 elements\\n        H = [nums1[tau[l]] for l in range(i+1,n)] # To compute contribution from nums1\\n        sum_ = sum(H) # variable to keep track of contributions of nums1.\\n        heapq.heapify(H) # Heapify H to be able to pop mins fast.\\n        while i >= 0:\\n            heapq.heappush(H , nums1[tau[i]]) # Now H has k elements\\n            sum_ += nums1[tau[i]] # This is the sum of H.\\n            score = nums2[tau[i]] * sum_ # The score for i\\n            current_max = max(current_max, score) # We update current_max\\n            sum_ -= H[0] \\n            heapq.heappop(H) \\n            # The last two lines remove the min of H, now H has k-1 elements and \\n            # we can move on to the next iteration of the loop\\n            i -= 1\\n            \\n        return current_max\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    import heapq\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n = len(nums1)\\n        # Sort nums2 based on their indices\\n        tau = sorted(range(n) , key = lambda i : nums2[i])\\n\\n        current_max = 0  # To compute maximal score\\n        i = n - k # Chosen so that H below has exactly k-1 elements\\n        H = [nums1[tau[l]] for l in range(i+1,n)] # To compute contribution from nums1\\n        sum_ = sum(H) # variable to keep track of contributions of nums1.\\n        heapq.heapify(H) # Heapify H to be able to pop mins fast.\\n        while i >= 0:\\n            heapq.heappush(H , nums1[tau[i]]) # Now H has k elements\\n            sum_ += nums1[tau[i]] # This is the sum of H.\\n            score = nums2[tau[i]] * sum_ # The score for i\\n            current_max = max(current_max, score) # We update current_max\\n            sum_ -= H[0] \\n            heapq.heappop(H) \\n            # The last two lines remove the min of H, now H has k-1 elements and \\n            # we can move on to the next iteration of the loop\\n            i -= 1\\n            \\n        return current_max\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074412,
                "title": "python3-solution-with-sorting-and-minimum-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we want to maximize `(nums1[i0] + nums1[i1] + ... + nums1[ik - 1]) * min(nums2[i0], nums2[i1], ..., nums2[ik - 1])`, one good intuition is to prioritize the second component to maximize the lower bound of the `k` numbers chosen from `nums2`. Thus we sort the pairs of `nums1` and `nums2` according to `nums2` in the descending order.\\n\\nThe first `k` pairs give us the initial score but it may not be the final answer. Why? Think of `nums1 = [2, 1, 4, 1, 2]` and `nums2 = [10, 9, 7, 6, 5]` with `k = 2`. After sorting (I\\'ve already sorted the array in the example for convenience), the first 2 pairs would be `(10, 2), (9, 1)` which gives the score `9 * (2+1) = 27`, but if we look at the next pair `(7, 4)`, we would discard `(9, 1)` from the selected pairs and get a larger score `7 * (2+4) = 42`. How do we know which pair to discard? We can construct a minimum heap from `[2, 1]` that comes from `(10, 2), (9, 1)` and pop the top element each time. In this case, we pop `1` that refers to `(9, 1)`.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log n)$ for sorting the pairs, $O(n\\\\log k)$ for finding the max score, total $O(n\\\\log n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ for the pairs, $O(k)$ for the heap, total $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = list(zip(nums2, nums1))\\n        pairs.sort(reverse=True)\\n\\n        min_heap = [b for a, b in pairs[:k]]\\n        heapify(min_heap)\\n        ksum = sum(min_heap)\\n        max_score = pairs[k-1][0] * ksum\\n\\n        for min_fact, num in pairs[k:]:\\n            ksum -= heappop(min_heap)\\n            ksum += num\\n            heappush(min_heap, num)\\n            max_score = max(max_score, min_fact * ksum)\\n\\n        return max_score\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        pairs = list(zip(nums2, nums1))\\n        pairs.sort(reverse=True)\\n\\n        min_heap = [b for a, b in pairs[:k]]\\n        heapify(min_heap)\\n        ksum = sum(min_heap)\\n        max_score = pairs[k-1][0] * ksum\\n\\n        for min_fact, num in pairs[k:]:\\n            ksum -= heappop(min_heap)\\n            ksum += num\\n            heappush(min_heap, num)\\n            max_score = max(max_score, min_fact * ksum)\\n\\n        return max_score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063931,
                "title": "sorting-and-priority-queue-and-tuple-soln",
                "content": "# Intuition\\ntry to think of a Greedy approach. \\n\\n# Approach\\n- create a vector of pairs, store all elemetns such that arr[i] = { nums2[i], nums1[i] }. arr is the vector of paris.\\n- sort arr in descending order.\\n- now create a MIN PQ to store the minimum k elements till now. and a sum var to store the sum till now.\\n- loop through arr and in each iteration sum add arr[i].second and push arr[i].sec to PQ,  update the ans and subtract the the pq.top() from sum and pop the top. as top was the minimum till now.  \\n\\n\\n# Complexity\\n- Time complexity:\\n$$ O(N*logN) $$\\n\\n- Space complexity:\\n$$O(K)$$\\n\\n# Code\\n```\\n#define PB push_back\\n#define v vector\\n#define all(x) x.begin(),x.end()\\n#define rall(x) x.rbegin(),x.rend()\\n#define ll long long\\nclass Solution {\\npublic:\\n    static bool comp(tuple<ll,ll> a, tuple<ll,ll> b){\\n        auto [a1,a2] = a; auto [b1,b2] =b;\\n        if(a1 == b1) return a2 < b2;\\n        return a1 < b1;\\n    }\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ll n = nums1.size();\\n        v<tuple<ll,ll>> arr;\\n        for(ll i=0; i<n; i++){\\n            arr.PB({nums2[i],nums1[i]});\\n        }\\n        sort(rall(arr));\\n\\n        // for(auto [a,b] : arr){\\n        //     cout<<a<<\" \" << b << \"\\\\n\";\\n        // } cout<<\"--------------\\\\n\";\\n\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        \\n        ll ans=INT_MIN,sum=0;\\n        for(ll i=0; i<n; i++){\\n            auto [mini,b] = arr[i];\\n            sum += b;\\n            pq.push(b);\\n            if(i<k-1) continue;\\n\\n            ans = max(ans, sum*mini);\\n            sum -= pq.top(); pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define PB push_back\\n#define v vector\\n#define all(x) x.begin(),x.end()\\n#define rall(x) x.rbegin(),x.rend()\\n#define ll long long\\nclass Solution {\\npublic:\\n    static bool comp(tuple<ll,ll> a, tuple<ll,ll> b){\\n        auto [a1,a2] = a; auto [b1,b2] =b;\\n        if(a1 == b1) return a2 < b2;\\n        return a1 < b1;\\n    }\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ll n = nums1.size();\\n        v<tuple<ll,ll>> arr;\\n        for(ll i=0; i<n; i++){\\n            arr.PB({nums2[i],nums1[i]});\\n        }\\n        sort(rall(arr));\\n\\n        // for(auto [a,b] : arr){\\n        //     cout<<a<<\" \" << b << \"\\\\n\";\\n        // } cout<<\"--------------\\\\n\";\\n\\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\\n        \\n        ll ans=INT_MIN,sum=0;\\n        for(ll i=0; i<n; i++){\\n            auto [mini,b] = arr[i];\\n            sum += b;\\n            pq.push(b);\\n            if(i<k-1) continue;\\n\\n            ans = max(ans, sum*mini);\\n            sum -= pq.top(); pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4056187,
                "title": "easy-c-solution-using-heap-and-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool sortrev(const pair<int,int> &a,  const pair<int,int> &b) \\n    { \\n      return (a.first > b.first); \\n    }\\n    \\n    long long maxScore(vector<int>& a, vector<int>& b, int k) \\n    {\\n        vector<pair<int,int>> p;\\n        int n = a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            p.push_back({b[i],a[i]});\\n        }\\n        sort(p.begin(),p.end(),sortrev);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long ans = 0;\\n        long long curr = 0;\\n        \\n        for(int i=0;i<k-1;i++)\\n        {\\n            curr += p[i].second;\\n            pq.push(p[i].second);\\n        }\\n        \\n        for(int i=k-1;i<n;i++)\\n        {\\n            curr += p[i].second;\\n            ans = max(ans, curr*p[i].first);\\n            \\n            if(pq.size() > 1 && pq.top() < p[i].second)\\n            {\\n                curr -= pq.top();\\n                pq.pop();\\n                pq.push(p[i].second);\\n            }\\n            else\\n            {\\n                curr -= p[i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortrev(const pair<int,int> &a,  const pair<int,int> &b) \\n    { \\n      return (a.first > b.first); \\n    }\\n    \\n    long long maxScore(vector<int>& a, vector<int>& b, int k) \\n    {\\n        vector<pair<int,int>> p;\\n        int n = a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            p.push_back({b[i],a[i]});\\n        }\\n        sort(p.begin(),p.end(),sortrev);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        long long ans = 0;\\n        long long curr = 0;\\n        \\n        for(int i=0;i<k-1;i++)\\n        {\\n            curr += p[i].second;\\n            pq.push(p[i].second);\\n        }\\n        \\n        for(int i=k-1;i<n;i++)\\n        {\\n            curr += p[i].second;\\n            ans = max(ans, curr*p[i].first);\\n            \\n            if(pq.size() > 1 && pq.top() < p[i].second)\\n            {\\n                curr -= pq.top();\\n                pq.pop();\\n                pq.push(p[i].second);\\n            }\\n            else\\n            {\\n                curr -= p[i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049680,
                "title": "beginner-c-solution-pls-give-me-views",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        std::vector<std::pair<int, int>> pairs;\\n        int len = nums1.size();\\n        for(int i = 0; i < len; i++){\\n            pairs.push_back({nums1[i], nums2[i]});\\n        }\\n        std::sort(pairs.begin(), pairs.end(), [](const std::pair<int, int>& a, const    std::pair<int, int>& b) {\\n        return a.second > b.second;\\n        });\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\\n        long long n1Sum = 0;\\n        long long res = 0;\\n        for(auto [i, j]: pairs){\\n            n1Sum+=i;\\n            minHeap.push(i);\\n            if (minHeap.size()>k){\\n                n1Sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            if(minHeap.size() == k){\\n                res = max(n1Sum*j, res);\\n            }\\n        }\\n        \\n        return res;\\n// [(12, 6),(1, 7),(2, 11),(14, 13)]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        std::vector<std::pair<int, int>> pairs;\\n        int len = nums1.size();\\n        for(int i = 0; i < len; i++){\\n            pairs.push_back({nums1[i], nums2[i]});\\n        }\\n        std::sort(pairs.begin(), pairs.end(), [](const std::pair<int, int>& a, const    std::pair<int, int>& b) {\\n        return a.second > b.second;\\n        });\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\\n        long long n1Sum = 0;\\n        long long res = 0;\\n        for(auto [i, j]: pairs){\\n            n1Sum+=i;\\n            minHeap.push(i);\\n            if (minHeap.size()>k){\\n                n1Sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            if(minHeap.size() == k){\\n                res = max(n1Sum*j, res);\\n            }\\n        }\\n        \\n        return res;\\n// [(12, 6),(1, 7),(2, 11),(14, 13)]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048313,
                "title": "python-greedy-priority-queue",
                "content": "```\\nfrom heapq import heappush, heappushpop\\nfrom operator import itemgetter\\n\\n\\nclass Solution:\\n    def maxScore(self, A: list[int], B: list[int], k: int) -> int:\\n        pq = []\\n\\n        output, total = 0, 0\\n\\n        for a, b in sorted(zip(A, B), key=itemgetter(1), reverse=True):\\n            total += a\\n\\n            if len(pq) < k:\\n                heappush(pq, a)\\n            else:\\n                total -= heappushpop(pq, a)\\n            \\n            if len(pq) == k:\\n                output = max(output, total * b)\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappushpop\\nfrom operator import itemgetter\\n\\n\\nclass Solution:\\n    def maxScore(self, A: list[int], B: list[int], k: int) -> int:\\n        pq = []\\n\\n        output, total = 0, 0\\n\\n        for a, b in sorted(zip(A, B), key=itemgetter(1), reverse=True):\\n            total += a\\n\\n            if len(pq) < k:\\n                heappush(pq, a)\\n            else:\\n                total -= heappushpop(pq, a)\\n            \\n            if len(pq) == k:\\n                output = max(output, total * b)\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018557,
                "title": "c-easiest-solution-using-priority-queue-with-explanation",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool com(pair<int,int>& a,pair<int,int>& b){\\n        if(a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        k--;\\n        int n=nums1.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),com);\\n        long long maxi=0,sum=0;\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i=n-1;i>=0;i--){            \\n            if(q.size()==k){\\n                long long score=(long long)(v[i].first*(sum+v[i].second));\\n                maxi=max(maxi,score);\\n            }\\n            q.push(v[i].second);\\n            sum+=(v[i].second);\\n            if(q.size()>k){               \\n                sum-=q.top();\\n                q.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool com(pair<int,int>& a,pair<int,int>& b){\\n        if(a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        k--;\\n        int n=nums1.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(v.begin(),v.end(),com);\\n        long long maxi=0,sum=0;\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i=n-1;i>=0;i--){            \\n            if(q.size()==k){\\n                long long score=(long long)(v[i].first*(sum+v[i].second));\\n                maxi=max(maxi,score);\\n            }\\n            q.push(v[i].second);\\n            sum+=(v[i].second);\\n            if(q.size()>k){               \\n                sum-=q.top();\\n                q.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017873,
                "title": "pq",
                "content": "**time:`O(NlogN)`; space: `O(N)`**\\n```\\nlong long maxScore(vector<int>& n1, vector<int>& n2, int k)\\n{\\n\\tvector<int> v(size(n1));\\n\\tiota(begin(v), end(v), 0);\\n\\tsort(begin(v), end(v), [&](auto i, auto j){  return n2[i]>n2[j];  });\\n\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tlong long s{0ll}, out{LONG_MIN};\\n\\tfor(int i{}; i<size(n2); ++i)\\n\\t\\tif(i<k-1)\\n\\t\\t\\tpq.push(n1[v[i]]), s+=n1[v[i]];\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tout=max(out, (s+n1[v[i]])*n2[v[i]]);\\n\\t\\t\\tif(k>1 and pq.top()<n1[v[i]])\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=-pq.top()+n1[v[i]];\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push(n1[v[i]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maxScore(vector<int>& n1, vector<int>& n2, int k)\\n{\\n\\tvector<int> v(size(n1));\\n\\tiota(begin(v), end(v), 0);\\n\\tsort(begin(v), end(v), [&](auto i, auto j){  return n2[i]>n2[j];  });\\n\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tlong long s{0ll}, out{LONG_MIN};\\n\\tfor(int i{}; i<size(n2); ++i)\\n\\t\\tif(i<k-1)\\n\\t\\t\\tpq.push(n1[v[i]]), s+=n1[v[i]];\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tout=max(out, (s+n1[v[i]])*n2[v[i]]);\\n\\t\\t\\tif(k>1 and pq.top()<n1[v[i]])\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=-pq.top()+n1[v[i]];\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push(n1[v[i]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017512,
                "title": "priorityqueue-solution-using-custom-sorting-function-java",
                "content": "\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        public  Pair(int first,int second){\\n            this.first=first;\\n            this.second=second;\\n        }\\n    }\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<nums1.length;i++){\\n            li.add(new Pair(nums2[i],nums1[i]));\\n        }\\n        Collections.sort(li,(a,b)->Integer.compare(b.first,a.first));\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long ksum = 0;\\n        for (int i = 0; i < k; i++) {\\n            ksum += li.get(i).second;\\n            pq.add(li.get(i).second);\\n            // System.out.println(li.get(i).first+\" \"+li.get(i).second);\\n        }\\n\\n        long result = ksum * li.get(k-1).first;\\n\\n        for (int i = k; i < nums1.length; i++) {\\n            ksum += li.get(i).second - pq.peek();\\n            pq.poll();\\n            pq.add(li.get(i).second);\\n            result = Math.max(result, ksum * li.get(i).first);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    class Pair {\\n        int first;\\n        int second;\\n        public  Pair(int first,int second){\\n            this.first=first;\\n            this.second=second;\\n        }\\n    }\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<nums1.length;i++){\\n            li.add(new Pair(nums2[i],nums1[i]));\\n        }\\n        Collections.sort(li,(a,b)->Integer.compare(b.first,a.first));\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long ksum = 0;\\n        for (int i = 0; i < k; i++) {\\n            ksum += li.get(i).second;\\n            pq.add(li.get(i).second);\\n            // System.out.println(li.get(i).first+\" \"+li.get(i).second);\\n        }\\n\\n        long result = ksum * li.get(k-1).first;\\n\\n        for (int i = k; i < nums1.length; i++) {\\n            ksum += li.get(i).second - pq.peek();\\n            pq.poll();\\n            pq.add(li.get(i).second);\\n            result = Math.max(result, ksum * li.get(i).first);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016373,
                "title": "note",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nmax sum of subsequence -> maintain a priority queue \\n\\n# Note\\noperator()(x, y) x > y means x should be put in front of y in sorting\\n\\n```\\npriority_queue<int, vector<int>, greater<int> > min_nums1_pq;\\n```\\n\\n```\\n    struct comp{\\n        bool operator()(const pair<int, int>& x, const pair<int, int>& y){\\n            if(x.second > y.second){\\n                return true;\\n            }else if(x.second < y.second){\\n                return false;\\n            }else{\\n                return x.first > y.first;\\n            }\\n        }\\n    };\\n\\n    sort(pair_nums.begin(), pair_nums.end(), comp());\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct comp{\\n        bool operator()(const pair<int, int>& x, const pair<int, int>& y){\\n            if(x.second > y.second){\\n                return true;\\n            }else if(x.second < y.second){\\n                return false;\\n            }else{\\n                return x.first > y.first;\\n            }\\n        }\\n    };\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long res = 0;\\n        vector<pair<int, int> > pair_nums;\\n        priority_queue<int, vector<int>, greater<int> > min_nums1_pq;\\n        long long tmp_max_sum = 0;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            pair_nums.push_back(make_pair(nums1[i], nums2[i]));\\n        }\\n\\n        sort(pair_nums.begin(), pair_nums.end(), comp());\\n        for(int i = 0; i < pair_nums.size(); i++){\\n            if(i < k){\\n                min_nums1_pq.push(pair_nums[i].first);\\n                tmp_max_sum += pair_nums[i].first;\\n            }else{\\n                int min_top = min_nums1_pq.top();\\n                if(pair_nums[i].first > min_top){\\n                    min_nums1_pq.pop();\\n                    min_nums1_pq.push(pair_nums[i].first);\\n                    tmp_max_sum = tmp_max_sum - min_top + pair_nums[i].first;\\n                }\\n                // tmp_max_sum = tmp_max_sum - min_top + pair_nums[i].first;\\n            }\\n\\n            if(min_nums1_pq.size() == k){\\n                res = max(res, tmp_max_sum * pair_nums[i].second);\\n            }\\n        }\\n\\n        return res;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npriority_queue<int, vector<int>, greater<int> > min_nums1_pq;\\n```\n```\\n    struct comp{\\n        bool operator()(const pair<int, int>& x, const pair<int, int>& y){\\n            if(x.second > y.second){\\n                return true;\\n            }else if(x.second < y.second){\\n                return false;\\n            }else{\\n                return x.first > y.first;\\n            }\\n        }\\n    };\\n\\n    sort(pair_nums.begin(), pair_nums.end(), comp());\\n```\n```\\nclass Solution {\\npublic:\\n    struct comp{\\n        bool operator()(const pair<int, int>& x, const pair<int, int>& y){\\n            if(x.second > y.second){\\n                return true;\\n            }else if(x.second < y.second){\\n                return false;\\n            }else{\\n                return x.first > y.first;\\n            }\\n        }\\n    };\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long res = 0;\\n        vector<pair<int, int> > pair_nums;\\n        priority_queue<int, vector<int>, greater<int> > min_nums1_pq;\\n        long long tmp_max_sum = 0;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            pair_nums.push_back(make_pair(nums1[i], nums2[i]));\\n        }\\n\\n        sort(pair_nums.begin(), pair_nums.end(), comp());\\n        for(int i = 0; i < pair_nums.size(); i++){\\n            if(i < k){\\n                min_nums1_pq.push(pair_nums[i].first);\\n                tmp_max_sum += pair_nums[i].first;\\n            }else{\\n                int min_top = min_nums1_pq.top();\\n                if(pair_nums[i].first > min_top){\\n                    min_nums1_pq.pop();\\n                    min_nums1_pq.push(pair_nums[i].first);\\n                    tmp_max_sum = tmp_max_sum - min_top + pair_nums[i].first;\\n                }\\n                // tmp_max_sum = tmp_max_sum - min_top + pair_nums[i].first;\\n            }\\n\\n            if(min_nums1_pq.size() == k){\\n                res = max(res, tmp_max_sum * pair_nums[i].second);\\n            }\\n        }\\n\\n        return res;\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015946,
                "title": "4d-dp-tle-approach-followed-by-optimal-descending-sorting-greedy-min-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // // TLE APPROACH\\n    // // DP-Approach\\n    // // Here in this DP, 4-states are changing --> sum,min,index,count\\n    // // hence it becomes 4D-DP, so even if we try to memoize it, will return TLE.\\n    // // TC: O(2^n)\\n    // // SC: O(n)+O(n^2) = priority queue + recursive stack space(each_recursive_call*call_for_priority_queue)\\n    // int n;\\n    // priority_queue<int,vector<int>, greater<int>> pq;\\n    // void removefrompq(int num){\\n    //     vector<int> temp;\\n    //     while(!pq.empty()){\\n    //         int x = pq.top();\\n    //         pq.pop();\\n    //         if(x==num) break;\\n    //         temp.push_back(x);\\n    //     }\\n    //     for(auto &number: temp){\\n    //         pq.push(number);\\n    //     }\\n    // }\\n    // long long solvedp(vector<int>& nums1, vector<int>& nums2, long long sum, int min, int index, int count, int k){\\n    //     if(count==k) return sum*min;\\n    //     if(index>=n) return 0;\\n    //     pq.push(nums2[index]);\\n    //     long long take = solvedp(nums1,nums2,sum+nums1[index],pq.top(),index+1, count+1, k);\\n    //     removefrompq(nums2[index]);\\n    //     long long nottake = solvedp(nums1,nums2,sum,min,index+1, count, k);\\n    //     return max(take,nottake);\\n    // }\\n    // long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n    //     while(!pq.empty()){\\n    //         pq.pop();\\n    //     }\\n    //     n = nums1.size();\\n    //     return solvedp(nums1,nums2,0,0,0,0,k);\\n    // }\\n\\n/* --------------------------------------Optimal Priority Queue --------------------------------- */\\n\\n// SORTING+GREEDY+MIN-HEAP;\\n// TC: O(n*log(n))\\n// SC: O(2*n)\\n\\nint n;\\nlong long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n = nums1.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        vector<pair<int,int>> vect;\\n        for(int i = 0; i<n; i++){\\n            vect.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vect.begin(),vect.end());\\n        reverse(vect.begin(),vect.end());\\n        long long sum = 0;\\n        for(int i = 0; i<=k-1; i++){\\n            pq.push(vect[i].second);\\n            sum+=vect[i].second;\\n        }\\n        long long maxi = sum*(vect[k-1].first);\\n        for(int i = k; i<n; i++){\\n            sum+=vect[i].second-pq.top();\\n            maxi = max(maxi,sum*vect[i].first);\\n            pq.pop();\\n            pq.push(vect[i].second);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // // TLE APPROACH\\n    // // DP-Approach\\n    // // Here in this DP, 4-states are changing --> sum,min,index,count\\n    // // hence it becomes 4D-DP, so even if we try to memoize it, will return TLE.\\n    // // TC: O(2^n)\\n    // // SC: O(n)+O(n^2) = priority queue + recursive stack space(each_recursive_call*call_for_priority_queue)\\n    // int n;\\n    // priority_queue<int,vector<int>, greater<int>> pq;\\n    // void removefrompq(int num){\\n    //     vector<int> temp;\\n    //     while(!pq.empty()){\\n    //         int x = pq.top();\\n    //         pq.pop();\\n    //         if(x==num) break;\\n    //         temp.push_back(x);\\n    //     }\\n    //     for(auto &number: temp){\\n    //         pq.push(number);\\n    //     }\\n    // }\\n    // long long solvedp(vector<int>& nums1, vector<int>& nums2, long long sum, int min, int index, int count, int k){\\n    //     if(count==k) return sum*min;\\n    //     if(index>=n) return 0;\\n    //     pq.push(nums2[index]);\\n    //     long long take = solvedp(nums1,nums2,sum+nums1[index],pq.top(),index+1, count+1, k);\\n    //     removefrompq(nums2[index]);\\n    //     long long nottake = solvedp(nums1,nums2,sum,min,index+1, count, k);\\n    //     return max(take,nottake);\\n    // }\\n    // long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n    //     while(!pq.empty()){\\n    //         pq.pop();\\n    //     }\\n    //     n = nums1.size();\\n    //     return solvedp(nums1,nums2,0,0,0,0,k);\\n    // }\\n\\n/* --------------------------------------Optimal Priority Queue --------------------------------- */\\n\\n// SORTING+GREEDY+MIN-HEAP;\\n// TC: O(n*log(n))\\n// SC: O(2*n)\\n\\nint n;\\nlong long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        n = nums1.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        vector<pair<int,int>> vect;\\n        for(int i = 0; i<n; i++){\\n            vect.push_back({nums2[i],nums1[i]});\\n        }\\n        sort(vect.begin(),vect.end());\\n        reverse(vect.begin(),vect.end());\\n        long long sum = 0;\\n        for(int i = 0; i<=k-1; i++){\\n            pq.push(vect[i].second);\\n            sum+=vect[i].second;\\n        }\\n        long long maxi = sum*(vect[k-1].first);\\n        for(int i = k; i<n; i++){\\n            sum+=vect[i].second-pq.top();\\n            maxi = max(maxi,sum*vect[i].first);\\n            pq.pop();\\n            pq.push(vect[i].second);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004474,
                "title": "python-sorting-minheap-approach",
                "content": "To understand the solution easily, we can divide the problem into sub-problems.\\n\\nIt is given that for chosen indices i0, i1, ..., ik - 1, the score is defined as: \\n\\n\\tThe sum of the selected elements from nums1 \\n\\tmultiplied with the minimum of the selected elements from nums2.\\n\\t\\nSo, we have two things to take care of in this problem - \\n\\n\\t1. We want to find the sum of elements of a subsequence in nums1\\n\\t2. We want the find the minimum of elements of a subsequence in nums2\\n\\nAnd we want to have an efficient way to do both these things. A Brute Force approach will fail due to the constraints.\\n\\nLet\\'s think of the second sub-problem first. We want the minimum element in a subsequence. So, we can use sorting here because if we sort nums2 in decreasing order, then for any subsequence that ends at an index \"i\", the minimum element will always be nums2[i] since nums2 is sorted.\\n\\n\\tThat is, if we have nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\\n\\t\\n\\tIf we sort nums2 in decreasing order -> nums2 = [4,3,2,1]\\n\\t\\n\\tSo, if a subsequence ends at index 2, then minimum is nums2[2] => 2\\n\\tIf a subsequence ends at index 3, then the minimum is nums2[3] => 1\\n\\t\\n\\tBut, since we sorted nums2, num1\\'s elements also need to be arranged accordingly\\n\\t\\n\\tThat\\'s why, we won\\'t sort nums2 alone but first we will combine both the lists\\n\\t\\n\\tnums = [(1,2), (3,1), (3,3), (2,4)]\\n\\t\\n\\tSo now, each pair at index \"i\" in nums is like this => (nums1[i], nums2[i])\\n\\t\\n\\tAnd now we can sort this combined list based on the nums2 data in decreasing order\\n\\t\\n\\tnums = [(4,2), (3,3), (1,2), (3,1)]\\n\\t\\nSo, our second sub-problem is now solved as we can now efficiently get the smallest element in a subsequence ending at index \"i\".\\n\\nBut what about the first sub-problem of finding the sum?\\n\\n\\tLet\\'s take the same example. \\n\\tSo far, nums = [(4,2), (3,3), (1,2), (3,1)]\\n\\t\\n\\tWe want a subsequence to be of length \"k\"\\n\\tSuppose, we are checking the subsequence ending at index 3\\n\\t\\n\\tSo, for a subsequence ending at index 3, minimum = nums[3][1]\\n\\t\\n\\tAnd what about sum? We cannot just go over every single subsequence ending at index 3 and get its sum\\n\\tSince we want to maximize the overall subsequence score, \\n\\twe want the maximum subsequence sum for a subsequence that ends at index 3\\n\\t\\n\\tAs we have already considered index 3, we have already found one element of subsequence.\\n\\tAnd so, we want the rest k - 1 other elements for this subsequence.\\n\\tIt is also pretty obvious that since this subsequence ends at index 3,\\n\\tthe rest k - 1 elements will be on the left side of index 3.\\n\\t\\n\\tAnd since we want to maximize this sum, we want the maximum k - 1 elements on left side of index 2.\\n\\t\\nNow you should\\'ve got a hint of what approach to take to find the maximum k - 1 elements till a particular index.\\n\\nWe will use a minHeap here to get the top k -1 elements at any time for any subsequence ending at index \"i\"\\n\\nWe also want to maintain the current subsequence sum to avoid having to write a nested loop to get the sum from the heap.\\n\\nSo, as we push a new element to the minHeap, it will have to remove the smallest element from it so that its size remains k only.\\n\\nSo, whatever element it removes, that will also be reduced from the current subsequence sum. And whatever element we push to the heap, that will be added to the current subsequence sum. In this way, we can maintain the subsequence sum easily.\\n\\t\\nAnd finally, we just want to update the maximum score in each iteration and return it at the end.\\n\\n\\n```\\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        # Length of lists\\n        n = len(nums1)\\n\\t\\t\\n        # For the minimum, we can use sorting\\n        # Combine the data in a single list\\n        nums = [(nums1[i], nums2[i]) for i in range(n)]\\n        \\n        # Sort based on nums2 value in decreasing order\\n        nums.sort(key = lambda x: x[1], reverse=True)\\n\\t\\t\\n        # We will use a minHeap here and we want to always have at most k - 1 values in it\\n        # So, at any time, our minHeap will have the top k - 1 values\\n        minHeap = []\\n        \\n        # To keep track of the maximum possible sum of a subsequence ending at index \"i\"\\n        currSubsequenceSum = 0\\n        \\n        for i in range(k): \\n            heappush(minHeap, nums[i][0])\\n            currSubsequenceSum += nums[i][0]\\n        \\n        # Maximum Subsequence Score (Initialize it by the score of first subsequence)\\n        maxScore = currSubsequenceSum * nums[k - 1][1]\\n\\n        # We start our loop from k index\\n        for i in range(k, n):\\n            \\n            # We want to push this value \"i\" into the heap and increment the currSubsequenceSum by that\\n            # And if there is some smaller value that is removed from heap, we want to reduce the currSubsequenceSum by that\\n            removedVal = heappushpop(minHeap, nums[i][0])\\n            \\n            # Increment the currSubsequenceSum by nums[i][0]\\n            currSubsequenceSum += nums[i][0]\\n            \\n            # Decrement the currSubsequenceSum by removedVal\\n            currSubsequenceSum -= removedVal\\n            \\n            # Here, each \"i\" index represents the last index of a subsequence\\n            # So it is also the minimum among all\\n            minimum = nums[i][1]\\n            \\n            # Update the maximum Score\\n            maxScore = max(maxScore, currSubsequenceSum * minimum)\\n\\n        # Return the Maximum Subsequence Score\\n        return maxScore     \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        # Length of lists\\n        n = len(nums1)\\n\\t\\t\\n        # For the minimum, we can use sorting\\n        # Combine the data in a single list\\n        nums = [(nums1[i], nums2[i]) for i in range(n)]\\n        \\n        # Sort based on nums2 value in decreasing order\\n        nums.sort(key = lambda x: x[1], reverse=True)\\n\\t\\t\\n        # We will use a minHeap here and we want to always have at most k - 1 values in it\\n        # So, at any time, our minHeap will have the top k - 1 values\\n        minHeap = []\\n        \\n        # To keep track of the maximum possible sum of a subsequence ending at index \"i\"\\n        currSubsequenceSum = 0\\n        \\n        for i in range(k): \\n            heappush(minHeap, nums[i][0])\\n            currSubsequenceSum += nums[i][0]\\n        \\n        # Maximum Subsequence Score (Initialize it by the score of first subsequence)\\n        maxScore = currSubsequenceSum * nums[k - 1][1]\\n\\n        # We start our loop from k index\\n        for i in range(k, n):\\n            \\n            # We want to push this value \"i\" into the heap and increment the currSubsequenceSum by that\\n            # And if there is some smaller value that is removed from heap, we want to reduce the currSubsequenceSum by that\\n            removedVal = heappushpop(minHeap, nums[i][0])\\n            \\n            # Increment the currSubsequenceSum by nums[i][0]\\n            currSubsequenceSum += nums[i][0]\\n            \\n            # Decrement the currSubsequenceSum by removedVal\\n            currSubsequenceSum -= removedVal\\n            \\n            # Here, each \"i\" index represents the last index of a subsequence\\n            # So it is also the minimum among all\\n            minimum = nums[i][1]\\n            \\n            # Update the maximum Score\\n            maxScore = max(maxScore, currSubsequenceSum * minimum)\\n\\n        # Return the Maximum Subsequence Score\\n        return maxScore     \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3988470,
                "title": "min-heap-beats-97-python",
                "content": "# Intuition\\n1. First we sort the elements in descending order according to nums2 and nums1.\\n2. Select the first k nums1 elements => sum them and heapify them. The current sum is the maximum sum over nums1\\n3. Multiply the result by the last element of nums2 since its the largest.\\n4. Iterate through the two arrays and update the heap, the current sum and multiply by the current num2 which is alwats larger than the previous.\\n\\n# Complexity\\n- Time complexity:O(NlogN+ (N-k)logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\\n        nums = sorted(((b, a) for a, b in zip(nums1, nums2)), reverse = True)\\n\\n        heap = [num[1] for num in nums[:k]]\\n        ksum = sum(heap)\\n        heapq.heapify(heap)\\n\\n        maxResult = ksum * nums[k-1][0]\\n\\n        for num2, num1 in nums[k:]:\\n            \\n            ksum += num1 - heapq.heappushpop(heap, num1)\\n\\n            maxResult = max(maxResult, ksum * num2)\\n\\n        return maxResult\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\\n        nums = sorted(((b, a) for a, b in zip(nums1, nums2)), reverse = True)\\n\\n        heap = [num[1] for num in nums[:k]]\\n        ksum = sum(heap)\\n        heapq.heapify(heap)\\n\\n        maxResult = ksum * nums[k-1][0]\\n\\n        for num2, num1 in nums[k:]:\\n            \\n            ksum += num1 - heapq.heappushpop(heap, num1)\\n\\n            maxResult = max(maxResult, ksum * num2)\\n\\n        return maxResult\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970283,
                "title": "python-minheap",
                "content": "# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        # Building a list of tuples to represent pairs\\n        pairs = [(num1, num2) for num1, num2 in zip(nums1, nums2)]\\n        \\n        # Sorting pairs by the corresponding value in nums2\\n        pairs = sorted(pairs, key = lambda pair : pair[1], reverse = True)\\n\\n        minHeap = []\\n        n1Sum = 0\\n        result = 0 # max score\\n\\n        for num1, num2 in pairs:\\n            n1Sum += num1\\n            heapq.heappush(minHeap, num1)\\n\\n            if len(minHeap) > k:\\n                n1Sum -= heapq.heappop(minHeap)\\n            \\n            if len(minHeap) == k:\\n                result = max(result, n1Sum * num2)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        # Building a list of tuples to represent pairs\\n        pairs = [(num1, num2) for num1, num2 in zip(nums1, nums2)]\\n        \\n        # Sorting pairs by the corresponding value in nums2\\n        pairs = sorted(pairs, key = lambda pair : pair[1], reverse = True)\\n\\n        minHeap = []\\n        n1Sum = 0\\n        result = 0 # max score\\n\\n        for num1, num2 in pairs:\\n            n1Sum += num1\\n            heapq.heappush(minHeap, num1)\\n\\n            if len(minHeap) > k:\\n                n1Sum -= heapq.heappop(minHeap)\\n            \\n            if len(minHeap) == k:\\n                result = max(result, n1Sum * num2)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957975,
                "title": "scala-using-foldleft",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxScore(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {\\n        val n = nums1.length\\n        \\n        k match {\\n            case count if count == n => nums1.map(_.toLong).sum * nums2.min\\n            case _ =>\\n                val mults = nums2.zip(nums1).sortBy(-_._1)\\n            \\n                val numsQueue = new collection.mutable.PriorityQueue[Long]()(Ordering[Long].reverse)\\n                numsQueue.enqueue(mults.take(k).map(_._2.toLong): _*)\\n\\n                var sum = numsQueue.sum \\n\\n                (k until n)\\n                    .foldLeft(sum * mults(k-1)._1){\\n                        (max, j) =>\\n                            val (mult, newNum) = mults(j)\\n                            if (numsQueue.head < newNum) {\\n                                sum = sum - numsQueue.dequeue + newNum\\n                                numsQueue.enqueue(newNum)\\n                            }\\n                            math.max(max, sum * mult)\\n                    }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxScore(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {\\n        val n = nums1.length\\n        \\n        k match {\\n            case count if count == n => nums1.map(_.toLong).sum * nums2.min\\n            case _ =>\\n                val mults = nums2.zip(nums1).sortBy(-_._1)\\n            \\n                val numsQueue = new collection.mutable.PriorityQueue[Long]()(Ordering[Long].reverse)\\n                numsQueue.enqueue(mults.take(k).map(_._2.toLong): _*)\\n\\n                var sum = numsQueue.sum \\n\\n                (k until n)\\n                    .foldLeft(sum * mults(k-1)._1){\\n                        (max, j) =>\\n                            val (mult, newNum) = mults(j)\\n                            if (numsQueue.head < newNum) {\\n                                sum = sum - numsQueue.dequeue + newNum\\n                                numsQueue.enqueue(newNum)\\n                            }\\n                            math.max(max, sum * mult)\\n                    }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945696,
                "title": "minimum-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) The first thing that we will do, we will try to fix the minimum element from the nums2 .\\n2) We have to choose k elements, If we are choosing the ith element to be minimum then remaining k - 1 elements should be greater than or equal to ith element. So we can think of something sorting. But we also need the corresponding element from the nums1. So we have to keep the order of element as well.\\n3) Now the sum of remaining k - 1 elements of nums1 should be as maximum as possible.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int numSize = nums1.size();\\n        long long ans = 0;\\n\\n        if(k == 1) {\\n            for(int i = 0; i < numSize; i++) {\\n                ans = max(ans, 1LL*nums1[i]*nums2[i]);\\n            }\\n            return ans;\\n        } \\n\\n        vector<pair<long long,long long>>v;\\n\\n        for(int i = 0; i < numSize; i++) {\\n            v.push_back({nums2[i], i});\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        \\n        long long heap_sum = 0;\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n\\n        for(int i = numSize - 1; i >= 0; i--) {\\n\\n            int idx = v[i].second;\\n            \\n            if(pq.size() == k - 1) {\\n                \\n                long long mini = v[i].first;\\n                long long curr_sum = heap_sum + nums1[idx];\\n\\n                ans = max(ans, curr_sum*mini);\\n\\n                if(nums1[idx] > pq.top()) {\\n                   \\n                    heap_sum -= pq.top();\\n                    pq.pop();\\n                    pq.push(nums1[idx]);\\n                    heap_sum += nums1[idx];\\n\\n                }\\n\\n            } else {\\n                heap_sum += nums1[idx];\\n                pq.push(nums1[idx]);\\n            }\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int numSize = nums1.size();\\n        long long ans = 0;\\n\\n        if(k == 1) {\\n            for(int i = 0; i < numSize; i++) {\\n                ans = max(ans, 1LL*nums1[i]*nums2[i]);\\n            }\\n            return ans;\\n        } \\n\\n        vector<pair<long long,long long>>v;\\n\\n        for(int i = 0; i < numSize; i++) {\\n            v.push_back({nums2[i], i});\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        \\n        long long heap_sum = 0;\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n\\n        for(int i = numSize - 1; i >= 0; i--) {\\n\\n            int idx = v[i].second;\\n            \\n            if(pq.size() == k - 1) {\\n                \\n                long long mini = v[i].first;\\n                long long curr_sum = heap_sum + nums1[idx];\\n\\n                ans = max(ans, curr_sum*mini);\\n\\n                if(nums1[idx] > pq.top()) {\\n                   \\n                    heap_sum -= pq.top();\\n                    pq.pop();\\n                    pq.push(nums1[idx]);\\n                    heap_sum += nums1[idx];\\n\\n                }\\n\\n            } else {\\n                heap_sum += nums1[idx];\\n                pq.push(nums1[idx]);\\n            }\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935150,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied\\n\\n    // My solution - TLE\\n    // As I go for the brute force approach by finding the k subsequence sum and then finding the min value among that k sunsequence and the updating value;\\n\\n\\n\\n  /*  static int ans = 0;\\n\\n    static void helper(int arr1[], int arr2[], int k, int idx, ArrayList<Integer> sum, ArrayList<Integer> min){\\n        if(idx>=arr1.length) return;\\n\\n        if(k==1){\\n            for(int i=idx; i<arr1.length; i++){\\n                sum.set(0,sum.get(0)+arr1[i]);\\n                int a = min.get(0);\\n                min.set(0,Math.min(a,arr2[i]));\\n\\n                ans = Math.max(ans,sum.get(0)*min.get(0));\\n\\n                sum.set(0,sum.get(0)-arr1[i]);\\n                min.set(0,a);\\n            }\\n            return;\\n        }\\n\\n            for(int i=idx; i<=arr1.length-k; i++){\\n                sum.set(0,sum.get(0)+arr1[i]);\\n                int a = min.get(0);\\n                min.set(0,Math.min(a,arr2[i]));\\n                helper(arr1,arr2,k-1,i+1,sum,min);\\n\\n                sum.set(0,sum.get(0)-arr1[i]);\\n                min.set(0,a);\\n            }\\n        }\\n\\n        static int helper(int[] arr1, int[] arr2, int k){\\n            ans = 0;\\n        \\n\\n        ArrayList<Integer> sum = new ArrayList<>();\\n        ArrayList<Integer> min = new ArrayList<>();\\n\\n        sum.add(0);\\n        min.add(Integer.MAX_VALUE);\\n\\n        helper(arr1,arr2,k,0,sum,min);\\n        return ans;\\n        } */\\n\\n\\n    static final int SHIFT = 20;\\n    static final long MASK = 0xF_FFFFL;\\n    \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        \\n        // Simultaneous sort of nums1 and nums2, sorting ascending \\n        // by nums2.  Pack both nums1 and corresponding nums2 value \\n        // into a single long, in an array of long, then sort that \\n        // array of long.\\n        long[] nums21 = new long[n];\\n        for (int i = n - 1; i >= 0; i--) \\n            nums21[i] = ((long)nums2[i] << SHIFT) | nums1[i];\\n        Arrays.sort(nums21);\\n        \\n        // Build a priority queue with lowest first, containing the \\n        // k highest values from nums2.  Calculate a sum of the \\n        // values in the priority queue.  The index of the highest \\n        // possible min value from nums2, will be at index idx2 in \\n        // the sorted nums21 array.  The highest k-1 values in nums2 \\n        // will never be a min value from nums2, so skip the highest \\n        // k-1 values in nums2, and start min value testing at \\n        // highest possible min value, which is at index n-k in the \\n        // sorted nums21 array.\\n        PriorityQueue<Integer> kNumFromNums1 = new PriorityQueue(k + 1);\\n        long sumFromNums1 = 0;\\n        int idx21 = n - k;\\n        for (int i = idx21; i < n; i++) {\\n            sumFromNums1 += (nums21[i] & MASK);\\n            kNumFromNums1.add((int)(nums21[i] & MASK));\\n        }\\n\\n        // For each possible min value from nums1 (index n-k...0 in nums21), \\n        // test to see if the sum of the k highest available nums1 values \\n        // will resultin the highest score.\\n        long result = sumFromNums1 * (nums21[idx21] >> SHIFT);\\n        while (--idx21 >= 0) {\\n            sumFromNums1 += (nums21[idx21] & MASK) - kNumFromNums1.poll();\\n            kNumFromNums1.add((int)(nums21[idx21] & MASK));\\n            result = Math.max(result, sumFromNums1 * (nums21[idx21] >> SHIFT));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied\\n\\n    // My solution - TLE\\n    // As I go for the brute force approach by finding the k subsequence sum and then finding the min value among that k sunsequence and the updating value;\\n\\n\\n\\n  /*  static int ans = 0;\\n\\n    static void helper(int arr1[], int arr2[], int k, int idx, ArrayList<Integer> sum, ArrayList<Integer> min){\\n        if(idx>=arr1.length) return;\\n\\n        if(k==1){\\n            for(int i=idx; i<arr1.length; i++){\\n                sum.set(0,sum.get(0)+arr1[i]);\\n                int a = min.get(0);\\n                min.set(0,Math.min(a,arr2[i]));\\n\\n                ans = Math.max(ans,sum.get(0)*min.get(0));\\n\\n                sum.set(0,sum.get(0)-arr1[i]);\\n                min.set(0,a);\\n            }\\n            return;\\n        }\\n\\n            for(int i=idx; i<=arr1.length-k; i++){\\n                sum.set(0,sum.get(0)+arr1[i]);\\n                int a = min.get(0);\\n                min.set(0,Math.min(a,arr2[i]));\\n                helper(arr1,arr2,k-1,i+1,sum,min);\\n\\n                sum.set(0,sum.get(0)-arr1[i]);\\n                min.set(0,a);\\n            }\\n        }\\n\\n        static int helper(int[] arr1, int[] arr2, int k){\\n            ans = 0;\\n        \\n\\n        ArrayList<Integer> sum = new ArrayList<>();\\n        ArrayList<Integer> min = new ArrayList<>();\\n\\n        sum.add(0);\\n        min.add(Integer.MAX_VALUE);\\n\\n        helper(arr1,arr2,k,0,sum,min);\\n        return ans;\\n        } */\\n\\n\\n    static final int SHIFT = 20;\\n    static final long MASK = 0xF_FFFFL;\\n    \\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        \\n        // Simultaneous sort of nums1 and nums2, sorting ascending \\n        // by nums2.  Pack both nums1 and corresponding nums2 value \\n        // into a single long, in an array of long, then sort that \\n        // array of long.\\n        long[] nums21 = new long[n];\\n        for (int i = n - 1; i >= 0; i--) \\n            nums21[i] = ((long)nums2[i] << SHIFT) | nums1[i];\\n        Arrays.sort(nums21);\\n        \\n        // Build a priority queue with lowest first, containing the \\n        // k highest values from nums2.  Calculate a sum of the \\n        // values in the priority queue.  The index of the highest \\n        // possible min value from nums2, will be at index idx2 in \\n        // the sorted nums21 array.  The highest k-1 values in nums2 \\n        // will never be a min value from nums2, so skip the highest \\n        // k-1 values in nums2, and start min value testing at \\n        // highest possible min value, which is at index n-k in the \\n        // sorted nums21 array.\\n        PriorityQueue<Integer> kNumFromNums1 = new PriorityQueue(k + 1);\\n        long sumFromNums1 = 0;\\n        int idx21 = n - k;\\n        for (int i = idx21; i < n; i++) {\\n            sumFromNums1 += (nums21[i] & MASK);\\n            kNumFromNums1.add((int)(nums21[i] & MASK));\\n        }\\n\\n        // For each possible min value from nums1 (index n-k...0 in nums21), \\n        // test to see if the sum of the k highest available nums1 values \\n        // will resultin the highest score.\\n        long result = sumFromNums1 * (nums21[idx21] >> SHIFT);\\n        while (--idx21 >= 0) {\\n            sumFromNums1 += (nums21[idx21] & MASK) - kNumFromNums1.poll();\\n            kNumFromNums1.add((int)(nums21[idx21] & MASK));\\n            result = Math.max(result, sumFromNums1 * (nums21[idx21] >> SHIFT));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926912,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>&a, vector<int>&b){\\n        if(a[0]==b[0]) a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& num1, vector<int>& num2, int k) {\\n        vector<vector<int>> v;\\n        int i=0, n= num1.size();\\n        for(i=0;i<n;i++){\\n            v.push_back({num2[i], num1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans= 0,tmp=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(i=0;i<n ;i++){\\n            if(i<k){\\n                tmp+= v[i][1];\\n                pq.push(v[i][1]);\\n                if(i==k-1){\\n                    ans= max(ans, tmp*v[i][0]);\\n                }}else{\\n                    tmp+= v[i][1];\\n                    pq.push(v[i][1]);\\n                    tmp-= pq.top();\\n                    pq.pop();\\n                    ans= max(ans, tmp*v[i][0]);\\n\\n                \\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>&a, vector<int>&b){\\n        if(a[0]==b[0]) a[1]>b[1];\\n        return a[0]>b[0];\\n    }\\n    long long maxScore(vector<int>& num1, vector<int>& num2, int k) {\\n        vector<vector<int>> v;\\n        int i=0, n= num1.size();\\n        for(i=0;i<n;i++){\\n            v.push_back({num2[i], num1[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        long long int ans= 0,tmp=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(i=0;i<n ;i++){\\n            if(i<k){\\n                tmp+= v[i][1];\\n                pq.push(v[i][1]);\\n                if(i==k-1){\\n                    ans= max(ans, tmp*v[i][0]);\\n                }}else{\\n                    tmp+= v[i][1];\\n                    pq.push(v[i][1]);\\n                    tmp-= pq.top();\\n                    pq.pop();\\n                    ans= max(ans, tmp*v[i][0]);\\n\\n                \\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925264,
                "title": "max-heap-min-heap-priority-queue-cpp",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,int>>pq; // nums2, nums1\\n        for(int i = 0; i < nums1.size(); i++) {\\n            pq.push({nums2[i] , nums1[i]});\\n        }\\n        \\n        long long int ans = 0;\\n        priority_queue<int , vector<int> , greater<int>>lowSum;\\n        long long sum = 0;\\n        int minValue = 0;\\n        \\n        for(int i = 0; i < k; i++) {\\n            auto[x ,y] = pq.top();\\n            pq.pop();\\n            lowSum.push(y);\\n            sum += y;\\n            minValue = x;\\n        }\\n        \\n        ans = sum * minValue;\\n        \\n        for(int i = k; i < nums1.size(); i++) {\\n            auto[x ,y] = pq.top();\\n            pq.pop();\\n            \\n            sum -= lowSum.top();\\n            lowSum.pop();\\n            \\n            lowSum.push(y);\\n            sum += y;\\n            minValue = x;\\n            \\n            ans = max(ans, sum * minValue);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,int>>pq; // nums2, nums1\\n        for(int i = 0; i < nums1.size(); i++) {\\n            pq.push({nums2[i] , nums1[i]});\\n        }\\n        \\n        long long int ans = 0;\\n        priority_queue<int , vector<int> , greater<int>>lowSum;\\n        long long sum = 0;\\n        int minValue = 0;\\n        \\n        for(int i = 0; i < k; i++) {\\n            auto[x ,y] = pq.top();\\n            pq.pop();\\n            lowSum.push(y);\\n            sum += y;\\n            minValue = x;\\n        }\\n        \\n        ans = sum * minValue;\\n        \\n        for(int i = k; i < nums1.size(); i++) {\\n            auto[x ,y] = pq.top();\\n            pq.pop();\\n            \\n            sum -= lowSum.top();\\n            lowSum.pop();\\n            \\n            lowSum.push(y);\\n            sum += y;\\n            minValue = x;\\n            \\n            ans = max(ans, sum * minValue);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922362,
                "title": "solution-using-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```javascript []\\nvar maxScore = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue()\\n    const zipped = nums1.map((num1, i) => [num1, nums2[i]]);\\n    zipped.sort((a, b) => b[1] - a[1])\\n\\n    let result = 0, sum = 0;\\n\\n    for(const [num, min] of zipped) {\\n        minHeap.enqueue(num);\\n        sum += num;\\n\\n        if (minHeap.size() == k) {\\n            result = Math.max(result, sum * min);\\n            sum -= minHeap.dequeue().element\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\n```python []\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        zipped = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\\n        sum, result = 0, 0\\n        min_heap = []\\n\\n        for elem, min in zipped:\\n            sum += elem\\n            heapq.heappush(min_heap, elem)\\n\\n            if len(min_heap) == k:\\n                result = max(result, sum * min)\\n                sum -= heapq.heappop(min_heap)\\n\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript []\\nvar maxScore = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue()\\n    const zipped = nums1.map((num1, i) => [num1, nums2[i]]);\\n    zipped.sort((a, b) => b[1] - a[1])\\n\\n    let result = 0, sum = 0;\\n\\n    for(const [num, min] of zipped) {\\n        minHeap.enqueue(num);\\n        sum += num;\\n\\n        if (minHeap.size() == k) {\\n            result = Math.max(result, sum * min);\\n            sum -= minHeap.dequeue().element\\n        }\\n    }\\n\\n    return result;\\n};\\n```\n```python []\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        zipped = sorted(zip(nums1, nums2), key=lambda x: x[1], reverse=True)\\n        sum, result = 0, 0\\n        min_heap = []\\n\\n        for elem, min in zipped:\\n            sum += elem\\n            heapq.heappush(min_heap, elem)\\n\\n            if len(min_heap) == k:\\n                result = max(result, sum * min)\\n                sum -= heapq.heappop(min_heap)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921090,
                "title": "python-commented-line-by-line",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        # make pairs of elements of nums1 and nums2\\n        pairs = [(n1,n2) for n1, n2 in zip(nums1,nums2)] \\n        # sort the pairs in decreasing order on the basis of n2\\n        pairs = sorted(pairs, key=lambda x: x[1], reverse = True)\\n        minheap = []\\n        n1Sum = 0\\n        res = 0\\n        # iterate in pairs\\n        for n1, n2 in pairs:\\n            # we need to find out sum of ele of n1\\n            n1Sum += n1\\n            # and we can take only k elements at a time \\n            # while doing sum\\n            # make a minheap of n1--> we are making min heap because \\n            # we have to return max element and when we will be sliding \\n            # minheap then we can pop the first elem which will be min if ele goes more than\\n            # the size of k \\n            heapq.heappush(minheap,n1)\\n            # if len of minheap is > k then pop the first ele\\n            # and also sub it from n1sum\\n            if len(minheap)>k:\\n                n1Pop = heapq.heappop(minheap)\\n                n1Sum -= n1Pop\\n            # if we hit the size k then do calcultions as stated in the ques\\n            if len(minheap)==k:\\n                # and return the max of all the res\\n                res = max(res,n1Sum*n2)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        # make pairs of elements of nums1 and nums2\\n        pairs = [(n1,n2) for n1, n2 in zip(nums1,nums2)] \\n        # sort the pairs in decreasing order on the basis of n2\\n        pairs = sorted(pairs, key=lambda x: x[1], reverse = True)\\n        minheap = []\\n        n1Sum = 0\\n        res = 0\\n        # iterate in pairs\\n        for n1, n2 in pairs:\\n            # we need to find out sum of ele of n1\\n            n1Sum += n1\\n            # and we can take only k elements at a time \\n            # while doing sum\\n            # make a minheap of n1--> we are making min heap because \\n            # we have to return max element and when we will be sliding \\n            # minheap then we can pop the first elem which will be min if ele goes more than\\n            # the size of k \\n            heapq.heappush(minheap,n1)\\n            # if len of minheap is > k then pop the first ele\\n            # and also sub it from n1sum\\n            if len(minheap)>k:\\n                n1Pop = heapq.heappop(minheap)\\n                n1Sum -= n1Pop\\n            # if we hit the size k then do calcultions as stated in the ques\\n            if len(minheap)==k:\\n                # and return the max of all the res\\n                res = max(res,n1Sum*n2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919575,
                "title": "python-greedy-with-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are to find the maximum result of multiplication of a sum and a min element, it\\'s good to start with a maxinum min element available. While we start with the maxinum min element available, we move towards the smaller maximum min elements, and try different sums, and keep track of the maximum res along the way.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        from heapq import heapify, heappush, heappop\\n\\n        n = len(nums1)\\n        pairs = [(a,b) for a,b in zip(nums1, nums2)]\\n        pairs.sort(key = lambda x: -x[1])\\n        #print(pairs)\\n\\n        top_k = [pair[0] for pair in pairs][:k]\\n        #print(top_k)\\n        heapify(top_k)\\n        top_k_sum = sum(top_k)\\n        res = top_k_sum * pairs[k-1][1]\\n\\n        for i in range(k, n):\\n            # Do not first heappop, then heappush, and finally sum, because it makes the time complexity really bad\\n            top_k_sum += pairs[i][0] - heappop(top_k)\\n            heappush(top_k, pairs[i][0])\\n            res = max(top_k_sum * pairs[i][1], res)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        from heapq import heapify, heappush, heappop\\n\\n        n = len(nums1)\\n        pairs = [(a,b) for a,b in zip(nums1, nums2)]\\n        pairs.sort(key = lambda x: -x[1])\\n        #print(pairs)\\n\\n        top_k = [pair[0] for pair in pairs][:k]\\n        #print(top_k)\\n        heapify(top_k)\\n        top_k_sum = sum(top_k)\\n        res = top_k_sum * pairs[k-1][1]\\n\\n        for i in range(k, n):\\n            # Do not first heappop, then heappush, and finally sum, because it makes the time complexity really bad\\n            top_k_sum += pairs[i][0] - heappop(top_k)\\n            heappush(top_k, pairs[i][0])\\n            res = max(top_k_sum * pairs[i][1], res)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919008,
                "title": "golang-min-heap-solution",
                "content": "# Code\\n```go\\nfunc maxScore(nums1 []int, nums2 []int, k int) int64 {\\n\\tmagic := make([][2]int, len(nums1))\\n\\tfor i := range magic {\\n\\t\\tmagic[i] = [2]int{nums1[i], nums2[i]}\\n\\t}\\n\\tsort.Slice(magic, func(i, j int) bool {\\n\\t\\treturn magic[i][1] > magic[j][1]\\n\\t})\\n\\tminHeap := &Heap{}\\n\\tsummation := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\theap.Push(minHeap, magic[i][0])\\n\\t\\tsummation += magic[i][0]\\n\\t}\\n\\tfactor := magic[k-1][1]\\n\\tms := summation * factor\\n\\tfor i := k; i < len(magic); i++ {\\n\\t\\tsummation += magic[i][0]\\n\\t\\theap.Push(minHeap, magic[i][0])\\n\\t\\tsummation -= heap.Pop(minHeap).(int)\\n\\t\\tcms := magic[i][1] * summation\\n\\t\\tif cms > ms {\\n\\t\\t\\tms = cms\\n\\t\\t}\\n\\t}\\n\\treturn int64(ms)\\n}\\n\\ntype Heap []int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i] < p[j] }\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.(int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\nfunc maxScore(nums1 []int, nums2 []int, k int) int64 {\\n\\tmagic := make([][2]int, len(nums1))\\n\\tfor i := range magic {\\n\\t\\tmagic[i] = [2]int{nums1[i], nums2[i]}\\n\\t}\\n\\tsort.Slice(magic, func(i, j int) bool {\\n\\t\\treturn magic[i][1] > magic[j][1]\\n\\t})\\n\\tminHeap := &Heap{}\\n\\tsummation := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\theap.Push(minHeap, magic[i][0])\\n\\t\\tsummation += magic[i][0]\\n\\t}\\n\\tfactor := magic[k-1][1]\\n\\tms := summation * factor\\n\\tfor i := k; i < len(magic); i++ {\\n\\t\\tsummation += magic[i][0]\\n\\t\\theap.Push(minHeap, magic[i][0])\\n\\t\\tsummation -= heap.Pop(minHeap).(int)\\n\\t\\tcms := magic[i][1] * summation\\n\\t\\tif cms > ms {\\n\\t\\t\\tms = cms\\n\\t\\t}\\n\\t}\\n\\treturn int64(ms)\\n}\\n\\ntype Heap []int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i] < p[j] }\\nfunc (p *Heap) Swap(i, j int)      { (*p)[i], (*p)[j] = (*p)[j], (*p)[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.(int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913841,
                "title": "easy-solution-using-priority-queue",
                "content": "# **Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums1[i],nums2[i]});\\n        }\\n        auto lambda=[&](auto &p1,auto &p2){\\n            return p1.second>p2.second;\\n        };\\n        sort(begin(vec),end(vec),lambda);\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long ksum=0;\\n        for(int i=0;i<=k-1;i++){\\n            ksum+=vec[i].first;\\n            pq.push(vec[i].first);\\n        }\\n        long long result=ksum*vec[k-1].second;\\n        for(int i=k;i<n;i++){\\n            ksum+=vec[i].first-pq.top();\\n            pq.pop();\\n            pq.push(vec[i].first);\\n            result=max(result,ksum*vec[i].second);\\n\\n        }\\n        return result;\\n    }\\n};\\n```\\n# Upvote if u find it usefull\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums1[i],nums2[i]});\\n        }\\n        auto lambda=[&](auto &p1,auto &p2){\\n            return p1.second>p2.second;\\n        };\\n        sort(begin(vec),end(vec),lambda);\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long ksum=0;\\n        for(int i=0;i<=k-1;i++){\\n            ksum+=vec[i].first;\\n            pq.push(vec[i].first);\\n        }\\n        long long result=ksum*vec[k-1].second;\\n        for(int i=k;i<n;i++){\\n            ksum+=vec[i].first-pq.top();\\n            pq.pop();\\n            pq.push(vec[i].first);\\n            result=max(result,ksum*vec[i].second);\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911482,
                "title": "using-heapq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        L=[]\\n        for i in range(len(nums1)):\\n            L.append([nums1[i],nums2[i]])\\n        l=sorted(L,key=lambda x:x[1],reverse=True)\\n        minheap=[]\\n        n1sum=0\\n        res=0\\n        for n1,n2 in l:\\n            n1sum+=n1\\n            heapq.heappush(minheap,n1)\\n\\n            if len(minheap)>k:\\n                n1pop=heapq.heappop(minheap)\\n                n1sum-=n1pop\\n\\n            if len(minheap)==k:\\n                res=max(res,n1sum*n2)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        L=[]\\n        for i in range(len(nums1)):\\n            L.append([nums1[i],nums2[i]])\\n        l=sorted(L,key=lambda x:x[1],reverse=True)\\n        minheap=[]\\n        n1sum=0\\n        res=0\\n        for n1,n2 in l:\\n            n1sum+=n1\\n            heapq.heappush(minheap,n1)\\n\\n            if len(minheap)>k:\\n                n1pop=heapq.heappop(minheap)\\n                n1sum-=n1pop\\n\\n            if len(minheap)==k:\\n                res=max(res,n1sum*n2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900728,
                "title": "java-o-n-solution-beats-75-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nimport java.util.AbstractMap;\\nimport java.util.Arrays;\\nimport java.util.PriorityQueue;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0, sum = 0;\\n\\n        AbstractMap.SimpleEntry<Integer, Integer>[] vocabulary = new AbstractMap.SimpleEntry[nums1.length];\\n        Queue<Integer> queue = new PriorityQueue<>(k + 1);\\n\\n        for (int i = 0; i < nums1.length; i++)\\n            vocabulary[i] = new AbstractMap.SimpleEntry<>(nums2[i], nums1[i]);\\n\\n        Arrays.sort(vocabulary, (a, b) -> Integer.compare(b.getKey(), a.getKey()));\\n        for (AbstractMap.SimpleEntry<Integer, Integer> pair : vocabulary) {\\n\\n            queue.offer(pair.getValue());\\n            sum += pair.getValue();\\n\\n            if (queue.size() > k) sum -= queue.poll();\\n            if (queue.size() == k) ans = Math.max(ans, sum * pair.getKey());\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.AbstractMap;\\nimport java.util.Arrays;\\nimport java.util.PriorityQueue;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0, sum = 0;\\n\\n        AbstractMap.SimpleEntry<Integer, Integer>[] vocabulary = new AbstractMap.SimpleEntry[nums1.length];\\n        Queue<Integer> queue = new PriorityQueue<>(k + 1);\\n\\n        for (int i = 0; i < nums1.length; i++)\\n            vocabulary[i] = new AbstractMap.SimpleEntry<>(nums2[i], nums1[i]);\\n\\n        Arrays.sort(vocabulary, (a, b) -> Integer.compare(b.getKey(), a.getKey()));\\n        for (AbstractMap.SimpleEntry<Integer, Integer> pair : vocabulary) {\\n\\n            queue.offer(pair.getValue());\\n            sum += pair.getValue();\\n\\n            if (queue.size() > k) sum -= queue.poll();\\n            if (queue.size() == k) ans = Math.max(ans, sum * pair.getKey());\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895395,
                "title": "simple-java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair {\\n    public int a,b;\\n    public Pair(int a, int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        /*\\n            Create pairs\\n            Sort the num1 in desending order\\n            use priority queue on nums2, that will change nums1 in decending order \\n            take the min of nums2 pair and other to satisfy K\\n            while choosing others, make sure that it maximize the nums1 sum\\n        */\\n\\n        // 1,3,3,2\\n        // 2,1,3,4\\n\\n        // create pairs\\n        Pair[] p = new Pair[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Pair pair = new Pair(nums1[i], nums2[i]);\\n            p[i] = pair;\\n        }\\n\\n        // 1,2,3,3\\n        // 2,4,1,3\\n\\n        // sort the nums1 in decending order \\n        Arrays.sort(p, (p1, p2) -> -Integer.compare(p1.a, p2.a));\\n\\n        // Use PQ for nums2\\n        PriorityQueue<Pair> q = new PriorityQueue<>((p1, p2) -> Integer.compare(p1.b, p2.b));\\n\\n        // 1 3\\n        // 2 1\\n        // 4 2\\n\\n        // Select K pairs and add it to the queue\\n        long sum = 0;\\n        for(int i=0;i<k;i++){\\n            sum += p[i].a;\\n            q.add(p[i]);\\n        }\\n\\n        /*6 max\\n        6 sum*/\\n\\n        // Get the Max Score\\n        long max = sum * q.peek().b;\\n\\n        /*b a\\n        ----\\n        1 3 - remove\\n        2 1\\n        4 2\\n        3 3\\n\\n        sum - 3 = 6-3 = 3\\n        min = 3\\n        min = 2\\n        sum = 3 + 3 = 6\\n        max = 6, 6 * 2 = 12*/\\n\\n        // Check the remaining pairs apart from 0 to k-1\\n        for(int i=k;i<nums1.length;i++){\\n            \\n            // If any nums2 is more that min b(q.peek)\\n            if(q.peek().b < p[i].b){\\n                sum -= (long)q.remove().a; // Removing lowest num2\\'s a - remove the 1st element from queue as we add a new one\\n                \\n                int min = p[i].b; // Get the next max nums1\\'s b\\n                if(!q.isEmpty())\\n                    min = Math.min(min, q.peek().b); // Getting the next min from queue\\n\\n                // add the current pair to queue\\n                q.add(p[i]);\\n\\n                // update the max score\\n                sum += p[i].a;\\n                max = Math.max(max, sum * min);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair {\\n    public int a,b;\\n    public Pair(int a, int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        /*\\n            Create pairs\\n            Sort the num1 in desending order\\n            use priority queue on nums2, that will change nums1 in decending order \\n            take the min of nums2 pair and other to satisfy K\\n            while choosing others, make sure that it maximize the nums1 sum\\n        */\\n\\n        // 1,3,3,2\\n        // 2,1,3,4\\n\\n        // create pairs\\n        Pair[] p = new Pair[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Pair pair = new Pair(nums1[i], nums2[i]);\\n            p[i] = pair;\\n        }\\n\\n        // 1,2,3,3\\n        // 2,4,1,3\\n\\n        // sort the nums1 in decending order \\n        Arrays.sort(p, (p1, p2) -> -Integer.compare(p1.a, p2.a));\\n\\n        // Use PQ for nums2\\n        PriorityQueue<Pair> q = new PriorityQueue<>((p1, p2) -> Integer.compare(p1.b, p2.b));\\n\\n        // 1 3\\n        // 2 1\\n        // 4 2\\n\\n        // Select K pairs and add it to the queue\\n        long sum = 0;\\n        for(int i=0;i<k;i++){\\n            sum += p[i].a;\\n            q.add(p[i]);\\n        }\\n\\n        /*6 max\\n        6 sum*/\\n\\n        // Get the Max Score\\n        long max = sum * q.peek().b;\\n\\n        /*b a\\n        ----\\n        1 3 - remove\\n        2 1\\n        4 2\\n        3 3\\n\\n        sum - 3 = 6-3 = 3\\n        min = 3\\n        min = 2\\n        sum = 3 + 3 = 6\\n        max = 6, 6 * 2 = 12*/\\n\\n        // Check the remaining pairs apart from 0 to k-1\\n        for(int i=k;i<nums1.length;i++){\\n            \\n            // If any nums2 is more that min b(q.peek)\\n            if(q.peek().b < p[i].b){\\n                sum -= (long)q.remove().a; // Removing lowest num2\\'s a - remove the 1st element from queue as we add a new one\\n                \\n                int min = p[i].b; // Get the next max nums1\\'s b\\n                if(!q.isEmpty())\\n                    min = Math.min(min, q.peek().b); // Getting the next min from queue\\n\\n                // add the current pair to queue\\n                q.add(p[i]);\\n\\n                // update the max score\\n                sum += p[i].a;\\n                max = Math.max(max, sum * min);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894082,
                "title": "min-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)v.push_back({nums2[i],nums1[i]});\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        long long sum=0;\\n        for(int i=0;i<k;i++){\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n        }\\n        long long ans=sum*v[k-1].first;\\n        for(int i=k;i<v.size();i++){\\n            sum-=pq.top();\\n            pq.pop();\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n            ans=max(ans,sum*v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)v.push_back({nums2[i],nums1[i]});\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        long long sum=0;\\n        for(int i=0;i<k;i++){\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n        }\\n        long long ans=sum*v[k-1].first;\\n        for(int i=k;i<v.size();i++){\\n            sum-=pq.top();\\n            pq.pop();\\n            sum+=v[i].second;\\n            pq.push(v[i].second);\\n            ans=max(ans,sum*v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893500,
                "title": "min-heap-solution-explained",
                "content": "# Intuition\\n1st intuition is DP since it\\'s given we need subsequence. But that will take around O(n^4).\\n2nd intuition min heap since we have to get maximum score of k elements. Wherever it\\'s k elements and asked for max/min, think of Heap.\\n\\n# Approach\\nSince we need \\u21D2 min(nums2[i],\\u2026. nums2[k]) * nums1[i] + \\u2026.. + nums1[k] to be maximum, we want both of them to be as high as possible.\\n\\n1. Sort (desc order) both the array on the basis of nums2. Merge both nums1 and nums2 in 2d array of int[n][2], since we don\\u2019t want to mess up the indexing.\\n    \\n    eg. {{4,2,3,1,1}, {7,5,10,9,6}} \\u2014sorting\\u2014> {{3,1,4,1,2},{10,9,7,6,5}}\\n    \\n2. nums2[] = {10,9,7,6,5}. We will traverse and consider ith index as minimum. and multiply it with the sum.\\n    \\n    Here the issue is if k=3. Then,\\n    \\n    for i=0, we would need 3 elements. But if we take i=0, i=1, i=2. Then min(nums2[0],nums2[1],nums2[2]) would be nums2[2] since it\\u2019s sorted in desc order.\\n    \\n    Similarly for i=1, we can choose i=0, i=1, i=2, but min would be nums2[2].\\n    \\n    So we have to start from i=2, i.e. i=k-1. So we can consider nums2[i] as minimum and take previous elements too.\\n    \\n3. Now, focusing on nums1. We want sum of all taken elements to be maximum.\\n    \\n    At i=2, we have 7 as min from nums2 and (nums1[0] + nums1[1] + nums2[2]) as sum. So, res would be 7 * (3+1+4) = 56\\n    \\n    At i=3, we have 6 as min and for sum,\\n    \\n    we must take nums1[3]=1 since we took min of that from nums2.\\n    \\n    Rather than that we have option to choose 2 more from i=0, i=1, i=2. In this I\\u2019ll not choose the one with less nums1[i].\\n    \\n    So, I\\u2019ll choose nums1[0] = 3, nums1[2] = 4.\\n    \\n    sum = 3+4+1\\n    \\n    res would be 6 * (3+4+1) = 48\\n    \\n    At i=4, we have nums2[4]=5 as min and for sum,\\n    \\n    we must take nums1[4] = 2.\\n    \\n    Also  we have to choose 2 more previous index with max nums1. I\\u2019ll choose nums1[0] and nums1[2].\\n    \\n    sum = 2+3+4. so, res = 5 * (2+3+4) = 45\\n    \\n    1. Take maximum result from these, i.e. 56.\\n    2. Since we need the previous maximum values from nums1. We will maintain min heap to get k maximum values of nums1. (Note \\u2192 make sure that pq must contains the current index nums1[index]).\\n\\n# Complexity\\n- Time complexity:\\nO(nLog(n)) for sorting the nums2.\\n\\n- Space complexity:\\nO(k) to maintain min heap.\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] arr = new int[n][2];\\n        for(int i=0; i<n; i++){\\n            arr[i][0] = nums1[i];\\n            arr[i][1] = nums2[i];\\n        }\\n\\n        Arrays.sort(arr, (a,b) -> b[1] - a[1]); // sort in desc order\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min heap\\n\\n        long sum = 0, res = 0;\\n        int i =0;\\n        for(; i<k; i++){\\n            pq.offer(arr[i][0]);\\n            sum += arr[i][0];\\n        }\\n\\n        res = (arr[i-1][1] * sum);\\n\\n        for(; i<n; i++){\\n            int a = pq.poll();\\n            pq.offer(arr[i][0]);\\n            sum = sum + arr[i][0] - a;\\n\\n            res = Math.max(res, arr[i][1] * sum);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] arr = new int[n][2];\\n        for(int i=0; i<n; i++){\\n            arr[i][0] = nums1[i];\\n            arr[i][1] = nums2[i];\\n        }\\n\\n        Arrays.sort(arr, (a,b) -> b[1] - a[1]); // sort in desc order\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min heap\\n\\n        long sum = 0, res = 0;\\n        int i =0;\\n        for(; i<k; i++){\\n            pq.offer(arr[i][0]);\\n            sum += arr[i][0];\\n        }\\n\\n        res = (arr[i-1][1] * sum);\\n\\n        for(; i<n; i++){\\n            int a = pq.poll();\\n            pq.offer(arr[i][0]);\\n            sum = sum + arr[i][0] - a;\\n\\n            res = Math.max(res, arr[i][1] * sum);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888234,
                "title": "c-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    struct {\\n        bool operator()(const pair<int, int> &a, const pair<int, int> &b) {\\n            return a.second>b.second;\\n        }\\n    } myComp;\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int, int>>v;\\n        for(int i=0;i<n;i++) {\\n            v.push_back(make_pair(nums1[i], nums2[i]));\\n        }\\n        sort(v.begin(), v.end(), myComp);\\n\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        long long sum = 0;\\n        for(int i=0;i<k;i++)  {\\n            pq.push(v[i].first);\\n            sum +=v[i].first;\\n        }\\n        long long res = sum*(long long)v[k-1].second;\\n        for(int i=k;i<n;i++) {\\n            int top = pq.top();\\n            pq.pop();\\n            pq.push(v[i].first);\\n            sum = sum-top+v[i].first;\\n            res = max(res, sum*(long long)v[i].second);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct {\\n        bool operator()(const pair<int, int> &a, const pair<int, int> &b) {\\n            return a.second>b.second;\\n        }\\n    } myComp;\\n\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<pair<int, int>>v;\\n        for(int i=0;i<n;i++) {\\n            v.push_back(make_pair(nums1[i], nums2[i]));\\n        }\\n        sort(v.begin(), v.end(), myComp);\\n\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        long long sum = 0;\\n        for(int i=0;i<k;i++)  {\\n            pq.push(v[i].first);\\n            sum +=v[i].first;\\n        }\\n        long long res = sum*(long long)v[k-1].second;\\n        for(int i=k;i<n;i++) {\\n            int top = pq.top();\\n            pq.pop();\\n            pq.push(v[i].first);\\n            sum = sum-top+v[i].first;\\n            res = max(res, sum*(long long)v[i].second);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887325,
                "title": "java-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCombine nums1 array and nums2 array to (num1, num2) tuple array, sort by num2.\\n\\nAssume the left most position of the solution is x, find x from right to left. When exch possible x is checked, find the top (k-1) num1s in its right side as the best potential for this x.\\n\\nUse priority queue to dynamically record the top (k-1) positions other than x.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private class MyPair implements Comparable<MyPair> {\\n        int num1;\\n        int num2;\\n        public MyPair(int num1, int num2) {\\n            this.num1 = num1;\\n            this.num2 = num2;\\n        }\\n        \\n        @Override\\n        public int compareTo(MyPair pair) {\\n            return (this.num2 > pair.num2) ? 1 : -1;\\n        }\\n    }\\n\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        MyPair[] pairs = new MyPair[nums1.length];\\n        for (int i=0; i<nums1.length; ++i) {\\n            pairs[i] = new MyPair(nums1[i], nums2[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        long sum_top_k_minus_1_num1s = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); \\n        for (int i=pairs.length-1; i>pairs.length-k; --i) {\\n            pq.add(pairs[i].num1);\\n            sum_top_k_minus_1_num1s += pairs[i].num1;\\n        }\\n\\n        long res = 0;\\n        for (int i=pairs.length-k; i>=0; --i) {\\n            long optimal_k_num1s = sum_top_k_minus_1_num1s + pairs[i].num1;\\n            res = Math.max(res, optimal_k_num1s * pairs[i].num2);\\n            if (pq.size() > 0 && pairs[i].num1 > pq.peek()) {\\n                int toBeRemoved = pq.poll();\\n                pq.add(pairs[i].num1);\\n                sum_top_k_minus_1_num1s = sum_top_k_minus_1_num1s - toBeRemoved + pairs[i].num1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private class MyPair implements Comparable<MyPair> {\\n        int num1;\\n        int num2;\\n        public MyPair(int num1, int num2) {\\n            this.num1 = num1;\\n            this.num2 = num2;\\n        }\\n        \\n        @Override\\n        public int compareTo(MyPair pair) {\\n            return (this.num2 > pair.num2) ? 1 : -1;\\n        }\\n    }\\n\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        MyPair[] pairs = new MyPair[nums1.length];\\n        for (int i=0; i<nums1.length; ++i) {\\n            pairs[i] = new MyPair(nums1[i], nums2[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        long sum_top_k_minus_1_num1s = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); \\n        for (int i=pairs.length-1; i>pairs.length-k; --i) {\\n            pq.add(pairs[i].num1);\\n            sum_top_k_minus_1_num1s += pairs[i].num1;\\n        }\\n\\n        long res = 0;\\n        for (int i=pairs.length-k; i>=0; --i) {\\n            long optimal_k_num1s = sum_top_k_minus_1_num1s + pairs[i].num1;\\n            res = Math.max(res, optimal_k_num1s * pairs[i].num2);\\n            if (pq.size() > 0 && pairs[i].num1 > pq.peek()) {\\n                int toBeRemoved = pq.poll();\\n                pq.add(pairs[i].num1);\\n                sum_top_k_minus_1_num1s = sum_top_k_minus_1_num1s - toBeRemoved + pairs[i].num1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873451,
                "title": "easy-to-understand-runtime-beats-97-time-complexity-o-n-log-n",
                "content": "# Intuition\\n**Pairing:** Create pairs of elements from nums1 and nums2 to associate each element from nums1 with its corresponding nums2 value.\\n\\n**Sorting:** Sort the pairs in descending order based on their nums2 values to prioritize larger nums2 values in subsequences.\\n\\n**Min Heap:** Use a min heap to select elements from nums1 while maintaining their sum (n1Sum). Keep the heap size at most k to find subsequences of length k.\\n\\n**Calculate Score:** Traverse the sorted pairs, adding nums1 values to n1Sum and inserting them into the min heap. If the heap size exceeds k, remove the smallest element. When the heap size reaches k, calculate the score by multiplying n1Sum with the corresponding nums2 value. Update the res variable with the maximum score found.\\n\\n**Return Result:** After processing all pairs, res contains the maximum score for any subsequence of length k, which is returned as the result\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> pairs;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            pairs.emplace_back(nums1[i], nums2[i]);\\n        }\\n        \\nsort(pairs.begin(), pairs.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) {\\n            return p1.second > p2.second;\\n        });\\n        \\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        long long n1Sum = 0;\\n        long long res = 0;\\n\\n        for (const auto& pair : pairs) {\\n            n1Sum += pair.first;\\n            minHeap.push(pair.first);\\n\\n            if (minHeap.size() > k) {\\n                int n1pop = minHeap.top();\\n                minHeap.pop();\\n                n1Sum -= n1pop;\\n            }\\n\\n            if (minHeap.size() == k) {\\n                res = std::max(res, n1Sum * pair.second);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> pairs;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            pairs.emplace_back(nums1[i], nums2[i]);\\n        }\\n        \\nsort(pairs.begin(), pairs.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) {\\n            return p1.second > p2.second;\\n        });\\n        \\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        long long n1Sum = 0;\\n        long long res = 0;\\n\\n        for (const auto& pair : pairs) {\\n            n1Sum += pair.first;\\n            minHeap.push(pair.first);\\n\\n            if (minHeap.size() > k) {\\n                int n1pop = minHeap.top();\\n                minHeap.pop();\\n                n1Sum -= n1pop;\\n            }\\n\\n            if (minHeap.size() == k) {\\n                res = std::max(res, n1Sum * pair.second);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844224,
                "title": "java-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int pairs [][] = new int[nums1.length][2];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n\\n        for(int i = 0; i < nums1.length; i++){\\n            pairs[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(pairs, (a,b) -> b[1] - a[1]);\\n        long total = 0;\\n        long result = 0;\\n        for(int pair[] : pairs){\\n            pq.add(pair[0]);\\n            total = total + pair[0];\\n\\n            if(pq.size() > k){\\n                total = total - pq.poll();\\n            }\\n\\n            if(pq.size() == k){\\n                result = Math.max(result, total * pair[1]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int pairs [][] = new int[nums1.length][2];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n\\n        for(int i = 0; i < nums1.length; i++){\\n            pairs[i] = new int[]{nums1[i], nums2[i]};\\n        }\\n        Arrays.sort(pairs, (a,b) -> b[1] - a[1]);\\n        long total = 0;\\n        long result = 0;\\n        for(int pair[] : pairs){\\n            pq.add(pair[0]);\\n            total = total + pair[0];\\n\\n            if(pq.size() > k){\\n                total = total - pq.poll();\\n            }\\n\\n            if(pq.size() == k){\\n                result = Math.max(result, total * pair[1]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838466,
                "title": "i-am-share-my-solution",
                "content": "# Intuition\\n\\nI was stuck on this problem for a long time. It seems like the intuition for this problem was hard to come by. Where I got stuck was how do we even go about finding out the subsequence. A few things that made the problem simpler. \\n\\n1. Forget about the subsequence, ordering really doesn\\'t matter. You can pick any k elements and there would still be a possible order.\\n\\nThis simplifies the problem a lot. Because now we just need to ensure that we can find any k elements give us a solution or not, without worrying about the ordering. \\n\\nOkay, so now we know that we don\\'t have to worry about ordering. Then the second problem I was having difficulty with was how to calculate minimum of all subsequences. Instead, we need to see that at max, we\\'re going to have n-k-1 minimum elements. So just consider each element as a minimum and see whats the maximum we can form here. I arrived at this part, but was having a very hard time doing this while also ensuring the ordering. If you get rid of ordering, this becomes a lot simpler. \\n\\n\\n\\n# Approach\\n1. Sort the array by the second element.\\n2. Add the elements from the first array to a priority queue of size k.\\n3. For all the elements from k to n, just add them to the PQ and check if they give us a solution or not.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(n*3)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] nums = new int[n][2];\\n        for (int i = 0; i<n; i++)\\n            nums[i] = new int[]{nums1[i], nums2[i]};\\n\\n        Arrays.sort(nums, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long sum = 0L;\\n\\n        for (int i = 0; i < k-1; i++) {\\n            pq.offer(nums[i][0]);\\n            sum = sum + nums[i][0];\\n        }\\n\\n        long ans = Long.MIN_VALUE;\\n        \\n        for (int i = k-1; i < n; i++) {\\n            pq.offer(nums[i][0]);\\n            sum = sum + nums[i][0];\\n            ans = Math.max(sum*nums[i][1], ans);\\n            \\n            if (pq.size() == k) {\\n                sum = sum - pq.poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int[][] nums = new int[n][2];\\n        for (int i = 0; i<n; i++)\\n            nums[i] = new int[]{nums1[i], nums2[i]};\\n\\n        Arrays.sort(nums, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long sum = 0L;\\n\\n        for (int i = 0; i < k-1; i++) {\\n            pq.offer(nums[i][0]);\\n            sum = sum + nums[i][0];\\n        }\\n\\n        long ans = Long.MIN_VALUE;\\n        \\n        for (int i = k-1; i < n; i++) {\\n            pq.offer(nums[i][0]);\\n            sum = sum + nums[i][0];\\n            ans = Math.max(sum*nums[i][1], ans);\\n            \\n            if (pq.size() == k) {\\n                sum = sum - pq.poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838217,
                "title": "clean-c-priority-queue-greedy-beats-99-65-easy-to-understand",
                "content": "- Thanks to [NeetCode IO](https://www.youtube.com/watch?v=ax1DKi5lJwk) for solution.\\n- This is Greedy Approach with Sorting and Priority Queue\\n# Complexity\\n- Time complexity: O(nlogn) + O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n\\n        vector<pair<int,int>> greedyPair;\\n        for(int i=0; i<n; i++)\\n            greedyPair.push_back({nums2[i], nums1[i]});\\n\\n        sort(greedyPair.begin(), greedyPair.end(), greater<pair<int,int>>());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        long long n1Sum = 0;\\n        long long res = 0;\\n        for(int i=0; i<n; i++){\\n            n1Sum += greedyPair[i].second;\\n            pq.push(greedyPair[i].second);\\n\\n            if(pq.size() > k){\\n                int topEle = pq.top();\\n                pq.pop();\\n                n1Sum -= topEle;\\n            }\\n\\n            if(pq.size() == k){\\n                res = max(res, n1Sum*greedyPair[i].first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n\\n        vector<pair<int,int>> greedyPair;\\n        for(int i=0; i<n; i++)\\n            greedyPair.push_back({nums2[i], nums1[i]});\\n\\n        sort(greedyPair.begin(), greedyPair.end(), greater<pair<int,int>>());\\n\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        long long n1Sum = 0;\\n        long long res = 0;\\n        for(int i=0; i<n; i++){\\n            n1Sum += greedyPair[i].second;\\n            pq.push(greedyPair[i].second);\\n\\n            if(pq.size() > k){\\n                int topEle = pq.top();\\n                pq.pop();\\n                n1Sum -= topEle;\\n            }\\n\\n            if(pq.size() == k){\\n                res = max(res, n1Sum*greedyPair[i].first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826196,
                "title": "c-greedy-approach-beginner-friendly",
                "content": "**Intuition:**\\nwe will use a greedy approach. We will maintain two priority queues: one to keep track of the maximum elements from nums1, and another to keep track of the minimum elements from nums2. We will iteratively pick the maximum element from nums1, multiply it with the minimum element from nums2, and update the result accordingly.\\n\\n**Approach:**\\n1. Initialize variables `result` and `sum` to 0. The `result` will store the maximum possible score, and the `sum` will keep track of the sum of the selected elements from nums1 so far.\\n2. Create two priority queues:\\n   - `maxSum`: A max-heap to keep track of the maximum elements from nums1 along with their indices.\\n   - `minmulti`: A min-heap to keep track of the minimum elements from nums2 along with the indices of the corresponding elements from nums1.\\n3. Iterate through nums1 and add each element along with its index to `maxSum`.\\n4. While `maxSum` is not empty, do the following:\\n   - Pop the maximum element from `maxSum` and update the `sum` by adding the popped element\\'s value.\\n   - Push the corresponding element from nums2 along with the index of the popped element from `maxSum` to `minmulti`.\\n   - If `minmulti` has reached size k, do the following:\\n     - Pop the minimum element from `minmulti` and update the `result` by taking the maximum between its current value and the product of the popped element\\'s value and `sum`.\\n     - Subtract the popped element\\'s value from `sum` to maintain the sum of k elements in `sum`.\\n5. Return the `result` as the maximum possible score.\\n\\n**Complexity:**\\n- Time complexity: The main loop iterates through the elements in nums1, and at most k elements are added to the priority queues. Hence, the time complexity is O(n log k), where n is the size of nums1.\\n- Space complexity: The space complexity is O(k) due to the priority queues.\\n\\n**Code:**\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long result = 0, sum = 0 ;\\n\\n        priority_queue<pair<int,int>> maxSum;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minmulti;\\n\\n        for(int i = 0 ; i < nums1.size() ; ++i){\\n            maxSum.push({nums1[i],i});\\n        }\\n\\n        while(!maxSum.empty()){\\n\\n            auto current1 =  maxSum.top();\\n            maxSum.pop();\\n            sum +=  current1.first;\\n            minmulti.push({nums2[current1.second], current1.second});\\n\\n            if(minmulti.size() == k){\\n                auto current2 = minmulti.top();\\n                minmulti.pop();\\n                result = max(result, current2.first * sum);\\n                sum -= nums1[current2.second]; \\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long result = 0, sum = 0 ;\\n\\n        priority_queue<pair<int,int>> maxSum;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minmulti;\\n\\n        for(int i = 0 ; i < nums1.size() ; ++i){\\n            maxSum.push({nums1[i],i});\\n        }\\n\\n        while(!maxSum.empty()){\\n\\n            auto current1 =  maxSum.top();\\n            maxSum.pop();\\n            sum +=  current1.first;\\n            minmulti.push({nums2[current1.second], current1.second});\\n\\n            if(minmulti.size() == k){\\n                auto current2 = minmulti.top();\\n                minmulti.pop();\\n                result = max(result, current2.first * sum);\\n                sum -= nums1[current2.second]; \\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1903561,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903999,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1769711,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903656,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903539,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903977,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903797,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903668,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1904282,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1853305,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903561,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903999,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1769711,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903656,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903539,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903977,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903797,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903668,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1904282,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1853305,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "Don\\'t know that Medium is an appropriate difficulty for this problem. It\\'s very similar (hell, the algorithm is essentially the same) to [Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/), which is a Hard problem.\\n"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "Hard problem for me as well."
                    },
                    {
                        "username": "wareag1e",
                        "content": "I agree. This is a hard one. Maybe, this is a difficulty inflation. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Diamantis",
                        "content": "It would probably be fair to label this problem as hard.\\nReally interesting problem nonetheless."
                    },
                    {
                        "username": "rick_014",
                        "content": "This is an interesting problem. Most of the crowd circle around dynamic programming and backtracking but actually priority_queue is the game changer."
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@ui20ec21](/ui20ec21)  yes but constraints will give tle \\n"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is there  a way to solve this using dp ? "
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who were thinking about DP, that\\'s a dead alley ... try something else.\\n\\nLet say I already have all the answers to the subproblem I wanted, using the typical take it or leave it DP, you need these subproblem solutions to solve the problem for size A\\n\\nIf I take it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k elements in a size A-1 problem.\\n\\nNow if I want to want to solve the problem for size A+1, then I need to know how to pick k-1 element in a size A problem as well.\\n\\nTo solve a problem for size A picking k - 1 elements, I need these subproblem solutions.\\n\\nIf I take it, then I need to know how to pick the remaining k-2 elements in a size A-1 problem.\\nIf I leave it, then I need to know how to pick the remaining k-1 elements in a size A-1 problem.\\n\\nInductively, I need all the solution for all subproblems for all sizes picking any number > 1. $$ O(nk) $$ is obviously going to TLE, so DP is not the way to go.\\n"
                    },
                    {
                        "username": "alternative_way",
                        "content": "Yes, the DP really will not pass the time, moreover, the algorithm you cited is incorrect. This can be shown by a counter-example: Suppose you gave the following input a = [1,3,3], b = [2,1,3] and k = 2, then the optimal answer is achieved by choosing indices 0 and 2, and equals (1+3)*2=8, while the algorithm you have given will return indices 1 and 2 with the result (3+3)*1=6, which is incorrect. And all because the optimal solution is not reached from the optimal solution on the prefix. It may be possible to come up with another DP, but I couldn\\'t."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Yesterday I tried some priority queue problems, and hit this one!!!\n1. Sort the pairs `p[i]={nums2[i],nums1[i]};`  based on the first element in ascending order. It then iterates over the sorted pairs, calculating the sum of selected elements from nums1 and updating the maximum score accordingly. \n2. The priority queue is used to keep track of the k smallest elements encountered so far, ensuring that the sum only includes the k largest elements."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Prajju22](/Prajju22) 40*1=40"
                    },
                    {
                        "username": "Prajju22",
                        "content": "what if the input is \\nnum1= [40,8] and num2 = [1,3] and k=1? \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Andrii Nyvchyk](/anyvchyk)\nAfter sorting nums2(if ascending), it is very sure that\nnums2[i0]=min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])\nBut if nums1 in instead of nums2 is sorted, what it is min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])=?"
                    },
                    {
                        "username": "ryusei2000",
                        "content": "[@anyvchyk](/anyvchyk) I believe it\\'s because the multiplier generally carries more weight than the summed value so having a larger multiplier is more impactful than having a marginally greater initial sum pre-multiplying."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Could you explain please why do we sort pairs based on nums2? My logic was that we need to collect as powerful sum as possible based on nums1."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/maximum-subsequence-score/solutions/3557152/c-solution-using-sorting-and-priority-queue-with-explanation/"
                    },
                    {
                        "username": "layyy",
                        "content": "Even thinking of applying priority queue in this question is a win"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "True story :))"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Two and a half hours later, I gave up. If it appears in the contest, I\\'m screwed!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "At first I thought of one logic that is I saw that the sorting order and according to that index getting value from other array nums2 seems like I was close 20 passed tc\\n"
                    },
                    {
                        "username": "vnk01",
                        "content": "Guys, that subsequence thing is a red herring. This's not a DP problem. Don't fall for it! Luckily I know this is heap week!"
                    },
                    {
                        "username": "Avii_7739",
                        "content": "Problem is intresting\\n1.Create an  array using pairs of  nums1,nums2 and sort it based on value of nums2.\\n2.Then we need to find the sum of subsequence of k elements of nums1 and multiply it with subsequent minimum value of nums2 \\n    i)use a priority queue to store nums1 until k elements and then find the value of  sum*min \\n         (nums2).\\n     ii)store the value to check with value of next iterations for max.\\n    iii) pop out the element from priority queue to min element of subsequenece ,so that we can \\n             check other subsequenecs.\\n  "
                    },
                    {
                        "username": "Eckhart01",
                        "content": "think I figured it out, thanks for your tips!"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Is a Dynamic Programming Solution Possible here ?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i think if we will use dp then we will need and dp[10^5][10^5] . that is O(n2)."
                    },
                    {
                        "username": "GTai",
                        "content": "With additional array? Probably yes"
                    }
                ]
            },
            {
                "id": 1903552,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1768111,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1904573,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1904288,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1904215,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1904105,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1903959,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1903779,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1903681,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1768223,
                "content": [
                    {
                        "username": "blank_tc",
                        "content": "can someone explain to me why sort will not break the ordering of subsequence?"
                    },
                    {
                        "username": "user0780E",
                        "content": "The important thing is you maintain the synchronization of elements of nums1 and nums2 by maintaining a pair {nums1[i],nums2[i]}."
                    },
                    {
                        "username": "wareag1e",
                        "content": "It does break the ordering. But, this problem has nothing to do with the ordering, although it mentions `subsequence`. You can think that it just picks `k` numbers."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why when I using backtracking, I get TLE? :("
                    },
                    {
                        "username": "rick_014",
                        "content": "Bro backtracking will have a time complexity of O(2^n), where n has a max value of 1e5. So it will definitely lead you to TLE."
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "tnx everyone, I didn\\'t notice any restrictions :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "\\u041E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0435 \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C \\u0437\\u0434\\u0435\\u0441\\u044C \\u043F\\u0440\\u0438\\u044F\\u0442\\u0435\\u043B\\u044C, coz \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u044F \\u0431\\u044B\\u043B\\u0438 10^5, \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u043B\\u044E\\u0431\\u0443\\u044E \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0443 \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 10^8 ,\\n\\u043E\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442, \\u0447\\u0442\\u043E n^2 \\u0431\\u0443\\u0434\\u0435\\u0442 :(10^5)(10^5) =10^10 (\\u0447\\u0442\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0440\\u0438\\u043D\\u044F\\u0442\\u043E\\n\\u0438 \\u0432\\u0430\\u0448\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E\\u0433\\u043E \\u043E\\u0442\\u0441\\u043B\\u0435\\u0436\\u0438\\u0432\\u0430\\u043D\\u0438\\u044F (TC) \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u043A\\u0441\\u043F\\u043E\\u043D\\u0435\\u043D\\u0446\\u0438\\u0430\\u043B\\u044C\\u043D\\u044B\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C e^n \\u0438\\u043B\\u0438 \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043E\\u043D\\u043E \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u044B \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0434\\u0430\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 nlogn \\u0437\\u0434\\u0435\\u0441\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 <=nlogn \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0442\\u044C coz nlogn=10^5(log10^5)<=10^8\\n"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "bro looking constraints it was obvious it wiil give tle"
                    },
                    {
                        "username": "nikhil909",
                        "content": "coz constraints were 10^5  ,you have to solve any problem within 10^8 ,\nmeans n^2 would be :(10^5)*(10^5) =10^10 (which will not be accepted  \nand your backtracking solution(TC) would be exponential means e^n or greater ,thats why it will not work ,so you have to give nlogn solution here only solution <=nlogn will work coz nlogn=10^5*(log10^5)<=10^8"
                    },
                    {
                        "username": "Euclid1234",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    using pii = pair<long long, long long>;\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pii> num_pair;\\n        \\n        int sz = nums1.size();\\n        for (int i = 0; i < sz; i++){\\n            num_pair.push_back({nums1[i], nums2[i]});\\n        }\\n\\n        sort(num_pair.begin(), num_pair.end(), [](const pii &p1, const pii &p2){\\n            return p1.second >= p2.second;\\n        });\\n\\n        priority_queue<long long, vector<long long>, greater<long long>> k_largest;\\n        long long k_sum = 0;\\n        for(int i = 0; i < k; i++){\\n            k_largest.push(num_pair[i].first);\\n            k_sum += num_pair[i].first;\\n        }\\n\\n        long long max_score = num_pair[k - 1].second * k_sum;\\n        for (int i = k; i < num_pair.size(); i++){\\n            k_sum -= k_largest.top();\\n            k_largest.pop();\\n            k_sum += num_pair[i].first;\\n            k_largest.push(num_pair[i].first);\\n\\n            max_score = max(max_score, num_pair[i].second * k_sum);\\n        }\\n\\n        return max_score;\\n    }\\n}; \\n\\n```\\nhi everyone! It took me two hours trying to find solution to this problem before I gave up. I then went to the Editorial and had a look at the solution to get the idea and then implemented it myself. However, I kept getting the \"AddressSanitizer: heap-buffer-overflow\" error. As far as I know, this error may occur when I access unallowed memory, but I have checked my code and cannot find anywhere that I have done so (e.g. access index over the limit of a vector). I have attached my code above, can anyone tell me where I have done wrong?"
                    },
                    {
                        "username": "EbenChen",
                        "content": "Hello, I come up with the same idea! but slightly different, which causes an error in one of the cases. In the last for loop, I added a condition:\n\n```cpp\nif(num_pair[i].first> k_largest){\n    if((k_sum-k_largest.top()+num_pair[i].first)*num_pair[i].second>max_score){\n        k_sum -= k_largest.top()+num_pair[i].first;\n        max_score = max(max_score, num_pair[i].second * k_sum);\n        k_largest.pop();\n        k_largest.push(num_pair[i].first);\n    }\n}\n```\nWhat can the problem be?\n  "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "damn, im usually good with heap ... but this one slapped me around "
                    },
                    {
                        "username": "paliya64",
                        "content": "I still feel its a DP question!"
                    },
                    {
                        "username": "Tirbal",
                        "content": "This problem requires a complex usage of an unusual structure (PriorityQueue), that is Hard material for me."
                    },
                    {
                        "username": "rezanatha",
                        "content": "First thing that comes to mind is dynamic programming, but I can\\'t wrap up even the recurrence relation. Is DP even possible to solve this? I always thought every greedy solution has a valid DP solution."
                    },
                    {
                        "username": "saujanya_30",
                        "content": "I was able to solve this questions using recursion but wasn\\'t able to apply DP on my code\\nMy code:\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& a1, vector<int>& a2, long long sum, long long mn, int k){\\n        if(i==a1.size()){\\n            if(k==0){\\n                return sum * mn;\\n            }\\n            else return -1e9;\\n        }\\n        // pick\\n        long long pick = 0;\\n        if(k>0){\\n            pick = f(i+1, a1, a2, sum + a1[i], min(mn, a2[i]*1LL), k-1);\\n        }\\n        // not pick\\n        long long npick = f(i+1, a1, a2, sum, mn, k);\\n\\n        return max(pick, npick);\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long sum = 0, mn = INT_MAX;\\n        return f(0, nums1, nums2, sum, mn, k);\\n    }\\n};"
                    },
                    {
                        "username": "lukog468",
                        "content": "Hi there,\\nI\\'m new to this kind of problem. Could any one explain how to calculate subsequence and about DP?"
                    },
                    {
                        "username": "user8228j",
                        "content": "Definitely a Medium-Hard problem. the Time Complexity you are going for is nlogn, keep that in mind, so dont use built in stuff to make it O(n^2) by accident, like sum() in a for loop. (like I ended up doing...)"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    }
                ]
            },
            {
                "id": 1903902,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1767975,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 2014466,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1993460,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1984794,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1905067,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1904515,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1904506,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1904478,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1904337,
                "content": [
                    {
                        "username": "user5255Gn",
                        "content": "Horrible description . No where it is written that any elements can be chosen with breaking consequences. Everywhere you have written 0...k-1. Just wasted my time implementing a sliding window solution."
                    },
                    {
                        "username": "yash121001",
                        "content": "Same i almost applied the sliding window + priority_queue and then read that we can breaking consequences."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@prajyotgurav](/prajyotgurav) still could have been better description"
                    },
                    {
                        "username": "prajyotgurav",
                        "content": "\\'subsequence\\' is clearly mentioned "
                    },
                    {
                        "username": "TEMP_USER01",
                        "content": "I can comment before the contest gets over :)"
                    },
                    {
                        "username": "nikhil909",
                        "content": "Teach me master\\n"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "so who cares? \\uD83E\\uDD23"
                    },
                    {
                        "username": "krashkodes",
                        "content": "What black magic is this?"
                    },
                    {
                        "username": "tanveer__",
                        "content": "\" for a, b in sorted(list(zip(A, B)), key=lambda ab: -ab[1]): \" Can someone please explain this line.\\nand show the output of this example, nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3"
                    },
                    {
                        "username": "jaggz01",
                        "content": "This is definitely a hard one. The Hint didn\\'t help a lot. Had to look at Editorial for understanding."
                    },
                    {
                        "username": "user9464C",
                        "content": "For those who are confused why only elements on left for chosen minimum is being treated as set for nums1\\nEven after reading editorial I was not able to understand why to pick values from nums1 only on the left of the element chosen as Min in nums2. Then finally it came upon me.\\n\\nIn nums2 say the array is 3 1 4 2 7 6 and I chose 3 to be minimum. Since I am fixing 3 to be minimum I still need to chose remaining k-1 elements. But here\\'s the catch while chosing I can only chose elements larger than 3 because I have set \"3\" as minimum of K elements. And corresponding to which I have to pick my elements from nums1.\\n\\nNow for optimisation as other comments and editorial mention we sort the nums2 array. so after sorting the above array would become 7 6 4 3 2 1. So when I reach 3 on nums2 my possible values for k-1 would be on left as they are bigger. Hence correspondigly whatever element I fix in nums2 my domain for nums1 would be on its left."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im using brute force and failure at testcase 23, my result is 409642464643 while testcase is 454087096140, does somebody give me a tip to validate result correct or failure ?"
                    },
                    {
                        "username": "jwonz",
                        "content": "\"A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\"\\n\\nYou mean, subset?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Tough problem"
                    },
                    {
                        "username": "can-keklik",
                        "content": "Leetcode should create an ML challenge called \"Fix the question difficulties\"..."
                    },
                    {
                        "username": "mahade31",
                        "content": "27 / 28 testcases passed"
                    }
                ]
            },
            {
                "id": 1904257,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1904210,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1904207,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1904034,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1904031,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1903823,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1903626,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1903624,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1903568,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            },
            {
                "id": 1871839,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "The fact I was able to at least figure out it was on heaps gives me some comfort at least ;("
                    },
                    {
                        "username": "feng3245",
                        "content": "Am I missing something here?\n\n\n```\nimport heapq\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        combinedNums = sorted([(n2,n1) for n1, n2 in zip(nums1, nums2)], reverse = True)\n        remaining = combinedNums[k:]\n        currentNums = combinedNums[:k]\n        currentSum = long(sum([n1 for n2, n1 in currentNums]))\n        currentTotalSum = long(currentSum * currentNums[-1][0])\n        currentNums = [n1 for n2, n1 in currentNums]\n        heapq.heapify(currentNums)\n        for minimum, num in remaining:\n            if ((currentSum + num - currentNums[0]) * minimum) > currentTotalSum:\n                currentSum = (currentSum + num - currentNums[0])\n                currentTotalSum = currentSum * minimum\n                heapq.heappop(currentNums)\n                heapq.heappush(currentNums, num)\n        return currentTotalSum\n```\nThis has issue with test case 25. Is this something to do with number precision? "
                    },
                    {
                        "username": "feng3245",
                        "content": "Cross referenced a solution... looks like this was being too greedy here where a number may not currently contribute to a higher total but could later and would of been thrown out here"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any One tell me why it is giving me a  wrong answer when i am applying a memoization. Recursive code is working fine it is giving me a correct answer on recursion.\n `class Solution {\n    public long fun(int ind, int k, int [] nums1, int [] nums2, ArrayList<Integer> point, \n    ArrayList<Integer> l2, long [] dp){\n        if(ind  == nums1.length ){\n            if(k > 0) return 0;\n            long sum=0;\n            for(Integer elem: point) sum += elem;\n            long min = Integer.MAX_VALUE;\n            for(Integer elem: l2) min = Math.min(min, elem);\n            return min*sum; \n        }\n        // if(dp[ind] !=  -1 ) return dp[ind];\n        long collect = Integer.MIN_VALUE;\n        long notcollect = fun(ind+1, k, nums1, nums2, point, l2, dp);\n        if(k>0){\n            point.add(nums1[ind]);\n            l2.add(nums2[ind]);\n            collect = fun(ind+1, k-1, nums1, nums2, point, l2, dp);\n            point.remove(point.size()-1);\n            l2.remove(l2.size()-1);\n        }\n         return dp[ind] = Math.max(collect, notcollect);\n    }\n    public long maxScore(int[] nums1, int[] nums2, int k) {\n        ArrayList<Integer> point = new ArrayList<>();\n        ArrayList<Integer> l2 = new ArrayList<>();\n        long [] dp = new long[nums1.length];\n        for(int i=0; i<dp.length; i++){\n            dp[i] = -1;\n        }\n        return fun(0, k, nums1, nums2, point, l2 , dp);\n        \n    }\n}`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem is cool and interesting, it is similar to another problem: 1383. Maximum Performance of a Team\\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I came around one logic that If I am able to sort the no. of k values from nums1 and nums2 and select the \\n1st-case as let\\'s say we sum from largest to smallest k values from nums1 and take the min of largest to smallest k values from nums2 I would get one possible ans\\nand case2- the vice verce it almost worked for 22-23 testcases but the 2 failed.\\n"
                    },
                    {
                        "username": "shymkek",
                        "content": "Why do we have to use long in java? What is the difference if we used int instead?"
                    },
                    {
                        "username": "Destravna",
                        "content": "I have seen that this is a priority queue problem, but I wrote a backtracking solution, can anyone help me how do I memoize it. Its ok even if the memoized soltuion gives me TLE, I want to learn \\n `\\nclass Solution {\\npublic:\\n    long long res = 0;\\n    void helper(vector<int>& nums1, vector<int>& nums2, int k, int sum, int minm, int index){\\n        if(k == 0){\\n            res = res > minm*sum ? res : minm*sum;\\n        }\\n        if(index >= nums1.size()) return;\\n        sum += nums1[index];\\n        int temp = minm;\\n        minm = min(minm, nums2[index]);\\n        helper(nums1, nums2, k-1, sum, minm, index+1);\\n        sum -= nums1[index];\\n        minm = temp;\\n        helper(nums1, nums2, k, sum, minm, index+1);\\n        return;\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        helper(nums1, nums2, k, 0, INT_MAX, 0);\\n        return res;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "jatt12",
                        "content": "Hi friends, I tried solving this problem using memoization can anyone help me in figure out what is wrong with my solution\\n\\n\\n\\n----------------------------------starts from here ----------------------------------------------------\\n long long utility(vector<int>& nums1, vector<int>& nums2, int k,int i,long long sum,\\n    int j,vector<vector<int>> &dp)\\n    {\\n        if(k==0)\\n        {\\n            return (long long)sum*j;\\n        }\\n        if(i>=nums1.size())\\n        {\\n           \\n            return -1e8;\\n            \\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        long long t =utility(nums1,nums2,k-1,i+1,sum+nums1[i],min(j,nums2[i]),dp);\\n        long long nt =utility(nums1,nums2,k,i+1,sum,j,dp);\\n\\n        return dp[i][k]= max(t,nt);\\n\\n    }\\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>dp(nums1.size(),vector<int>(k+1,-1));\\n        return utility(nums1,nums2,k,0,0,INT_MAX,dp);\\n        \\n    }\\n"
                    },
                    {
                        "username": "_ordinary_being",
                        "content": "For each unique pair of i and k there can be multiple values possible for \\'sum\\' and j variable which you\\'re not memoizing / caching in your dp array. To fix this you will require a 4D dp array which will be very large because sum can have a very large value hence will lead you to memoy limit exceeded. That\\'s why this is not a DP problem."
                    },
                    {
                        "username": "Ayush3941",
                        "content": "hii  i am trying to solve this problem in python 3 i am getting a time limit exceeded in the case\\nnums1=[93,463,179,2488,619,2006,1561,137,53,1765,2304,1459,1768,450,1938,2054,466,331,670,1830,1550,1534,2164,1280,2277,2312,1509,867,2223,1482,2379,1032,359,1746,966,232,67,1203,2474,944,1740,1775,1799,1156,1982,1416,511,1167,1334,2344]\\nnum2=[345,229,976,2086,567,726,1640,2451,1829,77,1631,306,2032,2497,551,2005,2009,1855,1685,729,2498,2204,588,474,693,30,2051,1126,1293,1378,1693,1995,2188,1284,1414,1618,2005,1005,1890,30,895,155,526,682,2454,278,999,1417,1682,995]\\nk=42\\n\\nhow to process this large data using python any tips"
                    },
                    {
                        "username": "momonep",
                        "content": "Why is two pointer not working?"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It's much harder that. It's tricky because we need to deal with subsequence of elements. Two pointers can handle for e.g. 1,2,3 but it can't handle 1,2,5 or 1, 5, length-1.\nAnd actually we even don't really need to keep an initial order."
                    },
                    {
                        "username": "Prashant_Saini",
                        "content": "This code is passing 25/28 cases. What's the error ? Can anyone help.\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\nclass Solution {\npublic:\n    static bool sortbysec(pii &a, pii &b){\n        return b.second > a.second;\n    }\n    long long maxScore(vector<int>& nums1, vector<int>& nums2, int k) {\n    \n        int n = nums1.size();\n\n        vector<pii> v;\n        for(int i=0; i<n; i++) v.push_back({nums1[i],nums2[i]});\n        sort(v.rbegin(), v.rend(), sortbysec);\n\n        priority_queue<int,vector<int>,greater<int>> pq;\n\n        ll sum = 0;\n        for(int i=0; i<k; i++){\n            sum += v[i].first;\n            pq.push(v[i].first);\n        }\n        ll ans = sum * v[k-1].second;\n\n        for(int i=k; i<n; i++){\n            ll tempSum = sum - pq.top() + v[i].first;\n            ll tempAns = tempSum * v[i].second;\n            if(tempAns >= ans){\n                ans = tempAns;\n                sum = tempSum;\n                pq.pop();\n                pq.push(v[i].first);\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "mnciitbhu",
                        "content": "add a second condition in sortbysec \\nreturn b.second > a.second || (b.second == a.second && b.first > a.first);"
                    }
                ]
            }
        ]
    }
]