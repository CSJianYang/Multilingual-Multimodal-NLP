[
    {
        "title": "Delete Columns to Make Sorted",
        "question_content": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\n\n\tFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n\nabc\nbce\ncae\n\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\n&nbsp;\nExample 1:\n\nInput: strs = [\"cba\",\"daf\",\"ghi\"]\nOutput: 1\nExplanation: The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n\nExample 2:\n\nInput: strs = [\"a\",\"b\"]\nOutput: 0\nExplanation: The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\n\nExample 3:\n\nInput: strs = [\"zyx\",\"wvu\",\"tsr\"]\nOutput: 3\nExplanation: The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3.\n\n&nbsp;\nConstraints:\n\n\tn == strs.length\n\t1 <= n <= 100\n\t1 <= strs[i].length <= 1000\n\tstrs[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2989470,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** use a counter and if each char is lexicographically sorted column-wise.\\n\\n**Approach:**\\nFirst lets observe the given test example\\n![image](https://assets.leetcode.com/users/images/507a5d35-64d3-459c-a1bd-da9e768f0ded_1672712407.6624835.png)\\n* We can see that we are going through all the columns for comparision, so this is point 1. \\n* We need to compare the current char with the next char row-wise thus traversing will row-1, so this is point 2.\\n* If we find at any traversal that the order is not maintained, we need to delete the column according to the ques. So increment the counter and use break since the order is broken and we do not want to check that column any more, this is point 3.\\n* That\\'s it, just return the counter value now.\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};\\n```\\n**Time Complexity** => `O(row * col)`\\n**Space Complexity** => `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/025a6e75-7e39-4bdd-8ecd-ea9c6023729a_1672712882.8563874.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989644,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```\\n\\n\\n# Code\\n```\\nclass Solution{\\npublic int minDeletionSize(String[] strs) {\\n    // Return 0 if the input array is null or empty\\n    if (strs == null || strs.length == 0) {\\n        return 0;\\n    }\\n    // Initialize the number of columns to the length of the first string\\n    int numColumns = strs[0].length();\\n    int numColumnsToDelete = 0;\\n    // Iterate through each column of the grid\\n    for (int i = 0; i < numColumns; i++) {\\n        // Initialize the current character to the first character in the column\\n        char currChar = strs[0].charAt(i);\\n        // Iterate through each element in the column\\n        for (int j = 1; j < strs.length; j++) {\\n            // If the current element is lexicographically smaller than the previous element,\\n            // increment the number of columns to delete and break out of the loop\\n            if (strs[j].charAt(i) < currChar) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n            // Otherwise, update the current character to the current element\\n            currChar = strs[j].charAt(i);\\n        }\\n    }\\n    // Return the number of columns to delete\\n    return numColumnsToDelete;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```\n```\\nclass Solution{\\npublic int minDeletionSize(String[] strs) {\\n    // Return 0 if the input array is null or empty\\n    if (strs == null || strs.length == 0) {\\n        return 0;\\n    }\\n    // Initialize the number of columns to the length of the first string\\n    int numColumns = strs[0].length();\\n    int numColumnsToDelete = 0;\\n    // Iterate through each column of the grid\\n    for (int i = 0; i < numColumns; i++) {\\n        // Initialize the current character to the first character in the column\\n        char currChar = strs[0].charAt(i);\\n        // Iterate through each element in the column\\n        for (int j = 1; j < strs.length; j++) {\\n            // If the current element is lexicographically smaller than the previous element,\\n            // increment the number of columns to delete and break out of the loop\\n            if (strs[j].charAt(i) < currChar) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n            // Otherwise, update the current character to the current element\\n            currChar = strs[j].charAt(i);\\n        }\\n    }\\n    // Return the number of columns to delete\\n    return numColumnsToDelete;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194919,
                "title": "python-count-unsorted-columns",
                "content": "Just count unsorted column numbers. \\n\\n`O(NlogNM)`, with `N <= 100`\\n```\\n    def minDeletionSize(self, A):\\n        return sum(list(col) != sorted(col) for col in zip(*A))\\n```\\n`O(NM)`\\n```\\n    def minDeletionSize(self, A):\\n        return sum(any(a > b for a, b in zip(col, col[1:])) for col in zip(*A))\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDeletionSize(self, A):\\n        return sum(list(col) != sorted(col) for col in zip(*A))\\n```\n```\\n    def minDeletionSize(self, A):\\n        return sum(any(a > b for a, b in zip(col, col[1:])) for col in zip(*A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2989395,
                "title": "3-different-java-codes",
                "content": "**If you find it useful please upvote it means a lot to me \\uD83D\\uDE0A**\\n\\n\\n# 84 % Fast\\n```\\npublic int minDeletionSize(String[] arr) {\\n    int count = 0;\\n    for(int i=0; i<arr[0].length(); i++){\\n        for(int j=1; j<arr.length; j++){\\n            if(arr[j].charAt(i) < arr[j-1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }     \\n    return count;\\n}\\n```\\n# 99.9 % Fast\\n```\\npublic int minDeletionSize(String[] strs) \\n{\\n    int len = strs.length;\\n    int wordlen = strs[0].length();\\n    int ans = 0;\\n        \\n    for(int i=0; i<wordlen; i++)\\n    {\\n        char prev = strs[0].charAt(i);\\n        for(int j=1; j<len; j++)\\n        {\\n            char ch = strs[j].charAt(i);\\n             if(ch < prev) \\n            {\\n                ans++;\\n                break;\\n            }\\n            prev = ch;\\n        }\\n    }\\n    return ans;       \\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/4d2ab3d9-4005-4ab5-8d40-b7c9eebad0b2_1672714083.5173585.png)\\n![UPVOTE MEME.jpg](https://assets.leetcode.com/users/images/c0e14b52-4f1e-4328-be55-9c3d894b7f7f_1672715067.254083.jpeg)\\n\\n# Not Fastest But Cool \\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] S)\\n    {\\n        int answer = 0;\\n        int n = S.length;       \\n        int m = S[0].length(); \\n        char[][] matrix = new char[n][m];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = S[i].charAt(j);\\n            }\\n        }\\n        for(int col=0; col<m; col++){\\n            for(int row=1; row<n; row++){\\n                int min = matrix[row-1][col];\\n                if(matrix[row][col] < min){\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minDeletionSize(String[] arr) {\\n    int count = 0;\\n    for(int i=0; i<arr[0].length(); i++){\\n        for(int j=1; j<arr.length; j++){\\n            if(arr[j].charAt(i) < arr[j-1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }     \\n    return count;\\n}\\n```\n```\\npublic int minDeletionSize(String[] strs) \\n{\\n    int len = strs.length;\\n    int wordlen = strs[0].length();\\n    int ans = 0;\\n        \\n    for(int i=0; i<wordlen; i++)\\n    {\\n        char prev = strs[0].charAt(i);\\n        for(int j=1; j<len; j++)\\n        {\\n            char ch = strs[j].charAt(i);\\n             if(ch < prev) \\n            {\\n                ans++;\\n                break;\\n            }\\n            prev = ch;\\n        }\\n    }\\n    return ans;       \\n}\\n```\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] S)\\n    {\\n        int answer = 0;\\n        int n = S.length;       \\n        int m = S[0].length(); \\n        char[][] matrix = new char[n][m];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = S[i].charAt(j);\\n            }\\n        }\\n        for(int col=0; col<m; col++){\\n            for(int row=1; row<n; row++){\\n                int min = matrix[row-1][col];\\n                if(matrix[row][col] < min){\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989165,
                "title": "python3-one-liner-iterative",
                "content": "**Solution 1:** Simply go though each column and check if the column is sorted or not by comparing it with its sorted version. Same as [lee215](https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/194919/Python-Count-Unsorted-Columns)\\n\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(list(column) != sorted(column) for column in zip(*strs))\\n```\\n\\n**Solution 2:** Iterativelly go through each column, and compare each element with the previous one in this column, if the current element is smaller than the previous one, this column is not sorted, so increase the result and don\\'t look farther in this column. Same as [Vlad](https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/194916/C%2B%2B-brute-force-O(n-*-m))\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        res = 0\\n        \\n        # for each column index\\n        for j in range(len(strs[0])):\\n            \\n            # for each row index start from 1, since we need to compare with the previous one.\\n            for i in range(1,len(strs)):\\n\\n                # this column is not sorted, don\\'t look farther.\\n                if strs[i][j] < strs[i-1][j]:\\n                    res += 1\\n                    break\\n        return res\\n```\\n\\n**Solution 3:** one-liner iterative from [SunnyvaleCA](https://leetcode.com/SunnyvaleCA/)\\'s comment below.\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum( any( strs[i][j]<strs[i-1][j] for i in range(1,len(strs)) ) for j in range(len(strs[0])))\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(list(column) != sorted(column) for column in zip(*strs))\\n```\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        res = 0\\n        \\n        # for each column index\\n        for j in range(len(strs[0])):\\n            \\n            # for each row index start from 1, since we need to compare with the previous one.\\n            for i in range(1,len(strs)):\\n\\n                # this column is not sorted, don\\'t look farther.\\n                if strs[i][j] < strs[i-1][j]:\\n                    res += 1\\n                    break\\n        return res\\n```\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum( any( strs[i][j]<strs[i-1][j] for i in range(1,len(strs)) ) for j in range(len(strs[0])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194916,
                "title": "c-brute-force-o-n-m",
                "content": "Go column by column ```c```, then row by row ```i```. If ```A[i - 1][c] > A[i][c]```, then that column is unsorted - we increase the number of deleted columns and go to the next column.\\n```\\nint minDeletionSize(vector<string>& A, int res = 0) {\\n    if (A.empty()) return res;\\n    for (auto c = 0; c < A[0].size(); ++c)\\n        for (auto i = 1; i < A.size(); ++i) {\\n            if (A[i - 1][c] > A[i][c]) {\\n                ++res;\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```c```\n```i```\n```A[i - 1][c] > A[i][c]```\n```\\nint minDeletionSize(vector<string>& A, int res = 0) {\\n    if (A.empty()) return res;\\n    for (auto c = 0; c < A[0].size(); ++c)\\n        for (auto i = 1; i < A.size(); ++i) {\\n            if (A[i - 1][c] > A[i][c]) {\\n                ++res;\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989277,
                "title": "c-o-nm-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nCheck each column to ensure that it is in sorted order. If any elements breaks the sorting, increase the answer by one and move onto the next column\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        const int n = strs.size(), m = strs[0].size();\\n\\n        int ans = 0;\\n        for (int j = 0; j < m; j++)\\n            for (int i = 1; i < n; i++)\\n                if (strs[i][j] < strs[i - 1][j]) {\\n                    ans++;\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(NM)$$ where $$N$$ is the number of rows and $$M$$ is the number of columns\\n**Space Complexity:** $$O(1)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that `strs[i][j] >= str[i - 1][j]`. If any element breaks this rule, then we delete the column and move on\\n\\n## Approach \\n\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them. \\n\\nIn other words, we just check to see if `strs[i][j] < strs[i - 1][j]` at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return `ans` at the end.\\n\\n## Example\\n\\nLets use the second example, where `strs = [\"cba\",\"daf\",\"ghi\"]`\\n\\n* Col = 0\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\'`, which is `false` so we go to the next row\\n  * Row = 2\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\'`, which is `false` so we go to the next column\\n* Col = 1\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\'`, which is `true` so we delete the row and move to the next column\\n* Col = 2\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\'`, which is `false` so we go to the next row\\n  * Row = 2\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\'`, which is `false` so we exit the loop\\n\\nAt the end, `ans = 1` which is correct\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        const int n = strs.size(), m = strs[0].size();\\n\\n        int ans = 0;\\n        for (int j = 0; j < m; j++)\\n            for (int i = 1; i < n; i++)\\n                if (strs[i][j] < strs[i - 1][j]) {\\n                    ans++;\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223870,
                "title": "python3-efficient-and-concise-without-sorting",
                "content": "```python\\n\\tdef minDeletionSize(self, strs: List[str]) -> int:\\n        m, n = len(strs), len(strs[0])\\n        count = 0\\n        \\n        for i in range(n):\\n            for j in range(1,m):\\n                if strs[j][i] < strs[j-1][i]:\\n                    count += 1\\n                    break\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef minDeletionSize(self, strs: List[str]) -> int:\\n        m, n = len(strs), len(strs[0])\\n        count = 0\\n        \\n        for i in range(n):\\n            for j in range(1,m):\\n                if strs[j][i] < strs[j-1][i]:\\n                    count += 1\\n                    break\\n        \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2991965,
                "title": "c-solution-with-detailed-explanations",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ve to find the no of columns which are not sorted.\\n- First, we\\u2019ll take row & column numbers in ***n & m.***\\n- Then we\\u2019ll compare the column elements one by one in the for loop.\\n- If we find any one column is not in sorted order we\\u2019ll increase the *********ans********* count & break it.\\n- Return the ans.\\n- **Time complexity:** O(n*m).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(strs[j][i] > strs[j+1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "String Matching",
                    "Matrix"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(strs[j][i] > strs[j+1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989202,
                "title": "python-one-line",
                "content": "```python []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(col != sorted(col) for col in map(list, zip(*strs)))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(col != sorted(col) for col in map(list, zip(*strs)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197402,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A[0].length(); i++) {\\n            for (int j = 1; j < A.length; j++) {\\n                if (A[j-1].charAt(i) > A[j].charAt(i)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n         }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A[0].length(); i++) {\\n            for (int j = 1; j < A.length; j++) {\\n                if (A[j-1].charAt(i) > A[j].charAt(i)) {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 422457,
                "title": "javascript-beats-98-w-comments",
                "content": "```javascript\\nvar minDeletionSize = function(A) {\\n    //number of deletions\\n    var deletions = 0;\\n    \\n    //iterate through first word in array\\n    for (var index = 0; index < A[0].length; index++) {\\n        \\n        //now iterate through array\\n        for (var i = 0; i < A.length - 1; i++) {\\n            \\n            //check if the character at the index in this word is greater than the next\\n            if (A[i].charAt(index) > A[i + 1].charAt(index)) {\\n                //increment deletions (we would need to delete this char to make it sorted)\\n                deletions++;\\n                \\n                //break out of current for loop\\n                break;\\n            }\\n            \\n        }\\n    }\\n    \\n    //result\\n    return deletions;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minDeletionSize = function(A) {\\n    //number of deletions\\n    var deletions = 0;\\n    \\n    //iterate through first word in array\\n    for (var index = 0; index < A[0].length; index++) {\\n        \\n        //now iterate through array\\n        for (var i = 0; i < A.length - 1; i++) {\\n            \\n            //check if the character at the index in this word is greater than the next\\n            if (A[i].charAt(index) > A[i + 1].charAt(index)) {\\n                //increment deletions (we would need to delete this char to make it sorted)\\n                deletions++;\\n                \\n                //break out of current for loop\\n                break;\\n            }\\n            \\n        }\\n    }\\n    \\n    //result\\n    return deletions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989456,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=JTA_WgDqx8o&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=3) if you are interested.\\n\\n---\\n\\n# Intuition\\nCompare two characters in adjacent row in the same column to see if they are sorted, we can delete that column if they are not sorted.\\n\\n# Approach\\nBrute Force. First we iterate the columns, then iterate the rows. If the character in the previous row is greater than the character in the current row, then we can delete this column. \\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int ans = 0;\\n        // iterate cols\\n        for (int col = 0; col < s[0].size(); col++) {\\n            // iterate rows\\n            for (int row = 1; row < s.size(); row++) {\\n                // if the character in the previous row is greater than the character in the current row\\n                // then we can delete this column\\n                if (s[row - 1][col] > s[row][col]) {\\n                    ans += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int ans = 0;\\n        // iterate cols\\n        for (int col = 0; col < s[0].size(); col++) {\\n            // iterate rows\\n            for (int row = 1; row < s.size(); row++) {\\n                // if the character in the previous row is greater than the character in the current row\\n                // then we can delete this column\\n                if (s[row - 1][col] > s[row][col]) {\\n                    ans += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209807,
                "title": "88ms-python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len([s for s in zip(*A) if list(s) != sorted(s)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len([s for s in zip(*A) if list(s) != sorted(s)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990398,
                "title": "c-intuitive-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int dlt = 0;\\n\\n        for( int j=0 ; j<m ; j++ ){\\n            // store every current column\\n            string currCol = \"\";\\n\\n            for( int i=0 ; i<n ; i++ ){\\n                currCol += strs[i][j];\\n            }\\n\\n            // check that columns is lexicographically sorted or not \\n            string revCol = currCol;\\n            sort( currCol.begin(), currCol.end() );\\n            if( revCol != currCol ) dlt++;\\n        }\\n\\n        return dlt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int dlt = 0;\\n\\n        for( int j=0 ; j<m ; j++ ){\\n            // store every current column\\n            string currCol = \"\";\\n\\n            for( int i=0 ; i<n ; i++ ){\\n                currCol += strs[i][j];\\n            }\\n\\n            // check that columns is lexicographically sorted or not \\n            string revCol = currCol;\\n            sort( currCol.begin(), currCol.end() );\\n            if( revCol != currCol ) dlt++;\\n        }\\n\\n        return dlt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244899,
                "title": "java-straightforward-solution",
                "content": "**Well, Example 2 is really bad, so I used it as my special consition in line 3:**\\n```\\n if(A.length <= 1 || A[0].length() <= 1) return 0;\\n```\\n**Then use two for loop to go Straightforward!**\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        if(A.length <= 1 || A[0].length() <= 1) return 0;\\n        int res = 0;\\n        for(int i = 0; i < A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(A[j].charAt(i) < A[j-1].charAt(i)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n if(A.length <= 1 || A[0].length() <= 1) return 0;\\n```\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        if(A.length <= 1 || A[0].length() <= 1) return 0;\\n        int res = 0;\\n        for(int i = 0; i < A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(A[j].charAt(i) < A[j-1].charAt(i)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991429,
                "title": "another-linq-solution-super-simple",
                "content": "1. For each column `i`, construct the column:\\n  `col = strs.Select(s => s[i])`\\n2. Then check whether the column matches its sorted form:\\n  `col.OrderBy(c => c).SequenceEqual(col)`\\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = 0;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (!col.OrderBy(c => c).SequenceEqual(col)) res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nIn the latest version of C#, this part\\n`col.OrderBy(c => c).SequenceEqual(col)`\\ncan be shortened to:\\n`col.Order().SequenceEqual(col)`\\n\\nI don\\'t like the negated `if` condition. Here is how to get rid of it:\\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = strs[0].Length;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (col.OrderBy(c => c).SequenceEqual(col)) res--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = 0;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (!col.OrderBy(c => c).SequenceEqual(col)) res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = strs[0].Length;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (col.OrderBy(c => c).SequenceEqual(col)) res--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989760,
                "title": "python-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c=0\\n        for col in range(len(strs[0])):\\n            for row in range(len(strs)-1):\\n                if ord(strs[row][col])>ord(strs[row+1][col]):\\n                    print(strs[row][col],strs[row+1][col])\\n                    c+=1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c=0\\n        for col in range(len(strs[0])):\\n            for row in range(len(strs)-1):\\n                if ord(strs[row][col])>ord(strs[row+1][col]):\\n                    print(strs[row][col],strs[row+1][col])\\n                    c+=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723450,
                "title": "short-clean-java-javascript-solution",
                "content": "``` java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0; i<strs[0].length(); i++){\\n            for(int j=0; j<strs.length-1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n```javascript []\\nvar minDeletionSize = function(strs) {\\n    let count = 0;\\n    for(let i=0; i<strs[0].length; i++){\\n        for(let j=0; j<strs.length-1; j++){\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0; i<strs[0].length(); i++){\\n            for(int j=0; j<strs.length-1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```javascript []\\nvar minDeletionSize = function(strs) {\\n    let count = 0;\\n    for(let i=0; i<strs[0].length; i++){\\n        for(let j=0; j<strs.length-1; j++){\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991557,
                "title": "javascript-solutions-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge and compare strings in each column\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a function that counts how many columns of characters in a string array do not satisfy the order from smallest to largest.\\n\\nThe variable minDeletionSize is the name of the function. It takes in a parameter strs, which represents the string array to be checked.\\n\\nThe variable count is used to count how many columns of characters do not satisfy the order from smallest to largest. It is initialized to 0.\\n\\nNext is a loop that iterates through each character (i.e., each column) of strs[0].\\n\\nThe variable str is used to store the characters of the current column. It is initialized to an empty string.\\n\\nNext is another loop that iterates through each string (i.e., each row) in strs. For each string, it adds the character of the current column to str.\\n\\nThen, the variable check is used to store whether the characters of the current column satisfy the order from smallest to largest. This is done by converting the string str to a character array, sorting the character array, and then converting the sorted character array back to a string and comparing it with the original string.\\n\\nIf the value of check is false, it means that the characters of the current column do not satisfy the order from smallest to largest. In this case, count is incremented by 1.\\n\\nFinally, the function returns count.\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(L)$$\\nL is strs length\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let count = 0\\n    for(let i = 0; i < strs[0].length; i++){\\n        let str = \\'\\'\\n        for(let j = 0; j < strs.length; j++){\\n            str += strs[j][i]\\n        }\\n        let check = str.split(\\'\\').sort().join(\\'\\') == str\\n        if(!check){\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let count = 0\\n    for(let i = 0; i < strs[0].length; i++){\\n        let str = \\'\\'\\n        for(let j = 0; j < strs.length; j++){\\n            str += strs[j][i]\\n        }\\n        let check = str.split(\\'\\').sort().join(\\'\\') == str\\n        if(!check){\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990824,
                "title": "simplest-c-approach-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(row*col)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n      \\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0; j<strs.size();j++){\\n                if( j+1 < strs.size() && strs[j][i] > strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n      \\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0; j<strs.size();j++){\\n                if( j+1 < strs.size() && strs[j][i] > strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990400,
                "title": "java-short-and-explained-beats-93-3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the columns from 0 to strLen-1, for each column col:\\n\\n- Iterate over the rows row from 1 to n - 1:\\n\\n  - If the character at index col in the string strs[row] is smaller than the character at index col in the string strs[row - 1], then increment the counter variable answer. Also, we can break the inner loop here as we find the current column unsorted.\\n  - Otherwise, we check the next row.\\n\\n# Complexity\\n- Time complexity: $$O(N*K)$$ . As, you can see there are two nested for loops. **K** is the `strLen` and **N** is the `strs` array length.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ . We haven\\'t used any extra space. The spaces taken here are constant. Meaning they do not depend on the size of the input parameters.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Submission link: \\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/submissions/870222049/\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // number of columns..\\n        int strLen = strs[0].length();\\n        // cols to be deleted.. \\n        int dels = 0;\\n\\n        for(int col=0; col<strLen; col++){\\n            // by default take \\'0\\' as it is the smallest character\\n            char prev = \\'0\\';\\n            for(String str : strs){\\n                char cur = str.charAt(col);\\n                // compare with prev. if prev was bigger than cur,\\n                // it is unsorted. so, increase count and break;\\n                if(cur<prev){\\n                    dels++;\\n                    break;\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return dels;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/9a1fce67-3636-4da5-8a8a-52f395f24a50_1672725016.0186899.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // number of columns..\\n        int strLen = strs[0].length();\\n        // cols to be deleted.. \\n        int dels = 0;\\n\\n        for(int col=0; col<strLen; col++){\\n            // by default take \\'0\\' as it is the smallest character\\n            char prev = \\'0\\';\\n            for(String str : strs){\\n                char cur = str.charAt(col);\\n                // compare with prev. if prev was bigger than cur,\\n                // it is unsorted. so, increase count and break;\\n                if(cur<prev){\\n                    dels++;\\n                    break;\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return dels;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990299,
                "title": "super-easy-to-understand-fully-explained-different-approach-java",
                "content": "# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Approach [Explained in Comments] :\\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        if(strs==null||strs.length==0)\\n            return 0;//base case\\n        int res=0;//result\\n        int n=strs[0].length();//for longest column length\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;//should be 0 every time i increases\\n            for(;j<strs.length-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                    break;\\n            }\\n            if(j!=strs.length-1)// j not reach charcter of lowest string since break came\\n                res++;//one column not sorted found\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        if(strs==null||strs.length==0)\\n            return 0;//base case\\n        int res=0;//result\\n        int n=strs[0].length();//for longest column length\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;//should be 0 every time i increases\\n            for(;j<strs.length-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                    break;\\n            }\\n            if(j!=strs.length-1)// j not reach charcter of lowest string since break came\\n                res++;//one column not sorted found\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989143,
                "title": "daily-leetcoding-challenge-january-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-columns-to-make-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-columns-to-make-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 517343,
                "title": "python-99-easy-to-read",
                "content": "Yes, technically sorted should have worse O() than a linear scan, but in this particular context it delivers better performance (>99%) and a shorter code.\\n\\nWe basically take a slice of A, store in c and compare against sorted c.\\n\\n```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n\\n        ret = 0\\n        \\n        for c in zip(*A): \\n            if list(c) != sorted(c): \\n                ret += 1\\n                \\n        return ret \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n\\n        ret = 0\\n        \\n        for c in zip(*A): \\n            if list(c) != sorted(c): \\n                ret += 1\\n                \\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 385630,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        \\n        // Go through each char column\\n        for (int j = 0; j < A[0].length(); j++) {\\n            // Go through each string\\n            for (int i = 0; i < A.length - 1; i++) {\\n                // If column\\'s char is decreasing on the next string,\\n                // count as deletion index\\n                if (A[i].charAt(j) > A[i + 1].charAt(j)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        \\n        // Go through each char column\\n        for (int j = 0; j < A[0].length(); j++) {\\n            // Go through each string\\n            for (int i = 0; i < A.length - 1; i++) {\\n                // If column\\'s char is decreasing on the next string,\\n                // count as deletion index\\n                if (A[i].charAt(j) > A[i + 1].charAt(j)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991674,
                "title": "python-easy-beats-97-multiple-approaches",
                "content": "# Approach 1\\nUse a loop with zip and *strs. *strs will convert lists into tuple and zip will create another tuple with all the values at first index in each tuple in a tuple at first index.\\n**For Example:**\\n> Lets say there is a list with [[\"abc\"],[\"cdf\"]] then *strs will create a tuple ((\"abc\"),(\"cdf\")) and zip will convert them in ((\"ac\"),(\"bd\"),(\"cf\")).\\n\\nNow check if the tuple converted into a list and sorted tuple that would also return a sorted list aren\\'t equal. if they are not equal then count+=1. return count.\\n\\n# Complexity\\n- Time complexity: **Not sure what these convertion will take.**\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        counter = 0\\n\\n        for i in zip(*strs):\\n            if list(i)!=sorted(i):\\n                counter+=1\\n\\n        return counter              \\n```\\n\\n# Approach 2\\nWe can create a grid with all the strings as list then create another list to store the transpose of the grid. after that we can create another list to store the sorted list of that transposed grid and compare it with transpose of grid if it is not equal then we can simply increment the counter. (**This is too listy, i guess :D**)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        grid = []\\n\\n        for i in range(len(strs)):\\n            grid.append(list(strs[i]))\\n\\n\\n        result = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))] \\n\\n\\n        new = []\\n\\n        for i in range(len(result)):\\n            new.append(\"\".join(sorted(result[i])))\\n\\n        count = 0\\n\\n        for i in range(len(result)):\\n            if \"\".join(result[i])!=new[i]:\\n                count+=1\\n        \\n       \\n\\n        return count           \\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        counter = 0\\n\\n        for i in zip(*strs):\\n            if list(i)!=sorted(i):\\n                counter+=1\\n\\n        return counter              \\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        grid = []\\n\\n        for i in range(len(strs)):\\n            grid.append(list(strs[i]))\\n\\n\\n        result = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))] \\n\\n\\n        new = []\\n\\n        for i in range(len(result)):\\n            new.append(\"\".join(sorted(result[i])))\\n\\n        count = 0\\n\\n        for i in range(len(result)):\\n            if \"\".join(result[i])!=new[i]:\\n                count+=1\\n        \\n       \\n\\n        return count           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990789,
                "title": "easy-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int result = 0;\\n\\n        for(int i=0; i<strs[0].size(); ++i)\\n            for(int j=1; j<strs.size(); ++j)\\n                if(strs[j][i] < strs[j-1][i]){\\n                    ++result;\\n                    break;\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int result = 0;\\n\\n        for(int i=0; i<strs[0].size(); ++i)\\n            for(int j=1; j<strs.size(); ++j)\\n                if(strs[j][i] < strs[j-1][i]){\\n                    ++result;\\n                    break;\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990685,
                "title": "c-simple-logic-row-and-col-space-o-1-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        \\n        int ans=0;\\n        \\n        // just check for each column, and if we got wrong lexicographically order just remove that and incraese count by 1\\n        for(int j=0;j<m;j++)        // each column\\n        {\\n            for(int i=1;i<n;i++)    // each row\\n            {\\n                if(strs[i-1][j] > strs[i][j])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        \\n        int ans=0;\\n        \\n        // just check for each column, and if we got wrong lexicographically order just remove that and incraese count by 1\\n        for(int j=0;j<m;j++)        // each column\\n        {\\n            for(int i=1;i<n;i++)    // each row\\n            {\\n                if(strs[i-1][j] > strs[i][j])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989260,
                "title": "brute-force-approach-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply traverse the matrix column wise, when we encounter that two consecutive elements of the column are not in lexicographic order, we add the column number in a temporary list `c`.\\nAfter Traversing the whole list of strings, there\\'s a high chance of having redundant values in the list `c`. Thus , we typecaste the list `c` to a set, which will drop any redundant values in the list and have distinct column numbers to be deleted. At the end we will simply return the length of the set `c`.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c = []\\n        for i in range(len(strs)-1):\\n            for j in range(len(strs[0])):\\n                if strs[i][j] > strs[i+1][j]:\\n                    c.append(j)\\n        return len(set(c))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c = []\\n        for i in range(len(strs)-1):\\n            for j in range(len(strs[0])):\\n                if strs[i][j] > strs[i+1][j]:\\n                    c.append(j)\\n        return len(set(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991057,
                "title": "c-easy-fully-explained-in-hindi",
                "content": "# Intuition\\nJaisa question m bola h waisa he krna h (check for all char)\\n\\n# Approach\\nham sabse phle first word pr jayenge or uske first, second...nd all character ko remaining word ke first second ..nd all character se match krenge(how ??check if condition in my code) agar koi character condition satisfy nahi kr rha h to hmare count jo initially 0 tha usme increament krenge or loop ko break kr lenge for that char only.\\nwe will use 2 for loop for that\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)Constraints bhut chote h\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>&s) {\\n        int ans=0;\\n        for(int i=0;i<s[0].size();i++)\\n            for(int j=1;j<s.size();j++)\\n             if(s[j][i]<s[j-1][i]){\\n                ans++;\\n                break;\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>&s) {\\n        int ans=0;\\n        for(int i=0;i<s[0].size();i++)\\n            for(int j=1;j<s.size();j++)\\n             if(s[j][i]<s[j-1][i]){\\n                ans++;\\n                break;\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989849,
                "title": "c-java-and-javascript-o-n-solution-easy-to-understand",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int row=strs.length;\\n        int col=strs[0].length();\\n        int ans=0;\\n\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int col=s[0].length();\\n        int row=s.size();\\n        int ans=0;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(s[j][i]>s[j+1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const row=strs.length;\\n    const col=strs[0].length;\\n    let ans=0;\\n    for(let i=0;i<col;i++)\\n    {\\n        for(let j=0;j<row-1;j++)\\n        {\\n            if(strs[j][i]>strs[j+1][i])\\n            {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int row=strs.length;\\n        int col=strs[0].length();\\n        int ans=0;\\n\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int col=s[0].length();\\n        int row=s.size();\\n        int ans=0;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(s[j][i]>s[j+1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const row=strs.length;\\n    const col=strs[0].length;\\n    let ans=0;\\n    for(let i=0;i<col;i++)\\n    {\\n        for(let j=0;j<row-1;j++)\\n        {\\n            if(strs[j][i]>strs[j+1][i])\\n            {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989543,
                "title": "simple-java-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Since we are talking about a grid, we might need a nested loop to solve the problem.\\n- One way to solve this problem would be iterating over a particular column in a grid and checking whether that particular column in sorted.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a variable to keep track of the number of columns to be deleted. Let\\'s call it `colsDelete`. \\n- Have an outer loop to iterate over the length of any string in `strs`. (Since all the strings in `strs` have same length)\\n- The inner loop will iterate over all the strings in `strs` i.e. `strs.length`. This ensures that we are traversing columnwise. \\n- Now check whether `(strs[j].charAt(i) < strs[j-1].charAt(i))`. This means we are checking whether two adjacent rows in a column are lexiographically sorted or not.\\n- If not then increment `colsDelete` and `break` the inner loop as we do not need to check further whether that column is sorted.\\n- Finally, after checking for all columns, return `colsDelete`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int colsDelete = 0; \\n\\n        //Iterating over the length of any string in strs. Here we took strs[0]\\n        for(int i=0; i<strs[0].length(); i++){\\n\\n            //Iterating over all the strings in strs\\n            for(int j=1; j<strs.length; j++){\\n\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                    colsDelete++;\\n                    break;\\n                } \\n            }\\n        }\\n        return colsDelete;\\n    }\\n}\\n```\\n\\n**Please do Upvote if found helpful**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int colsDelete = 0; \\n\\n        //Iterating over the length of any string in strs. Here we took strs[0]\\n        for(int i=0; i<strs[0].length(); i++){\\n\\n            //Iterating over all the strings in strs\\n            for(int j=1; j<strs.length; j++){\\n\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                    colsDelete++;\\n                    break;\\n                } \\n            }\\n        }\\n        return colsDelete;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989304,
                "title": "c-c-java-python-brute-force",
                "content": "\\n```C++ []\\nint minDeletionSize(vector<string>& strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].size();++i)\\n        for(int j=0;j<strs.size()-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```java []\\npublic int minDeletionSize(String[] strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].length();i++)\\n        for(int j=0;j<strs.length-1;j++)\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```c []\\nint minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```python []\\ndef minDeletionSize(self, strs):\\n    remove = 0\\n    for i in range(len(strs[0])):\\n        for j in range(len(strs)-1):\\n            if(strs[j][i] > strs[j+1][i]):\\n                remove += 1\\n                break\\n    return remove \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```C++ []\\nint minDeletionSize(vector<string>& strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].size();++i)\\n        for(int j=0;j<strs.size()-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```java []\\npublic int minDeletionSize(String[] strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].length();i++)\\n        for(int j=0;j<strs.length-1;j++)\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```c []\\nint minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```python []\\ndef minDeletionSize(self, strs):\\n    remove = 0\\n    for i in range(len(strs[0])):\\n        for j in range(len(strs)-1):\\n            if(strs[j][i] > strs[j+1][i]):\\n                remove += 1\\n                break\\n    return remove \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2989210,
                "title": "python-o-m-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        del_col = 0\\n        for c in range(len(strs[0])):\\n            for r in range(len(strs)-1):\\n                if strs[r][c] > strs[r+1][c]:\\n                    del_col += 1\\n                    break\\n        return del_col\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        del_col = 0\\n        for c in range(len(strs[0])):\\n            for r in range(len(strs)-1):\\n                if strs[r][c] > strs[r+1][c]:\\n                    del_col += 1\\n                    break\\n        return del_col\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249501,
                "title": "golang-solution-with-quick-explanation",
                "content": "This solution loops through every column, and then if the previous letter in the column is greater than the current letter, we know that this column can be removed.\\n\\n``` go\\nfunc minDeletionSize(strs []string) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(strs[0]); i++ {\\n\\t\\tfor j := 1; j < len(strs); j++ {\\n\\t\\t\\tif strs[j][i] < strs[j-1][i] {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc minDeletionSize(strs []string) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(strs[0]); i++ {\\n\\t\\tfor j := 1; j < len(strs); j++ {\\n\\t\\t\\tif strs[j][i] < strs[j-1][i] {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995674,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993186,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a counter and increment it every time we got lexicographically unsorted characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We are going through all the columns, so this is outer loop.\\n2. We need to compare the current character with character at next row of same column, so traversal will be less than row-1.\\n3. If current character is greater than next row character, then increment counter and break from loop.\\n4. At last, return counter value.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletedCount = 0;\\n        int r = strs.size();\\n        int c = strs[0].size();\\n\\n        /*\\n        1. We are going through all the columns, so this is outer loop.\\n        2. We need to compare the currentChar with char at next row of same column, so traversal will be < row-1.\\n        3. If current char is > next row char, then increment deletedCount and break from loop.\\n        4. At last, return deletedCount.\\n        */\\n        \\n        for(int j=0; j<c; j++){\\n            for(int i=0; i<r-1; i++){\\n                if(strs[i][j] > strs[i+1][j]){\\n                    deletedCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n};\\n```\\n**Do UPVOTE, if you find this approach helpful.**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletedCount = 0;\\n        int r = strs.size();\\n        int c = strs[0].size();\\n\\n        /*\\n        1. We are going through all the columns, so this is outer loop.\\n        2. We need to compare the currentChar with char at next row of same column, so traversal will be < row-1.\\n        3. If current char is > next row char, then increment deletedCount and break from loop.\\n        4. At last, return deletedCount.\\n        */\\n        \\n        for(int j=0; j<c; j++){\\n            for(int i=0; i<r-1; i++){\\n                if(strs[i][j] > strs[i+1][j]){\\n                    deletedCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992494,
                "title": "easy-c-solution",
                "content": "Here is the code for the question:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int strlen = strs[0].length(), n = strs.size();\\n        int count{0};\\n        for (int i{0}; i<strlen; i++) {\\n            int a = \\'a\\';\\n            for (int j{0}; j<n; j++) {\\n                if (a <= strs[j][i]) {\\n                    a=strs[j][i];\\n                }\\n                else {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n*Upvote if it helped!*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int strlen = strs[0].length(), n = strs.size();\\n        int count{0};\\n        for (int i{0}; i<strlen; i++) {\\n            int a = \\'a\\';\\n            for (int j{0}; j<n; j++) {\\n                if (a <= strs[j][i]) {\\n                    a=strs[j][i];\\n                }\\n                else {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992451,
                "title": "java-easiest-solution-possible",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int x = strs[0].length(), n = strs.length;\\n        int ans = 0;\\n        for (int j = 0; j < x; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int x = strs[0].length(), n = strs.length;\\n        int ans = 0;\\n        for (int j = 0; j < x; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990754,
                "title": "c-most-optimized-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/ebb1f9d3-e025-4a0f-9f5d-6e49e414e63b_1672728455.6099532.png)\\n\\n**T->O(m * n) [Worst Case Complexity] && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDeletionSize(vector<string>& strs) {\\n\\t\\t\\t\\tint n = strs.size();\\n\\t\\t\\t\\tint m = strs[0].size();\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int col = 0 ; col < m ; col++){\\n\\t\\t\\t\\t\\tfor(int row = 0 ; row < n-1 ; row++){\\n\\t\\t\\t\\t\\t\\tif(strs[row][col] > strs[row+1][col]){\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDeletionSize(vector<string>& strs) {\\n\\t\\t\\t\\tint n = strs.size();\\n\\t\\t\\t\\tint m = strs[0].size();\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int col = 0 ; col < m ; col++){\\n\\t\\t\\t\\t\\tfor(int row = 0 ; row < n-1 ; row++){\\n\\t\\t\\t\\t\\t\\tif(strs[row][col] > strs[row+1][col]){\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2990652,
                "title": "c-simple-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(nxs)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size(), sz=strs[0].size();\\n        int cnt=0;\\n        for(int j=0; j<sz; j++)\\n        {\\n            for(int i=1; i<n; i++)\\n            {\\n                if(strs[i][j] < strs[i-1][j]) \\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size(), sz=strs[0].size();\\n        int cnt=0;\\n        for(int j=0; j<sz; j++)\\n        {\\n            for(int i=1; i<n; i++)\\n            {\\n                if(strs[i][j] < strs[i-1][j]) \\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990516,
                "title": "5ms-speed-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the Aschii values we can justify wether it is sorted or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i have created a count varibale for storing the answer value and a for loop for each coloum and then declared a temp variable which stores the temperory value of previous aschi value of the character, with this \\'temp\\' i have chechked whether the present character value is greater then the previous one. In case of failure the loop is terminated and the count value is increased.\\n# Complexity\\n- Time complexity: 5 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}else {\\n        \\t\\t\\tcount++;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}else {\\n        \\t\\t\\tcount++;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990389,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       bool check(string st)\\n        {\\n            int count=0;\\n            for(int i=1; i<st.length(); i++)\\n                if(st[i]<st[i-1])\\n                    return 1;   \\n            return 0;\\n        }\\n    int minDeletionSize(vector<string>& str) {\\n        int count=0;\\n        int col = str[0].size();\\n        for(int j=0; j<col; j++)\\n            {\\n                string str1 = \"\";\\n                for(int i=0; i<str.size(); i++)\\n                    str1 += str[i][j];\\n                if(check(str1)) count++;\\n            }\\n            return count;\\n        }\\n    };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       bool check(string st)\\n        {\\n            int count=0;\\n            for(int i=1; i<st.length(); i++)\\n                if(st[i]<st[i-1])\\n                    return 1;   \\n            return 0;\\n        }\\n    int minDeletionSize(vector<string>& str) {\\n        int count=0;\\n        int col = str[0].size();\\n        for(int j=0; j<col; j++)\\n            {\\n                string str1 = \"\";\\n                for(int i=0; i<str.size(); i++)\\n                    str1 += str[i][j];\\n                if(check(str1)) count++;\\n            }\\n            return count;\\n        }\\n    };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990169,
                "title": "using-map-short-easy-c",
                "content": "\\nThis can be done in a single pass! Look at the code.\\nn: strs.size() , m = strs[0].size()\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int minDeletionSize(vector<string>& strs) {\\n        unordered_map<int,bool> column;   //** store column to be deleted \\n\\n        for(int i =1;i<strs.size();i++)\\n            for(int j=0;j<strs[i].size();j++)\\n                if(strs[i][j]<strs[i-1][j])column[j]=true;\\n            \\n        return column.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minDeletionSize(vector<string>& strs) {\\n        unordered_map<int,bool> column;   //** store column to be deleted \\n\\n        for(int i =1;i<strs.size();i++)\\n            for(int j=0;j<strs[i].size();j++)\\n                if(strs[i][j]<strs[i-1][j])column[j]=true;\\n            \\n        return column.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989628,
                "title": "java-easy-iterative-solution",
                "content": "# Approach\\nWe use nested for loop.\\nWe take the column number in the outer loop\\nand the row number in the inner loop.\\nWe use the ascii values to check the lexicographic order.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] strs) {\\n        int c=0;\\n        int l = strs.length;\\n        for (int i = 0; i < strs[0].length(); i++) {\\n            for (int j = 0; j <l-1 ; j++) {\\n                if((int)strs[j].charAt(i)>(int)strs[j+1].charAt(i))\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minDeletionSize(String[] strs) {\\n        int c=0;\\n        int l = strs.length;\\n        for (int i = 0; i < strs[0].length(); i++) {\\n            for (int j = 0; j <l-1 ; j++) {\\n                if((int)strs[j].charAt(i)>(int)strs[j+1].charAt(i))\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989497,
                "title": "c-easiest-possible-approach-100-efficient-in-memory-simple-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0; // keep the track of non-ordered columns\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true; //mark true if found in non decreasing order\\n            }\\n            if(flag)\\n                cnt++; //update count\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Please upvote if you find this helpful.\\uD83D\\uDE4F\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0; // keep the track of non-ordered columns\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true; //mark true if found in non decreasing order\\n            }\\n            if(flag)\\n                cnt++; //update count\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989460,
                "title": "iterative-approach-c-easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m x n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m x n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int c=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int k=0;k<strs.size()-1;k++){\\n                if(strs[k][i]>strs[k+1][i]){\\n                    c++;break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int c=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int k=0;k<strs.size()-1;k++){\\n                if(strs[k][i]>strs[k+1][i]){\\n                    c++;break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989419,
                "title": "c-code-using-brute-force",
                "content": "# Intuition\\n- Brute Force \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Iterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the count and break out of the loop since we don\\'t need to check the rest of them.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Codestr\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=0;j<strs.size()-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=0;j<strs.size()-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989406,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { zip($0,$1).map { $0.0 > $0.1 ? \"~\" : $0.1 }}.filter { $0 == \"~\" }.count\\n    }\\n}\\n```\\n**NOTE:** This technically qualifies as a one-liner, since the `return` keyword was omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { columns, str in\\n\\t\\t\\t// Approach:\\n\\t\\t\\t// - Replace column element with `~` where lexographic order not maintained.\\n\\t\\t\\t// - At the end, return count of `~` in `columns`\\n            zip(columns, str)\\n            .map {\\n                // $0.0 is `columns` element \\n                // $0.1 is `str` element\\n                $0.0 > $0.1 ? \"~\" : $0.1  // `~` is (arbitrarily-chosen) larger ASCII value than `z`\\n            }\\n        }\\n        .filter { ch in ch == \"~\" }\\n        .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { zip($0,$1).map { $0.0 > $0.1 ? \"~\" : $0.1 }}.filter { $0 == \"~\" }.count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { columns, str in\\n\\t\\t\\t// Approach:\\n\\t\\t\\t// - Replace column element with `~` where lexographic order not maintained.\\n\\t\\t\\t// - At the end, return count of `~` in `columns`\\n            zip(columns, str)\\n            .map {\\n                // $0.0 is `columns` element \\n                // $0.1 is `str` element\\n                $0.0 > $0.1 ? \"~\" : $0.1  // `~` is (arbitrarily-chosen) larger ASCII value than `z`\\n            }\\n        }\\n        .filter { ch in ch == \"~\" }\\n        .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635180,
                "title": "without-zip-function-in-python-faster-than-82-o-n-2",
                "content": "```\\n        c= 0\\n        for i in range(len(strs[0])):\\n             for j in range(1,len(strs)):\\n                if strs[j-1][i] > strs[j][i]:\\n                    c+= 1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c= 0\\n        for i in range(len(strs[0])):\\n             for j in range(1,len(strs)):\\n                if strs[j-1][i] > strs[j][i]:\\n                    c+= 1\\n                    break\\n        return c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854921,
                "title": "easy-solution-o-nk-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    delete_count++;\\n                    break;\\n                }\\n                    \\n            }\\n        }\\n        return delete_count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    delete_count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1080827,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0;\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true;\\n            }\\n            if(flag)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nKindly upvote if this helps you!! :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0;\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true;\\n            }\\n            if(flag)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907550,
                "title": "java-5-ms",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int result = 0;\\n        char[][] aToChars = new char[A.length][A[0].length()];\\n        int k = 0;\\n        \\n        for(String s: A){\\n            aToChars[k] = s.toCharArray();\\n            k++;\\n        }\\n        \\n        for(int i = 0; i< A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(aToChars[j-1][i] > aToChars[j][i]){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDeletionSize(String[] A) {\\n        int result = 0;\\n        char[][] aToChars = new char[A.length][A[0].length()];\\n        int k = 0;\\n        \\n        for(String s: A){\\n            aToChars[k] = s.toCharArray();\\n            k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 751152,
                "title": "python-3-submission",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        strings = []\\n        for i in range(0,len(A[0])):\\n            temp = \"\".join([item[i] for item in A])\\n            if \"\".join(sorted(temp)) == temp:\\n                pass\\n            else:\\n                strings.append(1)\\n        return len(strings)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        strings = []\\n        for i in range(0,len(A[0])):\\n            temp = \"\".join([item[i] for item in A])\\n            if \"\".join(sorted(temp)) == temp:\\n                pass\\n            else:\\n                strings.append(1)\\n        return len(strings)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741397,
                "title": "c-one-liner",
                "content": "```csharp\\npublic int MinDeletionSize(string[] A) {\\n\\treturn Enumerable\\n\\t\\t.Range(0, A[0].Length)\\n\\t\\t.Select(i => new string(A.Select(s => s[i]).ToArray()))\\n\\t\\t.Count(col => new string(col.OrderBy(c => c).ToArray()) != col);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinDeletionSize(string[] A) {\\n\\treturn Enumerable\\n\\t\\t.Range(0, A[0].Length)\\n\\t\\t.Select(i => new string(A.Select(s => s[i]).ToArray()))\\n\\t\\t.Count(col => new string(col.OrderBy(c => c).ToArray()) != col);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427225,
                "title": "python3-6-line-96ms-beats-99-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        zipped=list(map(list,zip(*A)))\\n        count=0\\n        for item in zipped:\\n            if item!=sorted(item):\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        zipped=list(map(list,zip(*A)))\\n        count=0\\n        for item in zipped:\\n            if item!=sorted(item):\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240225,
                "title": "python-128-ms",
                "content": "```\\n check =0\\n        for i in range(len(A[0])):\\n            stack=[ord(x[i]) for x in A]\\n            if stack != sorted(stack):\\n                check += 1\\n            \\n        return check\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n check =0\\n        for i in range(len(A[0])):\\n            stack=[ord(x[i]) for x in A]\\n            if stack != sorted(stack):\\n                check += 1\\n            \\n        return check\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 198993,
                "title": "simple-javascript-solution-with-comments",
                "content": "@LeetCode please stop using/allowing single capital letters for param names. It is literally non-existent in real code.\\nSome people might even take note and start using it themselves.\\n\\n```\\nvar minDeletionSize = function(A) {\\n    \\n    // increment this if we find a\\n    // column that is out of order\\n    let numColumnsToDelete = 0;\\n\\n    // all strings in the array\\n    // are the same length\\n    const strLength = A[0].length;\\n\\n    // outer loop checks entire string\\n    for (let i = 0; i < strLength; i++) {\\n\\n        // inner loop checks the colunns\\n        for (let j = 0; j < A.length - 1; j++) {\\n\\n            const top = A[j][i];\\n            const bottom = A[j + 1][i];\\n\\n            if (top > bottom) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return numColumnsToDelete;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDeletionSize = function(A) {\\n    \\n    // increment this if we find a\\n    // column that is out of order\\n    let numColumnsToDelete = 0;\\n\\n    // all strings in the array\\n    // are the same length\\n    const strLength = A[0].length;\\n\\n    // outer loop checks entire string\\n    for (let i = 0; i < strLength; i++) {\\n\\n        // inner loop checks the colunns\\n        for (let j = 0; j < A.length - 1; j++) {\\n\\n            const top = A[j][i];\\n            const bottom = A[j + 1][i];\\n\\n            if (top > bottom) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return numColumnsToDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194896,
                "title": "stl-overkill",
                "content": "```\\nclass Solution {\\n    public:\\n        int minDeletionSize(vector<string>& A) {\\n            vector<string> s(A.front().size(), string(A.size(), \\' \\'));\\n            for (int r = 0; r < A.size(); ++r) {\\n                for (int c = 0; c < A[r].size(); ++c) {\\n                    s[c][r] = A[r][c];\\n                }\\n            }\\n            return count_if(s.begin(), s.end(), [](auto & p) {\\n                return !is_sorted(p.begin(), p.end());\\n            });\\n        }\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        int minDeletionSize(vector<string>& A) {\\n            vector<string> s(A.front().size(), string(A.size(), \\' \\'));\\n            for (int r = 0; r < A.size(); ++r) {\\n                for (int c = 0; c < A[r].size(); ++c) {\\n                    s[c][r] = A[r][c];\\n                }\\n            }\\n            return count_if(s.begin(), s.end(), [](auto & p) {\\n                return !is_sorted(p.begin(), p.end());\\n            });\\n        }\\n    };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339326,
                "title": "best-solution-98-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use an array to keep track of which columns need to be deleted. Initially, all columns are marked for deletion, and we mark columns as not needing to be deleted as we check each column. At the end, we return the count of columns that are marked for deletion.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const sortedCols = new Array(strs[0].length).fill(true);\\n    let count = 0;\\n    for(let i = 0; i < strs[0].length; i++){\\n        for(let j = 1; j < strs.length; j++){\\n            if(strs[j][i] < strs[j-1][i]){\\n                sortedCols[i] = false;\\n                break;\\n            }\\n        }\\n        if(!sortedCols[i]){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const sortedCols = new Array(strs[0].length).fill(true);\\n    let count = 0;\\n    for(let i = 0; i < strs[0].length; i++){\\n        for(let j = 1; j < strs.length; j++){\\n            if(strs[j][i] < strs[j-1][i]){\\n                sortedCols[i] = false;\\n                break;\\n            }\\n        }\\n        if(!sortedCols[i]){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3252864,
                "title": "python-98-fastest-solution-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing python zip function, get list of coulums and check for ordering in each column.\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n,ans=len(strs),len(strs[0]),0\\n        l=list(zip(*strs))\\n        for item in l:\\n            for i in range(1,len(item)):\\n                if item[i]<item[i-1]:\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n,ans=len(strs),len(strs[0]),0\\n        l=list(zip(*strs))\\n        for item in l:\\n            for i in range(1,len(item)):\\n                if item[i]<item[i-1]:\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011950,
                "title": "c-solution-with-full-explanation-and-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to delete \"columns\" that are not lexicographically sorted therefore we will need 2 loops and will have to travel across the matrix in column-wise fashion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe vector given is 1-D but it is a vector of strings so it can be thought of as a 2-D array with row elements as the strings and column elements as the individual characters of the string \\nOuter loop will iterate across the columns.\\nNo. if columns = length of string \\n\\nInner loop will iterate across the rows \\nNo. of rows = no. of elements in the vector \\n\\nif ASCII value of element of column i is greater than ASCII value of element of column i+1 then it is not sorted and we increase the count \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) - 2 nested for loops so n square time complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - declared only one additional variable to keep track of count so constant space complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // ELEMENTS SHOULD BE SORTED LEXICOGRAPHICALLY - IN ALPHABETICAL ORDER **COLUMN WISE** \\n\\n        int n = strs.size();\\n        int cnt = 0 ; \\n        // have to check column-wise therefore outerloop for columns\\n        for (int i = 0 ; i<strs[0].size() ; i++)\\n        {\\n            // inner loop for rows \\n            for (int j = 0 ; j<strs.size()-1; j++)\\n            {\\n                // if ASCII value of previous element is greater than that of next then it is not sorted, we increase count and break the loop to move on to the next column\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n                else continue ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // ELEMENTS SHOULD BE SORTED LEXICOGRAPHICALLY - IN ALPHABETICAL ORDER **COLUMN WISE** \\n\\n        int n = strs.size();\\n        int cnt = 0 ; \\n        // have to check column-wise therefore outerloop for columns\\n        for (int i = 0 ; i<strs[0].size() ; i++)\\n        {\\n            // inner loop for rows \\n            for (int j = 0 ; j<strs.size()-1; j++)\\n            {\\n                // if ASCII value of previous element is greater than that of next then it is not sorted, we increase count and break the loop to move on to the next column\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n                else continue ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994175,
                "title": "c-image-explanation-easiest-solution-very-easy-to-understand-understandable",
                "content": "\\napproach :- simply make a string of all same characters of given set of strings  and see if the sorted string is same as our string .if not that means it is not in lexicograpphycally .so increase count by one unit \\n\\n![IMG_20230104_011304.jpg](https://assets.leetcode.com/users/images/241b0105-a8be-4567-8eac-964a4b8c05b1_1672775259.2226002.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int size=strs[0].size();\\n        int ans=0;\\n        string temp=\"\";\\n        string temp2=\"\";\\n        for(int i=0;i<size;++i){\\n        for(auto string: strs){\\n            temp+=string[i];\\n        } \\n         string temp2=temp;\\n         sort(temp.begin(),temp.end());\\n        if(temp!=temp2){\\n         ans++;\\n        } temp=\"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int size=strs[0].size();\\n        int ans=0;\\n        string temp=\"\";\\n        string temp2=\"\";\\n        for(int i=0;i<size;++i){\\n        for(auto string: strs){\\n            temp+=string[i];\\n        } \\n         string temp2=temp;\\n         sort(temp.begin(),temp.end());\\n        if(temp!=temp2){\\n         ans++;\\n        } temp=\"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994134,
                "title": "simple-java-code",
                "content": "# Intuition \\nWe have to check each character of each string in array and break the loop as soon as we find non-lexicographicaly arranged character in column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int len=strs.length;\\n       int count=0;\\n        int k=strs[0].length();\\n        if(strs==null) return count;\\n        for(int i=0;i<k;i++)\\n        {\\n           \\nfor(int j=0;j<len-1;j++)\\n            {\\n                \\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    count++;\\n                    break;\\n                }\\n\\n            }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int len=strs.length;\\n       int count=0;\\n        int k=strs[0].length();\\n        if(strs==null) return count;\\n        for(int i=0;i<k;i++)\\n        {\\n           \\nfor(int j=0;j<len-1;j++)\\n            {\\n                \\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    count++;\\n                    break;\\n                }\\n\\n            }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993715,
                "title": "easy-and-simple-2-approaches-with-simple-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // initializing deletCol variable\\n        int deleteCol = 0;\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix \\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            // initializing temporay for checking sorted or not\\n            String tempStr = \"\";\\n            for(int j = 0; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n            }\\n            // check tempStr\\n            if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n    //  create method for checking sorted or not\\n    public  boolean isSorted(String str) {\\n        for(int i = 0; i < str.length() - 1; i ++){\\n            if(str.charAt(i) > str.charAt(i + 1))  return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```\\npublic int minDeletionSize(String[] strs) {\\n         // initializing deletCol variable\\n        int deleteCol = 0;\\n\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix\\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            String tempStr = \"\";\\n            for(int j = 1; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n                // checking character are in sorted or not\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                        deleteCol ++;\\n                        break;\\n                }\\n            }\\n            //if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // initializing deletCol variable\\n        int deleteCol = 0;\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix \\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            // initializing temporay for checking sorted or not\\n            String tempStr = \"\";\\n            for(int j = 0; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n            }\\n            // check tempStr\\n            if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n    //  create method for checking sorted or not\\n    public  boolean isSorted(String str) {\\n        for(int i = 0; i < str.length() - 1; i ++){\\n            if(str.charAt(i) > str.charAt(i + 1))  return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic int minDeletionSize(String[] strs) {\\n         // initializing deletCol variable\\n        int deleteCol = 0;\\n\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix\\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            String tempStr = \"\";\\n            for(int j = 1; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n                // checking character are in sorted or not\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                        deleteCol ++;\\n                        break;\\n                }\\n            }\\n            //if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992427,
                "title": "simple-o-mn-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse array and check for condition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nouter loop:for loop for traversing a string\\ninner loop:for loop for checking the same index character over the array\\nif condition satisfied count++ and end inner for loop I used i==strs.length to end it\\nreturn count\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0;\\n        for(int j=0;j<strs[0].length();j++){\\n            for(int i=1;i<strs.length;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    cnt++;i=strs.length;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0;\\n        for(int j=0;j<strs[0].length();j++){\\n            for(int i=1;i<strs.length;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    cnt++;i=strs.length;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992264,
                "title": "dart-solution-beats-100",
                "content": "# Complexity\\n### Time complexity:\\n- $$O(n*m)$$ -> worst case \\n    - Where (n) is the number of **strs** , and (m) is the length of strings.\\n\\n- **Space complexity**:\\nSolution is : $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nint minDeletionSize(List<String> strs) {\\n  var deletedColumnsCount = 0;\\n  for (var i = 0; i < strs[0].length; i++) {\\n    for (var j = 0; j < strs.length - 1; j++) {\\n      if (strs[j][i].codeUnits[0] > strs[j + 1][i].codeUnits[0]) {\\n        deletedColumnsCount++;\\n        break;\\n      }\\n    }\\n  }\\n  return deletedColumnsCount;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nint minDeletionSize(List<String> strs) {\\n  var deletedColumnsCount = 0;\\n  for (var i = 0; i < strs[0].length; i++) {\\n    for (var j = 0; j < strs.length - 1; j++) {\\n      if (strs[j][i].codeUnits[0] > strs[j + 1][i].codeUnits[0]) {\\n        deletedColumnsCount++;\\n        break;\\n      }\\n    }\\n  }\\n  return deletedColumnsCount;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991752,
                "title": "o-n-m-easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char curr=\\'a\\';\\n            for(string s:strs)\\n            {\\n                if(s[i]>=curr) curr=s[i];\\n                else\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char curr=\\'a\\';\\n            for(string s:strs)\\n            {\\n                if(s[i]>=curr) curr=s[i];\\n                else\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991728,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n        int columnDel = 0;\\n        for(int i = 0; i < strs[0].Length; i++)\\n        {\\n            for(int j = 0; j < strs.Length-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnDel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return columnDel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n        int columnDel = 0;\\n        for(int i = 0; i < strs[0].Length; i++)\\n        {\\n            for(int j = 0; j < strs.Length-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnDel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return columnDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991691,
                "title": "100-0ms-explained-beats-100-proof",
                "content": "# UPVOTE PLS\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c1030d8d-c24a-4807-aac6-96f28a069d50_1672740417.848588.png)\\n\\n# Complexity\\n- Time complexity: O(N*rowSize)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int deleted = 0;\\n        if (A == null || A.length == 0) return deleted;\\n        int rowSize = A[0].length();\\n        \\n        for (int col = 0; col < rowSize; col++){\\n            if (!isSorted(A, col)) deleted++;\\n        }\\n        \\n        return deleted;\\n    }\\n    \\n    boolean isSorted(String[] A, int col){\\n        int N = A.length;\\n        char prev = (char)0;\\n        for (int i = 0; i < N; i++){\\n            char c = A[i].charAt(col);\\n            //If out of order\\n            if (c < prev) return false;\\n            //update prev\\n            prev = c;\\n        }\\n        \\n        return true; //In order the whole time\\n    }\\n}\\n\\n\\npython \\n\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        return len([True for col in zip(*A) if sorted(col) != list(col)])\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int deleted = 0;\\n        if (A == null || A.length == 0) return deleted;\\n        int rowSize = A[0].length();\\n        \\n        for (int col = 0; col < rowSize; col++){\\n            if (!isSorted(A, col)) deleted++;\\n        }\\n        \\n        return deleted;\\n    }\\n    \\n    boolean isSorted(String[] A, int col){\\n        int N = A.length;\\n        char prev = (char)0;\\n        for (int i = 0; i < N; i++){\\n            char c = A[i].charAt(col);\\n            //If out of order\\n            if (c < prev) return false;\\n            //update prev\\n            prev = c;\\n        }\\n        \\n        return true; //In order the whole time\\n    }\\n}\\n\\n\\npython \\n\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        return len([True for col in zip(*A) if sorted(col) != list(col)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991545,
                "title": "ruby-1-liner",
                "content": "\\n\\n# Code\\n```ruby\\ndef min_deletion_size(strs)\\n    strs.map(&:chars).transpose.count{ |col| col.each_cons(2).any?{ _1 > _2 } } \\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_deletion_size < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_deletion_size([\"cba\",\"daf\",\"ghi\"])\\n        assert_equal 0, min_deletion_size([\"a\",\"b\"])\\n        assert_equal 3, min_deletion_size([\"zyx\",\"wvu\",\"tsr\"])\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_deletion_size(strs)\\n    strs.map(&:chars).transpose.count{ |col| col.each_cons(2).any?{ _1 > _2 } } \\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_deletion_size < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_deletion_size([\"cba\",\"daf\",\"ghi\"])\\n        assert_equal 0, min_deletion_size([\"a\",\"b\"])\\n        assert_equal 3, min_deletion_size([\"zyx\",\"wvu\",\"tsr\"])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991268,
                "title": "commented-line-by-line-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        # count: to store no of columns we need to delete\\n        count=0\\n        # for columns\\n        for col in range(len(strs[0])):\\n            #for rows\\n            for row in range(1,len(strs)):\\n                #if current char is smaller than previous char in that column\\n                #then we need to delete that column \\n                #so just increase the count\\n                if strs[row-1][col] > strs[row][col]:\\n                    count+=1\\n                    #break bcz if any char is not sorted lexi.. \\n                    #then the whole will be deleted\\n                    #so need to check further char of column\\n                    break\\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        # count: to store no of columns we need to delete\\n        count=0\\n        # for columns\\n        for col in range(len(strs[0])):\\n            #for rows\\n            for row in range(1,len(strs)):\\n                #if current char is smaller than previous char in that column\\n                #then we need to delete that column \\n                #so just increase the count\\n                if strs[row-1][col] > strs[row][col]:\\n                    count+=1\\n                    #break bcz if any char is not sorted lexi.. \\n                    #then the whole will be deleted\\n                    #so need to check further char of column\\n                    break\\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991085,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        vector<char> v[1005];\\n        for(int j=0; j<strs[0].size(); j++) {\\n            for(int i=0; i<strs.size(); i++) {\\n                v[j].push_back(strs[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<strs[0].size(); i++) {\\n            if(!is_sorted(v[i].begin(), v[i].end())) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        vector<char> v[1005];\\n        for(int j=0; j<strs[0].size(); j++) {\\n            for(int i=0; i<strs.size(); i++) {\\n                v[j].push_back(strs[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<strs[0].size(); i++) {\\n            if(!is_sorted(v[i].begin(), v[i].end())) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991001,
                "title": "simple-and-easy-to-understand-c",
                "content": "# Intuition\\n**Basically 2-D vector traversal**\\n# Approach\\nFirst, we are traversing throgh the entire string vector and checking whether the first character  of consecutive strings are in alphabetical order or not ,then the second character ...... upto the last character.\\n# Complexity\\n- Time complexity:\\n# **O(n*m)**\\nwhere n = size of each individual string \\n      m = size of string vector\\n\\n- Space complexity:\\n# **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans =0 , n=strs[1].size();\\n        int  j=0;\\n        while(j<n){\\n            int i=0;\\n            while(i<(strs.size())-1){\\n                string a = strs[i] ,b = strs[i+1];\\n                if(a[j] <= b[j]){\\n                    i++;\\n                }\\n                else{\\n                    ans++;\\n                    i++;\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans =0 , n=strs[1].size();\\n        int  j=0;\\n        while(j<n){\\n            int i=0;\\n            while(i<(strs.size())-1){\\n                string a = strs[i] ,b = strs[i+1];\\n                if(a[j] <= b[j]){\\n                    i++;\\n                }\\n                else{\\n                    ans++;\\n                    i++;\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990942,
                "title": "using-defaultdict-and-iterative-process-lengthy-easy-but-slow",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        to_delete = 0\\n        column_values = defaultdict(str)\\n        for i in range(len(strs[0])):\\n            for j in range(len(strs)):\\n                column_values[i] += strs[j][i]\\n        for each in column_values.values():\\n            if list(each) != sorted(each):\\n                to_delete += 1\\n        return to_delete\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        to_delete = 0\\n        column_values = defaultdict(str)\\n        for i in range(len(strs[0])):\\n            for j in range(len(strs)):\\n                column_values[i] += strs[j][i]\\n        for each in column_values.values():\\n            if list(each) != sorted(each):\\n                to_delete += 1\\n        return to_delete\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990912,
                "title": "c-bruteforce-approach-o-m-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++){\\n            for(int i=0; i<row-1; i++){\\n                if(strs[i][j]>strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++){\\n            for(int i=0; i<row-1; i++){\\n                if(strs[i][j]>strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990837,
                "title": "c-space-o-1-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) \\n    {\\n        int del_count = 0;\\n        for(int j = 0; j<s[0].size(); j++)\\n        {\\n            for(int i = 1; i<s.size(); i++)\\n            {\\n                if(s[i-1][j]>s[i][j])\\n                {\\n                    del_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return del_count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) \\n    {\\n        int del_count = 0;\\n        for(int j = 0; j<s[0].size(); j++)\\n        {\\n            for(int i = 1; i<s.size(); i++)\\n            {\\n                if(s[i-1][j]>s[i][j])\\n                {\\n                    del_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return del_count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990830,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# **Please share and upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990483,
                "title": "python3-simple-solutions",
                "content": "**Solution 1: for-loop**\\nhttps://leetcode.com/submissions/detail/870170112/\\nRuntime: **289 ms**, faster than 55.16% of Python3 online submissions for Delete Columns to Make Sorted.  \\nMemory Usage: 14.6 MB, less than 93.05% of Python3 online submissions for Delete Columns to Make Sorted.  \\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_rows, n_cols, n_del = len(strs), len(strs[0]), 0\\n        for j in range(n_cols):\\n            col_sorted = True\\n            for i in range(n_rows-1):\\n                if strs[i][j]>strs[i+1][j]:\\n                    col_sorted = False\\n                    break\\n            if not col_sorted:\\n                n_del += 1\\n        return n_del  \\n```\\n\\n**Solution 1.1: zip() and set()**  \\nhttps://leetcode.com/submissions/detail/870234000/\\nRuntime: **173 ms**, faster than 72.63% of Python3 online submissions for Delete Columns to Make Sorted.\\nMemory Usage: 14.6 MB, less than 61.89% of Python3 online submissions for Delete Columns to Make Sorted.\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_row = len(strs)\\n        if n_row<=1: return 0\\n        cols_del = set()\\n        for i in range(n_row-1):\\n            for j,(c1,c2) in enumerate(zip(strs[i], strs[i+1])):\\n                if (j not in cols_del) and c1>c2:\\n                    cols_del.add(j)\\n        return len(cols_del)\\n```\\n\\n**Solution 2: numpy**  \\nhttps://leetcode.com/submissions/detail/870207660/  \\nRuntime: **492 ms**    \\nMemory Usage: 34.2 MB  \\n```\\nimport numpy as np\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        if len(strs)<=1: return 0\\n        arr = np.array([[ord(c) for c in s] for s in strs])\\n        return np.sum((np.any(np.greater(arr[:-1], arr[1:]), axis=0)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_rows, n_cols, n_del = len(strs), len(strs[0]), 0\\n        for j in range(n_cols):\\n            col_sorted = True\\n            for i in range(n_rows-1):\\n                if strs[i][j]>strs[i+1][j]:\\n                    col_sorted = False\\n                    break\\n            if not col_sorted:\\n                n_del += 1\\n        return n_del  \\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_row = len(strs)\\n        if n_row<=1: return 0\\n        cols_del = set()\\n        for i in range(n_row-1):\\n            for j,(c1,c2) in enumerate(zip(strs[i], strs[i+1])):\\n                if (j not in cols_del) and c1>c2:\\n                    cols_del.add(j)\\n        return len(cols_del)\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        if len(strs)<=1: return 0\\n        arr = np.array([[ord(c) for c in s] for s in strs])\\n        return np.sum((np.any(np.greater(arr[:-1], arr[1:]), axis=0)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990383,
                "title": "simple-typescript-code-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(N*M) N = string length, M = strs array length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minDeletionSize(strs: string[]): number {\\n    \\n    const N = strs[0].length\\n    const M = strs.length\\n    let count = 0\\n\\n    // traverse each  columns\\n    for(let i=0; i< N; i++){;\\n        // traverse each row \\n        for(let j = 1; j < M; j++){\\n            // check previous char should be smaller or equall in case of greater\\n            // break the loop bcoz we need to delete that column.\\n            // main the count of delete\\n            if(strs[j-1].charCodeAt(i) > strs[j].charCodeAt(i)){\\n                count++\\n                break;\\n            }\\n        }\\n    }\\n    return count\\n}; \\n```\\n**If you like this solution please upvode, Thanks**",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction minDeletionSize(strs: string[]): number {\\n    \\n    const N = strs[0].length\\n    const M = strs.length\\n    let count = 0\\n\\n    // traverse each  columns\\n    for(let i=0; i< N; i++){;\\n        // traverse each row \\n        for(let j = 1; j < M; j++){\\n            // check previous char should be smaller or equall in case of greater\\n            // break the loop bcoz we need to delete that column.\\n            // main the count of delete\\n            if(strs[j-1].charCodeAt(i) > strs[j].charCodeAt(i)){\\n                count++\\n                break;\\n            }\\n        }\\n    }\\n    return count\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990263,
                "title": "c-most-easy-solution-if-else-statement",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0; // to count the non equal column\\n        int col = strs[0].size(); // column\\n        int row = strs.size(); // row\\n\\n\\n        for(int i=0; i<col; i++) // iterating throught column\\n        { \\n          // 1. 1st loop select the first column\\n          // 2. 2nd loop itreates row wise and checks the element of the colum nin each row\\n          // 3. if the ascii of the element is greater than the ascii of the next element it is not sorted\\n\\n            for(int j=0; j<row-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt; // return the non sorted column\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0; // to count the non equal column\\n        int col = strs[0].size(); // column\\n        int row = strs.size(); // row\\n\\n\\n        for(int i=0; i<col; i++) // iterating throught column\\n        { \\n          // 1. 1st loop select the first column\\n          // 2. 2nd loop itreates row wise and checks the element of the colum nin each row\\n          // 3. if the ascii of the element is greater than the ascii of the next element it is not sorted\\n\\n            for(int j=0; j<row-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt; // return the non sorted column\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990201,
                "title": "simple-easy-to-understand-brute-force-implementation-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int coldel = 0;\\n        for(int i=0; i<strs[0].size();i++)\\n        {\\n            for(int j=0; j <strs.size()-1;j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    coldel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return coldel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int coldel = 0;\\n        for(int i=0; i<strs[0].size();i++)\\n        {\\n            for(int j=0; j <strs.size()-1;j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    coldel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return coldel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989982,
                "title": "c-count-unsorted-columns-brute-force",
                "content": "# Approach\\n1. Traverse all strings column by column\\n2. Compare $$col$$th character of $$row$$th string with  $$col$$th character of $$row-1$$th string and increase $$ans$$ by $$1$$ if first character is lexographically greater than latter character\\n# Complexity\\n- Time complexity: $$O(n*m)$$ , where n is the number of strings in array and m is the length of each string \\n\\n- Space complexity: $$O(1)$$(Integer variables: n , len , ans , row , col)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size() , len=strs[0].length() , ans=0;\\n\\n        for(int col=0;col<len;col++)\\n        {\\n            for(int row=1;row<n;row++)\\n            {\\n                if(strs[row-1][col]>strs[row][col]) //Column is unsorted \\n                {\\n                    ans++;\\n                    break; //no need to check further in column\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size() , len=strs[0].length() , ans=0;\\n\\n        for(int col=0;col<len;col++)\\n        {\\n            for(int row=1;row<n;row++)\\n            {\\n                if(strs[row-1][col]>strs[row][col]) //Column is unsorted \\n                {\\n                    ans++;\\n                    break; //no need to check further in column\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989974,
                "title": "leetcode-official-answer-with-python-implementation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. --> \\nTake k = len(strs[0]) and ans = 0\\nIterate over the letters and second iteration over words and then check if the characters are in lexographical order or not, if not then increment ans by 1 and at last return ans.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        k = len(strs[0])\\n        ans = 0\\n        for col in range(0,k):\\n            for row in range(1,len(strs)):\\n                if strs[row][col] < strs[row-1][col]:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        k = len(strs[0])\\n        ans = 0\\n        for col in range(0,k):\\n            for row in range(1,len(strs)):\\n                if strs[row][col] < strs[row-1][col]:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989901,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse Column wise , if any current character of column is smaller than previous character count that column and break\\n\\n# Complexity\\n- Time complexity: (length of words)*(number of words)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i;i<strs[0].size();i++){\\n            for(int j=1;j<strs.size();j++){\\n                if(strs[j][i]<strs[j-1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i;i<strs[0].size();i++){\\n            for(int j=1;j<strs.size();j++){\\n                if(strs[j][i]<strs[j-1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989812,
                "title": "brute-force-simple-java-solution-beats-93-3",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int n=strs.length;\\n        int m=strs[0].length();\\n        int count=0;\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int n=strs.length;\\n        int m=strs[0].length();\\n        int count=0;\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989806,
                "title": "daily-leetcode-challenge-c-day-3",
                "content": "# Complexity\\n- Time complexity: O(row*column)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count = 0; // Counting number of deleted columns\\n        int row = strs.size(); // Counting number of rows\\n        int column = strs[0].size(); // Counting number of columns\\n        // First we will iterate through column and then row\\n        for(int j = 0; j < column; j++){\\n            for(int i = 0; i < row-1; i++){\\n                // If not sorted lexicographically then we count and then break that column because no mean to check further in that column \\n                if(strs[i][j] > strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count = 0; // Counting number of deleted columns\\n        int row = strs.size(); // Counting number of rows\\n        int column = strs[0].size(); // Counting number of columns\\n        // First we will iterate through column and then row\\n        for(int j = 0; j < column; j++){\\n            for(int i = 0; i < row-1; i++){\\n                // If not sorted lexicographically then we count and then break that column because no mean to check further in that column \\n                if(strs[i][j] > strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989732,
                "title": "c-begineer-friendly-easy-understanding-string-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=O35j95MSIZQ/\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minDeletionSize(vector<string>& strs) {\\n        // count no. of rows and coln.\\n        int rows = strs.size();\\n        int colns = strs[0].size();\\n\\n        // store the ans\\n        int ans =0;\\n\\n        // Traverse column wise and for each row.\\n        for(int i=0;i<colns;i++){\\n            for(int j=1;j<rows;j++){\\n                // if previous row as higher value mean not sorted hence increase the value\\u2003of ans and break the inner loop for checking next column.\\n                if(strs[j-1][i]>strs[j][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minDeletionSize(vector<string>& strs) {\\n        // count no. of rows and coln.\\n        int rows = strs.size();\\n        int colns = strs[0].size();\\n\\n        // store the ans\\n        int ans =0;\\n\\n        // Traverse column wise and for each row.\\n        for(int i=0;i<colns;i++){\\n            for(int j=1;j<rows;j++){\\n                // if previous row as higher value mean not sorted hence increase the value\\u2003of ans and break the inner loop for checking next column.\\n                if(strs[j-1][i]>strs[j][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989545,
                "title": "c-0ms-fastest-solution-100-fast-beginner-friendly-clean-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0;\\n\\n        for(int j = 0; j < strs[0].size(); ++j)\\n        {\\n            for(int i = 0; i < strs.size() - 1; ++i)\\n            {\\n                if(strs[i][j] > strs[i+1][j])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0;\\n\\n        for(int j = 0; j < strs[0].size(); ++j)\\n        {\\n            for(int i = 0; i < strs.size() - 1; ++i)\\n            {\\n                if(strs[i][j] > strs[i+1][j])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989286,
                "title": "c-parsing-by-column-with-condition-100-time-31ms-75-space-12-2mb",
                "content": "Nice problem for an easy one: not trivial, not trite.\\n\\nTo solve it, we will go and check each column separately, stopping as soon as we find an element out of order and increasing a counter with that information.\\n\\nStarting from our usual support variables, we will have:\\n* `res`, our counter of the unsorted columns, initialised to be `0`;\\n* `sorted`, a boolean flag we will use in our inner loop.\\n\\nWe will then go with `x` through each column and:\\n* reset the loop variables `prev` and `sorted` to `0` and `true`, respectively;\\n* loop through each row in the column with `y` and:\\n    * assign the value of the current cell `strs[y][x]` to `curr`;\\n    * deal with two cases:\\n        * if `curr` is not sorted in non-decreasing order (ie: `curr < prev`), we will:\\n            * flag `sorted` to be `false`;\\n            * `break` out of the inner loop;\\n        * otherwise, we will just set `prev` to be `curr` for the next iteration;\\n* increase `res` by `1` if we end the loop with `sorted == false`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // support variables\\n        int res = 0;\\n        bool sorted;\\n        // parsing strs\\n        for (int x = 0, lmtX = strs[0].size(), prev, curr; x < lmtX; x++) {\\n            // resetting loop variables\\n            prev = 0, sorted = true;\\n            // parsing the current column\\n            for (int y = 0, lmtY = strs.size(); y < lmtY; y++) {\\n                curr = strs[y][x];\\n                // case 1: unsorted element\\n                if (curr < prev) {\\n                    sorted = false;\\n                    break;\\n                }\\n                // case 2: sorted element\\n                else prev = curr;\\n            }\\n            res += !sorted;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/353991ba-eef3-4c40-944d-77568c01021d_1672707709.4222438.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // support variables\\n        int res = 0;\\n        bool sorted;\\n        // parsing strs\\n        for (int x = 0, lmtX = strs[0].size(), prev, curr; x < lmtX; x++) {\\n            // resetting loop variables\\n            prev = 0, sorted = true;\\n            // parsing the current column\\n            for (int y = 0, lmtY = strs.size(); y < lmtY; y++) {\\n                curr = strs[y][x];\\n                // case 1: unsorted element\\n                if (curr < prev) {\\n                    sorted = false;\\n                    break;\\n                }\\n                // case 2: sorted element\\n                else prev = curr;\\n            }\\n            res += !sorted;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930441,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n\\n        int cnt = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            bool flag = true;\\n            for (int j = 0; j < strs.size() - 1; j++) {\\n                if (strs[j][i] > strs[j + 1][i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag == false) {\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n\\n        int cnt = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            bool flag = true;\\n            for (int j = 0; j < strs.size() - 1; j++) {\\n                if (strs[j][i] > strs[j + 1][i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag == false) {\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851555,
                "title": "swift-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        var strs = strs.map { Array($0) }\\n\\t\\tvar result = 0\\n\\n\\t\\tfor column in 0..<strs[0].count {\\n\\t\\t\\tfor row in 0..<strs.count - 1 {\\n\\t\\t\\t\\tif strs[row][column] > strs[row + 1][column] {\\n\\t\\t\\t\\t\\tresult += 1\\n                    break\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        var strs = strs.map { Array($0) }\\n\\t\\tvar result = 0\\n\\n\\t\\tfor column in 0..<strs[0].count {\\n\\t\\t\\tfor row in 0..<strs.count - 1 {\\n\\t\\t\\t\\tif strs[row][column] > strs[row + 1][column] {\\n\\t\\t\\t\\t\\tresult += 1\\n                    break\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596251,
                "title": "js-simple-solution-with-o-n-2-easy-understand",
                "content": "```\\nvar minDeletionSize = function(strs) {\\n    let output = 0;\\n    for (let i = 0 ; i < strs[0].length; i++) {\\n        let isSorted = true;\\n        for (let j = 0 ; j < strs.length - 1; j++) {\\n            if (strs[j + 1][i] < strs[j][i]) {\\n                isSorted = false;\\n                break;\\n            }\\n        }\\n        if (!isSorted) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDeletionSize = function(strs) {\\n    let output = 0;\\n    for (let i = 0 ; i < strs[0].length; i++) {\\n        let isSorted = true;\\n        for (let j = 0 ; j < strs.length - 1; j++) {\\n            if (strs[j + 1][i] < strs[j][i]) {\\n                isSorted = false;\\n                break;\\n            }\\n        }\\n        if (!isSorted) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446370,
                "title": "java-o-n-m-6-ms",
                "content": "**Approach** : For every column, we keep track of the largest character visited, if we encounter a smaller character, that column has to be deleted\\n\\nConsider the following `strs`\\n```\\n[\"qowfc\",\"spyge\",\"sqbif\",\"vvrkk\"]\\u2935\\n\\n    |q o w f c|\\n\\t|s p y g e|     \\n\\t|s q b i f|\\n\\t|v v r k k|\\n```\\nFor the `1st` column we have `q <= s <= s <= v`, this column will not be deleted ( similary `2nd ,4th` column)\\nFor the `3rd` column we have `w <= y > b <= r`\\n\\n\\n**Time Complexity** : O(N*M)\\n**Space Complexity** : O(1)\\n\\nImplementation\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int n = strs.length, m = strs[0].length(),ans = 0;\\n        \\n        for(int j = 0;j<m;j++){\\n            \\n            int prev = 0; // largest previous character so far (we initialize this with \\'a\\')\\n            \\n            boolean toBeDeleted = false; \\n            \\n            for(int i = 0;i<n;i++){\\n                \\n                int cur = strs[i].charAt(j) - \\'a\\';\\n                \\n                if(cur >= prev){   // update prev if we get a larger character\\n                    \\n                    prev = cur;\\n                    \\n                }else{  // otherwise this column will be deleted\\n                    \\n                    toBeDeleted = true;\\n                    \\n                    break;\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            if(toBeDeleted) ans++; // increment count of deleted columns\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[\"qowfc\",\"spyge\",\"sqbif\",\"vvrkk\"]\\u2935\\n\\n    |q o w f c|\\n\\t|s p y g e|     \\n\\t|s q b i f|\\n\\t|v v r k k|\\n```\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int n = strs.length, m = strs[0].length(),ans = 0;\\n        \\n        for(int j = 0;j<m;j++){\\n            \\n            int prev = 0; // largest previous character so far (we initialize this with \\'a\\')\\n            \\n            boolean toBeDeleted = false; \\n            \\n            for(int i = 0;i<n;i++){\\n                \\n                int cur = strs[i].charAt(j) - \\'a\\';\\n                \\n                if(cur >= prev){   // update prev if we get a larger character\\n                    \\n                    prev = cur;\\n                    \\n                }else{  // otherwise this column will be deleted\\n                    \\n                    toBeDeleted = true;\\n                    \\n                    break;\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            if(toBeDeleted) ans++; // increment count of deleted columns\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356993,
                "title": "c-bruteforce-with-explanation-59ms-63",
                "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        vector<string>sk;\\n        string c;\\n        string d;\\n        char l;\\n        int count=0;\\n        int io=0;\\n        for(int i=0;i<strs[io].length();i++){ //adding every column of string to vector;\\n            for(int j=0;j<strs.size();j++){\\n                c+=strs[j][i];\\n\\n            }\\n\\t\\t  sk.push_back(c);\\n\\t\\t\\tc=\"\";                   ///initializing back to 0;\\n\\t}\\n\\n\\n\\tfor(int i=0;i<sk.size();i++){       //now seaching among the sk[i] if found greater than initailize it and comparing with next and incrementing count if found!\\n\\t\\td=sk[i];\\n\\t\\t l=d[0];\\n\\t\\tfor(int j=1;j<d.length();j++){\\n\\t\\t\\tif(d[j]>l){\\n\\t\\t\\t\\tl=d[j];\\n\\t\\t\\t}\\n\\t\\t\\tif(d[j]<l){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        vector<string>sk;\\n        string c;\\n        string d;\\n        char l;\\n        int count=0;\\n        int io=0;\\n        for(int i=0;i<strs[io].length();i++){ //adding every column of string to vector;\\n            for(int j=0;j<strs.size();j++){\\n                c+=strs[j][i];\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2241960,
                "title": "actually-fast-python-solution",
                "content": "```\\ndef minDeletionSize(self, strs):\\n        count = 0\\n        for column in zip(*strs):\\n            if list(column) != sorted(column):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minDeletionSize(self, strs):\\n        count = 0\\n        for column in zip(*strs):\\n            if list(column) != sorted(column):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1546060,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        vector<int> visited(strs[0].length(),0);\\n        for(int i=0;i<strs.size()-1;i++){\\n            for(int j=0;j<strs[0].length();j++){\\n                if(strs[i][j]>strs[i+1][j] && visited[j]==0){\\n                    \\n                    ans++;\\n                    visited[j]=1;\\n                \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        vector<int> visited(strs[0].length(),0);\\n        for(int i=0;i<strs.size()-1;i++){\\n            for(int j=0;j<strs[0].length();j++){\\n                if(strs[i][j]>strs[i+1][j] && visited[j]==0){\\n                    \\n                    ans++;\\n                    visited[j]=1;\\n                \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1407387,
                "title": "simple-rust-solution",
                "content": "```\\n pub fn min_deletion_size(strs: Vec<String>) -> i32 {\\n        let mut ret = 0;\\n\\n        let mut new_strs: Vec<Vec<char>> = Vec::new();\\n\\n        for i in 0..strs.len() {\\n            new_strs.push(strs[i].chars().collect::<Vec<char>>());\\n        }\\n\\n        for i in 0..new_strs[0].len() {\\n           for j in 1..new_strs.len() {\\n               if new_strs[j-1][i] > new_strs[j][i] {\\n                   ret +=1;\\n                   break\\n               }\\n           }\\n        }\\n\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n pub fn min_deletion_size(strs: Vec<String>) -> i32 {\\n        let mut ret = 0;\\n\\n        let mut new_strs: Vec<Vec<char>> = Vec::new();\\n\\n        for i in 0..strs.len() {\\n            new_strs.push(strs[i].chars().collect::<Vec<char>>());\\n        }\\n\\n        for i in 0..new_strs[0].len() {\\n           for j in 1..new_strs.len() {\\n               if new_strs[j-1][i] > new_strs[j][i] {\\n                   ret +=1;\\n                   break\\n               }\\n           }\\n        }\\n\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350250,
                "title": "simple-c-solution",
                "content": "```\\n   int minDeletionSize(vector<string>& A) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int ans=0;\\n        \\n        int a=0;\\n        \\n        while(a<m){\\n        for(int i=0;i<A.size()-1;i++){\\n         \\n          if(A[i][a]>A[i+1][a]){\\n              ans++;\\n              break;\\n          }  \\n            \\n        }\\n            a++;\\n       }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int minDeletionSize(vector<string>& A) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int ans=0;\\n        \\n        int a=0;\\n        \\n        while(a<m){\\n        for(int i=0;i<A.size()-1;i++){\\n         \\n          if(A[i][a]>A[i+1][a]){\\n              ans++;\\n              break;\\n          }  \\n            \\n        }\\n            a++;\\n       }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118008,
                "title": "fastest-100-java-easy-with-comments",
                "content": "```\\n    public int minDeletionSize(String[] strs) {\\n        int c = 0; // counter\\n        \\n    outer: for(int col = 0; col <  strs[0].length();col++){  //key concept is to iterate column wise and not row wise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//so that it is ensures that we visit every column once!\\n        \\n       for(int row = 0; row < strs.length - 1; row++){\\n\\t   \\n                if(strs[row + 1].charAt(col) - strs[row].charAt(col) >= 0){ //check order\\n                    continue;\\n                }\\n                else {\\n                    c++;\\n                    continue outer; // jump to next columns\\n                }\\n                \\n            } \\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minDeletionSize(String[] strs) {\\n        int c = 0; // counter\\n        \\n    outer: for(int col = 0; col <  strs[0].length();col++){  //key concept is to iterate column wise and not row wise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//so that it is ensures that we visit every column once!\\n        \\n       for(int row = 0; row < strs.length - 1; row++){\\n\\t   \\n                if(strs[row + 1].charAt(col) - strs[row].charAt(col) >= 0){ //check order\\n                    continue;\\n                }\\n                else {\\n                    c++;\\n                    continue outer; // jump to next columns\\n                }\\n                \\n            } \\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 953723,
                "title": "python-most-simple-o-nm-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        \\n        res = 0\\n        for pos in range(len(A[0])):\\n            for word in range(len(A)-1):\\n                if A[word][pos] > A[word+1][pos]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        \\n        res = 0\\n        for pos in range(len(A[0])):\\n            for word in range(len(A)-1):\\n                if A[word][pos] > A[word+1][pos]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 803740,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int d=0;\\n        for(int i=0;i<A[0].size();i++)\\n            for(int j=0;j+1<A.size();j++)\\n                if(A[j][i]>A[j+1][i]){\\n                    d++;\\n                    break;\\n                }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int d=0;\\n        for(int i=0;i<A[0].size();i++)\\n            for(int j=0;j+1<A.size();j++)\\n                if(A[j][i]>A[j+1][i]){\\n                    d++;\\n                    break;\\n                }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522732,
                "title": "simple-java-solution",
                "content": "```java\\nclass Solution {\\n    public int minDeletionSize(String[] a) {\\n        int deleteCount = 0;\\n        int strCount = a[0].length();\\n\\n        for (int i = 0; i < strCount; i++) {\\n            for (int j = 1; j < a.length; j++) {\\n                if (a[j].charAt(i) < a[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deleteCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minDeletionSize(String[] a) {\\n        int deleteCount = 0;\\n        int strCount = a[0].length();\\n\\n        for (int i = 0; i < strCount; i++) {\\n            for (int j = 1; j < a.length; j++) {\\n                if (a[j].charAt(i) < a[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deleteCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382127,
                "title": "solution-in-python-3-beats-100-one-line",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n    \\treturn sum(list(i) != sorted(i) for i in zip(*A))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n    \\treturn sum(list(i) != sorted(i) for i in zip(*A))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 280029,
                "title": "c-60-ms-faster-than-82-67-and-12-9-mb-less-than-98-91-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        if (A.size() <= 1)  return 0;\\n        int minDeletionSize = 0;\\n\\n        for (int i=0; i<A[0].size(); i++) {\\n            for (int j=1; j<A.size(); j++) {\\n                if (A[j-1][i] - A[j][i] > 0)  {\\n                    ++minDeletionSize;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return minDeletionSize;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        if (A.size() <= 1)  return 0;\\n        int minDeletionSize = 0;\\n\\n        for (int i=0; i<A[0].size(); i++) {\\n            for (int j=1; j<A.size(); j++) {\\n                if (A[j-1][i] - A[j][i] > 0)  {\\n                    ++minDeletionSize;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return minDeletionSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252883,
                "title": "javascript-solution-with-comments",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar minDeletionSize = function(A) {\\n    //Problem definition is worded to make it confusing.\\n    //TL;DR:\\n    //A is a 2D array of ints\\n    //Count the number of columns where the ints are not in ascending order.\\n    \\n    //Solution:\\n    //We\\'ll search the 2D array column by column. If we find one int out of order - we\\'ll add 1 to our count, and move on.\\n    //O(n) time complexity. O(1) space complexity.\\n    //\\n    //No faster way, since finding one column is out of order doesn\\'t tell us anything about any other columns.\\n    //As a plus though, this problem could be paralellized using SIMD instructions or threads.\\n    //But this is Javascript, so who cares about speed.\\n    \\n    //Useful Problem Constraints:\\n    //All strings are the same length.\\n    //All characters are ASCII.\\n    //There\\'s only <= 100 strings, each with <= 1000 characters.\\n    var columnsToDelete = 0;\\n    if (A.length == 0)\\n        return 0;\\n    \\n    var stringLength = A[0].length; //We know all strings are of the same length, so we can do this.\\n    for(var i = 0; i < stringLength; i++) //For each column/character in our string\\n    {\\n        for (var j = 0; j < A.length - 1; j++) //For each row/string... (-1 so we can compare this row with the next one)\\n        {\\n            var numValue = A[j][i];\\n            var nextNumValue = A[j+1][i];\\n            \\n            if (numValue > nextNumValue) //If we aren\\'t in ascending order\\n            {\\n                columnsToDelete++;\\n                break;\\n            }\\n\\n        }\\n    }\\n    \\n    return columnsToDelete;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar minDeletionSize = function(A) {\\n    //Problem definition is worded to make it confusing.\\n    //TL;DR:\\n    //A is a 2D array of ints\\n    //Count the number of columns where the ints are not in ascending order.\\n    \\n    //Solution:\\n    //We\\'ll search the 2D array column by column. If we find one int out of order - we\\'ll add 1 to our count, and move on.\\n    //O(n) time complexity. O(1) space complexity.\\n    //\\n    //No faster way, since finding one column is out of order doesn\\'t tell us anything about any other columns.\\n    //As a plus though, this problem could be paralellized using SIMD instructions or threads.\\n    //But this is Javascript, so who cares about speed.\\n    \\n    //Useful Problem Constraints:\\n    //All strings are the same length.\\n    //All characters are ASCII.\\n    //There\\'s only <= 100 strings, each with <= 1000 characters.\\n    var columnsToDelete = 0;\\n    if (A.length == 0)\\n        return 0;\\n    \\n    var stringLength = A[0].length; //We know all strings are of the same length, so we can do this.\\n    for(var i = 0; i < stringLength; i++) //For each column/character in our string\\n    {\\n        for (var j = 0; j < A.length - 1; j++) //For each row/string... (-1 so we can compare this row with the next one)\\n        {\\n            var numValue = A[j][i];\\n            var nextNumValue = A[j+1][i];\\n            \\n            if (numValue > nextNumValue) //If we aren\\'t in ascending order\\n            {\\n                columnsToDelete++;\\n                break;\\n            }\\n\\n        }\\n    }\\n    \\n    return columnsToDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252488,
                "title": "swift-fast-approach-216ms",
                "content": "216ms by using utf16 view of string.\\n\\n```\\nclass Solution {\\n    func minDeletionSize(_ A: [String]) -> Int {\\n        var d = 0\\n        for column in 0..<A[0].count {\\n            let columnIndex = A[0].utf16.index(A[0].utf16.startIndex, offsetBy: column)\\n            for row in 1..<A.count {\\n                if A[row][columnIndex] < A[row - 1][columnIndex] {\\n                    d += 1\\n                    break\\n                }\\n            }\\n        }\\n        return d\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ A: [String]) -> Int {\\n        var d = 0\\n        for column in 0..<A[0].count {\\n            let columnIndex = A[0].utf16.index(A[0].utf16.startIndex, offsetBy: column)\\n            for row in 1..<A.count {\\n                if A[row][columnIndex] < A[row - 1][columnIndex] {\\n                    d += 1\\n                    break\\n                }\\n            }\\n        }\\n        return d\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236378,
                "title": "javascript",
                "content": "```\\nvar minDeletionSize = function(A) {\\n    let result = 0\\n    const len = A[0].length\\n    for(let i = 0; i < len; i++) {\\n        for(let j = 1; j < A.length; j++){\\n            if(A[j][i] < A[j - 1][i]){\\n                result += 1\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDeletionSize = function(A) {\\n    let result = 0\\n    const len = A[0].length\\n    for(let i = 0; i < len; i++) {\\n        for(let j = 1; j < A.length; j++){\\n            if(A[j][i] < A[j - 1][i]){\\n                result += 1\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198881,
                "title": "fast-and-easy-to-understand-python-solution",
                "content": "With Zip\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n        count = 0\\n        \\n        for items in zip(*A):  # The * operator can be used in conjuncton with zip() to unzip the list.\\n            if sorted(items) != list(items):\\n                count += 1\\n                \\n        return count\\n```\\n\\nWith No Zip\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\tnew_A = []\\n\\t\\tcount = 0\\n\\n\\t\\tfor items in range(len(A[0])):\\n\\t\\t\\tcharacters = \\'\\'\\n\\n\\t\\t\\tfor item in range(len(A)):\\n\\t\\t\\t\\tcharacters += A[item][items]\\n\\n\\t\\t\\tnew_A.append(characters)\\n\\n\\t\\tfor items in new_A:\\n\\t\\t\\tif sorted(items) != list(items):\\n\\t\\t\\t\\tcount += 1\\n\\n\\t\\treturn count\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n        count = 0\\n        \\n        for items in zip(*A):  # The * operator can be used in conjuncton with zip() to unzip the list.\\n            if sorted(items) != list(items):\\n                count += 1\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\tnew_A = []\\n\\t\\tcount = 0\\n\\n\\t\\tfor items in range(len(A[0])):\\n\\t\\t\\tcharacters = \\'\\'\\n\\n\\t\\t\\tfor item in range(len(A)):\\n\\t\\t\\t\\tcharacters += A[item][items]\\n\\n\\t\\t\\tnew_A.append(characters)\\n\\n\\t\\tfor items in new_A:\\n\\t\\t\\tif sorted(items) != list(items):\\n\\t\\t\\t\\tcount += 1\\n\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195562,
                "title": "java-o-a-length-a-0-length-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int res = 0;\\n        int len = A[0].length();\\n        int n = A.length;\\n\\n        for (int j = 0; j < len; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (A[i].charAt(j) < A[i - 1].charAt(j)) {\\n                    ++res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int res = 0;\\n        int len = A[0].length();\\n        int n = A.length;\\n\\n        for (int j = 0; j < len; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (A[i].charAt(j) < A[i - 1].charAt(j)) {\\n                    ++res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785999,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] ary) {\\n        int count=0;   \\n         // imagine each word are raw \\n        int raw= ary.length;\\n        // imagine each word are colum\\n        int colum=ary[0].length();\\n        for(int j=0;j<colum;j++)\\n        {\\n            for(int i=0;i<raw-1;i++)\\n            {\\n               // check in colum wize\\n  if(ary[i].charAt(j)>ary[i+1].charAt(j))\\n                {\\n                     count++;\\n                    break;\\n                }\\n              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] ary) {\\n        int count=0;   \\n         // imagine each word are raw \\n        int raw= ary.length;\\n        // imagine each word are colum\\n        int colum=ary[0].length();\\n        for(int j=0;j<colum;j++)\\n        {\\n            for(int i=0;i<raw-1;i++)\\n            {\\n               // check in colum wize\\n  if(ary[i].charAt(j)>ary[i+1].charAt(j))\\n                {\\n                     count++;\\n                    break;\\n                }\\n              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610797,
                "title": "beats-90-cpp-sol",
                "content": "# Pls Upvote if Helpful **Bold**\\uD83D\\uDE07\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(string temp){\\n        for(int i = 0; i<temp.size()-1; i++){\\n            if(temp[i]>temp[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        int size = strs[0].size();\\n        int ans = 0;\\n        for(int i = 0; i<size; i++){\\n            string temp;\\n            for(int j = 0; j<strs.size(); j++){\\n                string s = strs[j];\\n                temp.push_back(s[i]);\\n            }\\n\\n            // if string is lexographically not sorted inc count\\n            if(check(temp)==false){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(string temp){\\n        for(int i = 0; i<temp.size()-1; i++){\\n            if(temp[i]>temp[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        int size = strs[0].size();\\n        int ans = 0;\\n        for(int i = 0; i<size; i++){\\n            string temp;\\n            for(int j = 0; j<strs.size(); j++){\\n                string s = strs[j];\\n                temp.push_back(s[i]);\\n            }\\n\\n            // if string is lexographically not sorted inc count\\n            if(check(temp)==false){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525295,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(NULL);\\n        std::cout.tie(NULL);\\n    }\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n        if (strs.size() == 1)\\n        {\\n            return 0;\\n        }\\n        std::vector<bool> toDelete(strs[0].size(), false);\\n        for (int r = 1; r < strs.size(); ++r)\\n        {\\n            auto const& curr = strs[r];\\n            auto const& last = strs[r-1];\\n            for (int c = 0; c < strs[0].size(); ++c)\\n            {\\n                if (toDelete[c])\\n                {\\n                    continue;\\n                }\\n                if (curr[c] < last[c])\\n                {\\n                    toDelete[c] = true;\\n                }\\n            }\\n        }\\n        return std::accumulate(toDelete.begin(), toDelete.end(), 0);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        char_matrix = []\\n        count = 0\\n        for column in zip(*strs):\\n            char_matrix.append(list(column))\\n        for col in char_matrix:\\n            if col != sorted(col):\\n                count += 1\\n        return count\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int columnsCount = 0;\\n        if(strs==null || strs.length==0){\\n            return columnsCount;\\n        }\\n        int strLen = strs[0].length();\\n        for(int coulmnNum=0; coulmnNum<strLen; coulmnNum++){\\n            if(!isCoulmnOrder(strs, coulmnNum)){\\n                columnsCount++;\\n            }\\n        }\\n        return columnsCount;\\n    }\\n    private boolean isCoulmnOrder(String[] strs, int coulmnNum){\\n        char currChar = \\'a\\';\\n        int linesCount = strs.length;\\n        for(int lineNum = 0; lineNum<linesCount; lineNum++ ){\\n            char nextChar = strs[lineNum].charAt(coulmnNum);\\n            if(currChar>nextChar){\\n                return false;\\n            }\\n            currChar = nextChar;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(NULL);\\n        std::cout.tie(NULL);\\n    }\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n        if (strs.size() == 1)\\n        {\\n            return 0;\\n        }\\n        std::vector<bool> toDelete(strs[0].size(), false);\\n        for (int r = 1; r < strs.size(); ++r)\\n        {\\n            auto const& curr = strs[r];\\n            auto const& last = strs[r-1];\\n            for (int c = 0; c < strs[0].size(); ++c)\\n            {\\n                if (toDelete[c])\\n                {\\n                    continue;\\n                }\\n                if (curr[c] < last[c])\\n                {\\n                    toDelete[c] = true;\\n                }\\n            }\\n        }\\n        return std::accumulate(toDelete.begin(), toDelete.end(), 0);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        char_matrix = []\\n        count = 0\\n        for column in zip(*strs):\\n            char_matrix.append(list(column))\\n        for col in char_matrix:\\n            if col != sorted(col):\\n                count += 1\\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int columnsCount = 0;\\n        if(strs==null || strs.length==0){\\n            return columnsCount;\\n        }\\n        int strLen = strs[0].length();\\n        for(int coulmnNum=0; coulmnNum<strLen; coulmnNum++){\\n            if(!isCoulmnOrder(strs, coulmnNum)){\\n                columnsCount++;\\n            }\\n        }\\n        return columnsCount;\\n    }\\n    private boolean isCoulmnOrder(String[] strs, int coulmnNum){\\n        char currChar = \\'a\\';\\n        int linesCount = strs.length;\\n        for(int lineNum = 0; lineNum<linesCount; lineNum++ ){\\n            char nextChar = strs[lineNum].charAt(coulmnNum);\\n            if(currChar>nextChar){\\n                return false;\\n            }\\n            currChar = nextChar;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3477689,
                "title": "quick-and-easy-java-solution-be-consistent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n           for(int j=1;j<strs.length;j++)\\n           {\\n               if((int)strs[j].charAt(i)<(int)strs[j-1].charAt(i))\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n           for(int j=1;j<strs.length;j++)\\n           {\\n               if((int)strs[j].charAt(i)<(int)strs[j-1].charAt(i))\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282917,
                "title": "delete-columns-to-make-sorted-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int i, j, count=0;\\n        for(i=0 ; i<strs[0].size() ; i++)\\n        {\\n            for(j=0 ; j<strs.size()-1 ; j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int i, j, count=0;\\n        for(i=0 ; i<strs[0].size() ; i++)\\n        {\\n            for(j=0 ; j<strs.size()-1 ; j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237885,
                "title": "one-liner-beat-99-75ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nm * m log m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        \\n        return sum(1 for i in zip(*strs) if list(i) != sorted(i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        \\n        return sum(1 for i in zip(*strs) if list(i) != sorted(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071146,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int n=strs.size();\\n        int l=strs[0].length();\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int n=strs.size();\\n        int l=strs[0].length();\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012526,
                "title": "columnwise-matrix-traversal",
                "content": "# Intuition\\nWe need to do columnwise matrix traversal .\\n\\n# Approach\\n1. We must check whether the no.of rows == 1 beforehand to avoid unnecessary computation of strings because if there is only one row in the matrix it cannot be compared with another string of the same column and therefore the matrix will always remain sorted columnwise.  For Example strs = [\"abc\"] or [\"a\"] .\\n2.  We must use outer loop for traversing in columnwise manner among the strings .\\n3.   We must use the inner loop for traversing rows in the matrix or strings in the array according to a particular column or index respectively and check whether they are in lexicographical order or not . See the implementation attached below .\\n\\n# Complexity\\n- Time complexity:\\nO(N * K)\\nwhere \\nN = length of the array of strings \"strs\" ,\\nK = length of each string . \\n\\n- Space complexity:\\nO(1)\\nAs only an extra variable unsorted_columns is required .\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        if(strs.length == 1)\\n            return 0;\\n        int unsorted_columns = 0;\\n        for(int i = 0 ; i < strs[0].length() ; ++i)\\n        {\\n            for(int j = 0 ; j < (strs.length - 1) ; ++j)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    ++unsorted_columns;\\n                    break;\\n                }\\n            }\\n        }\\n        return unsorted_columns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        if(strs.length == 1)\\n            return 0;\\n        int unsorted_columns = 0;\\n        for(int i = 0 ; i < strs[0].length() ; ++i)\\n        {\\n            for(int j = 0 ; j < (strs.length - 1) ; ++j)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    ++unsorted_columns;\\n                    break;\\n                }\\n            }\\n        }\\n        return unsorted_columns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002005,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Check vertically for each column that its sorted lexicographically if not increase your count and jump to next column and check.\\n\\n# Complexity\\n- Time complexity: O(NM)\\nN = length of array of Strings\\nM = String length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int n = strs.length;\\n        for(int i = 0 ; i < strs[0].length(); i ++){\\n            int nums = (int)strs[0].charAt(i);\\n            for(int j = 1; j < n; j ++){\\n                if((int)strs[j].charAt(i) >= nums){\\n                    nums = (int)strs[j].charAt(i);\\n                }else{\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int n = strs.length;\\n        for(int i = 0 ; i < strs[0].length(); i ++){\\n            int nums = (int)strs[0].charAt(i);\\n            for(int j = 1; j < n; j ++){\\n                if((int)strs[j].charAt(i) >= nums){\\n                    nums = (int)strs[j].charAt(i);\\n                }else{\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000606,
                "title": "explained-well-with-pictures-c",
                "content": "\\n# Approach (Please like :D)\\n<!-- Describe your approach to solving the problem. -->\\nThe function starts by declaring three local integer variables: \"firstWordLength,\" \"lengthOfArray,\" and \"columnsDeleted.\" The value of \"firstWordLength\" is set to the length of the first string in the input array, \"strs.\" The value of \"lengthOfArray\" is set to the length of the array \"strs\" minus 1. The value of \"columnsDeleted\" is set to 0.\\n\\nThe function then enters a loop that iterates over the characters in the first string of the input array (which is stored at index 0). For each iteration of the loop, another loop is entered that iterates over the strings in the input array, starting at index 0 and ending at the second-to-last index.\\n\\nInside the inner loop, the function compares the character at the current index (which is stored in the variable \"i\") of the current string (which is stored in the variable \"j\") to the character at the same index of the next string (which is stored at index \"j+1\"). If the character in the current string is greater (i.e., has a higher ASCII value), the function increments the value of \"columnsDeleted\" by 1 and exits the inner loop using the \"break\" statement.\\n\\nAfter both loops have completed, the function returns the value of \"columnsDeleted.\\n\\n![image.png](https://assets.leetcode.com/users/images/6e5819bd-8665-4dcd-bf1e-72857588e0ef_1672886178.666302.png)\\n\\n# Complexity\\n- Time complexity: 130 - 200 ms ish \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n\\n\\n        int firstWordLength = strs[0].Length;\\n        int lengthOfArray = strs.Length-1;\\n        int columnsDeleted = 0;\\n\\n        for(int i = 0; i < firstWordLength; i++)\\n        {\\n            for(int j = 0; j < lengthOfArray; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnsDeleted++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        return columnsDeleted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n\\n\\n        int firstWordLength = strs[0].Length;\\n        int lengthOfArray = strs.Length-1;\\n        int columnsDeleted = 0;\\n\\n        for(int i = 0; i < firstWordLength; i++)\\n        {\\n            for(int j = 0; j < lengthOfArray; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnsDeleted++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        return columnsDeleted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997960,
                "title": "javascript-o-n-k-time-o-n-space",
                "content": "# Intuition\\nTo determine if the letters are in order, it\\'s enough to compare their ASCII values. We know that if previous letter is less than current letter, letters are in order. This is simplified even more since we know all items will be from lowercase english alphabet.\\n\\nIn javascript, it\\'s not necessary to extract that value using any methods, we can directly compare the strings. \\n\\n# Approach\\n1) Declare a counter variable, `res` (or any other name you prefer)\\n2) Iterate over columns\\n    - Iterate over rows\\n    - Check if the previous character in a column is less than the current one. If it is not, increment the counter. Break to avoid duplication of result.\\n3) Retun the answer\\n\\n\\n# Complexity\\n- Time complexity: O(N * K); N is the size of the array, K is the size of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let res = 0\\n\\n    for (let col = 0; col < strs[0].length; col++) {\\n        for (let row = 1; row < strs.length; row++) {\\n            if (strs[row][col] < strs[row - 1][col]) {\\n                res++\\n                break\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let res = 0\\n\\n    for (let col = 0; col < strs[0].length; col++) {\\n        for (let row = 1; row < strs.length; row++) {\\n            if (strs[row][col] < strs[row - 1][col]) {\\n                res++\\n                break\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997278,
                "title": "swift-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nk)$$, n \\u2013 word lenght, k \\u2013 number of words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        let strs = strs.map { Array($0) }\\n        var counter = 0\\n\\n        for column in 0..<strs[0].count {\\n            for row in 0..<strs.count - 1 {\\n                if strs[row][column] > strs[row + 1][column] {\\n                    counter += 1\\n                    break\\n                }\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        let strs = strs.map { Array($0) }\\n        var counter = 0\\n\\n        for column in 0..<strs[0].count {\\n            for row in 0..<strs.count - 1 {\\n                if strs[row][column] > strs[row + 1][column] {\\n                    counter += 1\\n                    break\\n                }\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996514,
                "title": "easy-understanding-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        int deletionCount = 0;\\n        \\n        for(int i=0; i<strs[0].length(); i++)\\n        {\\n            for(int j=0; j<strs.length-1; j++)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    deletionCount++; break;\\n                }\\n            }\\n        }\\n        return deletionCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        int deletionCount = 0;\\n        \\n        for(int i=0; i<strs[0].length(); i++)\\n        {\\n            for(int j=0; j<strs.length-1; j++)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    deletionCount++; break;\\n                }\\n            }\\n        }\\n        return deletionCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995935,
                "title": "c-easiest-solution-deep-and-concise-detailed-solution-t-c-o-row-col",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n\\n**T.C => O(row*col)**\\n\\n*col -> word.size()\\nrow -> arr.length()-1*\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n           int ans=0;\\n           int word_size = strs[0].size();\\n           \\n           // Traverse in col. No. of col is length of words in arr. (# size of each words is same).\\n           // Traverse in row. No. of rows is No. of words in arr. \\n\\n           for(int col=0; col<word_size; col++)\\n           {\\n                  for(int row=0; row<strs.size()-1; row++) // strs.size()-1 -> becoz we take next pointer\\n                  {\\n                      if(strs[row][col] > strs[row+1][col])\\n                      {\\n                          ans++; // increment no of rows\\n                          break;  // we found fault.\\n                      }\\n                  } \\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n           int ans=0;\\n           int word_size = strs[0].size();\\n           \\n           // Traverse in col. No. of col is length of words in arr. (# size of each words is same).\\n           // Traverse in row. No. of rows is No. of words in arr. \\n\\n           for(int col=0; col<word_size; col++)\\n           {\\n                  for(int row=0; row<strs.size()-1; row++) // strs.size()-1 -> becoz we take next pointer\\n                  {\\n                      if(strs[row][col] > strs[row+1][col])\\n                      {\\n                          ans++; // increment no of rows\\n                          break;  // we found fault.\\n                      }\\n                  } \\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994473,
                "title": "python-easy-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994326,
                "title": "java-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int c = 0;\\n\\n        for (int i = 0; i < strs[0].length(); i++){\\n            char temp = strs[0].charAt(i);\\n            for (String str : strs) {\\n                if (temp <= str.charAt(i)) {\\n                    temp = str.charAt(i);\\n                }else {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int c = 0;\\n\\n        for (int i = 0; i < strs[0].length(); i++){\\n            char temp = strs[0].charAt(i);\\n            for (String str : strs) {\\n                if (temp <= str.charAt(i)) {\\n                    temp = str.charAt(i);\\n                }else {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994295,
                "title": "c-traversing-row-and-column-solution",
                "content": "\\n# Code\\n```\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int cnt=0;\\n        int m=strs.size();\\n        int n=strs[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int cnt=0;\\n        int m=strs.size();\\n        int n=strs[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994282,
                "title": "944-delete-columns-to-make-sorted",
                "content": "Approach use two loops one for choosing a particular  word for each string\\nOther for for comparing like [\"cba\",\"daf\",\"ghi\"] a with b its check a next ele with previous one\\nIf you find the solution useful then an upvote would really be an O(n) decison :)\\n\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int oddOne=0;\\n        int n=strs.length; // whole arr length\\n        int m=strs[0].length(); // particular word length\\n        for(int i=0;i<m;i++) { // for coloums\\n            for(int j=1;j<n;j++) { // for rows \\n            if(strs[j].charAt(i) <strs[j-1].charAt(i)){\\n                oddOne++;\\n                break;    \\n            }      \\n        }  \\n    }\\n        return oddOne;\\n   }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int oddOne=0;\\n        int n=strs.length; // whole arr length\\n        int m=strs[0].length(); // particular word length\\n        for(int i=0;i<m;i++) { // for coloums\\n            for(int j=1;j<n;j++) { // for rows \\n            if(strs[j].charAt(i) <strs[j-1].charAt(i)){\\n                oddOne++;\\n                break;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2994243,
                "title": "simple-solution-using-java-o-n-k-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        short deletedColumsNumber =0;\\n\\n        for(int i=0; i<strs[0].length(); i++){\\n     \\n            char prev = strs[0].charAt(i);\\n            for(int j=1; j<strs.length;j++){\\n                if(strs[j].charAt(i)-\\'a\\' < prev -\\'a\\') {deletedColumsNumber++; break;}\\n                prev = strs[j].charAt(i);\\n            }\\n        }\\n        return deletedColumsNumber;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        short deletedColumsNumber =0;\\n\\n        for(int i=0; i<strs[0].length(); i++){\\n     \\n            char prev = strs[0].charAt(i);\\n            for(int j=1; j<strs.length;j++){\\n                if(strs[j].charAt(i)-\\'a\\' < prev -\\'a\\') {deletedColumsNumber++; break;}\\n                prev = strs[j].charAt(i);\\n            }\\n        }\\n        return deletedColumsNumber;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993992,
                "title": "easiest-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt=0;\\n\\n        for(int j=0; j<strs[0].size(); j++){\\n\\n          char c=strs[0][j];\\n\\n          for(int i=1; i<strs.size();i++){\\n                 \\n                 if(strs[i][j]>=c){\\n                     c=strs[i][j];\\n                 }\\n                 else{\\n                     cnt++;\\n                     break;\\n                 }\\n\\n          }\\n\\n        }\\n\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt=0;\\n\\n        for(int j=0; j<strs[0].size(); j++){\\n\\n          char c=strs[0][j];\\n\\n          for(int i=1; i<strs.size();i++){\\n                 \\n                 if(strs[i][j]>=c){\\n                     c=strs[i][j];\\n                 }\\n                 else{\\n                     cnt++;\\n                     break;\\n                 }\\n\\n          }\\n\\n        }\\n\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993950,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int r=strs.size();\\n        int count=0;\\n        int col=strs[0].size();\\n        for(int j=0;j<col;j++)\\n        {\\n            for(int i=0;i<r-1;i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int r=strs.size();\\n        int count=0;\\n        int col=strs[0].size();\\n        for(int j=0;j<col;j++)\\n        {\\n            for(int i=0;i<r-1;i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993880,
                "title": "easy-understandable-c-code-with-o-1-sapce",
                "content": "# Intuition\\n<!-- Instead of RowWise Traversal we have have to do ColumnWise Traversal  -->\\n\\n# Approach\\n<!-- Just compare the chars in vertical order traversal -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n*m) -->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // a -> 97.     z -> 122. (ASCII VALUES)\\n\\n        int cnt = 0;\\n        int m = strs[0].size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 1; j < strs.size(); j++)\\n            {\\n                // cout<<strs[j][i];\\n                if(strs[j-1][i] > strs[j][i]){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        // cout<<\"cnt\"<<cnt<<endl;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // a -> 97.     z -> 122. (ASCII VALUES)\\n\\n        int cnt = 0;\\n        int m = strs[0].size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 1; j < strs.size(); j++)\\n            {\\n                // cout<<strs[j][i];\\n                if(strs[j-1][i] > strs[j][i]){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        // cout<<\"cnt\"<<cnt<<endl;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2993854,
                "title": "accepted-with-comments-solution-easy-and-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993830,
                "title": "java-string-matrix-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString and array manipulation \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut each string character wise in a matrix format. Then check for each column of the matrix if it is not inserted in ascending format, increase the count and break. Then move to next column and check for the same constraint. Finally return the count.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int m = strs.length;\\n        int n = strs[0].length();\\n        int matrix[][] = new int[m][n];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                matrix[i][j] = strs[i].charAt(j) - \\'a\\';\\n            }\\n        }\\n        for(int j = 0;j<n;j++){\\n            for(int i = 1;i<m;i++){\\n                if(matrix[i][j] < matrix[i-1][j]){\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int m = strs.length;\\n        int n = strs[0].length();\\n        int matrix[][] = new int[m][n];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                matrix[i][j] = strs[i].charAt(j) - \\'a\\';\\n            }\\n        }\\n        for(int j = 0;j<n;j++){\\n            for(int i = 1;i<m;i++){\\n                if(matrix[i][j] < matrix[i-1][j]){\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993737,
                "title": "simple-intuition-with-easy-approach-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition is that we will have to iterate through the entire string vector and compare each char of each string in it.\\n\\nWe will also have to store the status of each column (whether sorted or not) to find out how many total columns do we actually need to delete.\\n\\n--> We cannot simply make a counter variable and do *counter++* when there is an unsorted occurance because a column may have more than one unsorted occurances and in this case, then result will be incorrect. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the vector of strings has only one element, then we do not need to delete anything because a single element is always sorted in itself. Hence, directly return 0.\\n2. Else, create a bool array (sorted here) of size equal to the number of columns such that each index denotes each column status.\\n3. Initially, initialize each column status as true (means sorted).\\n4. Iterate through the entire vector of strings from its second element and keep comparing its each char with the char of previous element at the same index.\\n5. If any unsorted order occurs, change the status of that corresponding column to false (denoting that it needs to be deleted).\\n6. Finally count all the number of false occurances in the bool array and return that value as the required output.\\n# Complexity\\n- Time complexity = $$O(n * len)$$\\nwhere, n = length of vector of strings and \\nlen = length of each string in it or the total number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity = $$O(n)$$\\nfor using boolean array to hold the status of each column.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& str) {\\n        int n = str.size() ;\\n\\n        if(n == 1) return 0 ;\\n\\n        int len = str[0].length() ;\\n        bool sorted[len] ;    //To store result of each column.\\n        memset(sorted, true, sizeof(sorted)) ;\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<len; j++){\\n                if(str[i][j] < str[i-1][j]){\\n                    sorted[j] = false ;\\n                }\\n            }\\n        }\\n\\n        int count = 0 ;\\n        for(int i=0; i<len; i++){\\n            if(!sorted[i]){\\n                count++ ;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& str) {\\n        int n = str.size() ;\\n\\n        if(n == 1) return 0 ;\\n\\n        int len = str[0].length() ;\\n        bool sorted[len] ;    //To store result of each column.\\n        memset(sorted, true, sizeof(sorted)) ;\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<len; j++){\\n                if(str[i][j] < str[i-1][j]){\\n                    sorted[j] = false ;\\n                }\\n            }\\n        }\\n\\n        int count = 0 ;\\n        for(int i=0; i<len; i++){\\n            if(!sorted[i]){\\n                count++ ;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993411,
                "title": "easy-to-understand-c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem first we are traversing column wise so here if any greater ascii value alphabet if comes first  then count value increases by 1 then break the loop then again check the next column so on .finally we got the result as the count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n**Please upvote if you like the solution.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993409,
                "title": "easy-to-understand-c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem first we are traversing column wise so here if any greater ascii value alphabet if comes first  then count value increases by 1 then break the loop then again check the next column so on .finally we got the result as the count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n**Please upvote if you like the solution.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993374,
                "title": "easy-java-solution",
                "content": "#\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int m=strs[0].length();\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<strs.length;j++){\\n                if(strs[j].charAt(i)<strs[j-1].charAt(i)){\\n                 ans++;\\n                 break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int m=strs[0].length();\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<strs.length;j++){\\n                if(strs[j].charAt(i)<strs[j-1].charAt(i)){\\n                 ans++;\\n                 break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993278,
                "title": "m-n-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int col,row,res=0;\\n        for(col=0;col<m;col++){\\n            for(row=0;row<n-1;row++){\\n                if(strs[row][col]<=strs[row+1][col]){\\n                    continue;\\n                }\\n                else{\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int col,row,res=0;\\n        for(col=0;col<m;col++){\\n            for(row=0;row<n-1;row++){\\n                if(strs[row][col]<=strs[row+1][col]){\\n                    continue;\\n                }\\n                else{\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993164,
                "title": "simple-c-by-nested-loop-to-check-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count_col = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            char prev = strs[0][i];\\n            char curr ;\\n            for (int j = 1; j < strs.size(); j++) {\\n                curr = strs[j][i];\\n                if (prev > curr) {\\n                    count_col++;\\n                    break;\\n                } else {\\n                    prev = curr;\\n                }\\n            }\\n        }\\n        return count_col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count_col = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            char prev = strs[0][i];\\n            char curr ;\\n            for (int j = 1; j < strs.size(); j++) {\\n                curr = strs[j][i];\\n                if (prev > curr) {\\n                    count_col++;\\n                    break;\\n                } else {\\n                    prev = curr;\\n                }\\n            }\\n        }\\n        return count_col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992996,
                "title": "c-o-n-m-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& vec) {\\n        int r = 0; int c = 0; int colDel = 0;\\n        while(c < vec[0].size()) {\\n            if(r == vec.size()-1){\\n                r = 0;\\n                c++;\\n            }\\n            else if(vec[r][c] > vec[r + 1][c]) {\\n                colDel++;\\n                c++;\\n                r = 0;\\n            }\\n            else r++;\\n        }\\n        return colDel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& vec) {\\n        int r = 0; int c = 0; int colDel = 0;\\n        while(c < vec[0].size()) {\\n            if(r == vec.size()-1){\\n                r = 0;\\n                c++;\\n            }\\n            else if(vec[r][c] > vec[r + 1][c]) {\\n                colDel++;\\n                c++;\\n                r = 0;\\n            }\\n            else r++;\\n        }\\n        return colDel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992952,
                "title": "c-easy-approach-counitng",
                "content": "\\n\\n# Approach\\nTo check every character in a Col. Col should be constant and row must be kept changing.\\nAfter, that checking if previous char is greater than next only then inc counter(delete col) and break that loop.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int  r = strs.size();\\n        int c = strs[0].size();\\n        int cnt=0;\\n        \\n//tricky in loops\\n        for(int i=0; i<c; i++){\\n            for(int j=0; j<r-1; j++){\\n                if (strs[j][i] > strs[j+1][i]) {\\n                cnt++;\\n                break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String Matching",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int  r = strs.size();\\n        int c = strs[0].size();\\n        int cnt=0;\\n        \\n//tricky in loops\\n        for(int i=0; i<c; i++){\\n            for(int j=0; j<r-1; j++){\\n                if (strs[j][i] > strs[j+1][i]) {\\n                cnt++;\\n                break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992829,
                "title": "c",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0,n=strs.size(),m=strs[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=strs[0][i]-\\'a\\';\\n            for(int j=1;j<n;j++)\\n            {\\n                if(a>strs[j][i]-\\'a\\') \\n                {\\n                    count++;\\n                    break;\\n                }\\n                a=strs[j][i]-\\'a\\';\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0,n=strs.size(),m=strs[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=strs[0][i]-\\'a\\';\\n            for(int j=1;j<n;j++)\\n            {\\n                if(a>strs[j][i]-\\'a\\') \\n                {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2992782,
                "title": "c-faster-than-99",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int res = 0;\\n        for (int i = 0; i < strs[0].size(); ++ i) {\\n            for (int j = 1; j < strs.size(); ++ j) {\\n                if (strs[j][i] < strs[j - 1][i]) {\\n                    ++ res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int res = 0;\\n        for (int i = 0; i < strs[0].size(); ++ i) {\\n            for (int j = 1; j < strs.size(); ++ j) {\\n                if (strs[j][i] < strs[j - 1][i]) {\\n                    ++ res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992502,
                "title": "cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j-1][i]>strs[j][i])\\n                {\\n                    ans+=1;\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n//upvote if you find it helpful\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j-1][i]>strs[j][i])\\n                {\\n                    ans+=1;\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n//upvote if you find it helpful\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992497,
                "title": "easy-java-solution-90-faster",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n- \\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n\\n    int count=0;\\n     for(int i=0;i<strs[0].length();i++)\\n     {\\n          char prev=\\'0\\';\\n         for(String s:strs)\\n         {\\n             char curr=s.charAt(i);\\n             if(prev>curr)\\n             {\\n                 count++;\\n                  break;\\n             }\\n             prev=curr;\\n         }\\n     }\\n     return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n\\n    int count=0;\\n     for(int i=0;i<strs[0].length();i++)\\n     {\\n          char prev=\\'0\\';\\n         for(String s:strs)\\n         {\\n             char curr=s.charAt(i);\\n             if(prev>curr)\\n             {\\n                 count++;\\n                  break;\\n             }\\n             prev=curr;\\n         }\\n     }\\n     return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992478,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n;\\n        int ans = 0;// no of columns to be deleted\\n        int k = 0; // for iterating over the length of string\\n        \\n        while(k < strs[0].length()) {\\n            int prev = (int) strs[0].charAt(k);\\n            for(int i = 1; i < strs.length; i++) { //iterating through array to check all strings\\n                int curr = (int) strs[i].charAt(k);\\n                if(curr < prev) {\\n                    ans++;\\n                    break;\\n                }else {\\n                    prev = curr;\\n                }\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n;\\n        int ans = 0;// no of columns to be deleted\\n        int k = 0; // for iterating over the length of string\\n        \\n        while(k < strs[0].length()) {\\n            int prev = (int) strs[0].charAt(k);\\n            for(int i = 1; i < strs.length; i++) { //iterating through array to check all strings\\n                int curr = (int) strs[i].charAt(k);\\n                if(curr < prev) {\\n                    ans++;\\n                    break;\\n                }else {\\n                    prev = curr;\\n                }\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992389,
                "title": "easy-c-code",
                "content": "\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int m=strs.size(),n=strs[0].size(),ans=0;\\n        for(int j=0;j<n;j++){\\n            bool flag=1;\\n            for(int i=1;i<m;i++){\\n            if(strs[i][j]<strs[i-1][j]){//unsorted\\n            flag=0;\\n            break;}\\n            }\\n            if(!flag)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int m=strs.size(),n=strs[0].size(),ans=0;\\n        for(int j=0;j<n;j++){\\n            bool flag=1;\\n            for(int i=1;i<m;i++){\\n            if(strs[i][j]<strs[i-1][j]){//unsorted\\n            flag=0;\\n            break;}\\n            }\\n            if(!flag)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992240,
                "title": "very-easy-process-normal-loop-operation-java",
                "content": "- 85/85 cases passed (10 ms)\\n- Your runtime beats 69.21 % of java submissions\\n- Your memory usage beats 45.62 % of java submissions (47.7 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int l=strs[0].length(),out=0;\\n        for(int i=0;i<l;i++)\\n            for(int j=0;j<strs.length-1;j++)\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    out++;\\n                    break;\\n                }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int l=strs[0].length(),out=0;\\n        for(int i=0;i<l;i++)\\n            for(int j=0;j<strs.length-1;j++)\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    out++;\\n                    break;\\n                }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1738908,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739329,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739476,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1569669,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738901,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739477,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1565362,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739160,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738974,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738982,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738908,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739329,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739476,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1569669,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738901,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739477,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1565362,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739160,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738974,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738982,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....🧐?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739212,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1740128,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1739150,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1739116,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1569400,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1572550,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1961285,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1958841,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1958633,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1913130,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct 😂..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1779306,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1765162,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1750348,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1744641,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1741273,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740304,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740299,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740253,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740250,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740209,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740199,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740188,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740166,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740061,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740043,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740003,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739977,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739969,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739961,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739949,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739948,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739942,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739934,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739928,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739917,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739875,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739850,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739816,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739778,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739764,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739760,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739751,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739729,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739635,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739619,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739598,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739592,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739579,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739571,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739565,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b с are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739563,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739544,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739543,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739522,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739500,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739474,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739473,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739449,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739416,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739412,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739397,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739368,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739354,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739316,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739313,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739310,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739303,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739291,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739237,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739236,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739231,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739218,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739213,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739207,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739180,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739108,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739082,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739074,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739047,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739019,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1738996,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738992,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738987,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738975,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738955,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738953,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738947,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738946,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738900,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738897,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            }
        ]
    },
    {
        "title": "Balance a Binary Search Tree",
        "question_content": "<p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p>\n\n<p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg\" style=\"width: 500px; height: 319px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,null,3,null,4,null,null]\n<strong>Output:</strong> [2,1,3,null,null,null,4]\n<b>Explanation:</b> This is not the only correct answer, [3,1,4,null,2] is also correct.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 539686,
                "title": "java-c-sorted-array-to-bst-o-n-clean-code",
                "content": "**Intuitive**\\n- Traverse binary tree in-order to get sorted array\\n- The problem become [108. Convert Sorted Array to Binary Search Tree\\n](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n\\n**Java**\\n```java\\nclass Solution {\\n    List<TreeNode> sortedArr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root);\\n        inorderTraverse(root.right);\\n    }\\n    TreeNode sortedArrayToBST(int start, int end) {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = sortedArr.get(mid);\\n        root.left = sortedArrayToBST(start, mid - 1);\\n        root.right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n}\\n```\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    vector<TreeNode*> sortedArr;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode* root) {\\n        if (root == NULL) return;\\n        inorderTraverse(root->left);\\n        sortedArr.push_back(root);\\n        inorderTraverse(root->right);\\n    }\\n    TreeNode* sortedArrayToBST(int start, int end) {\\n        if (start > end) return NULL;\\n        int mid = (start + end) / 2;\\n        TreeNode* root = sortedArr[mid];\\n        root->left = sortedArrayToBST(start, mid - 1);\\n        root->right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n};\\n```\\nComplexity\\n- Time & Space: `O(n)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<TreeNode> sortedArr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root);\\n        inorderTraverse(root.right);\\n    }\\n    TreeNode sortedArrayToBST(int start, int end) {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = sortedArr.get(mid);\\n        root.left = sortedArrayToBST(start, mid - 1);\\n        root.right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<TreeNode*> sortedArr;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode* root) {\\n        if (root == NULL) return;\\n        inorderTraverse(root->left);\\n        sortedArr.push_back(root);\\n        inorderTraverse(root->right);\\n    }\\n    TreeNode* sortedArrayToBST(int start, int end) {\\n        if (start > end) return NULL;\\n        int mid = (start + end) / 2;\\n        TreeNode* root = sortedArr[mid];\\n        root->left = sortedArrayToBST(start, mid - 1);\\n        root->right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541785,
                "title": "c-java-with-picture-dsw-o-n-o-1",
                "content": "The DSW algorithm is more complicated than re-creating a balanced tree from a sorted array. However, it does not require any extra memory as we manipulate existing nodes. It can be a big plus if your node stores more than just an int.\\n\\nThe idea is to convert the tree into a vine (like linked list) using left rotations, and then balance it using right rotations. You can look online for the full description of the DSW algorithm.\\n\\n**Algorithm**\\n1. Convert the initial tree into a vine. By doing right rotations, we flatten a tree into a \\'linked list\\', where the head is the former leftmost node, and tail - former rightmost node.\\n2. As you convert the tree into a vine, count the total number of nodes in `cnt`.\\n3. Calculate the height of the closest perfectly balanced tree: `h = log2(cnt + 1)`. \\n4. Calculate the number of nodes in the closest perfectly balanced tree: `m = pow(2, h) - 1`.\\n5. Left-rotate `cnt - m` nodes to cover up the excess of nodes.\\n> Note: you rotate the root node, then you rotate the right child of the new root node, and so on. In other words, left rotations are performed on every second node of the vine. See pictures below for the illustration.\\n6. Left-rotate `m / 2` nodes.\\n7. Divide `m` by two and repeat the step above while `m / 2` is greater than zero.  \\n\\n**Example**\\nThis example is borrowed from [this article](https://csactor.blogspot.com/2018/08/dsw-day-stout-warren-algorithm-dsw.html).\\n\\n1. Our initial tree has 9 nodes, and we convert it to a vine.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584399705.png)![image](https://assets.leetcode.com/users/votrubac/image_1584399732.png)\\n2. The height of the closest perfectly balanced tree is 3, and it contains 7 nodes.\\n3. So, we initially perform 2 left rotations (9 - 7) to cover up the excess.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400245.png)\\n4. Then, we perform 3 left rotations (7 / 2).\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400266.png)\\n5. Finally, we perform 1 left rotation (3 / 2).\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400292.png)\\n\\n> Note two excess nodes fill the next (4th) level of the resulting tree, so it\\'s not just balanced but also complete.\\n\\n**Implementation**\\nIn order to achieve O(1) memory, we must to avoid recursion. To do that, we track the grandparent `grand` when doing rotations. Also, we create a temporary node as a tree root to be the initial grandparent.\\n\\n**C++**\\n```cpp\\nint makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n```\\n\\n**Java**\\n```java\\nint makeVine(TreeNode grand) {\\n  int cnt = 0;\\n  var n = grand.right;\\n  while (n != null) {\\n    if (n.left != null) {\\n      var old_n = n;\\n      n = n.left;\\n      old_n.left = n.right;\\n      n.right = old_n;\\n      grand.right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n.right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode grand, int m) {\\n  var n = grand.right;\\n  while (m-- > 0) {\\n    var old_n = n;\\n    n = n.right;\\n    grand.right = n;\\n    old_n.right = n.left;\\n    n.left = old_n;\\n    grand = n;\\n    n = n.right;\\n  }\\n}    \\npublic TreeNode balanceBST(TreeNode root) {\\n  TreeNode grand = new TreeNode(0);\\n  grand.right = root;\\n  int cnt = makeVine(grand);\\n  int m = (int)Math.pow(2, (int)(Math.log(cnt + 1) / Math.log(2))) - 1;\\n  compress(grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(grand, m);\\n  return grand.right;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: *O(n)*. We perform up to *n* rotations and traverse *n* nodes.\\n- Memory: *O(1)*. We re-use existing nodes and process our tree iteratively.",
                "solutionTags": [],
                "code": "```cpp\\nint makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n```\n```java\\nint makeVine(TreeNode grand) {\\n  int cnt = 0;\\n  var n = grand.right;\\n  while (n != null) {\\n    if (n.left != null) {\\n      var old_n = n;\\n      n = n.left;\\n      old_n.left = n.right;\\n      n.right = old_n;\\n      grand.right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n.right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode grand, int m) {\\n  var n = grand.right;\\n  while (m-- > 0) {\\n    var old_n = n;\\n    n = n.right;\\n    grand.right = n;\\n    old_n.right = n.left;\\n    n.left = old_n;\\n    grand = n;\\n    n = n.right;\\n  }\\n}    \\npublic TreeNode balanceBST(TreeNode root) {\\n  TreeNode grand = new TreeNode(0);\\n  grand.right = root;\\n  int cnt = makeVine(grand);\\n  int m = (int)Math.pow(2, (int)(Math.log(cnt + 1) / Math.log(2))) - 1;\\n  compress(grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(grand, m);\\n  return grand.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540038,
                "title": "python-3-easy-to-understand",
                "content": "\\t# Definition for a binary tree node.\\n\\t# class TreeNode:\\n\\t#     def __init__(self, x):\\n\\t#         self.val = x\\n\\t#         self.left = None\\n\\t#         self.right = None\\n\\n\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tv = []\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tdfs(node.left)\\n\\t\\t\\t\\t\\tv.append(node.val)\\n\\t\\t\\t\\t\\tdfs(node.right)\\n\\t\\t\\tdfs(root)\\n\\n\\t\\t\\tdef bst(v):\\n\\t\\t\\t\\tif not v:\\n\\t\\t\\t\\t\\treturn None\\n\\t\\t\\t\\tmid = len(v) // 2\\n\\t\\t\\t\\troot = TreeNode(v[mid])\\n\\t\\t\\t\\troot.left = bst(v[:mid])\\n\\t\\t\\t\\troot.right = bst(v[mid + 1:])\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\treturn bst(v)",
                "solutionTags": [],
                "code": "\\t# Definition for a binary tree node.\\n\\t# class TreeNode:\\n\\t#     def __init__(self, x):\\n\\t#         self.val = x\\n\\t#         self.left = None\\n\\t#         self.right = None\\n\\n\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tv = []\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tdfs(node.left)\\n\\t\\t\\t\\t\\tv.append(node.val)\\n\\t\\t\\t\\t\\tdfs(node.right)\\n\\t\\t\\tdfs(root)\\n\\n\\t\\t\\tdef bst(v):\\n\\t\\t\\t\\tif not v:\\n\\t\\t\\t\\t\\treturn None\\n\\t\\t\\t\\tmid = len(v) // 2\\n\\t\\t\\t\\troot = TreeNode(v[mid])\\n\\t\\t\\t\\troot.left = bst(v[:mid])\\n\\t\\t\\t\\troot.right = bst(v[mid + 1:])\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\treturn bst(v)",
                "codeTag": "Java"
            },
            {
                "id": 821240,
                "title": "visualized-c-code-well-explained",
                "content": "```\\n\\tExample:  [1,null,2,null,3,null,4,null,null]\\n\\t\\n\\t1. \\tCreate a vector Inorder to store the nodes. \\n\\t\\n\\t2. \\tTraverse the tree in such a way that the nodes stored in the vector are in ascending order i.e. Inorder Traversal. \\n\\t\\t\\t\\t\\t\\t\\t\\tInorder: [ 1, 2, 3, 4 ]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t3. \\tThen use this vector of nodes to find the root node of the balanced BST.\\n\\t\\n\\t4. \\tThe newRoot node will be mid element of the array;\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot= Inorder[mid]=2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t5. Then recursively add the mid of first half to the left of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->left=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t6. And the mid of second half to the right of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->right=3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\n**Code** \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        findInorder(root->left);\\n        inorder.push_back(root);\\n        findInorder(root->right);\\n    }\\n    TreeNode* buildTree(int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=inorder[mid];\\n        root->left=buildTree(start,mid-1);\\n        root->right=buildTree(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        findInorder(root);\\n        int n=inorder.size();\\n        root=buildTree(0,n-1);\\n        return root;\\n    }\\n};\\n```\\n**Please Upvote if you find it useful.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tExample:  [1,null,2,null,3,null,4,null,null]\\n\\t\\n\\t1. \\tCreate a vector Inorder to store the nodes. \\n\\t\\n\\t2. \\tTraverse the tree in such a way that the nodes stored in the vector are in ascending order i.e. Inorder Traversal. \\n\\t\\t\\t\\t\\t\\t\\t\\tInorder: [ 1, 2, 3, 4 ]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t3. \\tThen use this vector of nodes to find the root node of the balanced BST.\\n\\t\\n\\t4. \\tThe newRoot node will be mid element of the array;\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot= Inorder[mid]=2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t5. Then recursively add the mid of first half to the left of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->left=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t6. And the mid of second half to the right of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->right=3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        findInorder(root->left);\\n        inorder.push_back(root);\\n        findInorder(root->right);\\n    }\\n    TreeNode* buildTree(int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=inorder[mid];\\n        root->left=buildTree(start,mid-1);\\n        root->right=buildTree(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        findInorder(root);\\n        int n=inorder.size();\\n        root=buildTree(0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551956,
                "title": "python-3-dfs-in-order-extraction-balanced-tree-building",
                "content": "# Steps\\n1. We use DFS (in-order) to extract node values while preserving the order.\\n2. We build the balanced tree by recursively taking the middle element of the ordered list as root.\\n\\n*Note: we use indices (`l:left`, `r:right`) instead of slicing to preserve space.*\\n\\n```Python\\nclass Solution:\\n    def balanceBST(self, root):\\n        \\n        def dfs(node):\\n            if not node: return []\\n            return dfs(node.left) + [node.val] + dfs(node.right)\\n        ns = dfs(root)\\n        \\n        def build(l, r):\\n            if l > r: return None\\n            m = (l + r) // 2\\n            root = TreeNode(ns[m])\\n            root.left, root.right = build(l, m-1), build(m + 1, r)\\n            return root\\n        \\n        return build(0, len(ns) - 1)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def balanceBST(self, root):\\n        \\n        def dfs(node):\\n            if not node: return []\\n            return dfs(node.left) + [node.val] + dfs(node.right)\\n        ns = dfs(root)\\n        \\n        def build(l, r):\\n            if l > r: return None\\n            m = (l + r) // 2\\n            root = TreeNode(ns[m])\\n            root.left, root.right = build(l, m-1), build(m + 1, r)\\n            return root\\n        \\n        return build(0, len(ns) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838211,
                "title": "java-solution-2-ms-and-100-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null)\\n            return null;\\n        \\n        if (root.left == null && root.right == null)\\n            return root;\\n        \\n        List<Integer> bstArray = new ArrayList<Integer>();\\n        getSortedList(root, bstArray);\\n        \\n        root = createBST(bstArray, 0, bstArray.size()-1);\\n        return root;\\n    }\\n    \\n    public void getSortedList(TreeNode root, List<Integer> list) {\\n        \\n        if (root == null)\\n            return;\\n        \\n        getSortedList(root.left, list);\\n        list.add(root.val);\\n        getSortedList(root.right, list);\\n    }\\n    \\n    public TreeNode createBST(List<Integer> list, int start, int end) {\\n        \\n        if (start > end)\\n            return null;\\n        \\n        int mid = (start + end)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = createBST(list, start, mid-1);\\n        root.right = createBST(list, mid+1, end);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null)\\n            return null;\\n        \\n        if (root.left == null && root.right == null)\\n            return root;\\n        \\n        List<Integer> bstArray = new ArrayList<Integer>();\\n        getSortedList(root, bstArray);\\n        \\n        root = createBST(bstArray, 0, bstArray.size()-1);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 596965,
                "title": "python-solution-based-on-rotations-o-1-space-o-nlogn-runtime",
                "content": "```\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def rotateLeft(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.right\\n            x.right = y.left\\n            y.left = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n            \\n        def rotateRight(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.left\\n            x.left = y.right       \\n            y.right = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n        \\n        def getHeight(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            \\n            return max(getHeight(node.left), getHeight(node.right)) + 1\\n        \\n        def recBalance(node: TreeNode, p: TreeNode) -> tuple:\\n            if not node:\\n                return 0,0\\n            \\n            left_height, left_balance = recBalance(node.left, node)\\n            right_height, right_balance = recBalance(node.right, node)        \\n            \\n            node_balance = left_height - right_height\\n            \\n            if node_balance > 1:\\n                if left_balance < 0:\\n                    rotateLeft(node.left, node)\\n                return recBalance(rotateRight(node, p), p)\\n            elif node_balance < -1:\\n                if right_balance > 0:\\n                    rotateRight(node.right, node)\\n                return recBalance(rotateLeft(node, p), p)\\n            else:\\n                left_height, right_height = getHeight(node.left), getHeight(node.right)\\n                return max(left_height, right_height) + 1, left_height - right_height\\n    \\n        dummy = TreeNode(None)\\n        dummy.right = root\\n        recBalance(dummy.right, dummy)\\n        return dummy.right\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def rotateLeft(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.right\\n            x.right = y.left\\n            y.left = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n            \\n        def rotateRight(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.left\\n            x.left = y.right       \\n            y.right = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n        \\n        def getHeight(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            \\n            return max(getHeight(node.left), getHeight(node.right)) + 1\\n        \\n        def recBalance(node: TreeNode, p: TreeNode) -> tuple:\\n            if not node:\\n                return 0,0\\n            \\n            left_height, left_balance = recBalance(node.left, node)\\n            right_height, right_balance = recBalance(node.right, node)        \\n            \\n            node_balance = left_height - right_height\\n            \\n            if node_balance > 1:\\n                if left_balance < 0:\\n                    rotateLeft(node.left, node)\\n                return recBalance(rotateRight(node, p), p)\\n            elif node_balance < -1:\\n                if right_balance > 0:\\n                    rotateRight(node.right, node)\\n                return recBalance(rotateLeft(node, p), p)\\n            else:\\n                left_height, right_height = getHeight(node.left), getHeight(node.right)\\n                return max(left_height, right_height) + 1, left_height - right_height\\n    \\n        dummy = TreeNode(None)\\n        dummy.right = root\\n        recBalance(dummy.right, dummy)\\n        return dummy.right\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 599833,
                "title": "python-sol-by-rebuilding-w-hint",
                "content": "Python sol by rebuilding.\\n\\n---\\n**Hint**:\\n\\nExcept for roration-based algorithm, like [this post](https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)) by @votrubac.\\n\\nThere is another one feasible solution.\\nWe can reuse the algorithm we had developed before in [Leetcode #108 Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/).\\n\\n---\\n\\nHere is the procedure:\\n\\n1. \\nFlatten original BST into a ascending sorted sequence.\\n( Recall that BST is a binary tree with ordered elements with inorder traversal )\\n\\n2. \\nConvert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        nums = []\\n        \\n        def inorder( node,nums):\\n            \\'\\'\\'\\n            Convert BST to ascending sequence\\n            \\'\\'\\'    \\n            if node:\\n                \\n                inorder( node.left, nums )\\n                nums.append( node.val )\\n                inorder( node.right, nums )\\n                \\n        # ----------------------------------------\\n        \\n        def sequence_to_balanced_BST( left, right, nums):\\n            \\'\\'\\'\\n            Convert ascending sequence to balanced BST\\n            \\'\\'\\'\\n            if left > right:\\n                # Base case:\\n                return None\\n            \\n            else:\\n                # General case:\\n\\n                mid = left + ( right - left ) // 2\\n\\n                root = TreeNode( nums[mid] )\\n\\n                root.left = sequence_to_balanced_BST( left, mid-1, nums)\\n                root.right = sequence_to_balanced_BST( mid+1, right, nums)\\n\\n                return root\\n        \\n        # ----------------------------------------\\n\\t\\t\\n        # Flatten original BST into a ascending sorted sequence.\\n        inorder( root, nums )\\n        \\n\\t\\t# Convert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n        return sequence_to_balanced_BST( left = 0, right = len(nums)-1, nums = nums)\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #94 Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)\\n\\n[2] [Leetcode #108 Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        nums = []\\n        \\n        def inorder( node,nums):\\n            \\'\\'\\'\\n            Convert BST to ascending sequence\\n            \\'\\'\\'    \\n            if node:\\n                \\n                inorder( node.left, nums )\\n                nums.append( node.val )\\n                inorder( node.right, nums )\\n                \\n        # ----------------------------------------\\n        \\n        def sequence_to_balanced_BST( left, right, nums):\\n            \\'\\'\\'\\n            Convert ascending sequence to balanced BST\\n            \\'\\'\\'\\n            if left > right:\\n                # Base case:\\n                return None\\n            \\n            else:\\n                # General case:\\n\\n                mid = left + ( right - left ) // 2\\n\\n                root = TreeNode( nums[mid] )\\n\\n                root.left = sequence_to_balanced_BST( left, mid-1, nums)\\n                root.right = sequence_to_balanced_BST( mid+1, right, nums)\\n\\n                return root\\n        \\n        # ----------------------------------------\\n\\t\\t\\n        # Flatten original BST into a ascending sorted sequence.\\n        inorder( root, nums )\\n        \\n\\t\\t# Convert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n        return sequence_to_balanced_BST( left = 0, right = len(nums)-1, nums = nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362115,
                "title": "java-easy-approach-with-explanation-recursive-inorder-postoder-dfs",
                "content": "```\\nclass Solution\\n{\\n    List<Integer> arrS= new ArrayList<>();//to store the node value in sorted manner  \\n    \\n    public void inorder(TreeNode root) \\n    {//BST of inorder is sorted \\n        if (root == null)//base case when we reach to the null node \\n            return;//deleting the current activation block and returning to the parent \\n        \\n        inorder(root.left);//recursing down the left subtree \\n        \\n        arrS.add(root.val);//manipulating the root// adding the node value in ascending order \\n        \\n        inorder(root.right);//recursing down the right subtree \\n        \\n        return;//deleting the current activation block and returning to the parent, as all thefunctions are completed \\n    }\\n    \\n    public TreeNode createBST(int low, int high) \\n    {//postorder, bottom up approach is used because we want to know the child first then the parent \\n        if(low > high)//base case //not creating any further node on wrong index \\n           return null;\\n        \\n        int mid= low + (high - low)/2;//getting the middle index at every activation block \\n        \\n        int data= arrS.get(mid);//getting the data in the middle index \\n        \\n        //----Left----(Mid)----Right----\\n        \\n        TreeNode left= createBST(low, mid - 1);//recursing down in the left subtree in search of child, is there or null is returned //lower bound\\n        TreeNode right= createBST(mid + 1, high);//recursing down in the right subtree in search of child, is there or null//upper bound \\n        \\n        TreeNode node= new TreeNode(data, left, right);//finally creating root node after knowing the reference of the children(left, right)\\n       \\n        return node;//return the node to its parent for backward linking//to tell that I am present \\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) \\n    {\\n        TreeNode rootN= null;\\n        if(root == null)//when we are provided with null graph \\n            return rootN;\\n        \\n        inorder(root);//creates the sorted ArrayList \\n        rootN= createBST(0, arrS.size() - 1);//creates the tree and returns the root, because root is the last node created as it takes time to get left and right child information since we are doing postorder traversal \\n        return rootN;\\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    List<Integer> arrS= new ArrayList<>();//to store the node value in sorted manner  \\n    \\n    public void inorder(TreeNode root) \\n    {//BST of inorder is sorted \\n        if (root == null)//base case when we reach to the null node \\n            return;//deleting the current activation block and returning to the parent \\n        \\n        inorder(root.left);//recursing down the left subtree \\n        \\n        arrS.add(root.val);//manipulating the root// adding the node value in ascending order \\n        \\n        inorder(root.right);//recursing down the right subtree \\n        \\n        return;//deleting the current activation block and returning to the parent, as all thefunctions are completed \\n    }\\n    \\n    public TreeNode createBST(int low, int high) \\n    {//postorder, bottom up approach is used because we want to know the child first then the parent \\n        if(low > high)//base case //not creating any further node on wrong index \\n           return null;\\n        \\n        int mid= low + (high - low)/2;//getting the middle index at every activation block \\n        \\n        int data= arrS.get(mid);//getting the data in the middle index \\n        \\n        //----Left----(Mid)----Right----\\n        \\n        TreeNode left= createBST(low, mid - 1);//recursing down in the left subtree in search of child, is there or null is returned //lower bound\\n        TreeNode right= createBST(mid + 1, high);//recursing down in the right subtree in search of child, is there or null//upper bound \\n        \\n        TreeNode node= new TreeNode(data, left, right);//finally creating root node after knowing the reference of the children(left, right)\\n       \\n        return node;//return the node to its parent for backward linking//to tell that I am present \\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) \\n    {\\n        TreeNode rootN= null;\\n        if(root == null)//when we are provided with null graph \\n            return rootN;\\n        \\n        inorder(root);//creates the sorted ArrayList \\n        rootN= createBST(0, arrS.size() - 1);//creates the tree and returns the root, because root is the last node created as it takes time to get left and right child information since we are doing postorder traversal \\n        return rootN;\\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552673,
                "title": "python-solution",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n        vals=[]\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                vals.append(node.val)\\n                inorder(node.right)\\n        def balance(l, r):\\n            if l<=r:\\n                mid = (l+r)//2\\n                cur = TreeNode(vals[mid])\\n                cur.left = balance(l, mid-1)\\n                cur.right = balance(mid+1, r)\\n                return cur\\n        inorder(root)\\n        n=len(vals)\\n        return balance(0, n-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n        vals=[]\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                vals.append(node.val)\\n                inorder(node.right)\\n        def balance(l, r):\\n            if l<=r:\\n                mid = (l+r)//2\\n                cur = TreeNode(vals[mid])\\n                cur.left = balance(l, mid-1)\\n                cur.right = balance(mid+1, r)\\n                return cur\\n        inorder(root)\\n        n=len(vals)\\n        return balance(0, n-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 621291,
                "title": "javascript-simple-solution-using-tree-reconstruction",
                "content": "Steps:\\n1. Use inorder traversal to create a sorted array\\n2. Construct a balance tree using the sorted array\\n```javascript\\nvar balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124362,
                "title": "java-in-order-traversal-quite-fast",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList();                                         //declaring list globally so that it can be accessed thoughout the program.\\n    public void InOrder(TreeNode root) {                                           //InOrder traveral of the tree.\\n        \\n        if(root == null)\\n            return;\\n        else\\n        {\\n            InOrder(root.left);\\n            list.add(root);\\n            InOrder(root.right);    \\n        }\\n    }\\n    \\n    public TreeNode balancedBST(int start,int end) {                                   //creating new tree with the help of list.\\n        if(start>end)\\n            return null;\\n        int mid = (start+end)/2;\\n        TreeNode root = list.get(mid);\\n        root.left = balancedBST(start,mid-1);\\n        root.right = balancedBST(mid+1,end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        InOrder(root);\\n        return balancedBST(0,list.size()-1);\\n    }\\n}\\n```\\n\\n# // Do upvote if you like.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList();                                         //declaring list globally so that it can be accessed thoughout the program.\\n    public void InOrder(TreeNode root) {                                           //InOrder traveral of the tree.\\n        \\n        if(root == null)\\n            return;\\n        else\\n        {\\n            InOrder(root.left);\\n            list.add(root);\\n            InOrder(root.right);    \\n        }\\n    }\\n    \\n    public TreeNode balancedBST(int start,int end) {                                   //creating new tree with the help of list.\\n        if(start>end)\\n            return null;\\n        int mid = (start+end)/2;\\n        TreeNode root = list.get(mid);\\n        root.left = balancedBST(start,mid-1);\\n        root.right = balancedBST(mid+1,end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        InOrder(root);\\n        return balancedBST(0,list.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315556,
                "title": "easiest-solution-full-beginner-level-code",
                "content": "# Intuition\\n1) InOrder Sequence\\n2) Conversion of ArrayList into Balanced BST.\\n3) return BST\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Step -> is to add all the elements in ArrayList in sorted form.\\n2) Step -> Then conversion of arr to Balanced BST\\n3) Step -> return root.\\n<!-- Describe your approach to solving the problem. -->\\n-> If you will try to understand to will understand it very easily <-\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public static void getInOrder(TreeNode root, ArrayList<Integer> inorder){\\n        if(root==null){\\n            return;\\n        }\\n        getInOrder(root.left,inorder);\\n        inorder.add(root.val);\\n        getInOrder(root.right,inorder);\\n    }\\n    public static TreeNode CreateBST(ArrayList<Integer> inorder, int left, int right) {\\n        if (left > right) return null;\\n        int m = (right + left) / 2;\\n        TreeNode root = new TreeNode(inorder.get(m));\\n        root.left = CreateBST(inorder, left, m - 1);\\n        root.right = CreateBST(inorder, m+ 1, right);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> inorder = new ArrayList<>();\\n        getInOrder(root,inorder);\\n        root = CreateBST(inorder,0,inorder.size()-1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void getInOrder(TreeNode root, ArrayList<Integer> inorder){\\n        if(root==null){\\n            return;\\n        }\\n        getInOrder(root.left,inorder);\\n        inorder.add(root.val);\\n        getInOrder(root.right,inorder);\\n    }\\n    public static TreeNode CreateBST(ArrayList<Integer> inorder, int left, int right) {\\n        if (left > right) return null;\\n        int m = (right + left) / 2;\\n        TreeNode root = new TreeNode(inorder.get(m));\\n        root.left = CreateBST(inorder, left, m - 1);\\n        root.right = CreateBST(inorder, m+ 1, right);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> inorder = new ArrayList<>();\\n        getInOrder(root,inorder);\\n        root = CreateBST(inorder,0,inorder.size()-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919887,
                "title": "another-avl-solution-with-some-remarks-accepted-java",
                "content": "```\\nclass Solution {\\n    Map<TreeNode, Integer> nodeToHeight = new HashMap<>();\\n    {\\n        nodeToHeight.put(null, -1);    \\n    }\\n    int threshold = 1;         \\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root == null) {\\n            return null;\\n        }    \\n        TreeNode left =  balanceBST(root.left);        \\n        TreeNode right = balanceBST(root.right);    \\n        root.left = left;\\n        root.right = right;\\n        int leftHeight = nodeToHeight.get(left);\\n        int rightHeight = nodeToHeight.get(right);\\n        int balance = rightHeight - leftHeight;                   \\n        nodeToHeight.put(root, 1 + Math.max(leftHeight, rightHeight));        \\n        if(Math.abs(balance) > threshold) {\\n            if(balance > 0) {                                                               \\n                if(getBalance(right) < 0) {\\n                   root.right = rotateRight(right);          \\n                }              \\n                root = rotateLeft(root);  \\n            }                            \\n            else {                \\n                if(getBalance(left) > 0) {                    \\n                   root.left = rotateLeft(left);\\n                }               \\n                root = rotateRight(root);                  \\n            }\\n        } \\n\\t\\t//comment out this _if block_ if you want to see the solution to fail for some testcases like\\n\\t\\t//[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n        if(!isBalanced(root)) {\\n            return balanceBST(root);\\n        }\\n        return root;\\n    }\\n    \\t\\n    private int getBalance(TreeNode node) {\\n        return nodeToHeight.get(node.right) - nodeToHeight.get(node.left);\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode node) {\\n        if(node == null || node.left == null) {\\n            return node;\\n        }        \\n        TreeNode left = node.left;        \\n        int height1 = nodeToHeight.get(left.left);\\n        TreeNode two = left.right;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(node.right);\\n        TreeNode root = left;\\n        root.right = node;\\n        node.left = two;  \\n        int newNodeHeight = 1 + Math.max(height2, height3);\\n        int newRootHeight = 1 + Math.max(height1, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode node) {\\n        if(node == null || node.right == null) {\\n            return node;\\n        }\\n        TreeNode right = node.right; \\n        int height1 = nodeToHeight.get(node.left);\\n        TreeNode two = right.left;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(right.right);\\n        TreeNode root = right;\\n        root.left = node;\\n        node.right = two;\\n        int newNodeHeight = 1 + Math.max(height1, height2);\\n        int newRootHeight = 1 + Math.max(height3, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private boolean isBalanced(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        boolean left = isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        return left && right && Math.abs(getBalance(root)) <= threshold;                    \\n    }\\n}\\n```\\nIt turns out, not all binary trees can be balanced by rotation on \"one go\" (one set of recursive calls).\\nExample:\\n[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n![image](https://assets.leetcode.com/users/images/97250f89-a24a-496c-88a6-20fce9c22449_1604278341.2874842.png)\\n\\nWithout additional calls to balanceBST resulting tree can still be unbalanced:\\n[11,1,15,null,7,14,17,2,9,12,null,null,null,null,3]\\n![image](https://assets.leetcode.com/users/images/7a9cf12b-c295-449c-be1a-3795c3ad7200_1604278362.8475924.png)\\n\\nNotice how \"node 11\" itself has Math.abs(balance) equal to 1, yet \"node 1\" is still unbalanced.\\n\\nJust comment out this portion of code in *balanceBST* method to see the test fail:\\n```\\n if(!isBalanced(root)) {\\n        return balanceBST(root);\\n }\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<TreeNode, Integer> nodeToHeight = new HashMap<>();\\n    {\\n        nodeToHeight.put(null, -1);    \\n    }\\n    int threshold = 1;         \\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root == null) {\\n            return null;\\n        }    \\n        TreeNode left =  balanceBST(root.left);        \\n        TreeNode right = balanceBST(root.right);    \\n        root.left = left;\\n        root.right = right;\\n        int leftHeight = nodeToHeight.get(left);\\n        int rightHeight = nodeToHeight.get(right);\\n        int balance = rightHeight - leftHeight;                   \\n        nodeToHeight.put(root, 1 + Math.max(leftHeight, rightHeight));        \\n        if(Math.abs(balance) > threshold) {\\n            if(balance > 0) {                                                               \\n                if(getBalance(right) < 0) {\\n                   root.right = rotateRight(right);          \\n                }              \\n                root = rotateLeft(root);  \\n            }                            \\n            else {                \\n                if(getBalance(left) > 0) {                    \\n                   root.left = rotateLeft(left);\\n                }               \\n                root = rotateRight(root);                  \\n            }\\n        } \\n\\t\\t//comment out this _if block_ if you want to see the solution to fail for some testcases like\\n\\t\\t//[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n        if(!isBalanced(root)) {\\n            return balanceBST(root);\\n        }\\n        return root;\\n    }\\n    \\t\\n    private int getBalance(TreeNode node) {\\n        return nodeToHeight.get(node.right) - nodeToHeight.get(node.left);\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode node) {\\n        if(node == null || node.left == null) {\\n            return node;\\n        }        \\n        TreeNode left = node.left;        \\n        int height1 = nodeToHeight.get(left.left);\\n        TreeNode two = left.right;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(node.right);\\n        TreeNode root = left;\\n        root.right = node;\\n        node.left = two;  \\n        int newNodeHeight = 1 + Math.max(height2, height3);\\n        int newRootHeight = 1 + Math.max(height1, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode node) {\\n        if(node == null || node.right == null) {\\n            return node;\\n        }\\n        TreeNode right = node.right; \\n        int height1 = nodeToHeight.get(node.left);\\n        TreeNode two = right.left;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(right.right);\\n        TreeNode root = right;\\n        root.left = node;\\n        node.right = two;\\n        int newNodeHeight = 1 + Math.max(height1, height2);\\n        int newRootHeight = 1 + Math.max(height3, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private boolean isBalanced(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        boolean left = isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        return left && right && Math.abs(getBalance(root)) <= threshold;                    \\n    }\\n}\\n```\n```\\n if(!isBalanced(root)) {\\n        return balanceBST(root);\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742665,
                "title": "c-simple-clean-code",
                "content": "```\\nvector<TreeNode*> ans;\\n    void inorder(TreeNode *root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        ans.push_back(root);\\n        inorder(root->right);      \\n    }\\n    TreeNode* solve(int l,int h) {\\n        if(l>h) return NULL;\\n        int m=(l+h)/2;\\n        ans[m]->left=solve(l,m-1);\\n        ans[m]->right=solve(m+1,h);\\n        return ans[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,ans.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<TreeNode*> ans;\\n    void inorder(TreeNode *root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        ans.push_back(root);\\n        inorder(root->right);      \\n    }\\n    TreeNode* solve(int l,int h) {\\n        if(l>h) return NULL;\\n        int m=(l+h)/2;\\n        ans[m]->left=solve(l,m-1);\\n        ans[m]->right=solve(m+1,h);\\n        return ans[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,ans.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764006,
                "title": "python-easy-to-read-and-understand-inorder-and-recusion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bst(self, nums, i, j):\\n        if i > j:\\n            return None\\n        mid = (i+j) // 2\\n        node = TreeNode(nums[mid])\\n        node.left = self.bst(nums, i, mid-1)\\n        node.right = self.bst(nums, mid+1, j)\\n        return node\\n    \\n    def dfs(self, node):\\n        if not node:\\n            return []\\n        l, r = self.dfs(node.left), self.dfs(node.right)\\n        return l + [node.val] + r\\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.dfs(root)\\n        return self.bst(nums, 0, len(nums)-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bst(self, nums, i, j):\\n        if i > j:\\n            return None\\n        mid = (i+j) // 2\\n        node = TreeNode(nums[mid])\\n        node.left = self.bst(nums, i, mid-1)\\n        node.right = self.bst(nums, mid+1, j)\\n        return node\\n    \\n    def dfs(self, node):\\n        if not node:\\n            return []\\n        l, r = self.dfs(node.left), self.dfs(node.right)\\n        return l + [node.val] + r\\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.dfs(root)\\n        return self.bst(nums, 0, len(nums)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1324526,
                "title": "c-bst-using-rotation",
                "content": "Solving using recursion. Basically, at each node, we assume that the left and right sub-trees are balanced. Now we have to merge the 2 sub-trees with the node. There are 5 conditions that can occur during the balancing.\\nCondition for balanced tree is that ```abs(left_height - right_height)) <= 1 ```\\n1. Root node is already balanced -> Do Nothing.\\n2. Root node is unbalanced leaning on the left and the left sub-tree also has a height of or more -> (LL configuration) -> To balance this, simply do a right rotation. \\n3. LR configuration -> Do 2 swaps. First left rotate the left sub-tree root to make it a LL configuration, then right rotate the root.\\n4. RR configuration -> Do a left rotation on the root\\n5. RL configuration -> First right rotate the right sub-tree root to make it a RR config. Then left rotate the root.\\n\\nWhenever we rotate, we need to make sure the swapped nodes, form a balanced sub-tree too!\\n```\\n    int getHeight(TreeNode *root){\\n        if(root == NULL) return -1;\\n        return max(getHeight(root->left), getHeight(root->right))+1;\\n    }\\n    int isBalanced(TreeNode *root){\\n        return getHeight(root->left) - getHeight(root->right);\\n    }\\n    \\n    TreeNode* leftRotate(TreeNode* root){\\n        TreeNode* x = root->right;\\n        root->right = x->left;\\n        x->left = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* rightRotate(TreeNode* root){ // O(1)\\n       TreeNode* x = root->left;\\n        root->left = x->right;\\n        x->right = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* getRotation(TreeNode *root){\\n        int bal = isBalanced(root);\\n        // cout<<\"Root: \"<<root->val<<\" Bal: \"<<bal<<endl;\\n        if(bal >=2){ //Left height  > right height -> LL, LR\\n            if(isBalanced(root->left) >= 1){ // LL\\n                // cout<<\"LL case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n            else{ //LR\\n                // auto tmp = (root->left==NULL)?INT_MAX:root->left->val;\\n                // cout<<\"LR case: leftRotate(\"<<tmp<<\")\"<<endl;\\n                root->left = leftRotate(root->left);\\n                // cout<<\"LR case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n        }\\n        else if(bal <= -2){ //RR , RL\\n            if(isBalanced(root->right) <= -1){ // RR\\n                // cout<<\"RR case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }\\n            else{ //RL\\n                // auto tmp = (root->right==NULL)?INT_MAX:root->right->val; \\n                // cout<<\"RL case: RightRotate(\"<<tmp<<\")\"<<endl;\\n                root->right = rightRotate(root->right);\\n                // cout<<\"RL case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }        \\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        // cout<<\"balanceBST(\"<<root->val<<\")\"<<endl;\\n        root->left = balanceBST(root->left);\\n        // int tmp = (root->left)?root->left->val: INT_MAX;\\n        // cout<<root->val<<\"->left = \"<<tmp<<endl;\\n        root->right = balanceBST(root->right);\\n        // tmp = (root->right)?root->right->val: INT_MAX;\\n        // cout<<root->val<<\"->right = \"<<tmp<<endl;\\n        return getRotation(root);\\n        \\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```abs(left_height - right_height)) <= 1 ```\n```\\n    int getHeight(TreeNode *root){\\n        if(root == NULL) return -1;\\n        return max(getHeight(root->left), getHeight(root->right))+1;\\n    }\\n    int isBalanced(TreeNode *root){\\n        return getHeight(root->left) - getHeight(root->right);\\n    }\\n    \\n    TreeNode* leftRotate(TreeNode* root){\\n        TreeNode* x = root->right;\\n        root->right = x->left;\\n        x->left = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* rightRotate(TreeNode* root){ // O(1)\\n       TreeNode* x = root->left;\\n        root->left = x->right;\\n        x->right = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* getRotation(TreeNode *root){\\n        int bal = isBalanced(root);\\n        // cout<<\"Root: \"<<root->val<<\" Bal: \"<<bal<<endl;\\n        if(bal >=2){ //Left height  > right height -> LL, LR\\n            if(isBalanced(root->left) >= 1){ // LL\\n                // cout<<\"LL case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n            else{ //LR\\n                // auto tmp = (root->left==NULL)?INT_MAX:root->left->val;\\n                // cout<<\"LR case: leftRotate(\"<<tmp<<\")\"<<endl;\\n                root->left = leftRotate(root->left);\\n                // cout<<\"LR case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n        }\\n        else if(bal <= -2){ //RR , RL\\n            if(isBalanced(root->right) <= -1){ // RR\\n                // cout<<\"RR case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }\\n            else{ //RL\\n                // auto tmp = (root->right==NULL)?INT_MAX:root->right->val; \\n                // cout<<\"RL case: RightRotate(\"<<tmp<<\")\"<<endl;\\n                root->right = rightRotate(root->right);\\n                // cout<<\"RL case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }        \\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        // cout<<\"balanceBST(\"<<root->val<<\")\"<<endl;\\n        root->left = balanceBST(root->left);\\n        // int tmp = (root->left)?root->left->val: INT_MAX;\\n        // cout<<root->val<<\"->left = \"<<tmp<<endl;\\n        root->right = balanceBST(root->right);\\n        // tmp = (root->right)?root->right->val: INT_MAX;\\n        // cout<<root->val<<\"->right = \"<<tmp<<endl;\\n        return getRotation(root);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970237,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> ls=new ArrayList<>();\\n        inorder(root,ls);\\n        return construct(ls,0,ls.size()-1);\\n    }\\n    public void inorder(TreeNode root,List<TreeNode> ls){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,ls);\\n        ls.add(root);\\n        inorder(root.right,ls);\\n    }\\n    public TreeNode construct(List<TreeNode> ls,int si,int ei){\\n        if(si>ei)\\n            return null;\\n        int mid=(si+ei)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=construct(ls,si,mid-1);\\n        root.right=construct(ls,mid+1,ei);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> ls=new ArrayList<>();\\n        inorder(root,ls);\\n        return construct(ls,0,ls.size()-1);\\n    }\\n    public void inorder(TreeNode root,List<TreeNode> ls){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,ls);\\n        ls.add(root);\\n        inorder(root.right,ls);\\n    }\\n    public TreeNode construct(List<TreeNode> ls,int si,int ei){\\n        if(si>ei)\\n            return null;\\n        int mid=(si+ei)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=construct(ls,si,mid-1);\\n        root.right=construct(ls,mid+1,ei);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701184,
                "title": "very-simple-solution-using-java-python",
                "content": "> # Algorithm \\n- Traverse and find the inorder of the tree and store it in an ArrayList.\\n- Now Similar to merge sort we mantain low, high pointers and mid will be the root element and the left part will be its left subtree and right part will be its right subtree. \\n- We will be recursively travelling to the left and right parts of the ArrayList.\\n- Finally we will return the root that if have got from the buildTree function.\\n> ## *Look at the code for better understanding.* \\n---\\n# Java\\n```\\nclass Solution {\\n    public void inorderTraversal(TreeNode root,List<Integer> lst)\\n    {\\n        if(root!=null)\\n        {\\n            inorderTraversal(root.left,lst);\\n            lst.add(root.val);\\n            inorderTraversal(root.right,lst);\\n        }\\n    }\\n    public TreeNode buildTree(List<Integer> lst ,int low,int high)\\n    {\\n        if(low > high)  return null;\\n        int mid = (low+high)/2;\\n        TreeNode root = new TreeNode(lst.get(mid));\\n        root.left = buildTree(lst,low,mid-1);\\n        root.right = buildTree(lst,mid+1,high);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        inorderTraversal(root,lst);\\n        root = buildTree(lst,0,lst.size()-1);\\n        return root;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution:\\n    def inorder(self,root,lst):\\n        if root!=None:\\n            self.inorder(root.left,lst)\\n            lst.append(root.val)\\n            self.inorder(root.right,lst)\\n    def buildTree(self,lst,low,high):\\n        if low > high:\\n            return None\\n        mid = (low+high)//2\\n        root = TreeNode(lst[mid])\\n        root.left = self.buildTree(lst,low,mid-1)\\n        root.right = self.buildTree(lst,mid+1,high)\\n        return root\\n\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        lst = []\\n        self.inorder(root,lst)\\n        low = 0\\n        high = len(lst)-1\\n        root = self.buildTree(lst,low,high)\\n        return root\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my explanation.* \\u2B06\\uFE0F\\n---\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public void inorderTraversal(TreeNode root,List<Integer> lst)\\n    {\\n        if(root!=null)\\n        {\\n            inorderTraversal(root.left,lst);\\n            lst.add(root.val);\\n            inorderTraversal(root.right,lst);\\n        }\\n    }\\n    public TreeNode buildTree(List<Integer> lst ,int low,int high)\\n    {\\n        if(low > high)  return null;\\n        int mid = (low+high)/2;\\n        TreeNode root = new TreeNode(lst.get(mid));\\n        root.left = buildTree(lst,low,mid-1);\\n        root.right = buildTree(lst,mid+1,high);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        inorderTraversal(root,lst);\\n        root = buildTree(lst,0,lst.size()-1);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def inorder(self,root,lst):\\n        if root!=None:\\n            self.inorder(root.left,lst)\\n            lst.append(root.val)\\n            self.inorder(root.right,lst)\\n    def buildTree(self,lst,low,high):\\n        if low > high:\\n            return None\\n        mid = (low+high)//2\\n        root = TreeNode(lst[mid])\\n        root.left = self.buildTree(lst,low,mid-1)\\n        root.right = self.buildTree(lst,mid+1,high)\\n        return root\\n\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        lst = []\\n        self.inorder(root,lst)\\n        low = 0\\n        high = len(lst)-1\\n        root = self.buildTree(lst,low,high)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517360,
                "title": "c-sorted-array-to-bst-easy-solution",
                "content": "```\\nvoid inorder(TreeNode* root, vector<int> &in){\\n        // base case\\n        if(!root) return;\\n        inorder(root->left, in);\\n        in.push_back(root->val);\\n        inorder(root->right, in);\\n    }\\n    \\n    TreeNode* createBST(vector<int> &in, int st, int end){\\n        // base case\\n        if(st > end) return NULL;\\n        \\n        int mid = (st+end)/2;\\n        TreeNode* root = new TreeNode(in[mid]);\\n        root->left = createBST(in, st, mid-1);\\n        root->right = createBST(in, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root, in);\\n        return createBST(in, 0, in.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid inorder(TreeNode* root, vector<int> &in){\\n        // base case\\n        if(!root) return;\\n        inorder(root->left, in);\\n        in.push_back(root->val);\\n        inorder(root->right, in);\\n    }\\n    \\n    TreeNode* createBST(vector<int> &in, int st, int end){\\n        // base case\\n        if(st > end) return NULL;\\n        \\n        int mid = (st+end)/2;\\n        TreeNode* root = new TreeNode(in[mid]);\\n        root->left = createBST(in, st, mid-1);\\n        root->right = createBST(in, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root, in);\\n        return createBST(in, 0, in.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345696,
                "title": "using-avl-o-n",
                "content": "\\tint height[];\\n    public void updateHeight(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        \\n        height[root.val] = Math.max(lh,rh) + 1;\\n    }\\n    \\n    public int getBal(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        return lh - rh;\\n    }\\n    \\n    public TreeNode leftRotation(TreeNode A){\\n        TreeNode B = A.right;\\n        TreeNode BkaLeft = B.left;\\n        \\n        B.left = A;\\n        A.right = BkaLeft;\\n        \\n        B.left = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode rightRotation(TreeNode A){\\n        TreeNode B = A.left;\\n        TreeNode BkaRight = B.right;\\n        \\n        B.right = A;\\n        A.left = BkaRight;\\n        \\n        B.right = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode getRotation(TreeNode root){\\n        updateHeight(root);\\n        if(getBal(root) >= 2){   // ll, lr\\n            if(getBal(root.left) >= 1){  // ll\\n                return rightRotation(root);    \\n            }else{    // lr\\n                root.left = leftRotation(root.left);\\n                return rightRotation(root);\\n            }\\n        }else if(getBal(root) <= -2){  // rr,rl\\n            if(getBal(root.right) <= -1){   // rr\\n                return leftRotation(root);\\n            }else{ // rl\\n                root.right = rightRotation(root.right);\\n                return leftRotation(root);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode postOrder(TreeNode root){\\n        if(root == null) return null;\\n        \\n        root.left = postOrder(root.left);\\n        root.right = postOrder(root.right);\\n        \\n        return getRotation(root);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        height = new int[100001];\\n        return postOrder(root);\\n    }",
                "solutionTags": [],
                "code": "\\tint height[];\\n    public void updateHeight(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        \\n        height[root.val] = Math.max(lh,rh) + 1;\\n    }\\n    \\n    public int getBal(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        return lh - rh;\\n    }\\n    \\n    public TreeNode leftRotation(TreeNode A){\\n        TreeNode B = A.right;\\n        TreeNode BkaLeft = B.left;\\n        \\n        B.left = A;\\n        A.right = BkaLeft;\\n        \\n        B.left = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode rightRotation(TreeNode A){\\n        TreeNode B = A.left;\\n        TreeNode BkaRight = B.right;\\n        \\n        B.right = A;\\n        A.left = BkaRight;\\n        \\n        B.right = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode getRotation(TreeNode root){\\n        updateHeight(root);\\n        if(getBal(root) >= 2){   // ll, lr\\n            if(getBal(root.left) >= 1){  // ll\\n                return rightRotation(root);    \\n            }else{    // lr\\n                root.left = leftRotation(root.left);\\n                return rightRotation(root);\\n            }\\n        }else if(getBal(root) <= -2){  // rr,rl\\n            if(getBal(root.right) <= -1){   // rr\\n                return leftRotation(root);\\n            }else{ // rl\\n                root.right = rightRotation(root.right);\\n                return leftRotation(root);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode postOrder(TreeNode root){\\n        if(root == null) return null;\\n        \\n        root.left = postOrder(root.left);\\n        root.right = postOrder(root.right);\\n        \\n        return getRotation(root);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        height = new int[100001];\\n        return postOrder(root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 539780,
                "title": "python3-collect-values-reconstruct-bst-recursively",
                "content": "Algorithm:\\nCollect values and reconstruct the tree. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def dfs(node):\\n            \"\"\"inorder depth-first traverse bst\"\"\"\\n            if not node: return \\n            dfs(node.left)\\n            value.append(node.val)\\n            dfs(node.right)\\n        \\n        value = [] #collect values\\n        dfs(root)\\n        \\n        def tree(lo, hi): \\n            if lo > hi: return None\\n            mid = (lo + hi)//2\\n            ans = TreeNode(value[mid])\\n            ans.left = tree(lo, mid-1)\\n            ans.right = tree(mid+1, hi)\\n            return ans\\n        \\n        return tree(0, len(value)-1)\\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def dfs(node):\\n            \"\"\"inorder depth-first traverse bst\"\"\"\\n            if not node: return \\n            dfs(node.left)\\n            value.append(node.val)\\n            dfs(node.right)\\n        \\n        value = [] #collect values\\n        dfs(root)\\n        \\n        def tree(lo, hi): \\n            if lo > hi: return None\\n            mid = (lo + hi)//2\\n            ans = TreeNode(value[mid])\\n            ans.left = tree(lo, mid-1)\\n            ans.right = tree(mid+1, hi)\\n            return ans\\n        \\n        return tree(0, len(value)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858403,
                "title": "c-easy-solution-using-avl-trees-concept",
                "content": "Only Prerequiste is to know about concept for AVL Trees root insertion, as code is almost similar.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define null nullptr\\n#define l left\\n#define r right\\nclass Solution {\\npublic:\\n    TreeNode* rrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->l;\\n        root->l=x->r;\\n        x->r=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    TreeNode* lrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->r;\\n        root->r=x->l;\\n        x->l=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    int height (TreeNode* root){\\n        if(root==null) return -1;\\n        return 1 + max(height(root->l),height(root->r));\\n    }\\n    \\n    TreeNode* helper (TreeNode* root){\\n        if (root==null) return null;\\n        root->l=helper(root->l);\\n        root->r=helper(root->r);\\n        int l = height(root->l), r = height(root->r);\\n        int bf = l -r ;\\n        if(bf > 1){\\n            if (height(root->l->l)<height(root->l->r)){\\n                root->l=lrot(root->l);\\n            }\\n            return helper(rrot(root));\\n        }else if (bf<-1){\\n            if (height(root->r->r)<height(root->r->l)){\\n                root->r=rrot(root->r);\\n            }\\n            return helper(lrot(root));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root==null) return root;\\n        return helper(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define null nullptr\\n#define l left\\n#define r right\\nclass Solution {\\npublic:\\n    TreeNode* rrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->l;\\n        root->l=x->r;\\n        x->r=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    TreeNode* lrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->r;\\n        root->r=x->l;\\n        x->l=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    int height (TreeNode* root){\\n        if(root==null) return -1;\\n        return 1 + max(height(root->l),height(root->r));\\n    }\\n    \\n    TreeNode* helper (TreeNode* root){\\n        if (root==null) return null;\\n        root->l=helper(root->l);\\n        root->r=helper(root->r);\\n        int l = height(root->l), r = height(root->r);\\n        int bf = l -r ;\\n        if(bf > 1){\\n            if (height(root->l->l)<height(root->l->r)){\\n                root->l=lrot(root->l);\\n            }\\n            return helper(rrot(root));\\n        }else if (bf<-1){\\n            if (height(root->r->r)<height(root->r->l)){\\n                root->r=rrot(root->r);\\n            }\\n            return helper(lrot(root));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root==null) return root;\\n        return helper(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465380,
                "title": "c-easy-to-understand-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root==NULL)\\n            return;\\n        inorder(root->left, v);\\n        v.push_back(root);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* createBST(vector<TreeNode*> &v, int lo, int hi) {\\n        if (hi<lo)\\n            return NULL;\\n        \\n        int mid = lo + (hi-lo)/2;\\n        TreeNode* root = v[mid];\\n        root->left = createBST(v, lo, mid-1);\\n        root->right = createBST(v, mid+1, hi);\\n        \\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorder(root,v);\\n        return createBST(v,0,v.size()-1);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root==NULL)\\n            return;\\n        inorder(root->left, v);\\n        v.push_back(root);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* createBST(vector<TreeNode*> &v, int lo, int hi) {\\n        if (hi<lo)\\n            return NULL;\\n        \\n        int mid = lo + (hi-lo)/2;\\n        TreeNode* root = v[mid];\\n        root->left = createBST(v, lo, mid-1);\\n        root->right = createBST(v, mid+1, hi);\\n        \\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorder(root,v);\\n        return createBST(v,0,v.size()-1);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273243,
                "title": "quite-simple-solution-n-85-accuracy-python-and-good-structured-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/fbcfc483-7d61-417d-a96c-4adcef9fc8d2_1623726107.514847.png)\\n--\\n----> Approach <-------\\n--\\n1) Inorer traversal and store the nodes in the list.\\n2) Then make bst using recursion and take mid element of list as root.\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left); lst.append(root); inorder(root.right)\\n        \\n        lst = []\\n        inorder(root)\\n        \\n        def bst(arr):\\n            if len(arr) == 0:return \\n            mid = len(arr)//2;   root = arr[mid]\\n            root.left = bst(arr[:mid]);   root.right = bst(arr[mid+1:])\\n            return root\\n        \\n        return bst(lst) \\n```\\nPlease upvote if u Like < \\' - \\'>  \\n--",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left); lst.append(root); inorder(root.right)\\n        \\n        lst = []\\n        inorder(root)\\n        \\n        def bst(arr):\\n            if len(arr) == 0:return \\n            mid = len(arr)//2;   root = arr[mid]\\n            root.left = bst(arr[:mid]);   root.right = bst(arr[mid+1:])\\n            return root\\n        \\n        return bst(lst) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877598,
                "title": "solution-using-avl-tree-class-quality",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    struct AVL{\\n        \\n        struct AVLnode{\\n            int element;\\n            AVLnode* left;\\n            AVLnode* right;\\n            int height;\\n            AVLnode(int x, AVLnode* l, AVLnode* r, int h=0): element{x}, left{l}, right{r},height{h} {}\\n        };\\n        \\n        AVLnode* root;\\n        \\n        AVL(){\\n            root=nullptr;\\n        }\\n        \\n        int height(AVLnode* t){\\n            return t==nullptr ? -1: t->height;\\n        }\\n        \\n        void insert( int x, AVLnode*&  t ){\\n            \\n            if(t==nullptr) \\n                t=new AVLnode(x, nullptr, nullptr);\\n            \\n            else if(x<t->element)\\n                insert(x, t->left);\\n            else if(t->element<x)\\n                insert(x,t->right);\\n            \\n           balance(t);\\n        }\\n        \\n        void balance(AVLnode* & t){\\n            \\n            if(t==nullptr) return;\\n            \\n            if(height(t->left)-height(t->right)>1){\\n                if(height(t->left->left)>=height(t->left->right)) rotateWithLeftChild(t);\\n                else doubleWithLeftChild(t);\\n            }\\n            else{\\n                if(height(t->right)-height(t->left)>1){\\n                if(height(t->right->right)>=height(t->right->left)) rotateWithRightChild(t);\\n                else doubleWithRightChild(t);\\n                }\\n            }\\n            \\n            t->height=max(height(t->left), height(t->right))+1;\\n        }\\n        \\n        void rotateWithLeftChild(AVLnode* & k2){\\n            AVLnode* k1=k2->left;\\n            k2->left=k1->right;\\n            k1->right=k2;\\n            k2->height=max(height(k2->left),height(k2->right))+1;\\n            k1->height=max(height(k1->left),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void rotateWithRightChild(AVLnode* & k2){\\n            AVLnode* k1=k2->right;\\n            k2->right=k1->left;\\n            k1->left=k2;\\n            k2->height=max(height(k2->right),height(k2->left))+1;\\n            k1->height=max(height(k1->right),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void doubleWithLeftChild(AVLnode* & k3){\\n            \\n            rotateWithRightChild(k3->left);\\n            rotateWithLeftChild(k3);\\n        }\\n        \\n        void doubleWithRightChild(AVLnode* & k3){\\n           \\n            rotateWithLeftChild(k3->right);\\n            rotateWithRightChild(k3);\\n        }\\n        \\n        \\n        \\n        \\n    };\\n    \\n    \\n    \\n    \\n    \\n    void traverseAndStore(TreeNode* root, vector<int>& temp){\\n        \\n        if(root==nullptr) return;\\n        else temp.push_back(root->val);\\n        \\n        traverseAndStore(root->left, temp);\\n        traverseAndStore(root->right, temp);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    void f(TreeNode*& ans, AVL::AVLnode*& temp){\\n        \\n        if(temp==nullptr) return;\\n        else ans=new TreeNode(temp->element);\\n        \\n        f(ans->left,temp->left);\\n        f(ans->right,temp->right);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int> storeTree;\\n        \\n        traverseAndStore(root,storeTree);\\n        \\n        AVL* myAVL= new AVL();\\n        \\n        \\n        for( auto k: storeTree){\\n            myAVL->insert(k,myAVL->root);\\n        }\\n        \\n        TreeNode* ans;\\n        \\n        AVL:: AVLnode* temp=myAVL->root;\\n        \\n        f(ans,temp);\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    struct AVL{\\n        \\n        struct AVLnode{\\n            int element;\\n            AVLnode* left;\\n            AVLnode* right;\\n            int height;\\n            AVLnode(int x, AVLnode* l, AVLnode* r, int h=0): element{x}, left{l}, right{r},height{h} {}\\n        };\\n        \\n        AVLnode* root;\\n        \\n        AVL(){\\n            root=nullptr;\\n        }\\n        \\n        int height(AVLnode* t){\\n            return t==nullptr ? -1: t->height;\\n        }\\n        \\n        void insert( int x, AVLnode*&  t ){\\n            \\n            if(t==nullptr) \\n                t=new AVLnode(x, nullptr, nullptr);\\n            \\n            else if(x<t->element)\\n                insert(x, t->left);\\n            else if(t->element<x)\\n                insert(x,t->right);\\n            \\n           balance(t);\\n        }\\n        \\n        void balance(AVLnode* & t){\\n            \\n            if(t==nullptr) return;\\n            \\n            if(height(t->left)-height(t->right)>1){\\n                if(height(t->left->left)>=height(t->left->right)) rotateWithLeftChild(t);\\n                else doubleWithLeftChild(t);\\n            }\\n            else{\\n                if(height(t->right)-height(t->left)>1){\\n                if(height(t->right->right)>=height(t->right->left)) rotateWithRightChild(t);\\n                else doubleWithRightChild(t);\\n                }\\n            }\\n            \\n            t->height=max(height(t->left), height(t->right))+1;\\n        }\\n        \\n        void rotateWithLeftChild(AVLnode* & k2){\\n            AVLnode* k1=k2->left;\\n            k2->left=k1->right;\\n            k1->right=k2;\\n            k2->height=max(height(k2->left),height(k2->right))+1;\\n            k1->height=max(height(k1->left),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void rotateWithRightChild(AVLnode* & k2){\\n            AVLnode* k1=k2->right;\\n            k2->right=k1->left;\\n            k1->left=k2;\\n            k2->height=max(height(k2->right),height(k2->left))+1;\\n            k1->height=max(height(k1->right),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void doubleWithLeftChild(AVLnode* & k3){\\n            \\n            rotateWithRightChild(k3->left);\\n            rotateWithLeftChild(k3);\\n        }\\n        \\n        void doubleWithRightChild(AVLnode* & k3){\\n           \\n            rotateWithLeftChild(k3->right);\\n            rotateWithRightChild(k3);\\n        }\\n        \\n        \\n        \\n        \\n    };\\n    \\n    \\n    \\n    \\n    \\n    void traverseAndStore(TreeNode* root, vector<int>& temp){\\n        \\n        if(root==nullptr) return;\\n        else temp.push_back(root->val);\\n        \\n        traverseAndStore(root->left, temp);\\n        traverseAndStore(root->right, temp);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    void f(TreeNode*& ans, AVL::AVLnode*& temp){\\n        \\n        if(temp==nullptr) return;\\n        else ans=new TreeNode(temp->element);\\n        \\n        f(ans->left,temp->left);\\n        f(ans->right,temp->right);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int> storeTree;\\n        \\n        traverseAndStore(root,storeTree);\\n        \\n        AVL* myAVL= new AVL();\\n        \\n        \\n        for( auto k: storeTree){\\n            myAVL->insert(k,myAVL->root);\\n        }\\n        \\n        TreeNode* ans;\\n        \\n        AVL:: AVLnode* temp=myAVL->root;\\n        \\n        f(ans,temp);\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439377,
                "title": "easy-and-commented-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // for getting the inorder of BST\\n    void inorderTraversal(TreeNode*root,vector<TreeNode*>&inorder){\\n        if(root==NULL){\\n            return ;\\n        }\\n        if(root->left){\\n            inorderTraversal(root->left,inorder);\\n        }\\n\\n        inorder.push_back(root);\\n\\n        if(root->right){\\n            inorderTraversal(root->right,inorder);\\n        }\\n    }\\n\\n    // to make a balanced tree \\n    TreeNode* makeBalancedBST(vector<TreeNode*>&inorder,int start,int end){\\n        //base case \\n        if(start>end){\\n            return NULL;\\n        }\\n\\n        // find mid\\n        int mid=start + (end-start)/2;\\n        //now call for left and right \\n\\n        //for left keep start as it is and change end \\n        inorder[mid]->left=makeBalancedBST(inorder,start,mid-1);\\n\\n        // for right keeping end same but changing start\\n        inorder[mid]->right=makeBalancedBST(inorder,mid+1,end);\\n        \\n        return inorder[mid];//returning mid as it\\'s root for this subtree which will be linked with above left or right\\n    }\\n\\n            <!-- Please upvote \\uD83D\\uDE4F if you found this solution helpful\\uD83D\\uDE00 -->\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>inorder;//to store the inorder traversal of BST\\n        inorderTraversal(root,inorder);\\n\\n        int start=0;//initially start is 0 index and end is n-1\\n        int end=inorder.size()-1;\\n\\n        return makeBalancedBST(inorder,start,end);//this will return the mid of inorder which is our root for balanced BST\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // for getting the inorder of BST\\n    void inorderTraversal(TreeNode*root,vector<TreeNode*>&inorder){\\n        if(root==NULL){\\n            return ;\\n        }\\n        if(root->left){\\n            inorderTraversal(root->left,inorder);\\n        }\\n\\n        inorder.push_back(root);\\n\\n        if(root->right){\\n            inorderTraversal(root->right,inorder);\\n        }\\n    }\\n\\n    // to make a balanced tree \\n    TreeNode* makeBalancedBST(vector<TreeNode*>&inorder,int start,int end){\\n        //base case \\n        if(start>end){\\n            return NULL;\\n        }\\n\\n        // find mid\\n        int mid=start + (end-start)/2;\\n        //now call for left and right \\n\\n        //for left keep start as it is and change end \\n        inorder[mid]->left=makeBalancedBST(inorder,start,mid-1);\\n\\n        // for right keeping end same but changing start\\n        inorder[mid]->right=makeBalancedBST(inorder,mid+1,end);\\n        \\n        return inorder[mid];//returning mid as it\\'s root for this subtree which will be linked with above left or right\\n    }\\n\\n            <!-- Please upvote \\uD83D\\uDE4F if you found this solution helpful\\uD83D\\uDE00 -->\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>inorder;//to store the inorder traversal of BST\\n        inorderTraversal(root,inorder);\\n\\n        int start=0;//initially start is 0 index and end is n-1\\n        int end=inorder.size()-1;\\n\\n        return makeBalancedBST(inorder,start,end);//this will return the mid of inorder which is our root for balanced BST\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561068,
                "title": "javascript-solution-using-recursion-bst-array-bst",
                "content": "```\\nvar balanceBST = function(root) {\\n    const values = toArray(root);\\n    return toBST(values);\\n    \\n    function toBST(arr) {\\n        if (arr.length===0) return null;\\n        if (arr.length===1) return new TreeNode(arr[0]);\\n        const mid = Math.floor(arr.length / 2);\\n        const left = toBST(arr.slice(0, mid));\\n        const right = toBST(arr.slice(mid+1));\\n        return new TreeNode(arr[mid], left, right);\\n    }\\n    \\n    function toArray(node) {\\n        if (!node) return [];\\n        return [...toArray(node.left), node.val, ...toArray(node.right)];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nvar balanceBST = function(root) {\\n    const values = toArray(root);\\n    return toBST(values);\\n    \\n    function toBST(arr) {\\n        if (arr.length===0) return null;\\n        if (arr.length===1) return new TreeNode(arr[0]);\\n        const mid = Math.floor(arr.length / 2);\\n        const left = toBST(arr.slice(0, mid));\\n        const right = toBST(arr.slice(mid+1));\\n        return new TreeNode(arr[mid], left, right);\\n    }\\n    \\n    function toArray(node) {\\n        if (!node) return [];\\n        return [...toArray(node.left), node.val, ...toArray(node.right)];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555843,
                "title": "python-solutions-with-some-explanation",
                "content": "```\\nclass Solution(object):\\n\\t# We need to sort the distinct nodes of the BST by using inorder traversal\\n    def balanceBST(self, root):\\n        def inorder(root):\\n            if not root:\\n                return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root) # Because the function returns a list, we assign that list to variable nums for later uses\\n        \\n        def constructBST(nums):\\n            if len(nums) == 0: # Our list is empty\\n                return None\\n            if len(nums) == 1: # Our list has only one element\\n                return TreeNode(nums[0])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Here is one illustration before the code:\\n\\t\\t\\t# Assuming that we already have a sorted list : [1, 2, 5, 7, 9, 12, 14]\\n\\t\\t\\t# The middle value is 7, which is also our very first root\\n\\t\\t\\t# root.left will apply the same thought recursively with a sorted list: [1, 2, 5]\\n\\t\\t\\t# root.right will apply the same thought recursively with a sorted list: [9, 12, 14]\\n\\t\\t\\t# Below is the final code:\\n\\t\\t\\t\\n            mid = len(nums) // 2\\n            new_node = TreeNode(nums[mid])\\n            new_node.left = constructBST(nums[:mid])\\n            new_node.right = constructBST(nums[mid+1:])\\n            return new_node\\n        \\n        return constructBST(nums)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n\\t# We need to sort the distinct nodes of the BST by using inorder traversal\\n    def balanceBST(self, root):\\n        def inorder(root):\\n            if not root:\\n                return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root) # Because the function returns a list, we assign that list to variable nums for later uses\\n        \\n        def constructBST(nums):\\n            if len(nums) == 0: # Our list is empty\\n                return None\\n            if len(nums) == 1: # Our list has only one element\\n                return TreeNode(nums[0])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Here is one illustration before the code:\\n\\t\\t\\t# Assuming that we already have a sorted list : [1, 2, 5, 7, 9, 12, 14]\\n\\t\\t\\t# The middle value is 7, which is also our very first root\\n\\t\\t\\t# root.left will apply the same thought recursively with a sorted list: [1, 2, 5]\\n\\t\\t\\t# root.right will apply the same thought recursively with a sorted list: [9, 12, 14]\\n\\t\\t\\t# Below is the final code:\\n\\t\\t\\t\\n            mid = len(nums) // 2\\n            new_node = TreeNode(nums[mid])\\n            new_node.left = constructBST(nums[:mid])\\n            new_node.right = constructBST(nums[mid+1:])\\n            return new_node\\n        \\n        return constructBST(nums)",
                "codeTag": "Java"
            },
            {
                "id": 757687,
                "title": "java-inorder-beat-100-easy-understand",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        helper(root);\\n        if(list.size() == 0)\\n            return null;\\n        return formTree(0, list.size() - 1);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root == null)\\n            return;\\n        helper(root.left);\\n        list.add(root);  // don\\'t store value\\n        helper(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n    \\n\\t//recursive form BST\\n    private TreeNode formTree(int start, int end){\\n        if(start > end)\\n            return null;\\n        int middle = start + (end - start) / 2;\\n        TreeNode root = list.get(middle);\\n        root.left = formTree(start, middle - 1);\\n        root.right = formTree(middle + 1, end);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        helper(root);\\n        if(list.size() == 0)\\n            return null;\\n        return formTree(0, list.size() - 1);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root == null)\\n            return;\\n        helper(root.left);\\n        list.add(root);  // don\\'t store value\\n        helper(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n    \\n\\t//recursive form BST\\n    private TreeNode formTree(int start, int end){\\n        if(start > end)\\n            return null;\\n        int middle = start + (end - start) / 2;\\n        TreeNode root = list.get(middle);\\n        root.left = formTree(start, middle - 1);\\n        root.right = formTree(middle + 1, end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540352,
                "title": "javascript-inorder-traverse-and-build-a-balance-tree-100-beat",
                "content": "```\\nconst balanceBST = root => {\\n  let arr = [];\\n  const inorderTraverse = node => {\\n    if (!node) return;\\n    if (node.left) inorderTraverse(node.left);\\n    arr.push(node.val);\\n    if (node.right) inorderTraverse(node.right);\\n  }\\n  \\n  inorderTraverse(root);\\n  \\n  const constructBST = (start, end) => {\\n    if (start > end) return null;\\n    const mid = Math.floor((start+end) / 2);\\n    \\n    let node = new TreeNode(arr[mid]);\\n    node.left = constructBST(start, mid - 1);\\n    node.right = constructBST(mid + 1, end);\\n    \\n    return node;\\n  }\\n  \\n  let node = constructBST(0, arr.length - 1)\\n  \\n  return node;\\n};\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst balanceBST = root => {\\n  let arr = [];\\n  const inorderTraverse = node => {\\n    if (!node) return;\\n    if (node.left) inorderTraverse(node.left);\\n    arr.push(node.val);\\n    if (node.right) inorderTraverse(node.right);\\n  }\\n  \\n  inorderTraverse(root);\\n  \\n  const constructBST = (start, end) => {\\n    if (start > end) return null;\\n    const mid = Math.floor((start+end) / 2);\\n    \\n    let node = new TreeNode(arr[mid]);\\n    node.left = constructBST(start, mid - 1);\\n    node.right = constructBST(mid + 1, end);\\n    \\n    return node;\\n  }\\n  \\n  let node = constructBST(0, arr.length - 1)\\n  \\n  return node;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539735,
                "title": "clean-python-3-inorder-rebuild-tree-o-n",
                "content": "Get the inorder traversal of original tree first.\\nThen pick the middle one as the new root and rebuild entire tree.\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root: TreeNode) -> List[TreeNode]:\\n            stack, result = [], []\\n            while root or stack:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                root = stack.pop()\\n                result.append(root)\\n                root = root.right\\n            return result\\n            \\n        def build(nodes: List[TreeNode]) -> TreeNode:\\n            if not nodes: return None\\n            mid = len(nodes) // 2\\n            mid_node = nodes[mid]\\n            mid_node.left = build(nodes[:mid])\\n            mid_node.right = build(nodes[mid+1:])\\n            return mid_node\\n\\n        return build(inorder(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root: TreeNode) -> List[TreeNode]:\\n            stack, result = [], []\\n            while root or stack:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                root = stack.pop()\\n                result.append(root)\\n                root = root.right\\n            return result\\n            \\n        def build(nodes: List[TreeNode]) -> TreeNode:\\n            if not nodes: return None\\n            mid = len(nodes) // 2\\n            mid_node = nodes[mid]\\n            mid_node.left = build(nodes[:mid])\\n            mid_node.right = build(nodes[mid+1:])\\n            return mid_node\\n\\n        return build(inorder(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976249,
                "title": "2-best-c-solutions-beats-100-in-both-time-and-memory",
                "content": "# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    TreeNode* createBST(vector<int> ans, int start, int end){\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start+(end-start)/2;\\n        TreeNode *root = new TreeNode(ans[mid]);\\n        root->left = createBST(ans, start, mid-1);\\n        root->right = createBST(ans, mid+1, end);\\n        return root;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        int start = 0, end = ans.size()-1;\\n        return createBST(ans, start, end);\\n    }\\n};\\n\\n// Same solution but directly storing nodes and not integers\\n// Works way better in both time and space complexity\\nclass Solution {\\n    vector<TreeNode*> sorted;\\npublic:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL) \\n            return;\\n        \\n        inorder(root->left);\\n        sorted.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* createTree(int start, int end) {\\n        if (start > end) \\n            return NULL;\\n        \\n        int mid = start + (end - start)/2;\\n        TreeNode *root = sorted[mid];\\n        root->left = createTree(start, mid - 1);\\n        root->right = createTree(mid + 1, end);\\n        return root;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return createTree(0, sorted.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Greedy",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    TreeNode* createBST(vector<int> ans, int start, int end){\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start+(end-start)/2;\\n        TreeNode *root = new TreeNode(ans[mid]);\\n        root->left = createBST(ans, start, mid-1);\\n        root->right = createBST(ans, mid+1, end);\\n        return root;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        int start = 0, end = ans.size()-1;\\n        return createBST(ans, start, end);\\n    }\\n};\\n\\n// Same solution but directly storing nodes and not integers\\n// Works way better in both time and space complexity\\nclass Solution {\\n    vector<TreeNode*> sorted;\\npublic:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL) \\n            return;\\n        \\n        inorder(root->left);\\n        sorted.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* createTree(int start, int end) {\\n        if (start > end) \\n            return NULL;\\n        \\n        int mid = start + (end - start)/2;\\n        TreeNode *root = sorted[mid];\\n        root->left = createTree(start, mid - 1);\\n        root->right = createTree(mid + 1, end);\\n        return root;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return createTree(0, sorted.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370547,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of BST\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we Calculate inorder with the help of ArrayList\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode Balance( ArrayList<Integer> list,int st,int end){\\n        if(st>end){\\n            return null;\\n        }\\n        int mid=(st+end)/2;\\n        TreeNode root=new TreeNode(list.get(mid));\\n        root.left=Balance(list,st,mid-1);\\n        root.right=Balance(list,mid+1,end);\\n        return root;\\n    }\\n    public static void inorder(TreeNode root, ArrayList<Integer> list){\\n          if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n      if(root==null){\\n        return null;\\n      }\\n        inorder(root,list);\\n      \\n        TreeNode root1=Balance(list,0,list.size()-1);\\n        return root1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode Balance( ArrayList<Integer> list,int st,int end){\\n        if(st>end){\\n            return null;\\n        }\\n        int mid=(st+end)/2;\\n        TreeNode root=new TreeNode(list.get(mid));\\n        root.left=Balance(list,st,mid-1);\\n        root.right=Balance(list,mid+1,end);\\n        return root;\\n    }\\n    public static void inorder(TreeNode root, ArrayList<Integer> list){\\n          if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n      if(root==null){\\n        return null;\\n      }\\n        inorder(root,list);\\n      \\n        TreeNode root1=Balance(list,0,list.size()-1);\\n        return root1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796623,
                "title": "c-solution-balance-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n    }\\n    \\n    TreeNode* inorderToBST(int s , int e , vector<int> &inorderVal){\\n        if(s > e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        \\n        TreeNode* temp = new TreeNode(inorderVal[mid]);\\n        temp->left = inorderToBST(s , mid-1 , inorderVal);\\n        temp->right = inorderToBST(mid+1 , e , inorderVal);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        return inorderToBST(0 , inorderVal.size()-1 , inorderVal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n    }\\n    \\n    TreeNode* inorderToBST(int s , int e , vector<int> &inorderVal){\\n        if(s > e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        \\n        TreeNode* temp = new TreeNode(inorderVal[mid]);\\n        temp->left = inorderToBST(s , mid-1 , inorderVal);\\n        temp->right = inorderToBST(mid+1 , e , inorderVal);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        return inorderToBST(0 , inorderVal.size()-1 , inorderVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394387,
                "title": "c-get-inorder-traversal-and-make-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    void traverse(TreeNode * root){\\n        if(!root) return ;\\n        traverse(root->left) ;\\n        nums.push_back(root->val) ;\\n        traverse(root->right) ;\\n        return ;\\n    }\\n    \\n    TreeNode * makeTree(int s , int e){\\n        if(s > e) return nullptr ;\\n        int m = (s + e) / 2 ;\\n        TreeNode * root = new TreeNode(nums[m]) ;\\n        \\n        root->left = makeTree(s,m - 1) ;\\n        root->right = makeTree(m + 1,e) ;\\n        \\n        return root ;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        traverse(root) ;\\n        return makeTree(0,size(nums) - 1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    void traverse(TreeNode * root){\\n        if(!root) return ;\\n        traverse(root->left) ;\\n        nums.push_back(root->val) ;\\n        traverse(root->right) ;\\n        return ;\\n    }\\n    \\n    TreeNode * makeTree(int s , int e){\\n        if(s > e) return nullptr ;\\n        int m = (s + e) / 2 ;\\n        TreeNode * root = new TreeNode(nums[m]) ;\\n        \\n        root->left = makeTree(s,m - 1) ;\\n        root->right = makeTree(m + 1,e) ;\\n        \\n        return root ;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        traverse(root) ;\\n        return makeTree(0,size(nums) - 1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042990,
                "title": "python-very-easy-sol-using-inorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root,lst):\\n            if not root:\\n                return \\n            inorder(root.left,lst)\\n            lst.append(root.val)\\n            inorder(root.right,lst)\\n        \\n        def createBST(l,r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                return TreeNode(lst[mid],createBST(l,mid-1),createBST(mid+1,r))\\n            return None\\n            \\n        lst = []\\n        inorder(root,lst)\\n        l,r = 0,len(lst) - 1        \\n        return createBST(l,r)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root,lst):\\n            if not root:\\n                return \\n            inorder(root.left,lst)\\n            lst.append(root.val)\\n            inorder(root.right,lst)\\n        \\n        def createBST(l,r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                return TreeNode(lst[mid],createBST(l,mid-1),createBST(mid+1,r))\\n            return None\\n            \\n        lst = []\\n        inorder(root,lst)\\n        l,r = 0,len(lst) - 1        \\n        return createBST(l,r)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922692,
                "title": "python-clean-recursive-soln-beats-60-soln-w-comments-time-space-complexity-o-n",
                "content": "# Solution:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inOrderTraversal(self, root):\\n        if not root:\\n            return \\n        \\n\\t\\t# traverse left subtree\\n\\t\\tself.inOrderTraversal(root.left)\\n\\t\\t\\n\\t\\t# append to list\\n        self.inOrderList.append(root)\\n        \\n\\t\\t# traverse right subtree\\n\\t\\tself.inOrderTraversal(root.right)\\n        \\n        return \\n    \\n    def createBBST(self,low, high):\\n\\t\\t# base case\\n        if low > high:\\n            return None\\n\\n\\t\\t# pick middle node\\n        mid = low + high >> 1\\n        \\n        node = self.inOrderList[mid]\\n        node.left = self.createBBST(low, mid - 1)\\n        node.right = self.createBBST(mid + 1, high)\\n        \\n        return node\\n        \\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        self.inOrderList = []\\n        self.inOrderTraversal(root)\\n        return self.createBBST(0, len(self.inOrderList)-1)\\n```\\t\\t\\n\\t\\t\\n# Intuition/Approach:\\n**Step 1:** Inorder traversal on a binary search tree gives us all the nodes in sorted ascending order.\\n**Step 2:** To build a Balanced BST we would need a root with equal number of nodes to its left as to its right\\n**Example:** input: [3, 1, 4, null, null, null, 7, null, 9, null, 10] (*doesn\\'t really matter how the nodes are provided*)\\n```\\n\\t\\t3\\n\\t  /   \\\\\\n \\t 1     4\\n\\t        \\\\\\n\\t\\t\\t 7\\n\\t\\t\\t  \\\\\\n\\t\\t\\t   9\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t  \\t 10\\n\\t\\t\\t\\t \\n# we perform inOrderTraversal on this BST, we get\\n\\ninOrderList = [1,3,4,7,9,10]\\n\\n# Now if we were to form a Balanced BST from this list, our choice of root will be either 4 or 7 \\n#(partioning the list in such a way that left subtree is roughly equal to right subtree in size/# of nodes).\\n\\n# Say, it was 4: then\\n#\\t\\tleft node of 4 will be decided from the left half of the list (from inOrderList[0:2])\\n#\\t\\tand right node of 4 will be decided from the right half of the list (from inOrderList[3:])\\n#\\t\\tand the process goes on recursively\\n```\\n\\n\\n\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inOrderTraversal(self, root):\\n        if not root:\\n            return \\n        \\n\\t\\t# traverse left subtree\\n\\t\\tself.inOrderTraversal(root.left)\\n\\t\\t\\n\\t\\t# append to list\\n        self.inOrderList.append(root)\\n        \\n\\t\\t# traverse right subtree\\n\\t\\tself.inOrderTraversal(root.right)\\n        \\n        return \\n    \\n    def createBBST(self,low, high):\\n\\t\\t# base case\\n        if low > high:\\n            return None\\n\\n\\t\\t# pick middle node\\n        mid = low + high >> 1\\n        \\n        node = self.inOrderList[mid]\\n        node.left = self.createBBST(low, mid - 1)\\n        node.right = self.createBBST(mid + 1, high)\\n        \\n        return node\\n        \\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        self.inOrderList = []\\n        self.inOrderTraversal(root)\\n        return self.createBBST(0, len(self.inOrderList)-1)\\n```\n```\\n\\t\\t3\\n\\t  /   \\\\\\n \\t 1     4\\n\\t        \\\\\\n\\t\\t\\t 7\\n\\t\\t\\t  \\\\\\n\\t\\t\\t   9\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t  \\t 10\\n\\t\\t\\t\\t \\n# we perform inOrderTraversal on this BST, we get\\n\\ninOrderList = [1,3,4,7,9,10]\\n\\n# Now if we were to form a Balanced BST from this list, our choice of root will be either 4 or 7 \\n#(partioning the list in such a way that left subtree is roughly equal to right subtree in size/# of nodes).\\n\\n# Say, it was 4: then\\n#\\t\\tleft node of 4 will be decided from the left half of the list (from inOrderList[0:2])\\n#\\t\\tand right node of 4 will be decided from the right half of the list (from inOrderList[3:])\\n#\\t\\tand the process goes on recursively\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604379,
                "title": "easy-c-solution",
                "content": "```\\nprivate:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    private:\\n    TreeNode* BST(vector<int>&v,int l,int h)\\n    {\\n        if(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            TreeNode* root=new TreeNode(v[mid]);\\n            root->left=BST(v,l,mid-1);\\n            root->right=BST(v,mid+1,h);\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    public:\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        vector<int>v;\\n        if(root==NULL)\\n            return root;\\n        inorder(root,v);\\n        return BST(v,0,v.size()-1);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nprivate:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    private:\\n    TreeNode* BST(vector<int>&v,int l,int h)\\n    {\\n        if(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            TreeNode* root=new TreeNode(v[mid]);\\n            root->left=BST(v,l,mid-1);\\n            root->right=BST(v,mid+1,h);\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    public:\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        vector<int>v;\\n        if(root==NULL)\\n            return root;\\n        inorder(root,v);\\n        return BST(v,0,v.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1487702,
                "title": "c-easy-to-understand-fast-find-inorder-traversal-and-then-construct",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        if(root->right)\\n        inorder(root->right,v);\\n    }\\n    TreeNode* solve(int low,int high,vector<TreeNode*> &v)\\n    {\\n        if(low>high)\\n        return NULL;\\n        int m=(low+high)/2;\\n        v[m]->left=solve(low,m-1,v);\\n        v[m]->right=solve(m+1,high,v);\\n        return v[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     return solve(0,v.size()-1,v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        if(root->right)\\n        inorder(root->right,v);\\n    }\\n    TreeNode* solve(int low,int high,vector<TreeNode*> &v)\\n    {\\n        if(low>high)\\n        return NULL;\\n        int m=(low+high)/2;\\n        v[m]->left=solve(low,m-1,v);\\n        v[m]->right=solve(m+1,high,v);\\n        return v[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     return solve(0,v.size()-1,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473137,
                "title": "simple-java-o-n-solution-100-faster-clear-and-step-by-step",
                "content": "public TreeNode balanceBST(TreeNode root) {\\n        \\n        List<TreeNode> list=new ArrayList<>();\\n        \\n        inorder(root,list);\\n        \\n        \\n        return buildTree(list,0,list.size()-1); \\n        \\n        \\n    }\\n    \\n    \\n    public TreeNode buildTree(List<TreeNode> list,int start,int end){\\n        \\n        if(start>end){\\n            return null;\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        \\n        TreeNode root=list.get(mid);\\n        \\n        root.left=buildTree(list,start,mid-1);\\n        root.right=buildTree(list,mid+1,end);\\n        \\n        return root;\\n        \\n    }\\n    \\n    public void inorder(TreeNode root,List<TreeNode> list){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root);\\n        inorder(root.right,list);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "public TreeNode balanceBST(TreeNode root) {\\n        \\n        List<TreeNode> list=new ArrayList<>();\\n        \\n        inorder(root,list);\\n        \\n        \\n        return buildTree(list,0,list.size()-1); \\n        \\n        \\n    }\\n    \\n    \\n    public TreeNode buildTree(List<TreeNode> list,int start,int end){\\n        \\n        if(start>end){\\n            return null;\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        \\n        TreeNode root=list.get(mid);\\n        \\n        root.left=buildTree(list,start,mid-1);\\n        root.right=buildTree(list,mid+1,end);\\n        \\n        return root;\\n        \\n    }\\n    \\n    public void inorder(TreeNode root,List<TreeNode> list){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root);\\n        inorder(root.right,list);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1410630,
                "title": "c-red-balck-bst",
                "content": "DSW and Red-Black are two representative alogrithm to build a balanced tree. \\nDSW is static algorithm so any change after creating it will require you to apply DSW again to keep balance tree.\\nHowever, red-black tree is a dynamic data structure, all of its basic operations are LogN and it will maintain the balanced tree by modifiying itself on the fly when there is change.\\nSince there are already many people posted about DSW, I\\'m going to post Red-black tree version over here.\\n\\nAbout the algorithm : https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* rotateLeft(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode * newHead = root->right;\\n        root->right = newHead->left;\\n        newHead->left = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->left] = true;\\n        return newHead;\\n    }\\n    \\n    TreeNode* rotateRight(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode* newHead = root->left;\\n        root->left = newHead->right;\\n        newHead->right = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->right] = true;\\n        return newHead;\\n    }\\n    \\n    void flipColors(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        isRed[root] = true;\\n        isRed[root->left] = false;\\n        isRed[root->right] = false;\\n    }\\n    \\n    \\n    TreeNode* put(TreeNode* rbRoot, TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        if(rbRoot == nullptr){\\n            rbRoot = root;\\n            isRed[rbRoot] = true;\\n            return rbRoot;\\n        }\\n        if(root->val<= rbRoot->val){\\n            rbRoot->left = put(rbRoot->left, root, isRed);\\n        } else {\\n            rbRoot->right = put(rbRoot->right, root, isRed);\\n        }\\n        if(rbRoot->right && isRed[rbRoot->right]){\\n            rbRoot = rotateLeft(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->left->left && isRed[rbRoot->left->left] && isRed[rbRoot->left]){\\n            rbRoot = rotateRight(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->right && isRed[rbRoot->left] && isRed[rbRoot->right]){\\n            flipColors(rbRoot, isRed);\\n        }\\n        return rbRoot;\\n    }\\n    \\n    void iterate(TreeNode* root,TreeNode** rbRoot, unordered_map<TreeNode*, bool> &isRed){\\n        if(root == nullptr){\\n            return;\\n        }\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = nullptr;\\n        root->right = nullptr;\\n        iterate(left, rbRoot, isRed);\\n        *rbRoot = put(*rbRoot, root, isRed);\\n        iterate(right, rbRoot, isRed);\\n        return;\\n    }\\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        unordered_map<TreeNode*, bool> isRed;\\n        TreeNode* rbRoot = nullptr;\\n        iterate(root, &rbRoot, isRed);\\n        return rbRoot;\\n    }\\n};\\n```\\n\\nWhile DSW will use O(N) time to create, red-black tree will use O(NlogN) to balance a tree whose node size is N.\\nHowever, in the future when we add a new node, DSW will need to use its O(N) algorithm to balance while red-black tree will use O(logn) to add that new node.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* rotateLeft(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode * newHead = root->right;\\n        root->right = newHead->left;\\n        newHead->left = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->left] = true;\\n        return newHead;\\n    }\\n    \\n    TreeNode* rotateRight(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode* newHead = root->left;\\n        root->left = newHead->right;\\n        newHead->right = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->right] = true;\\n        return newHead;\\n    }\\n    \\n    void flipColors(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        isRed[root] = true;\\n        isRed[root->left] = false;\\n        isRed[root->right] = false;\\n    }\\n    \\n    \\n    TreeNode* put(TreeNode* rbRoot, TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        if(rbRoot == nullptr){\\n            rbRoot = root;\\n            isRed[rbRoot] = true;\\n            return rbRoot;\\n        }\\n        if(root->val<= rbRoot->val){\\n            rbRoot->left = put(rbRoot->left, root, isRed);\\n        } else {\\n            rbRoot->right = put(rbRoot->right, root, isRed);\\n        }\\n        if(rbRoot->right && isRed[rbRoot->right]){\\n            rbRoot = rotateLeft(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->left->left && isRed[rbRoot->left->left] && isRed[rbRoot->left]){\\n            rbRoot = rotateRight(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->right && isRed[rbRoot->left] && isRed[rbRoot->right]){\\n            flipColors(rbRoot, isRed);\\n        }\\n        return rbRoot;\\n    }\\n    \\n    void iterate(TreeNode* root,TreeNode** rbRoot, unordered_map<TreeNode*, bool> &isRed){\\n        if(root == nullptr){\\n            return;\\n        }\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = nullptr;\\n        root->right = nullptr;\\n        iterate(left, rbRoot, isRed);\\n        *rbRoot = put(*rbRoot, root, isRed);\\n        iterate(right, rbRoot, isRed);\\n        return;\\n    }\\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        unordered_map<TreeNode*, bool> isRed;\\n        TreeNode* rbRoot = nullptr;\\n        iterate(root, &rbRoot, isRed);\\n        return rbRoot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328246,
                "title": "basic-idea-inorder-traversal-balanced-bst",
                "content": "Break the problem into two-\\n* create an inorder traversal vector.\\n* use this vector to create balanced binary search tree\\n\\nvoid inorder(TreeNode *root,vector<int>&v)\\n    {\\n        if(root==NULL)return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    TreeNode* construct(vector<int>&v , int low , int high)\\n    {\\n        if(low>high)return NULL;\\n        int ind=low + (high-low)/2;\\n        TreeNode *root=new TreeNode(v[ind]);\\n        root->left = construct(v,low,ind-1);\\n        root->right = construct(v,ind+1,high);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int>v;\\n        inorder(root,v);\\n        return (construct(v,0,v.size()-1));\\n    }",
                "solutionTags": [],
                "code": "Break the problem into two-\\n* create an inorder traversal vector.\\n* use this vector to create balanced binary search tree\\n\\nvoid inorder(TreeNode *root,vector<int>&v)\\n    {\\n        if(root==NULL)return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    TreeNode* construct(vector<int>&v , int low , int high)\\n    {\\n        if(low>high)return NULL;\\n        int ind=low + (high-low)/2;\\n        TreeNode *root=new TreeNode(v[ind]);\\n        root->left = construct(v,low,ind-1);\\n        root->right = construct(v,ind+1,high);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int>v;\\n        inorder(root,v);\\n        return (construct(v,0,v.size()-1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1297056,
                "title": "python-inorder-traversal-and-reconstruct-bst",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        \\n        # Inorder traverse the tree\\n        def inorder(root, nums) -> None:\\n            if root == None:\\n                return\\n            \\n            if root.left != None:\\n                inorder(root.left, nums)\\n            \\n            nums.append(root.val)\\n            \\n            if root.right != None:\\n                inorder(root.right, nums)\\n\\n                \\n                \\n                \\n        # Recursively construct the BST given the list of value\\n        def constructBST(nums):\\n            totalNums = len(nums)\\n            \\n            if totalNums == 0:\\n                return None\\n            else:\\n                rootIndex = totalNums // 2\\n                print(nums, rootIndex)    \\n                root = TreeNode(nums[rootIndex])\\n                \\n                root.left = constructBST(nums[:rootIndex])\\n                root.right = constructBST(nums[rootIndex+1:])\\n                \\n                return root\\n                    \\n            \\n        nums = []\\n        inorder(root, nums)\\n        return constructBST(nums)\\n\\t\\t\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        \\n        # Inorder traverse the tree\\n        def inorder(root, nums) -> None:\\n            if root == None:\\n                return\\n            \\n            if root.left != None:\\n                inorder(root.left, nums)\\n            \\n            nums.append(root.val)\\n            \\n            if root.right != None:\\n                inorder(root.right, nums)\\n\\n                \\n                \\n                \\n        # Recursively construct the BST given the list of value\\n        def constructBST(nums):\\n            totalNums = len(nums)\\n            \\n            if totalNums == 0:\\n                return None\\n            else:\\n                rootIndex = totalNums // 2\\n                print(nums, rootIndex)    \\n                root = TreeNode(nums[rootIndex])\\n                \\n                root.left = constructBST(nums[:rootIndex])\\n                root.right = constructBST(nums[rootIndex+1:])\\n                \\n                return root\\n                    \\n            \\n        nums = []\\n        inorder(root, nums)\\n        return constructBST(nums)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861125,
                "title": "java-solution-using-inorder-and-then-balancing",
                "content": "```\\nclass Solution {\\n    private TreeNode roott;\\n    private List<Integer> list;\\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        TreeNode tn = balancedBst(0,list.size()-1);\\n        return tn;\\n    }\\n    \\n    void inorder(TreeNode node){\\n        if(node == null)\\n            return;\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n     TreeNode balancedBst(int start,int end){\\n        \\n         if(start > end){\\n             return null;\\n         }\\n         \\n         int mid = (start+end)/2;\\n         TreeNode node = new TreeNode(list.get(mid));\\n         node.left = balancedBst(start,mid-1);\\n         node.right = balancedBst(mid+1,end);\\n             \\n         return node;\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private TreeNode roott;\\n    private List<Integer> list;\\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        TreeNode tn = balancedBst(0,list.size()-1);\\n        return tn;\\n    }\\n    \\n    void inorder(TreeNode node){\\n        if(node == null)\\n            return;\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n     TreeNode balancedBst(int start,int end){\\n        \\n         if(start > end){\\n             return null;\\n         }\\n         \\n         int mid = (start+end)/2;\\n         TreeNode node = new TreeNode(list.get(mid));\\n         node.left = balancedBst(start,mid-1);\\n         node.right = balancedBst(mid+1,end);\\n             \\n         return node;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787872,
                "title": "java-o-n-space-o-n-time-2ms-recursion-divide-and-conquer",
                "content": "Please read comments. And upwote if you like this solution\\n```\\nclass Solution {\\n\\t// to store all nodes values\\n    List<Integer> array = new ArrayList<Integer>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n\\t\\t// traverse recursively to save sorged list of all node values\\n        traverse(root);\\n\\t\\t// build recursively new BST\\n        return buildTree(0, array.size() - 1);\\n    }\\n    \\n\\t// Divide and conquer\\n\\t// get mid item as a root node.\\n\\t// nodes to the left will build left subtree\\n\\t// nodes to the right will build right subtree\\n    public TreeNode buildTree(int start, int end) {\\n        if (start > end) return null;\\n        int mid = start + (end - start)/2;\\n        TreeNode node = new TreeNode(array.get(mid));\\n        node.left = buildTree(start, mid - 1);\\n        node.right = buildTree(mid + 1, end);\\n        return node;\\n    }\\n    \\n\\t// inorder traversal Left - Curr - Right\\n\\t// Array will be sorted, guaranted by BST Properties\\n    public void traverse(TreeNode root) {\\n        if (root.left != null) {\\n            traverse(root.left);\\n        }\\n        array.add(root.val);\\n        if (root.right != null) {\\n            traverse(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t// to store all nodes values\\n    List<Integer> array = new ArrayList<Integer>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n\\t\\t// traverse recursively to save sorged list of all node values\\n        traverse(root);\\n\\t\\t// build recursively new BST\\n        return buildTree(0, array.size() - 1);\\n    }\\n    \\n\\t// Divide and conquer\\n\\t// get mid item as a root node.\\n\\t// nodes to the left will build left subtree\\n\\t// nodes to the right will build right subtree\\n    public TreeNode buildTree(int start, int end) {\\n        if (start > end) return null;\\n        int mid = start + (end - start)/2;\\n        TreeNode node = new TreeNode(array.get(mid));\\n        node.left = buildTree(start, mid - 1);\\n        node.right = buildTree(mid + 1, end);\\n        return node;\\n    }\\n    \\n\\t// inorder traversal Left - Curr - Right\\n\\t// Array will be sorted, guaranted by BST Properties\\n    public void traverse(TreeNode root) {\\n        if (root.left != null) {\\n            traverse(root.left);\\n        }\\n        array.add(root.val);\\n        if (root.right != null) {\\n            traverse(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539793,
                "title": "java-inorder-bst",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> nums;\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        nums = new ArrayList<Integer>();\\n        getNumbers(root);\\n        TreeNode res = balanceTree(0,nums.size()-1);\\n        return res;\\n    }\\n    \\n    private void getNumbers(TreeNode node){\\n        if(node==null) return;\\n        getNumbers(node.left);\\n        nums.add(node.val);\\n        getNumbers(node.right);\\n    }\\n    \\n    private TreeNode balanceTree(int l, int r){\\n        if(l>r)return null;\\n        int middleIdx = l+ ((r-l)/2);\\n        TreeNode res = new TreeNode(nums.get(middleIdx));\\n        res.left = balanceTree(l,middleIdx-1);\\n        res.right = balanceTree(middleIdx+1,r);\\n        return res;\\n    }              \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> nums;\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        nums = new ArrayList<Integer>();\\n        getNumbers(root);\\n        TreeNode res = balanceTree(0,nums.size()-1);\\n        return res;\\n    }\\n    \\n    private void getNumbers(TreeNode node){\\n        if(node==null) return;\\n        getNumbers(node.left);\\n        nums.add(node.val);\\n        getNumbers(node.right);\\n    }\\n    \\n    private TreeNode balanceTree(int l, int r){\\n        if(l>r)return null;\\n        int middleIdx = l+ ((r-l)/2);\\n        TreeNode res = new TreeNode(nums.get(middleIdx));\\n        res.left = balanceTree(l,middleIdx-1);\\n        res.right = balanceTree(middleIdx+1,r);\\n        return res;\\n    }              \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539763,
                "title": "swift-inorder-dfs-clean-code",
                "content": "We create a sorted array by using inorder traversal\\n```\\nclass Solution {\\n    func balanceBST(_ root: TreeNode?) -> TreeNode? {\\n        var arr = [TreeNode]()\\n        \\n        func inorder(_ node: TreeNode?) {\\n            guard let node = node else { return }\\n            inorder(node.left)\\n            arr.append(node)\\n            inorder(node.right)\\n        }\\n        \\n        func build(_ nodes: [TreeNode], _ start: Int, _ end: Int) -> TreeNode? {\\n            if start > end { return nil }\\n  \\n            let mid = (start + end) / 2\\n            var node = nodes[mid] \\n            \\n            node.left = build(nodes, start, mid - 1)\\n            node.right = build(nodes, mid + 1, end)\\n\\n            return node\\n        }\\n        \\n        inorder(root)\\n        return build(arr, 0, arr.count-1)\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func balanceBST(_ root: TreeNode?) -> TreeNode? {\\n        var arr = [TreeNode]()\\n        \\n        func inorder(_ node: TreeNode?) {\\n            guard let node = node else { return }\\n            inorder(node.left)\\n            arr.append(node)\\n            inorder(node.right)\\n        }\\n        \\n        func build(_ nodes: [TreeNode], _ start: Int, _ end: Int) -> TreeNode? {\\n            if start > end { return nil }\\n  \\n            let mid = (start + end) / 2\\n            var node = nodes[mid] \\n            \\n            node.left = build(nodes, start, mid - 1)\\n            node.right = build(nodes, mid + 1, end)\\n\\n            return node\\n        }\\n        \\n        inorder(root)\\n        return build(arr, 0, arr.count-1)\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539728,
                "title": "java-store-inorder-and-then-build-the-tree-again",
                "content": "```\\nclass Solution {\\n    static List<Integer> arr;\\n    public static void dfs(TreeNode root) {\\n        if(root == null) return;\\n        dfs(root.left);\\n        arr.add(root.val);\\n        dfs(root.right);\\n    }\\n    public static TreeNode build(List<Integer> arr, int st, int end) {\\n        if(st > end) return null;\\n        if(st == end) return new TreeNode(arr.get(st));\\n        int mid = (st + end)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = build(arr, st, mid - 1);\\n        root.right = build(arr, mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        arr = new ArrayList<>();\\n        dfs(root);\\n        return build(arr, 0, arr.size() - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static List<Integer> arr;\\n    public static void dfs(TreeNode root) {\\n        if(root == null) return;\\n        dfs(root.left);\\n        arr.add(root.val);\\n        dfs(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4010316,
                "title": "didive-and-conquer-simple-solution-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- given a **Binary Search Tree**\\n- the goal is to make this tree `balanced`\\n\\n```py\\n# Example\\nnodes = TreeNode(0, None, TreeNode(1, None, TreeNode(2)))\\n\\n# The first step is to inorder traversal, to get all nodes\\n# in sorted order \\nnums = [0, 1, 2]\\n\\n# The next step is to recreate a tree,\\n# there\\'s a bunch of different approaches, like building \\n# AVL-tree, but for the sake of brefity, we focus only\\n# on Divide-and-Conquer.\\n# The goal is to split a list at equal size parts by\\n# defining a middle of an initial list\\nnode = TreeNode(nums[1])\\nnode.left = TreeNode(nums[0])\\nnode.right = TreeNode(nums[2])\\n\\n# The thing is that the example above HARDCODED only for 3 nodes\\n# in that list, thus we need to split a list and repeat\\n# the procedure until we\\'re out of nodes\\n\\n```\\n\\n# Approach\\n1. initialize a `nums` variable to store the ordered numbers\\n2. perform `inorder traversal` by implementing and calling `dfs` function\\n3. create a `balance` function with `left` and `right` arguments as starting and ending index of `nums`\\n4. if we\\'re out of nodes `left > right`, return `None`\\n5. find the `mid` by dividing a **sum** of pointers\\n6. shift the pointers as if it was a **binary search** and store the result into `node.left` and `node.right` children\\n7. return `node`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of twice iterating over `root` and `nums`\\n\\n- Space complexity: **O(n)**, this requires for recursive stack calling.\\n\\n# Code\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = []\\n\\n        def dfs(node):\\n            if not node:\\n                return \\n\\n            dfs(node.left)\\n            nums.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n\\n        def balance(left = 0, right = len(nums) - 1):\\n            if left > right:\\n                return None\\n\\n            mid = (left + right) // 2\\n            node = TreeNode(nums[mid])\\n            node.left = balance(left, mid - 1)\\n            node.right = balance(mid + 1, right)\\n\\n            return node\\n\\n        return balance() \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```py\\n# Example\\nnodes = TreeNode(0, None, TreeNode(1, None, TreeNode(2)))\\n\\n# The first step is to inorder traversal, to get all nodes\\n# in sorted order \\nnums = [0, 1, 2]\\n\\n# The next step is to recreate a tree,\\n# there\\'s a bunch of different approaches, like building \\n# AVL-tree, but for the sake of brefity, we focus only\\n# on Divide-and-Conquer.\\n# The goal is to split a list at equal size parts by\\n# defining a middle of an initial list\\nnode = TreeNode(nums[1])\\nnode.left = TreeNode(nums[0])\\nnode.right = TreeNode(nums[2])\\n\\n# The thing is that the example above HARDCODED only for 3 nodes\\n# in that list, thus we need to split a list and repeat\\n# the procedure until we\\'re out of nodes\\n\\n```\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = []\\n\\n        def dfs(node):\\n            if not node:\\n                return \\n\\n            dfs(node.left)\\n            nums.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n\\n        def balance(left = 0, right = len(nums) - 1):\\n            if left > right:\\n                return None\\n\\n            mid = (left + right) // 2\\n            node = TreeNode(nums[mid])\\n            node.left = balance(left, mid - 1)\\n            node.right = balance(mid + 1, right)\\n\\n            return node\\n\\n        return balance() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780838,
                "title": "solve-using-divide-and-conquer-algorithm",
                "content": "# Intuition\\nWe want to convert an original unbalanced binary search tree to balanced binary search tree.\\n\\n# Approach\\nFirst of all, we will use depth-first-search to traverse in-order and put them into a list of integer. Then we will use this list to construct a new height balanced binary search tree using normal divide and conquer.\\n\\n# Complexity\\n- Time complexity:\\nO(n) with n as the number of vertices.\\n\\n- Space complexity:\\nO(log(n)) on average and O(n) worst scenario.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // convert a bst to an inorder traversal\\n    private static void convertInorder(TreeNode root, List<Integer> inOrderTraversal) {\\n        if(root==null) return;\\n        convertInorder(root.left, inOrderTraversal);\\n        inOrderTraversal.add(root.val);\\n        convertInorder(root.right, inOrderTraversal);  \\n    }\\n    // construct a height balanced bst using the in-order\\n    private TreeNode constructBST(List<Integer> inOrderTraversal, int start, int end) {\\n        if(start > end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(inOrderTraversal.get(mid));\\n        root.left = constructBST(inOrderTraversal, start, mid-1);\\n        root.right = constructBST(inOrderTraversal, mid+1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root==null) return null;\\n        List<Integer> inOrderTraversal = new ArrayList<>();\\n        convertInorder(root, inOrderTraversal);\\n        return constructBST(inOrderTraversal, 0, inOrderTraversal.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // convert a bst to an inorder traversal\\n    private static void convertInorder(TreeNode root, List<Integer> inOrderTraversal) {\\n        if(root==null) return;\\n        convertInorder(root.left, inOrderTraversal);\\n        inOrderTraversal.add(root.val);\\n        convertInorder(root.right, inOrderTraversal);  \\n    }\\n    // construct a height balanced bst using the in-order\\n    private TreeNode constructBST(List<Integer> inOrderTraversal, int start, int end) {\\n        if(start > end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(inOrderTraversal.get(mid));\\n        root.left = constructBST(inOrderTraversal, start, mid-1);\\n        root.right = constructBST(inOrderTraversal, mid+1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root==null) return null;\\n        List<Integer> inOrderTraversal = new ArrayList<>();\\n        convertInorder(root, inOrderTraversal);\\n        return constructBST(inOrderTraversal, 0, inOrderTraversal.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712468,
                "title": "easy-c-solution-beat-80",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void inorderarray(TreeNode* &root,vector<int> &inorder){\\n        if(root==NULL)\\n        return ;\\n        inorderarray(root->left,inorder);\\n        inorder.push_back(root->val);\\n        inorderarray(root->right,inorder);\\n    }\\n    TreeNode* buildtree(vector<int>& inorder,int s,int e){\\n    if(s>e)\\n        return NULL;\\n    int mid=s+(e-s)/2;\\n    int ele=inorder[mid];\\n    TreeNode* root=new TreeNode(ele);\\n    root->left=buildtree(inorder,s,mid-1);\\n    root->right=buildtree(inorder,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        inorderarray(root,inorder);\\n        return buildtree(inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void inorderarray(TreeNode* &root,vector<int> &inorder){\\n        if(root==NULL)\\n        return ;\\n        inorderarray(root->left,inorder);\\n        inorder.push_back(root->val);\\n        inorderarray(root->right,inorder);\\n    }\\n    TreeNode* buildtree(vector<int>& inorder,int s,int e){\\n    if(s>e)\\n        return NULL;\\n    int mid=s+(e-s)/2;\\n    int ele=inorder[mid];\\n    TreeNode* root=new TreeNode(ele);\\n    root->left=buildtree(inorder,s,mid-1);\\n    root->right=buildtree(inorder,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        inorderarray(root,inorder);\\n        return buildtree(inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473553,
                "title": "easy-c-solution-using-recursion-and-inorder-traversal",
                "content": "\\n\\n# Approach\\nNormal BST to vector because we get in sorted order and then make a BST again\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root, vector<TreeNode*> &arr){\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root);\\n        fun(root->right,arr);\\n    }\\n\\n    TreeNode* newbst(vector<TreeNode*> &arr,int start,int end )\\n    {\\n        if(start>end)\\n        {\\n            return NULL;\\n        }\\n        int mid =start+(end-start)/2;\\n        TreeNode* temp=arr[mid];\\n        temp->left=newbst(arr,start,mid-1);\\n        temp->right=newbst(arr,mid+1,end);\\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>arr;\\n        fun(root,arr);\\n        return newbst(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root, vector<TreeNode*> &arr){\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root);\\n        fun(root->right,arr);\\n    }\\n\\n    TreeNode* newbst(vector<TreeNode*> &arr,int start,int end )\\n    {\\n        if(start>end)\\n        {\\n            return NULL;\\n        }\\n        int mid =start+(end-start)/2;\\n        TreeNode* temp=arr[mid];\\n        temp->left=newbst(arr,start,mid-1);\\n        temp->right=newbst(arr,mid+1,end);\\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>arr;\\n        fun(root,arr);\\n        return newbst(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092851,
                "title": "simple-approach-inorder-traversal-o-n-time",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*>inorder;\\n    void buildInorder(TreeNode* root){\\n        if(!root)return;\\n        buildInorder(root->left);\\n        inorder.push_back(root);\\n        buildInorder(root->right);\\n    }\\n    TreeNode* balanceUtil(TreeNode* root,int is,int ie){\\n        if(is>ie)return NULL;\\n        int mid=(is+ie)/2;\\n        root=inorder[mid];\\n        root->left=balanceUtil(root->left,is,mid-1);\\n        root->right=balanceUtil(root->right,mid+1,ie);\\n        return root;\\n\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        buildInorder(root);\\n        return balanceUtil(root,0,inorder.size()-1);\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*>inorder;\\n    void buildInorder(TreeNode* root){\\n        if(!root)return;\\n        buildInorder(root->left);\\n        inorder.push_back(root);\\n        buildInorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2848494,
                "title": "c-solution-recursion-sc-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solution1(vector <int> &v,int start,int end){\\n        if(start>end) return NULL;\\n        int mid=start+(end-start)/2;\\n        TreeNode * root=new TreeNode (v[mid]);\\n        root->left=solution1(v,start,mid-1);\\n         root->right=solution1(v,mid+1,end);\\n         return root;\\n        \\n    }\\n    void solution(vector <int> &v,TreeNode* root){\\n        if(!root) return;\\n        solution(v,root->left);\\n        v.push_back(root->val);\\n        solution(v,root->right);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector <int> v;\\n        solution(v,root);\\n        return solution1(v,0,v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solution1(vector <int> &v,int start,int end){\\n        if(start>end) return NULL;\\n        int mid=start+(end-start)/2;\\n        TreeNode * root=new TreeNode (v[mid]);\\n        root->left=solution1(v,start,mid-1);\\n         root->right=solution1(v,mid+1,end);\\n         return root;\\n        \\n    }\\n    void solution(vector <int> &v,TreeNode* root){\\n        if(!root) return;\\n        solution(v,root->left);\\n        v.push_back(root->val);\\n        solution(v,root->right);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector <int> v;\\n        solution(v,root);\\n        return solution1(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448929,
                "title": "90-faster-python-tc-385ms",
                "content": "```\\ndef helper(head): #getting a sorted list\\n\\tif not head:\\n\\t\\treturn\\n\\thelper(head.left)\\n\\tlist1.append(head.val)\\n\\thelper(head.right)\\n\\n\\ndef BBST(list1,start,end): #creating a Balance Binary search tree.\\n\\tif start > end:\\n\\t\\treturn\\n\\tmid = (end-start)//2 \\n\\troot = TreeNode(list1[mid]) \\n\\troot.left = BBST(list1[:mid],0,mid-1) \\n\\troot.right = BBST(list1[mid+1:],mid+1,len(list1)-1) \\n\\treturn root     \\n\\nlist1 = []\\nhelper(root) # getting a sorted list\\n_len = len(list1)   \\nreturn BBST(list1,0,_len) #creating a Balance Binary search tree.\\n```\\n\\nplease upvote.\\nThank You :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\ndef helper(head): #getting a sorted list\\n\\tif not head:\\n\\t\\treturn\\n\\thelper(head.left)\\n\\tlist1.append(head.val)\\n\\thelper(head.right)\\n\\n\\ndef BBST(list1,start,end): #creating a Balance Binary search tree.\\n\\tif start > end:\\n\\t\\treturn\\n\\tmid = (end-start)//2 \\n\\troot = TreeNode(list1[mid]) \\n\\troot.left = BBST(list1[:mid],0,mid-1) \\n\\troot.right = BBST(list1[mid+1:],mid+1,len(list1)-1) \\n\\treturn root     \\n\\nlist1 = []\\nhelper(root) # getting a sorted list\\n_len = len(list1)   \\nreturn BBST(list1,0,_len) #creating a Balance Binary search tree.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409235,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding inorder traversal of tree\\n    \\n    void inorder(TreeNode* root, vector<int>& arr)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root -> left, arr);\\n        \\n        arr.push_back(root -> val);\\n        \\n        inorder(root -> right, arr);\\n    }\\n    \\n    // function for balancing bst\\n    \\n    TreeNode* balance_bst(vector<int>& arr, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n            return NULL;\\n        \\n        // find mid\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        // create root and insert value as arr[mid]\\n        \\n        TreeNode* root = new TreeNode(arr[mid]);\\n        \\n        // call for creating balanced left subtree\\n        \\n        root -> left = balance_bst(arr, start, mid - 1);\\n        \\n        // call for creating balanced right subtree\\n        \\n        root -> right = balance_bst(arr, mid + 1, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        // arr will store the inorder traversal of bst\\n        \\n        vector<int> arr;\\n        \\n        inorder(root, arr);\\n        \\n        // create balance bst\\n        \\n        return balance_bst(arr, 0, arr.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding inorder traversal of tree\\n    \\n    void inorder(TreeNode* root, vector<int>& arr)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root -> left, arr);\\n        \\n        arr.push_back(root -> val);\\n        \\n        inorder(root -> right, arr);\\n    }\\n    \\n    // function for balancing bst\\n    \\n    TreeNode* balance_bst(vector<int>& arr, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n            return NULL;\\n        \\n        // find mid\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        // create root and insert value as arr[mid]\\n        \\n        TreeNode* root = new TreeNode(arr[mid]);\\n        \\n        // call for creating balanced left subtree\\n        \\n        root -> left = balance_bst(arr, start, mid - 1);\\n        \\n        // call for creating balanced right subtree\\n        \\n        root -> right = balance_bst(arr, mid + 1, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        // arr will store the inorder traversal of bst\\n        \\n        vector<int> arr;\\n        \\n        inorder(root, arr);\\n        \\n        // create balance bst\\n        \\n        return balance_bst(arr, 0, arr.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310699,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> arr = new ArrayList();\\n        InOrder( root,  arr);\\n        return sortedArrayToBST( arr, 0, arr.size()-1);\\n    }\\n    \\n    public void InOrder(TreeNode node, List<Integer> arr){\\n        if(node != null){\\n            InOrder( node.left, arr);\\n            arr.add(node.val);\\n            InOrder( node.right, arr);\\n        }\\n    }\\n    \\n    public TreeNode sortedArrayToBST(List<Integer> arr, int start, int end) {\\n\\n        if (start > end) {\\n            return null;\\n        }\\n \\n        int mid = (start + end) / 2;\\n        \\n        TreeNode node = new TreeNode(arr.get(mid));\\n        node.left = sortedArrayToBST(arr, start, mid - 1);\\n        node.right = sortedArrayToBST(arr, mid + 1, end);\\n         \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> arr = new ArrayList();\\n        InOrder( root,  arr);\\n        return sortedArrayToBST( arr, 0, arr.size()-1);\\n    }\\n    \\n    public void InOrder(TreeNode node, List<Integer> arr){\\n        if(node != null){\\n            InOrder( node.left, arr);\\n            arr.add(node.val);\\n            InOrder( node.right, arr);\\n        }\\n    }\\n    \\n    public TreeNode sortedArrayToBST(List<Integer> arr, int start, int end) {\\n\\n        if (start > end) {\\n            return null;\\n        }\\n \\n        int mid = (start + end) / 2;\\n        \\n        TreeNode node = new TreeNode(arr.get(mid));\\n        node.left = sortedArrayToBST(arr, start, mid - 1);\\n        node.right = sortedArrayToBST(arr, mid + 1, end);\\n         \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296913,
                "title": "c-inorder-traversal-o-n-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    void getTree(TreeNode* node, vector<int>&v)\\n    {\\n        if(!node)\\n            return;\\n        \\n        getTree(node->left, v);\\n        v.push_back(node->val);\\n        getTree(node->right, v);\\n    }\\n    \\n    TreeNode* makeTree(vector<int>& v, int left, int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        int mid=(left+right)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        node->left=makeTree(v, left, mid-1);\\n        node->right=makeTree(v, mid+1, right); \\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        getTree(root, v);\\n        return makeTree(v, 0, v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    void getTree(TreeNode* node, vector<int>&v)\\n    {\\n        if(!node)\\n            return;\\n        \\n        getTree(node->left, v);\\n        v.push_back(node->val);\\n        getTree(node->right, v);\\n    }\\n    \\n    TreeNode* makeTree(vector<int>& v, int left, int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        int mid=(left+right)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        node->left=makeTree(v, left, mid-1);\\n        node->right=makeTree(v, mid+1, right); \\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        getTree(root, v);\\n        return makeTree(v, 0, v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173620,
                "title": "convert-to-doublylinkedlist-and-then-to-bst-without-extra-space-o-n",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n        \\n        TreeNode prev=new TreeNode(-1);\\n        createDLL(root,prev);\\n\\t\\t\\n        return balancedBST(prev.right,null);\\n    }\\n    \\n    private TreeNode balancedBST(TreeNode start, TreeNode end){\\n        if(start==end || start==null){\\n            return null;\\n        }\\n        \\n        TreeNode slow=start;\\n        TreeNode fast=start;\\n        while(fast!=end && fast.right!=end){\\n            slow=slow.right;\\n            fast=fast.right.right;\\n        }\\n        \\n        slow.left=balancedBST(start,slow);\\n        slow.right=balancedBST(slow.right,end);\\n        \\n        return slow;\\n    }\\n    \\n    private TreeNode createDLL(TreeNode root, TreeNode prev){\\n        \\n        if(root.left!=null){\\n            prev=createDLL(root.left,prev);\\n        }\\n        \\n        prev.right=root;\\n        root.left=prev;\\n        prev=root;\\n        \\n        if(root.right!=null){\\n            prev=createDLL(root.right,prev);\\n        }\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n        \\n        TreeNode prev=new TreeNode(-1);\\n        createDLL(root,prev);\\n\\t\\t\\n        return balancedBST(prev.right,null);\\n    }\\n    \\n    private TreeNode balancedBST(TreeNode start, TreeNode end){\\n        if(start==end || start==null){\\n            return null;\\n        }\\n        \\n        TreeNode slow=start;\\n        TreeNode fast=start;\\n        while(fast!=end && fast.right!=end){\\n            slow=slow.right;\\n            fast=fast.right.right;\\n        }\\n        \\n        slow.left=balancedBST(start,slow);\\n        slow.right=balancedBST(slow.right,end);\\n        \\n        return slow;\\n    }\\n    \\n    private TreeNode createDLL(TreeNode root, TreeNode prev){\\n        \\n        if(root.left!=null){\\n            prev=createDLL(root.left,prev);\\n        }\\n        \\n        prev.right=root;\\n        root.left=prev;\\n        prev=root;\\n        \\n        if(root.right!=null){\\n            prev=createDLL(root.right,prev);\\n        }\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2127321,
                "title": "java-extremely-easy-to-understand-faster-than-98",
                "content": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(n)\\n\\nclass Solution {\\n    List<TreeNode> inorder = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        getInOrder(root);\\n        return createBalancedBST(0, inorder.size() - 1);\\n    }\\n    \\n    public void getInOrder(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        getInOrder(node.left);\\n        inorder.add(node);\\n        getInOrder(node.right);\\n    }\\n    \\n    public TreeNode createBalancedBST(int left, int right) {\\n        if(left > right) {\\n            return null;\\n        }\\n        \\n        int mid = (left + right) / 2;\\n        TreeNode curr = inorder.get(mid);\\n        \\n        curr.left = createBalancedBST(left, mid - 1);\\n        curr.right = createBalancedBST(mid + 1, right);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(n)\\n\\nclass Solution {\\n    List<TreeNode> inorder = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        getInOrder(root);\\n        return createBalancedBST(0, inorder.size() - 1);\\n    }\\n    \\n    public void getInOrder(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        getInOrder(node.left);\\n        inorder.add(node);\\n        getInOrder(node.right);\\n    }\\n    \\n    public TreeNode createBalancedBST(int left, int right) {\\n        if(left > right) {\\n            return null;\\n        }\\n        \\n        int mid = (left + right) / 2;\\n        TreeNode curr = inorder.get(mid);\\n        \\n        curr.left = createBalancedBST(left, mid - 1);\\n        curr.right = createBalancedBST(mid + 1, right);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091065,
                "title": "dsw-algorithm-o-n-o-1-c-explained",
                "content": "**Approach**:  The algorithm used in this scenario is the Day-Stout-Warren algorithm. The balanced tree formed will be a complete binary tree. Follow the steps below for the implementation of the algorithm.\\n\\n**Step 1**: Convert the given BST into a linked list ( right-sided linked list ) using the concept of right rotations by means of inorder traversal. This form of BST is known as backbone or vine. the Runtime of this phase is linear and no extra space is required. \\nThe function is coded in such a way that it does all the required right rotation to flatten the BST and at the end returns the number of nodes in BST.\\n\\n**Step 2:**  Calculate the height of BST in which all the levels will be completely filled using the formula h = log2(N+1) [N is the total number of nodes]. And using the height calculate the number of nodes that can be fitted in that height m = pow(2, h)-1. [h is height till which all the levels are fully filled with nodes]\\nThe difference (diff) of N and m is the amount of nodes that will be there in last level of balanced complete binary tree.\\nThe vine obtained in the first step is then left rotated diff amount of time from its root. The above modified tree is then left rotated m/2, m/4, m/8 . . . times until m is greater than 0 according to the algorithm.\\n**Illustrations:**\\n\\n**Illustration-1:** Here the given tree is a left skewed BST\\n![image](https://assets.leetcode.com/users/images/e9b46040-fbd2-4f83-ac72-093417ad432e_1653807803.6961153.png)\\n\\n                             \\n\\n**Illustration-2:** Here it is a non-skewed but unbalanced BST\\n![image](https://assets.leetcode.com/users/images/3e37188f-4912-48a2-9b12-ab1a66c8f8a4_1653920334.9465852.png)\\n\\n\\n\\n\\n                                                   Example-2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nsource- gfg\\n```\\n/ C++ code to balance BST using DSW algorithm.\\n// Function to convert input BST\\n// to right linked list\\n// known as vine or backbone.\\nint bstToVine(TreeNode* grand)\\n{\\n    int count = 0;\\n \\n    // Make tmp pointer to traverse\\n    // and right flatten the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse until tmp becomes NULL\\n    while (tmp) {\\n         \\n        // If left exist for node\\n        // pointed by tmp then\\n        // right rotate it.\\n        if (tmp->left) {\\n            TreeNode* oldTmp = tmp;\\n            tmp = tmp->left;\\n            oldTmp->left = tmp->right;\\n            tmp->right = oldTmp;\\n            grand->right = tmp;\\n        }\\n \\n        // If left dont exists\\n        // add 1 to count and\\n        // traverse further right to\\n        // flatten remaining BST.\\n        else {\\n            count++;\\n            grand = tmp;\\n            tmp = tmp->right;\\n        }\\n    }\\n \\n    return count;\\n}\\n \\n// Function to compress given tree\\n// with its root as grand->right.\\nvoid compress(TreeNode* grand, int m)\\n{\\n    // Make tmp pointer to traverse\\n    // and compress the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse and left-rotate root m times\\n    // to compress given vine form of BST.\\n    for (int i = 0; i < m; i++) {\\n        TreeNode* oldTmp = tmp;\\n        tmp = tmp->right;\\n        grand->right = tmp;\\n        oldTmp->right = tmp->left;\\n        tmp->left = oldTmp;\\n        grand = tmp;\\n        tmp = tmp->right;\\n    }\\n}\\n \\n// Function to implement the algorithm\\nTreeNode* balanceBST(TreeNode* root)\\n{\\n    // create dummy node with value 0\\n    TreeNode* grand = new TreeNode(0);\\n \\n    // assign the right of dummy node as our input BST\\n    grand->right = root;\\n \\n    // get the number of nodes in input BST and\\n    // simultaneously convert it into right linked list.\\n    int count = bstToVine(grand);\\n \\n    // gets the height of tree in which all levels\\n    // are completely filled.\\n    int h = log2(count + 1);\\n \\n    // get number of nodes until second last level\\n    int m = pow(2, h) - 1;\\n \\n    // Left rotate for excess nodes at last level\\n    compress(grand, count - m);\\n \\n    // Left rotation till m becomes 0\\n    // Step is done as mentioned in algo to\\n    // make BST balanced.\\n    for (m = m / 2; m > 0; m /= 2) {\\n        compress(grand, m);\\n    }\\n \\n    // return the balanced tree\\n    return grand->right;\\n}\\n \\n\\n```\\n\\n**Please Upvote if you find it helpful ....**\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/ C++ code to balance BST using DSW algorithm.\\n// Function to convert input BST\\n// to right linked list\\n// known as vine or backbone.\\nint bstToVine(TreeNode* grand)\\n{\\n    int count = 0;\\n \\n    // Make tmp pointer to traverse\\n    // and right flatten the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse until tmp becomes NULL\\n    while (tmp) {\\n         \\n        // If left exist for node\\n        // pointed by tmp then\\n        // right rotate it.\\n        if (tmp->left) {\\n            TreeNode* oldTmp = tmp;\\n            tmp = tmp->left;\\n            oldTmp->left = tmp->right;\\n            tmp->right = oldTmp;\\n            grand->right = tmp;\\n        }\\n \\n        // If left dont exists\\n        // add 1 to count and\\n        // traverse further right to\\n        // flatten remaining BST.\\n        else {\\n            count++;\\n            grand = tmp;\\n            tmp = tmp->right;\\n        }\\n    }\\n \\n    return count;\\n}\\n \\n// Function to compress given tree\\n// with its root as grand->right.\\nvoid compress(TreeNode* grand, int m)\\n{\\n    // Make tmp pointer to traverse\\n    // and compress the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse and left-rotate root m times\\n    // to compress given vine form of BST.\\n    for (int i = 0; i < m; i++) {\\n        TreeNode* oldTmp = tmp;\\n        tmp = tmp->right;\\n        grand->right = tmp;\\n        oldTmp->right = tmp->left;\\n        tmp->left = oldTmp;\\n        grand = tmp;\\n        tmp = tmp->right;\\n    }\\n}\\n \\n// Function to implement the algorithm\\nTreeNode* balanceBST(TreeNode* root)\\n{\\n    // create dummy node with value 0\\n    TreeNode* grand = new TreeNode(0);\\n \\n    // assign the right of dummy node as our input BST\\n    grand->right = root;\\n \\n    // get the number of nodes in input BST and\\n    // simultaneously convert it into right linked list.\\n    int count = bstToVine(grand);\\n \\n    // gets the height of tree in which all levels\\n    // are completely filled.\\n    int h = log2(count + 1);\\n \\n    // get number of nodes until second last level\\n    int m = pow(2, h) - 1;\\n \\n    // Left rotate for excess nodes at last level\\n    compress(grand, count - m);\\n \\n    // Left rotation till m becomes 0\\n    // Step is done as mentioned in algo to\\n    // make BST balanced.\\n    for (m = m / 2; m > 0; m /= 2) {\\n        compress(grand, m);\\n    }\\n \\n    // return the balanced tree\\n    return grand->right;\\n}\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755619,
                "title": "c-inorder-sorted-array-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> in_order;\\n    void inorder(TreeNode* root){\\n        if(root == NULL) return ;\\n        \\n        inorder(root->left);\\n        in_order.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* res(int l, int r){\\n       \\n        if(l>r) return NULL;\\n        int mid = l + (r - l) / 2;\\n        TreeNode* head = new TreeNode(in_order[mid]);\\n        head -> right = res(mid + 1, r);\\n        head -> left = res(l, mid - 1);\\n        \\n        return head;\\n    \\n    }  \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n         \\n        inorder(root);\\n        \\n        return res(0, in_order.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> in_order;\\n    void inorder(TreeNode* root){\\n        if(root == NULL) return ;\\n        \\n        inorder(root->left);\\n        in_order.push_back(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1751435,
                "title": "c-solution",
                "content": "```\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // first, do a inorder traverse of the tree, and put values into a vector\\n        // the values in the vector should be in incresing order\\n        // then construct the balance BST with the vector\\n        vector<TreeNode*> treeVec;\\n        generateVec(root, treeVec);\\n        return generateBST(treeVec, 0, treeVec.size() - 1);\\n    }\\n    \\n    void generateVec(TreeNode* node, vector<TreeNode*>& res) {\\n        if (node->left != NULL) {\\n            generateVec(node->left, res);\\n        }\\n        res.push_back(node);\\n        if (node->right != NULL) {\\n            generateVec(node->right, res);\\n        }\\n    }\\n    \\n    // we choose the middle value as the root, so that the difference between right and left height would be at most 1\\n    TreeNode* generateBST(vector<TreeNode*>& res, int begin, int end) {\\n        if (begin > end) {\\n            return NULL;\\n        }\\n        int mid = (begin + end) / 2;\\n        TreeNode* root = res[mid];\\n        root->left = generateBST(res, begin, mid - 1);\\n        root->right = generateBST(res, mid + 1, end);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // first, do a inorder traverse of the tree, and put values into a vector\\n        // the values in the vector should be in incresing order\\n        // then construct the balance BST with the vector\\n        vector<TreeNode*> treeVec;\\n        generateVec(root, treeVec);\\n        return generateBST(treeVec, 0, treeVec.size() - 1);\\n    }\\n    \\n    void generateVec(TreeNode* node, vector<TreeNode*>& res) {\\n        if (node->left != NULL) {\\n            generateVec(node->left, res);\\n        }\\n        res.push_back(node);\\n        if (node->right != NULL) {\\n            generateVec(node->right, res);\\n        }\\n    }\\n    \\n    // we choose the middle value as the root, so that the difference between right and left height would be at most 1\\n    TreeNode* generateBST(vector<TreeNode*>& res, int begin, int end) {\\n        if (begin > end) {\\n            return NULL;\\n        }\\n        int mid = (begin + end) / 2;\\n        TreeNode* root = res[mid];\\n        root->left = generateBST(res, begin, mid - 1);\\n        root->right = generateBST(res, mid + 1, end);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686238,
                "title": "c-inorder-neat-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root,vector<int> &v){\\n        if(!root){\\n            return;\\n        }\\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    \\n    TreeNode* makeTree(vector<int> &v,int start, int end){\\n        if(start>end) {\\n           return NULL;\\n         }\\n        int mid=start+(end-start)/2;\\n        TreeNode* nn=new TreeNode(v[mid]);\\n        nn->left=makeTree(v,start,mid-1);\\n        nn->right=makeTree(v,mid+1,end);\\n        return nn;\\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inOrder(root,v);\\n        TreeNode* ans=makeTree(v,0,v.size()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root,vector<int> &v){\\n        if(!root){\\n            return;\\n        }\\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    \\n    TreeNode* makeTree(vector<int> &v,int start, int end){\\n        if(start>end) {\\n           return NULL;\\n         }\\n        int mid=start+(end-start)/2;\\n        TreeNode* nn=new TreeNode(v[mid]);\\n        nn->left=makeTree(v,start,mid-1);\\n        nn->right=makeTree(v,mid+1,end);\\n        return nn;\\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inOrder(root,v);\\n        TreeNode* ans=makeTree(v,0,v.size()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649374,
                "title": "simple-javascript-solution-81-88-clean",
                "content": "Runtime: 156 ms, faster than 81.09% of JavaScript online submissions for Balance a Binary Search Tree.\\nMemory Usage: 55.5 MB, less than 88.24% of JavaScript online submissions for Balance a Binary Search Tree.\\n\\n```\\nconst balanceBST = root => {\\n  const nodes = [];\\n\\n  const getNodesArray = node => {\\n    if (!node) return;\\n    getNodesArray(node.left);\\n    nodes.push(node.val);\\n    getNodesArray(node.right);\\n  }\\n  \\n  const getNode = (l, r) => {\\n    const mid = Math.floor((l + r) /2);\\n    return {\\n      val: nodes[mid],\\n      left: l >= mid ? null : getNode(l, mid - 1),\\n      right: r <= mid ? null : getNode(mid + 1, r)\\n    }\\n  }  \\n\\n  getNodesArray(root);  \\n  return getNode(0, nodes.length - 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst balanceBST = root => {\\n  const nodes = [];\\n\\n  const getNodesArray = node => {\\n    if (!node) return;\\n    getNodesArray(node.left);\\n    nodes.push(node.val);\\n    getNodesArray(node.right);\\n  }\\n  \\n  const getNode = (l, r) => {\\n    const mid = Math.floor((l + r) /2);\\n    return {\\n      val: nodes[mid],\\n      left: l >= mid ? null : getNode(l, mid - 1),\\n      right: r <= mid ? null : getNode(mid + 1, r)\\n    }\\n  }  \\n\\n  getNodesArray(root);  \\n  return getNode(0, nodes.length - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590587,
                "title": "c-with-comments-beat-100",
                "content": "Here is the code with some comments, ***feel free to drop a comment! And plz upvote if  it helps.***\\n```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // v: where we want to store the TreeNodes in their value order\\n        // construct list using inorder dfs\\n        vector<TreeNode*> v;\\n        dfs(root,v);\\n\\n        // user vector to contruct a balanced tree\\n        auto ans = build_tree(v, 0, v.size() - 1);\\n            \\n        // return tree root node\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root == nullptr)\\n            return;\\n        dfs(root->left, v);\\n        v.push_back(root);\\n        dfs(root->right, v);\\n    }\\n    \\n    TreeNode* build_tree(const vector<TreeNode*> & v, int left, int right) {\\n        if(left > right) {\\n            return nullptr;\\n        }\\n        int mid = left + (right - left) / 2;\\n        auto root = v[mid];\\n        root-> left = build_tree(v, left, mid - 1);\\n        root-> right = build_tree(v, mid + 1, right);\\n        return root;\\n    }\\n};\\n```\\n***feel free to drop a comment! And plz upvote if  it helps.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // v: where we want to store the TreeNodes in their value order\\n        // construct list using inorder dfs\\n        vector<TreeNode*> v;\\n        dfs(root,v);\\n\\n        // user vector to contruct a balanced tree\\n        auto ans = build_tree(v, 0, v.size() - 1);\\n            \\n        // return tree root node\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root == nullptr)\\n            return;\\n        dfs(root->left, v);\\n        v.push_back(root);\\n        dfs(root->right, v);\\n    }\\n    \\n    TreeNode* build_tree(const vector<TreeNode*> & v, int left, int right) {\\n        if(left > right) {\\n            return nullptr;\\n        }\\n        int mid = left + (right - left) / 2;\\n        auto root = v[mid];\\n        root-> left = build_tree(v, left, mid - 1);\\n        root-> right = build_tree(v, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570508,
                "title": "readable-c-99-o-n-time-o-logn-space",
                "content": "1.  Convert BST to a doubly linked list.\\n2.  Convert linked list to a perfectly balanced BST.\\n\\nWe do 2 passes on the tree/list, that\\'s O(N) time. The stack takes up O(logN) space due to recursion.\\n\\nMost solutions here that claim O(1) space are incorrect, recursion will always take O(logN) space unless you use something like Morris traversal.\\n\\n```\\npair<TreeNode*, TreeNode*> BSTToSortedLinkedList(TreeNode* t, int& length) {\\n    auto left = t->left ? BSTToSortedLinkedList(t->left, length) : make_pair(t, nullptr);\\n    if (left.second && !left.second->right) {\\n        left.second->right = t;\\n    }\\n    auto right = t->right ? BSTToSortedLinkedList(t->right, length) : make_pair(nullptr, t);\\n    t->left = left.second;\\n    t->right = right.first;\\n    ++length;\\n    return {left.first, right.second};\\n}\\n\\nTreeNode* SortedLinkedListToBST(TreeNode*& head, int lo, int hi) {\\n    if (lo > hi) {\\n        return nullptr;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    TreeNode* left = SortedLinkedListToBST(head, lo, mid-1);\\n    TreeNode* root = head;\\n    head = head->right;\\n    root->left = left;\\n    root->right = SortedLinkedListToBST(head, mid+1, hi);\\n    return root;\\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        int length = 0;\\n        TreeNode* head = BSTToSortedLinkedList(root, length).first;\\n        root = SortedLinkedListToBST(head, 0, length-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npair<TreeNode*, TreeNode*> BSTToSortedLinkedList(TreeNode* t, int& length) {\\n    auto left = t->left ? BSTToSortedLinkedList(t->left, length) : make_pair(t, nullptr);\\n    if (left.second && !left.second->right) {\\n        left.second->right = t;\\n    }\\n    auto right = t->right ? BSTToSortedLinkedList(t->right, length) : make_pair(nullptr, t);\\n    t->left = left.second;\\n    t->right = right.first;\\n    ++length;\\n    return {left.first, right.second};\\n}\\n\\nTreeNode* SortedLinkedListToBST(TreeNode*& head, int lo, int hi) {\\n    if (lo > hi) {\\n        return nullptr;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    TreeNode* left = SortedLinkedListToBST(head, lo, mid-1);\\n    TreeNode* root = head;\\n    head = head->right;\\n    root->left = left;\\n    root->right = SortedLinkedListToBST(head, mid+1, hi);\\n    return root;\\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        int length = 0;\\n        TreeNode* head = BSTToSortedLinkedList(root, length).first;\\n        root = SortedLinkedListToBST(head, 0, length-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552927,
                "title": "well-coded-for-beginners-easy-approach",
                "content": "## IDEA :\\n* Traverse Inorder, Since root of BST is given so array formed will be sorted.\\n* Now by Divide and Conquer make new BST which will be balanced.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        arr = []\\n        def inorder(root):\\n            if root is None:\\n                return \\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        \\n        def mbst(i,j,arr):\\n            if i>j:\\n                return None\\n            if i==j:\\n                return TreeNode(arr[i])\\n            \\n            m = (i+j)//2\\n            root = TreeNode(arr[m])\\n            root.left = mbst(i,m-1,arr)\\n            root.right= mbst(m+1,j,arr)\\n            return root\\n        \\n        inorder(root)\\n        i, j = 0, len(arr)-1\\n        return mbst(i,j,arr\\n\\t\\n### Thanks & Upvote if you like the Idea !!\\u270C",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "## IDEA :\\n* Traverse Inorder, Since root of BST is given so array formed will be sorted.\\n* Now by Divide and Conquer make new BST which will be balanced.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        arr = []\\n        def inorder(root):\\n            if root is None:\\n                return \\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        \\n        def mbst(i,j,arr):\\n            if i>j:\\n                return None\\n            if i==j:\\n                return TreeNode(arr[i])\\n            \\n            m = (i+j)//2\\n            root = TreeNode(arr[m])\\n            root.left = mbst(i,m-1,arr)\\n            root.right= mbst(m+1,j,arr)\\n            return root\\n        \\n        inorder(root)\\n        i, j = 0, len(arr)-1\\n        return mbst(i,j,arr\\n\\t\\n### Thanks & Upvote if you like the Idea !!\\u270C",
                "codeTag": "Java"
            },
            {
                "id": 1520065,
                "title": "c-convert-inorder-to-bst-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> io;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root); //inorder will sort the BST by left, root, right order which is nearly a sorted array.\\n        return build(0, io.size() - 1);\\n    }\\n    \\n    TreeNode* build(int start, int end) {\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start) / 2;\\n        TreeNode *root = io[mid];\\n        root->left = build(start, mid - 1);\\n        root->right = build(mid + 1, end);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        io.push_back(root);\\n        inorder(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> io;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root); //inorder will sort the BST by left, root, right order which is nearly a sorted array.\\n        return build(0, io.size() - 1);\\n    }\\n    \\n    TreeNode* build(int start, int end) {\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start) / 2;\\n        TreeNode *root = io[mid];\\n        root->left = build(start, mid - 1);\\n        root->right = build(mid + 1, end);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        io.push_back(root);\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483940,
                "title": "clean-code-python3-recursive-0-n",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def binaryTraverse(arr, left, right):\\n            if left > right:\\n                return None\\n            mid = left + (right - left) // 2\\n            node = TreeNode(arr[mid])\\n            node.left = binaryTraverse(arr, left, mid - 1)\\n            node.right = binaryTraverse(arr, mid + 1, right)\\n            return node\\n        def inorder(root, traverse):\\n            if not root:\\n                return\\n            inorder(root.left, traverse)\\n            traverse.append(root.val)\\n            inorder(root.right, traverse)\\n            return\\n        traversal = []\\n        inorder(root, traversal)\\n        return binaryTraverse(traversal,0, len(traversal) - 1) \\n\\n\\n\\n````",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def binaryTraverse(arr, left, right):\\n            if left > right:\\n                return None\\n            mid = left + (right - left) // 2\\n            node = TreeNode(arr[mid])\\n            node.left = binaryTraverse(arr, left, mid - 1)\\n            node.right = binaryTraverse(arr, mid + 1, right)\\n            return node\\n        def inorder(root, traverse):\\n            if not root:\\n                return\\n            inorder(root.left, traverse)\\n            traverse.append(root.val)\\n            inorder(root.right, traverse)\\n            return\\n        traversal = []\\n        inorder(root, traversal)\\n        return binaryTraverse(traversal,0, len(traversal) - 1) \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411614,
                "title": "simple-java-2ms-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> pq = new ArrayList<>();\\n    public void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        inorder(root.left);\\n        pq.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode helper(int start,int end)\\n    {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = pq.get(mid);\\n        root.left = helper(start, mid - 1);\\n        root.right = helper(mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        int start = 0;\\n        int end = pq.size()-1;\\n        TreeNode result = helper(start,end);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> pq = new ArrayList<>();\\n    public void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        inorder(root.left);\\n        pq.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode helper(int start,int end)\\n    {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = pq.get(mid);\\n        root.left = helper(start, mid - 1);\\n        root.right = helper(mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        int start = 0;\\n        int end = pq.size()-1;\\n        TreeNode result = helper(start,end);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357917,
                "title": "leetcode-discuss-hints-coded-as-solution",
                "content": "```\\nIf you find this helpful, please upvote\\n```\\n```\\nclass Solution {\\npublic:\\n//Inorder Traversal of the tree \\n    void helper(TreeNode* root,vector<int>& inorder)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left,inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right,inorder);\\n    }\\n\\t//Take the start and index and the array which has the inorder traveral \\n    TreeNode* helper1(int s,int e,vector<int>& inorder)\\n    {\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//middle is start + end divided by 2 and we do this recursively \\n        int mid=(s+e)/2;\\n        TreeNode* root=new TreeNode(inorder[mid]);\\n        root->left=helper1(s,mid-1,inorder);\\n        root->right=helper1(mid+1,e,inorder);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int> inorder;\\n    helper(root,inorder);\\n        int s=0;\\n        int e=inorder.size()-1;\\n        int n=inorder.size()/2;\\n        return helper1(s,e,inorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find this helpful, please upvote\\n```\n```\\nclass Solution {\\npublic:\\n//Inorder Traversal of the tree \\n    void helper(TreeNode* root,vector<int>& inorder)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left,inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right,inorder);\\n    }\\n\\t//Take the start and index and the array which has the inorder traveral \\n    TreeNode* helper1(int s,int e,vector<int>& inorder)\\n    {\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//middle is start + end divided by 2 and we do this recursively \\n        int mid=(s+e)/2;\\n        TreeNode* root=new TreeNode(inorder[mid]);\\n        root->left=helper1(s,mid-1,inorder);\\n        root->right=helper1(mid+1,e,inorder);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int> inorder;\\n    helper(root,inorder);\\n        int s=0;\\n        int e=inorder.size()-1;\\n        int n=inorder.size()/2;\\n        return helper1(s,e,inorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294545,
                "title": "do-it-in-place-o-n-time-no-need-to-create-sorted-array",
                "content": "```\\nTreeNode* balanceBST(TreeNode* root) {\\n        auto* node = root;\\n        int n = 0;\\n        stack<TreeNode*> sk;\\n        TreeNode* prev = nullptr, *head = nullptr;\\n        while (!sk.empty() || node) {\\n            while (node) {\\n                sk.push(node);\\n                node = node->left;\\n            }\\n            node = sk.top();\\n            sk.pop();\\n            if (prev) {\\n                prev->right = node;\\n            } else {\\n                head = node;\\n            }\\n            n++;\\n            node->left = nullptr;\\n            prev = node;\\n            node = node->right;\\n        }\\n        return helper(head, n);\\n    }\\n    \\n    TreeNode* helper(TreeNode*& node, int n) {\\n        if (n == 0) return nullptr;        \\n        node->left = helper(node, n/2);\\n        auto* root = node;\\n        node = node->right;\\n        root->right = helper(node, n-n/2-1);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* balanceBST(TreeNode* root) {\\n        auto* node = root;\\n        int n = 0;\\n        stack<TreeNode*> sk;\\n        TreeNode* prev = nullptr, *head = nullptr;\\n        while (!sk.empty() || node) {\\n            while (node) {\\n                sk.push(node);\\n                node = node->left;\\n            }\\n            node = sk.top();\\n            sk.pop();\\n            if (prev) {\\n                prev->right = node;\\n            } else {\\n                head = node;\\n            }\\n            n++;\\n            node->left = nullptr;\\n            prev = node;\\n            node = node->right;\\n        }\\n        return helper(head, n);\\n    }\\n    \\n    TreeNode* helper(TreeNode*& node, int n) {\\n        if (n == 0) return nullptr;        \\n        node->left = helper(node, n/2);\\n        auto* root = node;\\n        node = node->right;\\n        root->right = helper(node, n-n/2-1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273037,
                "title": "java-iterative-inordertraversal-sortedarraytobst",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n    \\n    if(root==null) return null;\\n        \\n    List<Integer> list = getInorder(root);\\n    \\n    \\n    return sortedArrayToBalancedBst(list,0,list.size()-1);\\n        \\n    }\\n    \\n    public TreeNode sortedArrayToBalancedBst(List<Integer> list, int start, int end){\\n        if(list.size()==0 || start>end) return null;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = sortedArrayToBalancedBst(list,start,mid-1);\\n        root.right = sortedArrayToBalancedBst(list,mid+1,end);\\n        return root;\\n    }\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n           if(root!=null){\\n               s.push(root);\\n               root=root.left;\\n           }else{\\n               if(s.isEmpty()) break;\\n               root = s.pop();\\n               list.add(root.val);\\n               root=root.right;\\n           }\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n    \\n    if(root==null) return null;\\n        \\n    List<Integer> list = getInorder(root);\\n    \\n    \\n    return sortedArrayToBalancedBst(list,0,list.size()-1);\\n        \\n    }\\n    \\n    public TreeNode sortedArrayToBalancedBst(List<Integer> list, int start, int end){\\n        if(list.size()==0 || start>end) return null;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = sortedArrayToBalancedBst(list,start,mid-1);\\n        root.right = sortedArrayToBalancedBst(list,mid+1,end);\\n        return root;\\n    }\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n           if(root!=null){\\n               s.push(root);\\n               root=root.left;\\n           }else{\\n               if(s.isEmpty()) break;\\n               root = s.pop();\\n               list.add(root.val);\\n               root=root.right;\\n           }\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206221,
                "title": "c-99-faster-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void bst2array(TreeNode* root, vector<TreeNode*>& nodes)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        bst2array(root->left,nodes);\\n        nodes.push_back(root);\\n        bst2array(root->right,nodes);\\n    }\\n    \\n    TreeNode* array2bst(vector<TreeNode*>& nodes, int start, int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = nodes[mid];\\n        root->left = array2bst(nodes,start,mid-1);\\n        root->right = array2bst(nodes,mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        bst2array(root,nodes);\\n        \\n        int n = nodes.size();\\n        return array2bst(nodes,0,n-1);\\n        \\n    }\\n};\\n\\t\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bst2array(TreeNode* root, vector<TreeNode*>& nodes)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        bst2array(root->left,nodes);\\n        nodes.push_back(root);\\n        bst2array(root->right,nodes);\\n    }\\n    \\n    TreeNode* array2bst(vector<TreeNode*>& nodes, int start, int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = nodes[mid];\\n        root->left = array2bst(nodes,start,mid-1);\\n        root->right = array2bst(nodes,mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        bst2array(root,nodes);\\n        \\n        int n = nodes.size();\\n        return array2bst(nodes,0,n-1);\\n        \\n    }\\n};\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1100893,
                "title": "javascript-balance-using-avl-tree-rotation",
                "content": "```javascript\\nfunction balanceBST(root) {\\n    \\n    function rightRotate(node) {\\n        const mid = node.left;\\n        node.left = mid.right;\\n        mid.right = node;\\n        return mid;\\n    }\\n    \\n    function leftRotate(node) {\\n        const mid = node.right;\\n        node.right = mid.left;\\n        mid.left = node;\\n        return mid;\\n    }\\n    \\n    function getHeight(node) {\\n        if(!node) return 0\\n        return Math.max(getHeight(node.left), getHeight(node.right)) + 1\\n    }\\n    \\n    function recurse(node) {\\n        if(!node) return null;\\n        \\n        node.left = recurse(node.left);\\n        node.right = recurse(node.right);\\n        \\n        const leftHeight = getHeight(node.left);\\n        const rightHeight = getHeight(node.right);\\n        \\n        if(Math.abs(leftHeight - rightHeight) <= 1) return node\\n        \\n        if(leftHeight > rightHeight) {\\n            \\n            const leftOfLeft = getHeight(node.left.left);\\n            const rightOfLeft = getHeight(node.left.right);\\n            \\n            if(rightOfLeft > leftOfLeft) {\\n                node.left = leftRotate(node.left);\\n            }\\n            node = rightRotate(node);\\n        } else if(rightHeight > leftHeight) {\\n            \\n            const leftOfRight = getHeight(node.right.left);\\n            const rightOfRight = getHeight(node.right.right);\\n            \\n            if(leftOfRight > rightOfRight) {\\n                node.right = rightRotate(node.right);\\n            }\\n            node = leftRotate(node);\\n        }\\n        return recurse(node);\\n    }\\n    \\n    return recurse(root)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nfunction balanceBST(root) {\\n    \\n    function rightRotate(node) {\\n        const mid = node.left;\\n        node.left = mid.right;\\n        mid.right = node;\\n        return mid;\\n    }\\n    \\n    function leftRotate(node) {\\n        const mid = node.right;\\n        node.right = mid.left;\\n        mid.left = node;\\n        return mid;\\n    }\\n    \\n    function getHeight(node) {\\n        if(!node) return 0\\n        return Math.max(getHeight(node.left), getHeight(node.right)) + 1\\n    }\\n    \\n    function recurse(node) {\\n        if(!node) return null;\\n        \\n        node.left = recurse(node.left);\\n        node.right = recurse(node.right);\\n        \\n        const leftHeight = getHeight(node.left);\\n        const rightHeight = getHeight(node.right);\\n        \\n        if(Math.abs(leftHeight - rightHeight) <= 1) return node\\n        \\n        if(leftHeight > rightHeight) {\\n            \\n            const leftOfLeft = getHeight(node.left.left);\\n            const rightOfLeft = getHeight(node.left.right);\\n            \\n            if(rightOfLeft > leftOfLeft) {\\n                node.left = leftRotate(node.left);\\n            }\\n            node = rightRotate(node);\\n        } else if(rightHeight > leftHeight) {\\n            \\n            const leftOfRight = getHeight(node.right.left);\\n            const rightOfRight = getHeight(node.right.right);\\n            \\n            if(leftOfRight > rightOfRight) {\\n                node.right = rightRotate(node.right);\\n            }\\n            node = leftRotate(node);\\n        }\\n        return recurse(node);\\n    }\\n    \\n    return recurse(root)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870600,
                "title": "java-100",
                "content": "class Solution {\\n\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        inOrder(root);\\n        return balanced(0,list.size()-1);\\n    }\\n    \\n    void inOrder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inOrder(root.left);\\n        list.add(root);\\n        inOrder(root.right);\\n    }\\n    \\n    TreeNode balanced(int start, int end){\\n        if(start>end)\\n            return null;\\n        int mid=start +(end-start)/2;\\n        TreeNode node=list.get(mid);\\n        node.left=balanced(start,mid-1);\\n        node.right=balanced(mid+1,end);\\n        return node;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        inOrder(root);\\n        return balanced(0,list.size()-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 728466,
                "title": "java-clean-code-inorder-traversal-and-construct-tree-2-ms-time-92-faster",
                "content": "```\\nclass Solution {\\n \\n\\tprivate void inorderTraversal (TreeNode root, List<Integer> inorderList) {\\n\\t\\t\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorderTraversal (root.left, inorderList);\\n\\t\\t\\tinorderList.add (root.val);\\n\\t\\t\\tinorderTraversal (root.right, inorderList);\\n\\t\\t}\\n\\t}\\n \\n\\tprivate TreeNode constructBinarySearchTree (List<Integer> inorderList, int start, int end) {\\n\\t\\n\\t\\tif (start > end) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint mid = (start + end) / 2;\\n\\t\\tTreeNode root = new TreeNode (inorderList.get (mid));\\n        \\n\\t\\troot.left = constructBinarySearchTree (inorderList, start, mid - 1);\\n\\t\\troot.right = constructBinarySearchTree (inorderList, mid + 1, end);\\n        \\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode balanceBST (TreeNode root) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\t\\n\\t\\tList<Integer> inorderList = new ArrayList <>();\\n\\t\\tinorderTraversal (root, inorderList);\\n \\n\\t\\treturn constructBinarySearchTree (inorderList, 0, inorderList.size () - 1);\\n\\t}\\n}\\n\\nTime Complexity: O(N)\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tprivate void inorderTraversal (TreeNode root, List<Integer> inorderList) {\\n\\t\\t\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorderTraversal (root.left, inorderList);\\n\\t\\t\\tinorderList.add (root.val);\\n\\t\\t\\tinorderTraversal (root.right, inorderList);\\n\\t\\t}\\n\\t}\\n \\n\\tprivate TreeNode constructBinarySearchTree (List<Integer> inorderList, int start, int end) {\\n\\t\\n\\t\\tif (start > end) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint mid = (start + end) / 2;\\n\\t\\tTreeNode root = new TreeNode (inorderList.get (mid));\\n        \\n\\t\\troot.left = constructBinarySearchTree (inorderList, start, mid - 1);\\n\\t\\troot.right = constructBinarySearchTree (inorderList, mid + 1, end);\\n        \\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode balanceBST (TreeNode root) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\t\\n\\t\\tList<Integer> inorderList = new ArrayList <>();\\n\\t\\tinorderTraversal (root, inorderList);\\n \\n\\t\\treturn constructBinarySearchTree (inorderList, 0, inorderList.size () - 1);\\n\\t}\\n}\\n\\nTime Complexity: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727132,
                "title": "simple-c-solution-using-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> m;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        \\n        return;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(!root)\\n            return NULL;\\n       inorder(root);\\n       for(auto i=0;i<v.size();i++)\\n           m[v[i]]=i;\\n        \\n       return buildBST (v, 0,v.size()-1);\\n    }\\n    TreeNode* buildBST(vector<int> v, int strt, int end){\\n        \\n        if(strt>end)\\n            return NULL;\\n        int mid= (strt+end)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        if(strt==end)\\n            return node;\\n        \\n        node->left=buildBST(v,strt,mid-1);\\n        node->right=buildBST(v,mid+1,end);\\n        \\n        return node;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> m;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        \\n        return;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(!root)\\n            return NULL;\\n       inorder(root);\\n       for(auto i=0;i<v.size();i++)\\n           m[v[i]]=i;\\n        \\n       return buildBST (v, 0,v.size()-1);\\n    }\\n    TreeNode* buildBST(vector<int> v, int strt, int end){\\n        \\n        if(strt>end)\\n            return NULL;\\n        int mid= (strt+end)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        if(strt==end)\\n            return node;\\n        \\n        node->left=buildBST(v,strt,mid-1);\\n        node->right=buildBST(v,mid+1,end);\\n        \\n        return node;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721154,
                "title": "c-easy-to-understand-solution",
                "content": "1) count the nodes\\n2) create array to store nodes of tree\\n3) convert into balance bst by dividing into two halves\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid node(struct TreeNode* root, int *count) {\\n    \\n    if(root == NULL)\\n        return;\\n    \\n    node(root->left,count);\\n    (*count)++;\\n    node(root->right,count);\\n    \\n}\\n//create arr\\nvoid create(struct TreeNode *root, struct TreeNode **arr, int *k) {\\n    \\n    \\n    if(root == NULL)\\n        return;\\n    \\n    create(root->left,arr,k);\\n    \\n    arr[(*k)++] = root;\\n    create(root->right,arr,k);\\n}\\n\\n//convert to balance tree\\nstruct TreeNode* help(struct TreeNode **arr, int low, int high) {\\n    struct TreeNode *temp;\\n    if(low > high)\\n        return NULL;\\n    int mid = (low+high)/2;    \\n    \\n    temp = arr[mid];\\n    temp->left = help(arr,low,mid-1);\\n    temp->right = help(arr,mid+1,high);\\n    \\n    return temp;\\n    \\n}\\n\\nstruct TreeNode* balanceBST(struct TreeNode* root){\\n    \\n    int count=0;\\n    int k=0;\\n    struct TreeNode **arr;\\n    \\n    //count no of nodes\\n    node(root, &count);\\n\\n    //create arr of binary search tree\\n    arr = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * count);\\n    create(root, arr, &k) ;  \\n    \\n    //conver\\n    root = help(arr,0,count-1);\\n    free(arr);\\n    return root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid node(struct TreeNode* root, int *count) {\\n    \\n    if(root == NULL)\\n        return;\\n    \\n    node(root->left,count);\\n    (*count)++;\\n    node(root->right,count);\\n    \\n}\\n//create arr\\nvoid create(struct TreeNode *root, struct TreeNode **arr, int *k) {\\n    \\n    \\n    if(root == NULL)\\n        return;\\n    \\n    create(root->left,arr,k);\\n    \\n    arr[(*k)++] = root;\\n    create(root->right,arr,k);\\n}\\n\\n//convert to balance tree\\nstruct TreeNode* help(struct TreeNode **arr, int low, int high) {\\n    struct TreeNode *temp;\\n    if(low > high)\\n        return NULL;\\n    int mid = (low+high)/2;    \\n    \\n    temp = arr[mid];\\n    temp->left = help(arr,low,mid-1);\\n    temp->right = help(arr,mid+1,high);\\n    \\n    return temp;\\n    \\n}\\n\\nstruct TreeNode* balanceBST(struct TreeNode* root){\\n    \\n    int count=0;\\n    int k=0;\\n    struct TreeNode **arr;\\n    \\n    //count no of nodes\\n    node(root, &count);\\n\\n    //create arr of binary search tree\\n    arr = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * count);\\n    create(root, arr, &k) ;  \\n    \\n    //conver\\n    root = help(arr,0,count-1);\\n    free(arr);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693606,
                "title": "c-very-naive-solution",
                "content": "- inorder a BST can retrieve a sorted array.\\n- rebuild the BST and make sure the middle of the sorted arry is the root. this can help the tree is always balanced.\\n- recusion.\\n```\\npublic class Solution {\\n    List<TreeNode> list = new List<TreeNode>();\\n    \\n    public TreeNode BalanceBST(TreeNode root) {\\n        if (root == null || root.left == null && root.right == null)\\n            return root;\\n        \\n        DFS(root);\\n        \\n        return Rebuild(0, list.Count - 1);\\n    }\\n    \\n    private void DFS(TreeNode node)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        DFS(node.left);\\n        list.Add(node);\\n        DFS(node.right);\\n    }\\n    \\n    private TreeNode Rebuild(int i, int j)\\n    {\\n        if (i > j)\\n            return null;\\n        \\n        TreeNode root = new TreeNode();\\n        \\n        if (i == j)\\n            root.val = list[i].val;\\n        else\\n        {\\n            int mid = j + (i - j) / 2;\\n            \\n            root.val = list[mid].val;\\n            root.left = Rebuild(i, mid - 1);\\n            root.right = Rebuild(mid + 1, j);\\n        }\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<TreeNode> list = new List<TreeNode>();\\n    \\n    public TreeNode BalanceBST(TreeNode root) {\\n        if (root == null || root.left == null && root.right == null)\\n            return root;\\n        \\n        DFS(root);\\n        \\n        return Rebuild(0, list.Count - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 582156,
                "title": "c-solution-avl-tree-like-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\nprivate:\\n    TreeNode* leftRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->right;\\n        node->right = pRoot->left;\\n        pRoot->left = node;\\n        return pRoot;\\n    }\\n\\n    TreeNode* rightRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->left;\\n        node->left = pRoot->right;\\n        pRoot->right = node;\\n        return pRoot;\\n    }\\n    \\n    int height(TreeNode *node)\\n    {\\n        auto const left_h = node->left ? height(node->left) : 0;\\n        auto const right_h = node->right ? height(node->right) : 0;\\n        return std::max(left_h, right_h) + 1;\\n    }\\n    \\n    int bfactor(TreeNode *node)\\n    {\\n        return node ? (node->right ? height(node->right) : 0) - (node->left ? height(node->left) : 0) : 0;\\n    }\\n    \\n    TreeNode* balance(TreeNode *node)\\n    {\\n        if (!node)\\n            return nullptr;\\n        node->left = balance(node->left);\\n        node->right = balance(node->right);\\n        auto const bf = bfactor(node);\\n        if (bf >= 2)\\n        {\\n            if (bfactor(node->right) < 0)\\n                node->right = rightRotate(node->right);\\n            return balance(leftRotate(node));\\n        }\\n        else if (bf <= -2)\\n        {\\n            if (bfactor(node->left) > 0)\\n                node->left = leftRotate(node->left);\\n            return balance(rightRotate(node));\\n        }\\n        return node;\\n    }\\n\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        return balance(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\nprivate:\\n    TreeNode* leftRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->right;\\n        node->right = pRoot->left;\\n        pRoot->left = node;\\n        return pRoot;\\n    }\\n\\n    TreeNode* rightRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->left;\\n        node->left = pRoot->right;\\n        pRoot->right = node;\\n        return pRoot;\\n    }\\n    \\n    int height(TreeNode *node)\\n    {\\n        auto const left_h = node->left ? height(node->left) : 0;\\n        auto const right_h = node->right ? height(node->right) : 0;\\n        return std::max(left_h, right_h) + 1;\\n    }\\n    \\n    int bfactor(TreeNode *node)\\n    {\\n        return node ? (node->right ? height(node->right) : 0) - (node->left ? height(node->left) : 0) : 0;\\n    }\\n    \\n    TreeNode* balance(TreeNode *node)\\n    {\\n        if (!node)\\n            return nullptr;\\n        node->left = balance(node->left);\\n        node->right = balance(node->right);\\n        auto const bf = bfactor(node);\\n        if (bf >= 2)\\n        {\\n            if (bfactor(node->right) < 0)\\n                node->right = rightRotate(node->right);\\n            return balance(leftRotate(node));\\n        }\\n        else if (bf <= -2)\\n        {\\n            if (bfactor(node->left) > 0)\\n                node->left = leftRotate(node->left);\\n            return balance(rightRotate(node));\\n        }\\n        return node;\\n    }\\n\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        return balance(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553491,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 944 ms, faster than 83.13% of Go online submissions for Balance a Binary Search Tree.\\nMemory Usage: 275.1 MB, less than 100.00% of Go online submissions for Balance a Binary Search Tree.\\n\\n```go\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    sorted := []int{}\\n    inorder(root, &sorted)\\n    return helper(sorted)\\n}\\n\\nfunc inorder(node *TreeNode, sorted *[]int) {\\n    if node == nil { return }\\n    inorder(node.Left, sorted)\\n    *sorted = append(*sorted, node.Val)\\n    inorder(node.Right, sorted)\\n}\\n\\nfunc helper(sorted []int) *TreeNode {\\n    if len(sorted) == 0 { return nil }\\n    index := len(sorted) / 2\\n    return &TreeNode{Val: sorted[index], Left: helper(sorted[:index]), Right: helper(sorted[index + 1:])}\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    sorted := []int{}\\n    inorder(root, &sorted)\\n    return helper(sorted)\\n}\\n\\nfunc inorder(node *TreeNode, sorted *[]int) {\\n    if node == nil { return }\\n    inorder(node.Left, sorted)\\n    *sorted = append(*sorted, node.Val)\\n    inorder(node.Right, sorted)\\n}\\n\\nfunc helper(sorted []int) *TreeNode {\\n    if len(sorted) == 0 { return nil }\\n    index := len(sorted) / 2\\n    return &TreeNode{Val: sorted[index], Left: helper(sorted[:index]), Right: helper(sorted[index + 1:])}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540670,
                "title": "java-solution-pre-construct-in-order-traversal-to-modify-100-time-100-memory-up-to-current",
                "content": "1. count the total number of nodes in the given tree.\\n2. pre construct a binary tree recurisively;\\n3. modify the pre construct binary tree based on in order traversal of the given tree.\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        int count = countNodes(root);\\n        Map<Integer, TreeNode> mapping  = new HashMap<>();\\n        TreeNode newRoot = buildBinaryTree(1, count, mapping);\\n        modifyTreeValue(root, mapping);\\n        return newRoot;\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n    private TreeNode buildBinaryTree(int st, int en, Map<Integer, TreeNode> mapping) {\\n        if(st > en) return null;\\n        int rootVal  = st + (en - st) / 2;\\n        TreeNode root = new TreeNode(rootVal);\\n        root.left = buildBinaryTree(st, rootVal - 1, mapping);\\n        root.right = buildBinaryTree(rootVal + 1, en, mapping);\\n        mapping.put(rootVal, root);\\n        return root;\\n    }\\n\\t\\n    private void modifyTreeValue(TreeNode oldTree, Map<Integer, TreeNode> mapping) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = oldTree;\\n        int index = 1;\\n        while(!stack.isEmpty() || curr != null) {\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else {\\n                curr = stack.pop();\\n                mapping.get(index).val = curr.val;\\n                curr = curr.right;\\n                ++index;\\n            }\\n        }    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        int count = countNodes(root);\\n        Map<Integer, TreeNode> mapping  = new HashMap<>();\\n        TreeNode newRoot = buildBinaryTree(1, count, mapping);\\n        modifyTreeValue(root, mapping);\\n        return newRoot;\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n    private TreeNode buildBinaryTree(int st, int en, Map<Integer, TreeNode> mapping) {\\n        if(st > en) return null;\\n        int rootVal  = st + (en - st) / 2;\\n        TreeNode root = new TreeNode(rootVal);\\n        root.left = buildBinaryTree(st, rootVal - 1, mapping);\\n        root.right = buildBinaryTree(rootVal + 1, en, mapping);\\n        mapping.put(rootVal, root);\\n        return root;\\n    }\\n\\t\\n    private void modifyTreeValue(TreeNode oldTree, Map<Integer, TreeNode> mapping) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = oldTree;\\n        int index = 1;\\n        while(!stack.isEmpty() || curr != null) {\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else {\\n                curr = stack.pop();\\n                mapping.get(index).val = curr.val;\\n                curr = curr.right;\\n                ++index;\\n            }\\n        }    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539842,
                "title": "simple-solution-with-explanation",
                "content": "**Explanation:** This problem is acually really simple once you get the idea. Lets take an example first:\\n\\n           30\\n         /\\n       20\\n      /\\n    10\\n\\t\\nWhat we have to return is:\\n\\n        20\\n\\t   /  \\\\\\n\\t  10  30\\n\\t  \\nWe first create an inorder traversal of the tree, and store it into an array. In this case, that array will become ```{10, 20, 30}```, because the inorder traversal is ```{10, 20, 30}```. The root of the tree will be the middle of the inorder traversal, which in this case is ```20```. We recursively call the same method with the left side of the array to get the tree left of the root, and recursively call the right side of the arrray to get the tree to the right of the root. If we take this same example ```10, 20, 30```:\\n\\n```{10, 20, 30}```\\n\\n```20``` is selected as the root. Recursively call the same method with the left side of the array, or ```{10}``` for the left of the root. ```10``` is the midpoint of the array ```{10}```, and ```{10}``` has no left or right, so terminate. Recursively call the same method with the right side of the array, or ```{30}``` to get the right side of ```20```. That assigns ```30``` to the right of ```20```.\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        int n = nodes.size();\\n        return helper(nodes, 0, n - 1);\\n    }\\n\\n    private void inorder(TreeNode root, ArrayList<TreeNode> nodes) { // Does inorder traversal on root and assigns it to nodes.\\n        if (root == null) {\\n            return;\\n        }\\n\\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n\\n    private TreeNode helper(ArrayList<TreeNode> nodes, int start, int end) {\\n        if (start > end) { // Base case.\\n            return null;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode node = nodes.get(mid); // Add the root as the middle of nodes.\\n\\n        node.left = helper(nodes, start, mid - 1); // Recursively call the same method with the left side of the array, and assign it to the left of the root.\\n        node.right = helper(nodes, mid + 1, end); // Recursively call the same method with the right side of the array, and assign it to the right of the root.\\n\\n        return node; // Return the current TreeNode to your previous caller.\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(n)\\nInorder traversal takes O(n) and constructing the tree takes O(n) too. So, the time complexity is just O(n). \\n\\n**Space Complexity:** O(n)\\nYou create a new array size n, so space complexity is O(n).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```{10, 20, 30}```\n```{10, 20, 30}```\n```20```\n```10, 20, 30```\n```{10, 20, 30}```\n```20```\n```{10}```\n```10```\n```{10}```\n```{10}```\n```{30}```\n```20```\n```30```\n```20```\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        int n = nodes.size();\\n        return helper(nodes, 0, n - 1);\\n    }\\n\\n    private void inorder(TreeNode root, ArrayList<TreeNode> nodes) { // Does inorder traversal on root and assigns it to nodes.\\n        if (root == null) {\\n            return;\\n        }\\n\\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n\\n    private TreeNode helper(ArrayList<TreeNode> nodes, int start, int end) {\\n        if (start > end) { // Base case.\\n            return null;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode node = nodes.get(mid); // Add the root as the middle of nodes.\\n\\n        node.left = helper(nodes, start, mid - 1); // Recursively call the same method with the left side of the array, and assign it to the left of the root.\\n        node.right = helper(nodes, mid + 1, end); // Recursively call the same method with the right side of the array, and assign it to the right of the root.\\n\\n        return node; // Return the current TreeNode to your previous caller.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539740,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    List<TreeNode> nodes = new List<TreeNode>();\\n    public TreeNode BalanceBST(TreeNode root) \\n    {\\n        Traverse(root);\\n        nodes.Sort((x, y) => x.val.CompareTo(y.val));  \\n        return MakeBBST(nodes, 0, nodes.Count - 1);\\n    }\\n    \\n    private TreeNode MakeBBST(List<TreeNode> nodes, int start, int end)\\n    {\\n        if(start > end) return null;\\n        int mid = (start + end) / 2;\\n        var root = nodes[mid];\\n        root.left = MakeBBST(nodes, start, mid - 1);\\n        root.right = MakeBBST(nodes, mid + 1, end);\\n        return root;\\n    }\\n    \\n    private void Traverse(TreeNode root)\\n    {\\n        if(root == null) return;\\n        nodes.Add(root);\\n        Traverse(root.left);\\n        Traverse(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    List<TreeNode> nodes = new List<TreeNode>();\\n    public TreeNode BalanceBST(TreeNode root) \\n    {\\n        Traverse(root);\\n        nodes.Sort((x, y) => x.val.CompareTo(y.val));  \\n        return MakeBBST(nodes, 0, nodes.Count - 1);\\n    }\\n    \\n    private TreeNode MakeBBST(List<TreeNode> nodes, int start, int end)\\n    {\\n        if(start > end) return null;\\n        int mid = (start + end) / 2;\\n        var root = nodes[mid];\\n        root.left = MakeBBST(nodes, start, mid - 1);\\n        root.right = MakeBBST(nodes, mid + 1, end);\\n        return root;\\n    }\\n    \\n    private void Traverse(TreeNode root)\\n    {\\n        if(root == null) return;\\n        nodes.Add(root);\\n        Traverse(root.left);\\n        Traverse(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539724,
                "title": "c-generate-from-mid-from-in-order-traversal-array",
                "content": "```csharp\\npublic class Solution\\n{\\n    public TreeNode BalanceBST(TreeNode root)\\n    {\\n        List<int> nums = new List<int>();\\n        inorder(root, nums);\\n                \\n        var result = buildTree(nums, 0, nums.Count - 1);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode node, List<int> nums)\\n    {\\n        if(node != null)\\n        {\\n            inorder(node.left, nums);\\n            nums.Add(node.val);\\n            inorder(node.right, nums);\\n        }\\n    }\\n    \\n    private TreeNode buildTree(List<int> nums, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        TreeNode node = new TreeNode(nums[mid]);        \\n        node.left = buildTree(nums, start, mid - 1);\\n        node.right = buildTree(nums, mid + 1, end);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution\\n{\\n    public TreeNode BalanceBST(TreeNode root)\\n    {\\n        List<int> nums = new List<int>();\\n        inorder(root, nums);\\n                \\n        var result = buildTree(nums, 0, nums.Count - 1);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode node, List<int> nums)\\n    {\\n        if(node != null)\\n        {\\n            inorder(node.left, nums);\\n            nums.Add(node.val);\\n            inorder(node.right, nums);\\n        }\\n    }\\n    \\n    private TreeNode buildTree(List<int> nums, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        TreeNode node = new TreeNode(nums[mid]);        \\n        node.left = buildTree(nums, start, mid - 1);\\n        node.right = buildTree(nums, mid + 1, end);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539708,
                "title": "c-in-order-traversal-and-build-the-balanced-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    TreeNode* build(const vector<int>& vals, int left, int right) {\\n        if (left >= right) return nullptr;\\n        TreeNode* tn = new TreeNode(vals[(left + right) / 2]);\\n        tn->left = build(vals, left, (left + right) / 2);\\n        tn->right = build(vals, (left + right) / 2 + 1, right);\\n        return tn;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> vals;\\n        function<void(TreeNode*)> inorder = [&](TreeNode* tn) {\\n            if (!tn) return;\\n            inorder(tn->left);\\n            vals.push_back(tn->val);\\n            inorder(tn->right);\\n        };\\n        inorder(root);\\n        return build(vals, 0, vals.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    TreeNode* build(const vector<int>& vals, int left, int right) {\\n        if (left >= right) return nullptr;\\n        TreeNode* tn = new TreeNode(vals[(left + right) / 2]);\\n        tn->left = build(vals, left, (left + right) / 2);\\n        tn->right = build(vals, (left + right) / 2 + 1, right);\\n        return tn;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> vals;\\n        function<void(TreeNode*)> inorder = [&](TreeNode* tn) {\\n            if (!tn) return;\\n            inorder(tn->left);\\n            vals.push_back(tn->val);\\n            inorder(tn->right);\\n        };\\n        inorder(root);\\n        return build(vals, 0, vals.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442020,
                "title": "c-solution-very-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root,vector<int>&v) {\\n        if(root==NULL)\\n        return;\\n\\n        inorderTraversal(root->left,v);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right,v);\\n        return;\\n    }\\n\\n    TreeNode* build(int i,int j,vector<int>&v){\\n        if(i>j) return NULL;\\n        int mid=(i+j)/2;\\n         TreeNode*newNode=new TreeNode(v[mid]);\\n         newNode->left=build(i,mid-1,v);\\n         newNode->right=build(mid+1,j,v);\\n         return newNode;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>v;\\n         inorderTraversal(root,v);\\n        int i=0,j=v.size()-1;\\n\\n        return build(0,j,v);\\n    }\\n};\\n```\\nUpvote if you like the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root,vector<int>&v) {\\n        if(root==NULL)\\n        return;\\n\\n        inorderTraversal(root->left,v);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right,v);\\n        return;\\n    }\\n\\n    TreeNode* build(int i,int j,vector<int>&v){\\n        if(i>j) return NULL;\\n        int mid=(i+j)/2;\\n         TreeNode*newNode=new TreeNode(v[mid]);\\n         newNode->left=build(i,mid-1,v);\\n         newNode->right=build(mid+1,j,v);\\n         return newNode;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>v;\\n         inorderTraversal(root,v);\\n        int i=0,j=v.size()-1;\\n\\n        return build(0,j,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389353,
                "title": "java-solution-using-simple-approach-of-inorder-traversal-and-binary-search",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void traversal(TreeNode root, List<Integer> list) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left,list);\\n        // Add the current node\\'s value to the result list\\n        list.add(root.val);\\n        traversal(root.right, list);\\n   }\\n   public TreeNode balance(ArrayList<Integer> nums, int start, int end){\\n       if(start>end){\\n           return null;\\n       }\\n       int mid = (start+end)/2;\\n       TreeNode root = new TreeNode(nums.get(mid));\\n       root.left = balance(nums,start,mid-1);\\n       root.right = balance(nums, mid+1,end);\\n       return root;\\n   }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        if(root == null){\\n            return null;\\n        }\\n        traversal(root, list);\\n        TreeNode newRoot = balance(list,0,list.size()-1);\\n        return newRoot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void traversal(TreeNode root, List<Integer> list) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left,list);\\n        // Add the current node\\'s value to the result list\\n        list.add(root.val);\\n        traversal(root.right, list);\\n   }\\n   public TreeNode balance(ArrayList<Integer> nums, int start, int end){\\n       if(start>end){\\n           return null;\\n       }\\n       int mid = (start+end)/2;\\n       TreeNode root = new TreeNode(nums.get(mid));\\n       root.left = balance(nums,start,mid-1);\\n       root.right = balance(nums, mid+1,end);\\n       return root;\\n   }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        if(root == null){\\n            return null;\\n        }\\n        traversal(root, list);\\n        TreeNode newRoot = balance(list,0,list.size()-1);\\n        return newRoot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370779,
                "title": "solve-three-questions-with-this-approach-easy-java",
                "content": "```\\n//Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n     List<TreeNode> ls=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n       helper(root);\\n        int start=0;\\n        int end=ls.size()-1;\\n      return  createBBST(start,end);\\n        \\n    }\\n    public void helper(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        helper(root.left);\\n        ls.add(root);\\n        helper(root.right);\\n    }\\n    \\n    public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n//Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n     List<TreeNode> ls=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n       helper(root);\\n        int start=0;\\n        int end=ls.size()-1;\\n      return  createBBST(start,end);\\n        \\n    }\\n    public void helper(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        helper(root.left);\\n        ls.add(root);\\n        helper(root.right);\\n    }\\n    \\n    public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142530,
                "title": "c-easiest-approach-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &in){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    TreeNode* inorderToBST(int s,int e,vector<int> &in){\\n        if(s>e)\\n        return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode* root=new TreeNode(in[mid]);\\n        root->left = inorderToBST(s,mid-1,in);\\n        root->right = inorderToBST(mid+1,e,in);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root,inorderVal);\\n        return inorderToBST(0,inorderVal.size()-1,inorderVal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &in){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    TreeNode* inorderToBST(int s,int e,vector<int> &in){\\n        if(s>e)\\n        return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode* root=new TreeNode(in[mid]);\\n        root->left = inorderToBST(s,mid-1,in);\\n        root->right = inorderToBST(mid+1,e,in);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root,inorderVal);\\n        return inorderToBST(0,inorderVal.size()-1,inorderVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787111,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781041,
                "title": "c-inorder-traversal-o-n-time",
                "content": "# Intuition\\n- Convert the given BST to a sorted array using Inorder traversal.\\n- Build the tree using the inorder traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        stack<TreeNode*> st;\\n        TreeNode* temp = root;\\n\\n        while(temp || !st.empty()){\\n            while(temp){\\n                st.push(temp);\\n                temp = temp->left;\\n            }\\n            temp = st.top();\\n            st.pop();\\n            in.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n\\n        return buildTree(in, 0, in.size() - 1);\\n    }\\n\\n    TreeNode* buildTree(vector<int> &in, int start, int end){\\n        if(start > end){\\n            return nullptr;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode* newNode = new TreeNode(in[mid]);\\n        newNode->left = buildTree(in, start, mid - 1);\\n        newNode->right = buildTree(in, mid + 1, end);\\n\\n        return newNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        stack<TreeNode*> st;\\n        TreeNode* temp = root;\\n\\n        while(temp || !st.empty()){\\n            while(temp){\\n                st.push(temp);\\n                temp = temp->left;\\n            }\\n            temp = st.top();\\n            st.pop();\\n            in.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n\\n        return buildTree(in, 0, in.size() - 1);\\n    }\\n\\n    TreeNode* buildTree(vector<int> &in, int start, int end){\\n        if(start > end){\\n            return nullptr;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode* newNode = new TreeNode(in[mid]);\\n        newNode->left = buildTree(in, start, mid - 1);\\n        newNode->right = buildTree(in, mid + 1, end);\\n\\n        return newNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599981,
                "title": "c-solution-using-recursion-and-inorder-traversal",
                "content": "```\\nclass Solution {\\n    void inorder(TreeNode*root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* help(int s,int e,vector<int> v)\\n    {\\n//         base case\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n        int mid=s+(e-s)/2;\\n        TreeNode*root=new TreeNode(v[mid]);\\n        root->left=help(s,mid-1,v);\\n        root->right=help(mid+1,e,v);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {  \\n        vector<int> v;\\n        inorder(root,v);\\n        return help(0,v.size()-1,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void inorder(TreeNode*root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* help(int s,int e,vector<int> v)\\n    {\\n//         base case\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n        int mid=s+(e-s)/2;\\n        TreeNode*root=new TreeNode(v[mid]);\\n        root->left=help(s,mid-1,v);\\n        root->right=help(mid+1,e,v);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {  \\n        vector<int> v;\\n        inorder(root,v);\\n        return help(0,v.size()-1,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536812,
                "title": "c-solution-de-structuring-and-structuring-solved",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>nodeList;\\n        nodes(root,nodeList);\\n        TreeNode *ans = constructBst(nodeList,0,nodeList.size()-1);\\n        return ans;\\n        \\n    }\\n    void nodes(TreeNode *root,vector<int> &v) {\\n        if(root==NULL)return ;\\n        nodes(root->left,v);\\n        v.push_back(root->val);\\n        nodes(root->right,v);\\n        return;\\n    }\\n    TreeNode* constructBst(vector<int>&v,int s,int e){\\n        if(s>e)return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(v[mid]);\\n        root->left = constructBst(v,s,mid-1);\\n        root->right = constructBst(v,mid+1,e);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>nodeList;\\n        nodes(root,nodeList);\\n        TreeNode *ans = constructBst(nodeList,0,nodeList.size()-1);\\n        return ans;\\n        \\n    }\\n    void nodes(TreeNode *root,vector<int> &v) {\\n        if(root==NULL)return ;\\n        nodes(root->left,v);\\n        v.push_back(root->val);\\n        nodes(root->right,v);\\n        return;\\n    }\\n    TreeNode* constructBst(vector<int>&v,int s,int e){\\n        if(s>e)return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(v[mid]);\\n        root->left = constructBst(v,s,mid-1);\\n        root->right = constructBst(v,mid+1,e);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504986,
                "title": "simple-python-solution-with-inorder-traversal-beats-92",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.arr = []\\n    def inOrder(self,root):\\n        if root is None:\\n            return []\\n        else:\\n            self.inOrder(root.left)\\n            self.arr.append(root.val)\\n            self.inOrder(root.right)\\n        return self.arr\\n    \\n    def balanced(self,left,right,nums):\\n        if left > right:\\n            return None\\n        else:\\n            mid = (left + right)//2\\n            root = TreeNode(nums[mid])\\n            root.left = self.balanced(left,mid-1,nums)\\n            root.right = self.balanced(mid+1,right,nums)\\n        return root\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.inOrder(root)\\n        return self.balanced(0,len(nums)-1,nums)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.arr = []\\n    def inOrder(self,root):\\n        if root is None:\\n            return []\\n        else:\\n            self.inOrder(root.left)\\n            self.arr.append(root.val)\\n            self.inOrder(root.right)\\n        return self.arr\\n    \\n    def balanced(self,left,right,nums):\\n        if left > right:\\n            return None\\n        else:\\n            mid = (left + right)//2\\n            root = TreeNode(nums[mid])\\n            root.left = self.balanced(left,mid-1,nums)\\n            root.right = self.balanced(mid+1,right,nums)\\n        return root\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.inOrder(root)\\n        return self.balanced(0,len(nums)-1,nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479600,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*>res;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return bst(0,res.size()-1);\\n    }\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        res.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* bst(int start,int end){\\n        if(start>end)return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=res[mid];\\n        root->left=bst(start,mid-1);\\n        root->right=bst(mid+1,end);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*>res;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return bst(0,res.size()-1);\\n    }\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        res.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* bst(int start,int end){\\n        if(start>end)return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=res[mid];\\n        root->left=bst(start,mid-1);\\n        root->right=bst(mid+1,end);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378016,
                "title": "c-easy-recurion-inorder",
                "content": "\\n**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tvoid storeInorder(TreeNode* root , vector<int> &inorderVal){\\n    \\n    if(root == NULL)\\n        return ;\\n        \\n\\t\\tstoreInorder(root->left , inorderVal);\\n\\t\\tinorderVal.push_back(root->val);\\n\\t\\tstoreInorder(root->right , inorderVal);\\n\\t}    \\n    \\n\\tTreeNode* inorderToBST( int s , int e , vector<int> &inorderVal ){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* newroot = new TreeNode(inorderVal[mid]);\\n        // value less than mid will be stored in left part\\n        newroot->left  = inorderToBST(s,mid-1,inorderVal );\\n        \\n        // value more than mid will be stored in right part\\n        newroot->right = inorderToBST(mid+1,e,inorderVal );\\n        \\n    return newroot;\\n\\t}    \\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n       \\n\\n        vector<int> inorderVal;\\n\\n        storeInorder(root, inorderVal);\\n    \\n        return inorderToBST( 0 , inorderVal.size() -1 ,inorderVal);\\n    \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tvoid storeInorder(TreeNode* root , vector<int> &inorderVal){\\n    \\n    if(root == NULL)\\n        return ;\\n        \\n\\t\\tstoreInorder(root->left , inorderVal);\\n\\t\\tinorderVal.push_back(root->val);\\n\\t\\tstoreInorder(root->right , inorderVal);\\n\\t}    \\n    \\n\\tTreeNode* inorderToBST( int s , int e , vector<int> &inorderVal ){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* newroot = new TreeNode(inorderVal[mid]);\\n        // value less than mid will be stored in left part\\n        newroot->left  = inorderToBST(s,mid-1,inorderVal );\\n        \\n        // value more than mid will be stored in right part\\n        newroot->right = inorderToBST(mid+1,e,inorderVal );\\n        \\n    return newroot;\\n\\t}    \\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n       \\n\\n        vector<int> inorderVal;\\n\\n        storeInorder(root, inorderVal);\\n    \\n        return inorderToBST( 0 , inorderVal.size() -1 ,inorderVal);\\n    \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2336401,
                "title": "c-easy-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &nums){\\n        if (root == NULL) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    \\n    TreeNode* buildTree(vector<int> &nums, int s , int e){\\n        if (s > e) return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(nums[mid]);\\n        root->left = buildTree(nums, s, mid-1);\\n        root->right = buildTree(nums, mid+1, e);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        int n = nums.size()-1;\\n        return buildTree(nums, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &nums){\\n        if (root == NULL) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    \\n    TreeNode* buildTree(vector<int> &nums, int s , int e){\\n        if (s > e) return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(nums[mid]);\\n        root->left = buildTree(nums, s, mid-1);\\n        root->right = buildTree(nums, mid+1, e);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        int n = nums.size()-1;\\n        return buildTree(nums, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327707,
                "title": "java-by-rotating-tree-avl-time-complexity-o-n",
                "content": "```\\n    // ? Remember that we can convert BST to a sorted array and then convert it into\\n    // ? balanced BST. Because when converting a sorted array into BST, we find the\\n    // ? middle and then split it into two halfs. Therefore the BST formed is\\n    // ? balanced\\n\\n    // # But here we would have taken the extra space of array.\\n\\n    // So we can also convert the BST into sorted doubly linked list, inplace and\\n    // then convert the sorted DLL to BST\\n\\n    // # But here it can also be solved by using AVL.\\n\\n    // ! But the question is HOW ???\\n\\n    // So that we can calculate the height in O(1), we will be keeping an array of\\n    // size of the range of nodes value since node value will be distinct.\\n\\n    // Otherwise we will have to calculate the height everytime and that will an\\n    // operation of logN itself.\\n\\n    // We are going to do as we did in AVL.\\n\\n    // We are going to rotate the tree such that our tree remains balanced.\\n\\n    // So we have just called the simple post order call.\\n\\n    // ? Why post order ???\\n\\n    // # It is because to calculate the balance factor we will be needing the height\\n    // # of both left and right subtree.\\n\\n    // And whenever we are returing the root, we Rotate it using the getRotation\\n    // function to get the balance BST.\\n\\n    // ! Important Note : To solve this using the AVL, please dry on the skew tree\\n\\n    public static void updateHeight(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        height[root.val] = Math.max(lh, rh) + 1;\\n    }\\n\\n    public static int getBalance(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        int bal = lh - rh;\\n\\n        return bal;\\n    }\\n\\n    public static TreeNode leftRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.right;\\n        TreeNode BKaLeft = B.left;\\n\\n        B.left = A;\\n        A.right = BKaLeft;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.left = getRotation(A, height);\\n        return getRotation(B, height);\\n    }\\n\\n    public static TreeNode rightRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.left;\\n        TreeNode BKaRight = B.right;\\n\\n        B.right = A;\\n        A.left = BKaRight;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.right = getRotation(A, height);\\n        return getRotation(B, height);\\n\\n    }\\n\\n    public static TreeNode getRotation(TreeNode root, int[] height) {\\n        // Now since here we are converting an already BSt to a balanced BST, so the\\n        // ` balance factor can be greater than 2 and can be less that -2. Other wise\\n        // the call remains the same as in AVL tree\\n\\n        updateHeight(root, height);\\n        if (getBalance(root, height) >= 2) {\\n            if (getBalance(root.left, height) >= 1) {\\n                return rightRotation(root, height);\\n            } else {\\n                root.left = leftRotation(root.left, height);\\n                return rightRotation(root, height);\\n            }\\n        } else if (getBalance(root, height) <= -2) {\\n            if (getBalance(root.right, height) <= -1) {\\n                return leftRotation(root, height);\\n            } else {\\n                root.right = rightRotation(root.right, height);\\n                return leftRotation(root, height);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root, int[] height) {\\n\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        root.left = balanceBST(root.left, height);\\n        root.right = balanceBST(root.right, height);\\n\\n        return getRotation(root, height);\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n\\n        int[] height = new int[(int) 1e5 + 1];\\n        return balanceBST(root, height);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n    // ? Remember that we can convert BST to a sorted array and then convert it into\\n    // ? balanced BST. Because when converting a sorted array into BST, we find the\\n    // ? middle and then split it into two halfs. Therefore the BST formed is\\n    // ? balanced\\n\\n    // # But here we would have taken the extra space of array.\\n\\n    // So we can also convert the BST into sorted doubly linked list, inplace and\\n    // then convert the sorted DLL to BST\\n\\n    // # But here it can also be solved by using AVL.\\n\\n    // ! But the question is HOW ???\\n\\n    // So that we can calculate the height in O(1), we will be keeping an array of\\n    // size of the range of nodes value since node value will be distinct.\\n\\n    // Otherwise we will have to calculate the height everytime and that will an\\n    // operation of logN itself.\\n\\n    // We are going to do as we did in AVL.\\n\\n    // We are going to rotate the tree such that our tree remains balanced.\\n\\n    // So we have just called the simple post order call.\\n\\n    // ? Why post order ???\\n\\n    // # It is because to calculate the balance factor we will be needing the height\\n    // # of both left and right subtree.\\n\\n    // And whenever we are returing the root, we Rotate it using the getRotation\\n    // function to get the balance BST.\\n\\n    // ! Important Note : To solve this using the AVL, please dry on the skew tree\\n\\n    public static void updateHeight(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        height[root.val] = Math.max(lh, rh) + 1;\\n    }\\n\\n    public static int getBalance(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        int bal = lh - rh;\\n\\n        return bal;\\n    }\\n\\n    public static TreeNode leftRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.right;\\n        TreeNode BKaLeft = B.left;\\n\\n        B.left = A;\\n        A.right = BKaLeft;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.left = getRotation(A, height);\\n        return getRotation(B, height);\\n    }\\n\\n    public static TreeNode rightRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.left;\\n        TreeNode BKaRight = B.right;\\n\\n        B.right = A;\\n        A.left = BKaRight;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.right = getRotation(A, height);\\n        return getRotation(B, height);\\n\\n    }\\n\\n    public static TreeNode getRotation(TreeNode root, int[] height) {\\n        // Now since here we are converting an already BSt to a balanced BST, so the\\n        // ` balance factor can be greater than 2 and can be less that -2. Other wise\\n        // the call remains the same as in AVL tree\\n\\n        updateHeight(root, height);\\n        if (getBalance(root, height) >= 2) {\\n            if (getBalance(root.left, height) >= 1) {\\n                return rightRotation(root, height);\\n            } else {\\n                root.left = leftRotation(root.left, height);\\n                return rightRotation(root, height);\\n            }\\n        } else if (getBalance(root, height) <= -2) {\\n            if (getBalance(root.right, height) <= -1) {\\n                return leftRotation(root, height);\\n            } else {\\n                root.right = rightRotation(root.right, height);\\n                return leftRotation(root, height);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root, int[] height) {\\n\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        root.left = balanceBST(root.left, height);\\n        root.right = balanceBST(root.right, height);\\n\\n        return getRotation(root, height);\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n\\n        int[] height = new int[(int) 1e5 + 1];\\n        return balanceBST(root, height);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313715,
                "title": "python-solution-dfs-inorder-extraction-and-building-tree-clean-code",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node,arr):\\n            if node is None:\\n                return None\\n            \\n            inorder(node.left,arr)\\n            arr.append(node)\\n            inorder(node.right,arr)\\n        \\n        def construct(arr):\\n            if not arr:\\n                return None\\n            \\n            mid = len(arr)//2\\n            \\n            node = TreeNode(arr[mid].val)\\n            node.left = construct(arr[:mid])\\n            node.right = construct(arr[mid+1:])\\n            \\n            return node\\n            \\n        arr = []\\n        inorder(root,arr)\\n        \\n        return construct(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node,arr):\\n            if node is None:\\n                return None\\n            \\n            inorder(node.left,arr)\\n            arr.append(node)\\n            inorder(node.right,arr)\\n        \\n        def construct(arr):\\n            if not arr:\\n                return None\\n            \\n            mid = len(arr)//2\\n            \\n            node = TreeNode(arr[mid].val)\\n            node.left = construct(arr[:mid])\\n            node.right = construct(arr[mid+1:])\\n            \\n            return node\\n            \\n        arr = []\\n        inorder(root,arr)\\n        \\n        return construct(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303328,
                "title": "python-divide-and-conquer-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tnodes = []\\n\\n\\t\\t\\tdef inOrderTraverse(node: TreeNode):\\n\\t\\t\\t\\tif not node.right and not node.left:\\n\\t\\t\\t\\t\\tnodes.append(node.val)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.left)\\n\\n\\t\\t\\t\\tnodes.append(node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.right)\\n\\n\\t\\t\\tdef divideAndConquer(nodes_list: List[int], l: int, r: int) -> TreeNode:\\n\\t\\t\\t\\tif l >= 0 and r < len(nodes_list) and l <= r:\\n\\t\\t\\t\\t\\tmid = (l + r) // 2\\n\\t\\t\\t\\t\\tmid_val = nodes_list[mid]\\n\\n\\t\\t\\t\\t\\tnew_node = TreeNode(mid_val)\\n\\n\\t\\t\\t\\t\\tnew_node.left = divideAndConquer(nodes_list, l, mid - 1)\\n\\t\\t\\t\\t\\tnew_node.right = divideAndConquer(nodes_list, mid + 1, r)\\n\\n\\t\\t\\t\\t\\treturn new_node\\n\\n\\t\\t\\tinOrderTraverse(root)\\n\\t\\t\\treturn divideAndConquer(nodes, 0, len(nodes)-1)",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tnodes = []\\n\\n\\t\\t\\tdef inOrderTraverse(node: TreeNode):\\n\\t\\t\\t\\tif not node.right and not node.left:\\n\\t\\t\\t\\t\\tnodes.append(node.val)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.left)\\n\\n\\t\\t\\t\\tnodes.append(node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.right)\\n\\n\\t\\t\\tdef divideAndConquer(nodes_list: List[int], l: int, r: int) -> TreeNode:\\n\\t\\t\\t\\tif l >= 0 and r < len(nodes_list) and l <= r:\\n\\t\\t\\t\\t\\tmid = (l + r) // 2\\n\\t\\t\\t\\t\\tmid_val = nodes_list[mid]\\n\\n\\t\\t\\t\\t\\tnew_node = TreeNode(mid_val)\\n\\n\\t\\t\\t\\t\\tnew_node.left = divideAndConquer(nodes_list, l, mid - 1)\\n\\t\\t\\t\\t\\tnew_node.right = divideAndConquer(nodes_list, mid + 1, r)\\n\\n\\t\\t\\t\\t\\treturn new_node\\n\\n\\t\\t\\tinOrderTraverse(root)\\n\\t\\t\\treturn divideAndConquer(nodes, 0, len(nodes)-1)",
                "codeTag": "Java"
            },
            {
                "id": 2263962,
                "title": "c-recursion-tree-creation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* node, vector<int>& v){\\n        if(node == NULL) return;\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& v, int i, int j){\\n        if(i>j) return NULL;\\n        int mid = (i+j)/2;\\n        TreeNode* cur = new TreeNode(v[mid]);\\n        cur->left = createTree(v,i,mid-1);\\n        cur->right = createTree(v,mid+1,j);\\n        return cur;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        dfs(root,v);\\n        TreeNode* res = createTree(v,0,v.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* node, vector<int>& v){\\n        if(node == NULL) return;\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& v, int i, int j){\\n        if(i>j) return NULL;\\n        int mid = (i+j)/2;\\n        TreeNode* cur = new TreeNode(v[mid]);\\n        cur->left = createTree(v,i,mid-1);\\n        cur->right = createTree(v,mid+1,j);\\n        return cur;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        dfs(root,v);\\n        TreeNode* res = createTree(v,0,v.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263961,
                "title": "67-tc-and-56-sc-easy-python-solution",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tlru_cache(None)\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn []\\n\\t\\treturn dfs(node.left) + [node.val] + dfs(node.right)\\n\\tarr = dfs(root)\\n\\tdef balance(i, j):\\n\\t\\tif(i > j):\\n\\t\\t\\treturn None\\n\\t\\tif(i == j):\\n\\t\\t\\treturn TreeNode(arr[i])\\n\\t\\tmid = (i+j)//2\\n\\t\\treturn TreeNode(arr[mid], balance(i, mid-1), balance(mid+1, j))\\n\\treturn balance(0, len(arr)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tlru_cache(None)\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn []\\n\\t\\treturn dfs(node.left) + [node.val] + dfs(node.right)\\n\\tarr = dfs(root)\\n\\tdef balance(i, j):\\n\\t\\tif(i > j):\\n\\t\\t\\treturn None\\n\\t\\tif(i == j):\\n\\t\\t\\treturn TreeNode(arr[i])\\n\\t\\tmid = (i+j)//2\\n\\t\\treturn TreeNode(arr[mid], balance(i, mid-1), balance(mid+1, j))\\n\\treturn balance(0, len(arr)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2219250,
                "title": "c-solution-explained-faster-than-81-71-runtime-154ms-memory-61-9mb",
                "content": "Pull the elements in a vector by doing inorder traversal. (Note: Inorder of bst gives (ascending) sorted ordered elements)\\nNow find the middle element and start inserting to form a new bst.\\nRepeat the above step recursively until the start element = end element.\\nRefer to code below for further insights.\\n\\nIntuition: If the no. of elements in the right and left of the element to be inserted be equal or differ by one at each stage of insertion, the resultant tree would be balanced.\\n\\nComment down for further discussion.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *insert(TreeNode *root, int value)\\n    {\\n        if(root == NULL)\\n        {\\n            root  = new TreeNode(0);\\n            root->left = NULL; root->right = NULL;\\n            root->val = value;\\n            return root;\\n        }\\n        \\n        TreeNode *trav = root;\\n        \\n        while(true)\\n        {\\n            if(value < trav->val)\\n            {\\n                if(trav->left == NULL) break;\\n                trav = trav->left;\\n            }\\n            else\\n            {\\n                if(trav->right == NULL) break;\\n                trav = trav->right;\\n            }\\n        }\\n        \\n        TreeNode *tmp = new TreeNode(0);\\n        tmp->left = NULL; tmp->right = NULL;\\n        tmp->val = value;\\n        \\n        if(value < trav->val)\\n        {\\n            trav->left = tmp;\\n        }\\n        else\\n        {\\n            trav->right = tmp;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    TreeNode *balance(vector<int> &v, TreeNode *root, int start, int end)\\n    {\\n        if(start == end) \\n        {\\n            root = insert(root, v[start]);\\n            return root;\\n        }\\n        int mid = ceil((start + end)/2);\\n        root = insert(root, v[mid]);\\n        \\n        if(mid != end)\\n        {\\n            root = balance(v, root, mid+1, end);\\n        }\\n        \\n        if(mid != start)\\n        {\\n            root = balance(v, root, start, mid-1);\\n        }\\n        return root;\\n    }\\n    \\n    void trav(vector<int> &v, TreeNode* root)\\n    {\\n        if(root == NULL) return;\\n        trav(v, root->left);\\n        v.push_back(root->val);\\n        trav(v, root->right);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        vector<int> v;\\n        trav(v, root);\\n        \\n        root = NULL;\\n        root = balance(v, root, 0, v.size()-1);\\n        \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *insert(TreeNode *root, int value)\\n    {\\n        if(root == NULL)\\n        {\\n            root  = new TreeNode(0);\\n            root->left = NULL; root->right = NULL;\\n            root->val = value;\\n            return root;\\n        }\\n        \\n        TreeNode *trav = root;\\n        \\n        while(true)\\n        {\\n            if(value < trav->val)\\n            {\\n                if(trav->left == NULL) break;\\n                trav = trav->left;\\n            }\\n            else\\n            {\\n                if(trav->right == NULL) break;\\n                trav = trav->right;\\n            }\\n        }\\n        \\n        TreeNode *tmp = new TreeNode(0);\\n        tmp->left = NULL; tmp->right = NULL;\\n        tmp->val = value;\\n        \\n        if(value < trav->val)\\n        {\\n            trav->left = tmp;\\n        }\\n        else\\n        {\\n            trav->right = tmp;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    TreeNode *balance(vector<int> &v, TreeNode *root, int start, int end)\\n    {\\n        if(start == end) \\n        {\\n            root = insert(root, v[start]);\\n            return root;\\n        }\\n        int mid = ceil((start + end)/2);\\n        root = insert(root, v[mid]);\\n        \\n        if(mid != end)\\n        {\\n            root = balance(v, root, mid+1, end);\\n        }\\n        \\n        if(mid != start)\\n        {\\n            root = balance(v, root, start, mid-1);\\n        }\\n        return root;\\n    }\\n    \\n    void trav(vector<int> &v, TreeNode* root)\\n    {\\n        if(root == NULL) return;\\n        trav(v, root->left);\\n        v.push_back(root->val);\\n        trav(v, root->right);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        vector<int> v;\\n        trav(v, root);\\n        \\n        root = NULL;\\n        root = balance(v, root, 0, v.size()-1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210507,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\n\\n    // function to find BST elements in inorder(sorted) form\\nvoid inorder( TreeNode *root, vector<int>& in)\\n{\\n    // base case\\n    if(root == NULL)\\n    {\\n        return;\\n    }\\n    // inorder: left root right\\n    inorder(root->left, in);\\n    in.push_back(root->val);\\n    inorder(root->right, in);\\n}\\n    // function to get balanced bst\\n TreeNode * balancedBST(int s, int e, vector<int>& in)\\n{\\n    // base case\\n    if(s > e)\\n    {\\n        return NULL;\\n    }\\n     // find mid index\\n    int mid = (s+e)/2;\\n     // create root node\\n    TreeNode * root = new TreeNode(in[mid]);\\n    // left and right child of tree\\n    root->left = balancedBST(s,mid-1, in);\\n    root->right = balancedBST(mid+1, e, in);\\n    return root;\\n}\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // to store inorder elements from BST\\n        vector<int>in;\\n        // store BST elements in inorder form inside in array\\n        inorder(root, in);\\n        int st = 0, end = in.size()-1;\\n        \\n        // creating balanced bst\\n         TreeNode * newRoot = balancedBST(st, end, in);\\n        return newRoot;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n    // function to find BST elements in inorder(sorted) form\\nvoid inorder( TreeNode *root, vector<int>& in)\\n{\\n    // base case\\n    if(root == NULL)\\n    {\\n        return;\\n    }\\n    // inorder: left root right\\n    inorder(root->left, in);\\n    in.push_back(root->val);\\n    inorder(root->right, in);\\n}\\n    // function to get balanced bst\\n TreeNode * balancedBST(int s, int e, vector<int>& in)\\n{\\n    // base case\\n    if(s > e)\\n    {\\n        return NULL;\\n    }\\n     // find mid index\\n    int mid = (s+e)/2;\\n     // create root node\\n    TreeNode * root = new TreeNode(in[mid]);\\n    // left and right child of tree\\n    root->left = balancedBST(s,mid-1, in);\\n    root->right = balancedBST(mid+1, e, in);\\n    return root;\\n}\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // to store inorder elements from BST\\n        vector<int>in;\\n        // store BST elements in inorder form inside in array\\n        inorder(root, in);\\n        int st = 0, end = in.size()-1;\\n        \\n        // creating balanced bst\\n         TreeNode * newRoot = balancedBST(st, end, in);\\n        return newRoot;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192937,
                "title": "python-easy-to-understand",
                "content": "**Intuition**\\nWe need to store the values stored in the given BST into an array in ascending order. \\nWe can achieve that by inorder traversal.\\n\\nNext we perform a pre-order traversal on the array and insert the values as nodes accordingly.\\n\\n**Solution**\\n1. Create a function `extract()` that will take values from the given BST and insert them in ascending order into an array.\\n2. Create a funtion `makeTree()` that takes the array and calls a function `makeTreeUtil()`.\\n3. `makeTreeUtil()` will take the middle value and insert it as the root node and then recursively call itself and assign the left and right child accordingly.\\n4. Return `self.makeTree(root)` in the return function of `balanceBST()`.\\n\\n***Code***\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        return self.makeTree(root)\\n    \\n    def makeTreeUtil(self, arr, left, right):\\n        if left>right:\\n            return None\\n        \\n        mid = (right+left)//2\\n        \\n        node = TreeNode(arr[mid])\\n        node.left = self.makeTreeUtil(arr, left, mid-1)\\n        node.right = self.makeTreeUtil(arr , mid+1, right)\\n        \\n        return node\\n    \\n    \\n    def makeTree(self, root):\\n        arr= self.extract(root, [])\\n        return self.makeTreeUtil(arr, 0, len(arr)-1)\\n    \\n    \\n    def extract(self, node, arr):\\n        if not node:\\n            return\\n        self.extract(node.left, arr)\\n        arr.append(node.val)\\n        self.extract(node.right, arr) \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        return self.makeTree(root)\\n    \\n    def makeTreeUtil(self, arr, left, right):\\n        if left>right:\\n            return None\\n        \\n        mid = (right+left)//2\\n        \\n        node = TreeNode(arr[mid])\\n        node.left = self.makeTreeUtil(arr, left, mid-1)\\n        node.right = self.makeTreeUtil(arr , mid+1, right)\\n        \\n        return node\\n    \\n    \\n    def makeTree(self, root):\\n        arr= self.extract(root, [])\\n        return self.makeTreeUtil(arr, 0, len(arr)-1)\\n    \\n    \\n    def extract(self, node, arr):\\n        if not node:\\n            return\\n        self.extract(node.left, arr)\\n        arr.append(node.val)\\n        self.extract(node.right, arr) \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137310,
                "title": "python-inorder",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        x=[]\\n        def g(r):\\n            if not r:return 0\\n            g(r.left)\\n            x.append(r.val)\\n            g(r.right)\\n        def f(i,j):\\n            if i>j:return \\n            m=(i+j)//2\\n            r=TreeNode(x[m])\\n            if i==j:return r\\n            r.left=f(i,m-1)\\n            r.right=f(m+1,j)\\n            return r\\n        g(root)\\n        return f(0,len(x)-1)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        x=[]\\n        def g(r):\\n            if not r:return 0\\n            g(r.left)\\n            x.append(r.val)\\n            g(r.right)\\n        def f(i,j):\\n            if i>j:return \\n            m=(i+j)//2\\n            r=TreeNode(x[m])\\n            if i==j:return r\\n            r.left=f(i,m-1)\\n            r.right=f(m+1,j)\\n            return r\\n        g(root)\\n        return f(0,len(x)-1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127029,
                "title": "c-inorder-recursion",
                "content": "form a vector from inorder traversal , & this will be sorted as , inorder traversal gives sorted vector.\\nFrom this we will buid a tree recursively by finding middle of the vector\\n```\\nclass Solution {\\npublic:\\n   \\n    TreeNode* buildFromInorder(vector<int> v,int start, int end){\\n        if(start>end)\\n            return NULL;\\n        \\n        int mid=(start+end)/2;\\n        TreeNode* root=new TreeNode(v[mid]);\\n        \\n        root->left= buildFromInorder(v,start,mid-1);\\n        root->right= buildFromInorder(v,mid+1,end);\\n        \\n        return root;\\n        \\n        \\n    }\\n    void inorder(TreeNode* root, vector<int> &v){\\n        if(!root)\\n            return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n\\n       return  buildFromInorder(v,0,v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    TreeNode* buildFromInorder(vector<int> v,int start, int end){\\n        if(start>end)\\n            return NULL;\\n        \\n        int mid=(start+end)/2;\\n        TreeNode* root=new TreeNode(v[mid]);\\n        \\n        root->left= buildFromInorder(v,start,mid-1);\\n        root->right= buildFromInorder(v,mid+1,end);\\n        \\n        return root;\\n        \\n        \\n    }\\n    void inorder(TreeNode* root, vector<int> &v){\\n        if(!root)\\n            return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n\\n       return  buildFromInorder(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099010,
                "title": "golang",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc InOrder(root *TreeNode, arr *[]int) {\\n    if root==nil {\\n        return\\n    }\\n    InOrder(root.Left, arr)\\n    *arr=append(*arr, root.Val)\\n    InOrder(root.Right, arr)\\n    \\n}\\n\\nfunc createBalancedBST(A []int, l, r int) *TreeNode {\\n    if l>r {\\n        return nil\\n    }\\n    m:=(l+r)/2\\n    root:=&TreeNode{Val: A[m]}\\n    root.Left=createBalancedBST(A, l, m-1)\\n    root.Right=createBalancedBST(A, m+1, r)\\n    return root\\n}\\n\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    var arr []int\\n    InOrder(root, &arr)\\n    result:=createBalancedBST(arr, 0, len(arr)-1)\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc InOrder(root *TreeNode, arr *[]int) {\\n    if root==nil {\\n        return\\n    }\\n    InOrder(root.Left, arr)\\n    *arr=append(*arr, root.Val)\\n    InOrder(root.Right, arr)\\n    \\n}\\n\\nfunc createBalancedBST(A []int, l, r int) *TreeNode {\\n    if l>r {\\n        return nil\\n    }\\n    m:=(l+r)/2\\n    root:=&TreeNode{Val: A[m]}\\n    root.Left=createBalancedBST(A, l, m-1)\\n    root.Right=createBalancedBST(A, m+1, r)\\n    return root\\n}\\n\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    var arr []int\\n    InOrder(root, &arr)\\n    result:=createBalancedBST(arr, 0, len(arr)-1)\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2098593,
                "title": "easy-java-solution-with-comments",
                "content": "```\\n\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        //creating sorted array from bst using Inorder\\n        inorder(root);\\n        // creating bst from sorted arr\\n        return bst(0,arr.size()-1);\\n    }\\n\\n//     creating bst\\n    public TreeNode bst(int start, int end){\\n        if(start>end) return null;\\n        int mid=(start+end)/2;\\n        TreeNode node= new TreeNode(arr.get(mid));\\n        node.left=bst(start,mid-1);\\n        node.right=bst(mid+1,end);\\n        return node;\\n    }\\n    //inorder mmethod\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        arr.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        //creating sorted array from bst using Inorder\\n        inorder(root);\\n        // creating bst from sorted arr\\n        return bst(0,arr.size()-1);\\n    }\\n\\n//     creating bst\\n    public TreeNode bst(int start, int end){\\n        if(start>end) return null;\\n        int mid=(start+end)/2;\\n        TreeNode node= new TreeNode(arr.get(mid));\\n        node.left=bst(start,mid-1);\\n        node.right=bst(mid+1,end);\\n        return node;\\n    }\\n    //inorder mmethod\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        arr.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096187,
                "title": "c-inorder-list-recursive-bst-build",
                "content": "```\\npublic class Solution {\\n    public TreeNode BalanceBST(TreeNode root) {\\n        List<int> treeList=InorderTraverse(root,new List<int>());\\n        return BuildBST(treeList,0,treeList.Count-1);\\n    }\\n\\t\\n    private TreeNode BuildBST(List<int> list,int l,int r){\\n\\t\\t//This is base case, you can\\'t build a tree at this point so return null\\n        if(l>r){return null;}\\n\\t\\t\\n        int mid=l+(r-l)/2;\\n\\t\\t//make the middle element root\\n        TreeNode root=new TreeNode(list[mid]);\\n\\t\\t//from left end to mid-1 will be left sub-tree\\n        root.left=BuildBST(list,l,mid-1);\\n\\t\\t//from mid+1 to right end will be right sub tree\\n        root.right=BuildBST(list,mid+1,r);\\n\\t\\t\\n        return root;\\n    }\\n\\t\\n\\t// Do in-order traversal and convert to list\\n    private List<int> InorderTraverse(TreeNode root,List<int> list){\\n        if(root==null){\\n            return list;\\n        }\\n        InorderTraverse(root.left,list);\\n        list.Add(root.val);\\n        InorderTraverse(root.right,list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode BalanceBST(TreeNode root) {\\n        List<int> treeList=InorderTraverse(root,new List<int>());\\n        return BuildBST(treeList,0,treeList.Count-1);\\n    }\\n\\t\\n    private TreeNode BuildBST(List<int> list,int l,int r){\\n\\t\\t//This is base case, you can\\'t build a tree at this point so return null\\n        if(l>r){return null;}\\n\\t\\t\\n        int mid=l+(r-l)/2;\\n\\t\\t//make the middle element root\\n        TreeNode root=new TreeNode(list[mid]);\\n\\t\\t//from left end to mid-1 will be left sub-tree\\n        root.left=BuildBST(list,l,mid-1);\\n\\t\\t//from mid+1 to right end will be right sub tree\\n        root.right=BuildBST(list,mid+1,r);\\n\\t\\t\\n        return root;\\n    }\\n\\t\\n\\t// Do in-order traversal and convert to list\\n    private List<int> InorderTraverse(TreeNode root,List<int> list){\\n        if(root==null){\\n            return list;\\n        }\\n        InorderTraverse(root.left,list);\\n        list.Add(root.val);\\n        InorderTraverse(root.right,list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090256,
                "title": "python-python-solution-inorder-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node):\\n            return inorder(node.left) + [node.val] + inorder(node.right) if node else []\\n        def bst(v):\\n            if not v:\\n                return None\\n            mid = len(v) // 2\\n            root = TreeNode(v[mid])\\n            root.left = bst(v[:mid])\\n            root.right = bst(v[mid + 1:])\\n            return root\\n        v = inorder(root)\\n        return bst(v)\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node):\\n            return inorder(node.left) + [node.val] + inorder(node.right) if node else []\\n        def bst(v):\\n            if not v:\\n                return None\\n            mid = len(v) // 2\\n            root = TreeNode(v[mid])\\n            root.left = bst(v[:mid])\\n            root.right = bst(v[mid + 1:])\\n            return root\\n        v = inorder(root)\\n        return bst(v)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2049361,
                "title": "java-visualization-balance-a-binary-search-tree",
                "content": "**Algorithm:**\\n1. Convert BST to a sorted array using Inorder traversal\\n2. Build the balanced BST from sorted array.\\n    - Recursively choose the middle element of the sorted array as the root of the balanced BST\\n    - All the elements on the left of the middle element will be part of left subtree and elements on the right of the middle element will be part of right subtree\\n\\n**Visualization:**\\n\\n![image](https://assets.leetcode.com/users/images/717c400d-3711-48fe-ba83-a71557ccffd8_1652829347.4040399.png)\\n\\n**Code:**\\n```\\nclass Solution {\\n    List<Integer> sortedArray = new ArrayList();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return construct(0, sortedArray.size()-1);\\n    }\\n    \\n    private TreeNode construct(int start, int end){\\n        if(start>end) return null;\\n        int mid = (end+start)/2;\\n        TreeNode root = new TreeNode(sortedArray.get(mid));\\n        root.left = construct(start, mid - 1);\\n        root.right = construct(mid+1, end);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        sortedArray.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```\\n\\n**Complexity:**\\n\\nTime Complexity :    O(N)\\nSpace Complexity :  O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> sortedArray = new ArrayList();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return construct(0, sortedArray.size()-1);\\n    }\\n    \\n    private TreeNode construct(int start, int end){\\n        if(start>end) return null;\\n        int mid = (end+start)/2;\\n        TreeNode root = new TreeNode(sortedArray.get(mid));\\n        root.left = construct(start, mid - 1);\\n        root.right = construct(mid+1, end);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        sortedArray.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018226,
                "title": "mergesort-2-ms-java",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList();\\n        inOrder(root,list);\\n        return makeTree(list,0,list.size() - 1);\\n    }\\n    public TreeNode makeTree(ArrayList<Integer> list, int low, int high){\\n        if(low > high){\\n            return null;\\n        }   \\n        int middle = low + (high - low)/2;\\n        TreeNode node = new TreeNode(list.get(middle));\\n        node.left= makeTree(list,low,middle - 1);\\n        node.right= makeTree(list,middle + 1,high);\\n        return node;\\n    }\\n    \\n    public void inOrder(TreeNode root,ArrayList<Integer> list){\\n        if(root == null){\\n            return;\\n        }\\n        inOrder(root.left,list);\\n        list.add(root.val);\\n        inOrder(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList();\\n        inOrder(root,list);\\n        return makeTree(list,0,list.size() - 1);\\n    }\\n    public TreeNode makeTree(ArrayList<Integer> list, int low, int high){\\n        if(low > high){\\n            return null;\\n        }   \\n        int middle = low + (high - low)/2;\\n        TreeNode node = new TreeNode(list.get(middle));\\n        node.left= makeTree(list,low,middle - 1);\\n        node.right= makeTree(list,middle + 1,high);\\n        return node;\\n    }\\n    \\n    public void inOrder(TreeNode root,ArrayList<Integer> list){\\n        if(root == null){\\n            return;\\n        }\\n        inOrder(root.left,list);\\n        list.add(root.val);\\n        inOrder(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011059,
                "title": "balance-a-binary-search-tree-java-inorder",
                "content": "#### **Balance a Binary Search Tree**\\n```\\nclass Solution {\\n    \\n    private void inorder(TreeNode root, List<TreeNode> nodes) {\\n        if (root != null) {\\n            inorder(root.left, nodes);\\n            root.left = null;\\n            nodes.add(root);\\n            inorder(root.right, nodes);\\n            root.right = null;\\n        }\\n    }\\n    \\n    private TreeNode create(List<TreeNode> nodes, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) {\\n            return nodes.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        nodes.get(mid).left = create(nodes, start, mid-1);\\n        nodes.get(mid).right = create(nodes, mid+1, end);\\n        return nodes.get(mid);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n        return create(nodes, 0, nodes.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void inorder(TreeNode root, List<TreeNode> nodes) {\\n        if (root != null) {\\n            inorder(root.left, nodes);\\n            root.left = null;\\n            nodes.add(root);\\n            inorder(root.right, nodes);\\n            root.right = null;\\n        }\\n    }\\n    \\n    private TreeNode create(List<TreeNode> nodes, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) {\\n            return nodes.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        nodes.get(mid).left = create(nodes, start, mid-1);\\n        nodes.get(mid).right = create(nodes, mid+1, end);\\n        return nodes.get(mid);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n        return create(nodes, 0, nodes.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999966,
                "title": "c-easy-clear-understanding",
                "content": "class Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,vector<TreeNode*> &vec)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,vec);\\n        vec.push_back(root);\\n        inorder(root->right,vec);\\n        \\n        \\n    }\\n    \\n    TreeNode* convert(vector<TreeNode*> &vec,int start,int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = (start+end)/2;\\n        TreeNode* root = vec[mid];\\n        \\n        root->left  = convert(vec,start,mid-1);\\n        root->right = convert(vec,mid+1,end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<TreeNode*> vec;\\n        \\n        inorder(root,vec);\\n        int n=vec.size();\\n        \\n        return convert(vec,0,n-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,vector<TreeNode*> &vec)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,vec);\\n        vec.push_back(root);\\n        inorder(root->right,vec);\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944795,
                "title": "java-in-place-solution-using-rotations",
                "content": "class Solution {\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null) return null;\\n        \\n        TreeNode parent = new TreeNode(0);\\n        parent.left = root;\\n        balance(parent.left, parent);\\n        return parent.left;\\n    }\\n    \\n    private void balance(TreeNode node, TreeNode parent) {\\n        if (node == null) return;\\n        balance(node.left, node); \\n        balance(node.right, node);\\n            \\n        int bal = getBalance(node);\\n        if (bal > 1) {\\n            if (getBalance(node.left) < 0) {\\n                rotateLeft(node.left, node); // LR\\n            }\\n            balance(rotateRight(node, parent), parent); // LL\\n        } else if (bal < -1) {\\n            if (getBalance(node.right) > 0) {\\n                rotateRight(node.right, node); // RL\\n            }\\n            balance(rotateLeft(node, parent), parent); // RR\\n        }\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode x, TreeNode parent) {\\n        TreeNode y = x.right;\\n        x.right = y.left;\\n        y.left = x;\\n        \\n        if (parent.left == x) parent.left = y;\\n        if (parent.right == x) parent.right = y;\\n        \\n        return y;\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode x, TreeNode parent) {\\n        TreeNode y = x.left;\\n        x.left = y.right;\\n        y.right = x;\\n        \\n        if (parent.left == x) parent.left = y;\\n        if (parent.right == x) parent.right = y;\\n        \\n        return y;\\n    }\\n    \\n    private int getBalance(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = getHeight(node.left);\\n        int r = getHeight(node.right);\\n        return l-r;\\n    }\\n    \\n    private int getHeight(TreeNode node) {\\n        if (node == null) return -1;\\n        int l = getHeight(node.left);\\n        int r = getHeight(node.right);\\n        return 1 + Math.max(l, r);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null) return null;\\n        \\n        TreeNode parent = new TreeNode(0);\\n        parent.left = root;\\n        balance(parent.left, parent);\\n        return parent.left;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1926483,
                "title": "java-2ms-faster-than-99",
                "content": "Steps:\\n1,  Create inorder array using inorder traversal algorithm\\n2. From inorder array create the balanced BST using recursion\\nTime complexity: O(n)\\nSpace complexity: O(n) (need an extra array and a new tree)\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // Create the inorder array\\n        ArrayList<Integer> inorderArray = new ArrayList<>();\\n        buildInorderArrayFromBST(root, inorderArray);\\n        \\n        // Create the balanced BST from inorder array\\n        return createBalancedBST_FromInorderArray(inorderArray, 0, inorderArray.size() - 1);\\n    }\\n    \\n    public TreeNode createBalancedBST_FromInorderArray(ArrayList<Integer> inorderArray, int l, int r) {\\n        if (l > r) return null;\\n        \\n        int m = l + (r - l) / 2;\\n        TreeNode root = new TreeNode(inorderArray.get(m));\\n        root.left = createBalancedBST_FromInorderArray(inorderArray, l, m - 1);\\n        root.right = createBalancedBST_FromInorderArray(inorderArray, m + 1, r);\\n        \\n        return root;\\n    }\\n\\n    public void buildInorderArrayFromBST(TreeNode root, ArrayList<Integer> inorderArray) {\\n        if (root == null) return;\\n        \\n        buildInorderArrayFromBST(root.left, inorderArray);\\n        inorderArray.add(root.val);\\n        buildInorderArrayFromBST(root.right, inorderArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // Create the inorder array\\n        ArrayList<Integer> inorderArray = new ArrayList<>();\\n        buildInorderArrayFromBST(root, inorderArray);\\n        \\n        // Create the balanced BST from inorder array\\n        return createBalancedBST_FromInorderArray(inorderArray, 0, inorderArray.size() - 1);\\n    }\\n    \\n    public TreeNode createBalancedBST_FromInorderArray(ArrayList<Integer> inorderArray, int l, int r) {\\n        if (l > r) return null;\\n        \\n        int m = l + (r - l) / 2;\\n        TreeNode root = new TreeNode(inorderArray.get(m));\\n        root.left = createBalancedBST_FromInorderArray(inorderArray, l, m - 1);\\n        root.right = createBalancedBST_FromInorderArray(inorderArray, m + 1, r);\\n        \\n        return root;\\n    }\\n\\n    public void buildInorderArrayFromBST(TreeNode root, ArrayList<Integer> inorderArray) {\\n        if (root == null) return;\\n        \\n        buildInorderArrayFromBST(root.left, inorderArray);\\n        inorderArray.add(root.val);\\n        buildInorderArrayFromBST(root.right, inorderArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916738,
                "title": "typescript-simple-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction balanceBST(root: TreeNode | null): TreeNode | null {\\n    let arr = [];\\n    dfs(root,arr);\\n    let newRoot = null\\n    const generate = (i: number,j: number) => {\\n        if(i > j) return null;\\n        let mid = Math.floor((i+j)/2);\\n        let node = new TreeNode(arr[mid]);\\n        if(!newRoot)  newRoot = node;\\n        node.left = generate(i,mid-1);\\n        node.right = generate(mid+1,j);\\n        return node;\\n    }\\n    generate(0,arr.length-1);\\n    return newRoot;\\n};\\nfunction dfs(node: TreeNode | null,arr: number[]) {\\n    if(!node) return;\\n    dfs(node.left,arr);\\n    arr.push(node.val);\\n    dfs(node.right,arr);\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction balanceBST(root: TreeNode | null): TreeNode | null {\\n    let arr = [];\\n    dfs(root,arr);\\n    let newRoot = null\\n    const generate = (i: number,j: number) => {\\n        if(i > j) return null;\\n        let mid = Math.floor((i+j)/2);\\n        let node = new TreeNode(arr[mid]);\\n        if(!newRoot)  newRoot = node;\\n        node.left = generate(i,mid-1);\\n        node.right = generate(mid+1,j);\\n        return node;\\n    }\\n    generate(0,arr.length-1);\\n    return newRoot;\\n};\\nfunction dfs(node: TreeNode | null,arr: number[]) {\\n    if(!node) return;\\n    dfs(node.left,arr);\\n    arr.push(node.val);\\n    dfs(node.right,arr);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1901269,
                "title": "dfs-easy-to-understand-63-2-mb-less-than-55-04-of-c-for-balance-a-binary-search-tree",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nvoid help(TreeNode* root, vector<int>& inorder) {\\n        if(root == NULL)\\n            return;\\n        help(root->left, inorder);\\n        inorder.push_back(root->val);\\n        help(root->right, inorder);\\n    }\\n    TreeNode* balance(vector<int>& inorder, int s, int e) {\\n        if(s>e)\\n            return NULL;\\n        int m = s + (e-s)/2;\\n        TreeNode* root = new TreeNode(inorder[m]);\\n        root->left = balance(inorder, s, m-1);\\n        root->right = balance(inorder, m+1, e);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        help(root, inorder);\\n        return balance(inorder, 0, inorder.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvoid help(TreeNode* root, vector<int>& inorder) {\\n        if(root == NULL)\\n            return;\\n        help(root->left, inorder);\\n        inorder.push_back(root->val);\\n        help(root->right, inorder);\\n    }\\n    TreeNode* balance(vector<int>& inorder, int s, int e) {\\n        if(s>e)\\n            return NULL;\\n        int m = s + (e-s)/2;\\n        TreeNode* root = new TreeNode(inorder[m]);\\n        root->left = balance(inorder, s, m-1);\\n        root->right = balance(inorder, m+1, e);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        help(root, inorder);\\n        return balance(inorder, 0, inorder.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897807,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        bstarray(root,arr);\\n        Collections.sort(arr);\\n        return balanceBSTfromarray(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n    // Converting the Sorted Array into Balanced Tree\\n    public TreeNode balanceBSTfromarray(ArrayList<Integer> arr,int start,int end){\\n        if(start>end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = balanceBSTfromarray(arr,start,mid-1);\\n        root.right = balanceBSTfromarray(arr,mid+1,end);\\n        return root;\\n        \\n    }\\n    \\n    // Constructing the Array using the Unbalanced Binary tree\\n    public void bstarray(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) return;\\n        arr.add(root.val);\\n        bstarray(root.left,arr);\\n        bstarray(root.right,arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        bstarray(root,arr);\\n        Collections.sort(arr);\\n        return balanceBSTfromarray(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n    // Converting the Sorted Array into Balanced Tree\\n    public TreeNode balanceBSTfromarray(ArrayList<Integer> arr,int start,int end){\\n        if(start>end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = balanceBSTfromarray(arr,start,mid-1);\\n        root.right = balanceBSTfromarray(arr,mid+1,end);\\n        return root;\\n        \\n    }\\n    \\n    // Constructing the Array using the Unbalanced Binary tree\\n    public void bstarray(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) return;\\n        arr.add(root.val);\\n        bstarray(root.left,arr);\\n        bstarray(root.right,arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892577,
                "title": "c-recursive-solution",
                "content": "**Please do upvote if it helps you!**\\n**First of all we store the values of the nodes of tree in a vector(using inordered traversal) in a sorted manner..and then we will make another function which will convert the sorted array in height balanced bst\\nNow this helper function will calculate the mid value and make a node(root) out of it and then root->left will be vector left part from mid and root->right will be vector right part after mid\\nand this is how a height balanced bst will be formed!\\nand ofcourse consider the edge cases**\\n\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode *root,vector<int>&v)\\n    {\\n\\t\\n        if(root)\\n        {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* helper(vector<int>&v,int low,int high)\\n    {\\n\\t\\n        int size=high-low;\\n        if(size<0)return NULL;\\n        if(size==0) return new TreeNode(v[low]);\\n        int mid=(low+high)/2;\\n        TreeNode *root=new TreeNode(v[mid]);\\n        root->left=helper(v,low,mid-1);\\n        root->right=helper(v,mid+1,high);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n\\t\\n        vector<int>v;\\n        inorder(root,v);\\n       return helper(v,0,v.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void inorder(TreeNode *root,vector<int>&v)\\n    {\\n\\t\\n        if(root)\\n        {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1878298,
                "title": "c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> nums;\\n    void inorder(TreeNode* root){ //First we write a function for inorder traversal of the tree  \\n        if(root){\\n        inorder(root->left);\\n        nums.push_back(root);// This snippet of code is tells if root exists in the binary tree first we go to the left child of the root and then we push the root into our vector nums and store it there ,and then move into the right child node of the root ,this is the basic recursive method fot inorder traversal.  \\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* solve(int start,int end)//This is the solving function we use to balance the tree,in this function we take 2 parameters start and end to denote the start and end points of our nums vector ,then we find out the mid variable and and the element in the middle of the vector nums is made the root of the tree.Then the left and right child nodes are chosen using the same solve function by taking mid-1 and mid+1 as the ending and starting points respectively. \\n    {\\n        if(start>end)\\n            return NULL; \\n        int mid=(start+end)/2;\\n        TreeNode *root=nums[mid];\\n    \\n        root->left=solve(start,mid-1);\\n        root->right=solve(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> nums;\\n    void inorder(TreeNode* root){ //First we write a function for inorder traversal of the tree  \\n        if(root){\\n        inorder(root->left);\\n        nums.push_back(root);// This snippet of code is tells if root exists in the binary tree first we go to the left child of the root and then we push the root into our vector nums and store it there ,and then move into the right child node of the root ,this is the basic recursive method fot inorder traversal.  \\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* solve(int start,int end)//This is the solving function we use to balance the tree,in this function we take 2 parameters start and end to denote the start and end points of our nums vector ,then we find out the mid variable and and the element in the middle of the vector nums is made the root of the tree.Then the left and right child nodes are chosen using the same solve function by taking mid-1 and mid+1 as the ending and starting points respectively. \\n    {\\n        if(start>end)\\n            return NULL; \\n        int mid=(start+end)/2;\\n        TreeNode *root=nums[mid];\\n    \\n        root->left=solve(start,mid-1);\\n        root->right=solve(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844708,
                "title": "simple-c-and-java-solution-easy",
                "content": "***C++***\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* tobbst(vector<int>& v, int l, int r) {\\n        if(l>r) {\\n            return NULL;\\n        }\\n        int mid = (l+r)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = tobbst( v, l, mid-1);\\n        root->right = tobbst( v, mid+1, r);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root, v);\\n        return tobbst(v, 0, v.size()-1);\\n    }\\n};\\n```\\n\\n***Java***\\n\\n```\\nclass Solution {\\n    public TreeNode solve(List<Integer> l, int s, int e) {\\n        if(s>e) {\\n            return null;\\n        }\\n        int m = s + (e-s)/2;\\n        TreeNode root = new TreeNode(l.get(m));\\n        root.left = solve(l, s, m-1);\\n        root.right = solve(l, m+1, e);\\n        return root;\\n    }\\n    public void inorder(TreeNode root, List<Integer>l) {\\n        if(root == null) {return ;}\\n        inorder(root.left, l);\\n        l.add(root.val);\\n        inorder(root.right, l);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        inorder(root, l);\\n        return solve(l, 0, l.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* tobbst(vector<int>& v, int l, int r) {\\n        if(l>r) {\\n            return NULL;\\n        }\\n        int mid = (l+r)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = tobbst( v, l, mid-1);\\n        root->right = tobbst( v, mid+1, r);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root, v);\\n        return tobbst(v, 0, v.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode solve(List<Integer> l, int s, int e) {\\n        if(s>e) {\\n            return null;\\n        }\\n        int m = s + (e-s)/2;\\n        TreeNode root = new TreeNode(l.get(m));\\n        root.left = solve(l, s, m-1);\\n        root.right = solve(l, m+1, e);\\n        return root;\\n    }\\n    public void inorder(TreeNode root, List<Integer>l) {\\n        if(root == null) {return ;}\\n        inorder(root.left, l);\\n        l.add(root.val);\\n        inorder(root.right, l);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        inorder(root, l);\\n        return solve(l, 0, l.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839967,
                "title": "java-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return makeBinaryTree(list);     \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode makeBinaryTree(List<TreeNode> list){\\n        if(list.size()==0 || list==null)\\n            return null;\\n        int mid=list.size()/2;\\n        TreeNode root=list.get(mid);\\n        root.left=makeBinaryTree(list.subList(0,mid));\\n        root.right=makeBinaryTree(list.subList(mid+1,list.size()));\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return makeBinaryTree(list);     \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode makeBinaryTree(List<TreeNode> list){\\n        if(list.size()==0 || list==null)\\n            return null;\\n        int mid=list.size()/2;\\n        TreeNode root=list.get(mid);\\n        root.left=makeBinaryTree(list.subList(0,mid));\\n        root.right=makeBinaryTree(list.subList(mid+1,list.size()));\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834021,
                "title": "normal-bst-to-balance-bst",
                "content": "```\\nclass Solution {\\nprivate:\\n    void inOrder(TreeNode* root, vector<int>& v){\\n        if(root==NULL)\\n            return ;\\n        \\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    TreeNode* inorderToBst(vector<int> v,int s,int e){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = inorderToBst(v,s,mid-1);\\n        root->right = inorderToBst(v,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        \\n        // storing elment in vector in sorted order using inorder traversal\\n        inOrder(root,v);\\n        \\n        //Forming a Balanced Binary Search Tree\\n        return inorderToBst(v,0,v.size()-1);\\n    }\\n};\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity:O(n)",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void inOrder(TreeNode* root, vector<int>& v){\\n        if(root==NULL)\\n            return ;\\n        \\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    TreeNode* inorderToBst(vector<int> v,int s,int e){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = inorderToBst(v,s,mid-1);\\n        root->right = inorderToBst(v,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        \\n        // storing elment in vector in sorted order using inorder traversal\\n        inOrder(root,v);\\n        \\n        //Forming a Balanced Binary Search Tree\\n        return inorderToBst(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833435,
                "title": "c-latest-code-with-hindi-explaination",
                "content": "```\\n\\tvoid inorder(TreeNode* root , vector<int> &v )\\n    {\\n        if( root == NULL )\\n            return ;\\n\\n        inorder( root->left , v ) ;\\n        v.push_back( root->val ) ;\\n        inorder( root->right , v ) ;\\n    }\\n\\n\\n    TreeNode* inorderToBST(  int s , int e , vector<int> &v )\\n    {\\n        if( s > e  )\\n            return NULL ;\\n\\n        int mid = (s+e)/2 ;       //mid nikalakar left part me small element daal do right me \\n                                //mid ke right side wale (bade) elements daal do \\n\\n        TreeNode* root = new TreeNode( v[mid] ) ; //mid hi BST ka 1st root node banega aur baaki ke mids node bante jayege \\n        root->left = inorderToBST( s , mid-1 , v) ;     //left-call \\n        root->right = inorderToBST( mid+1 , e , v) ;    //right-call\\n        \\n        \\n        return root ;\\n    }\\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int>  v ;\\n\\tinorder( root , v ) ;\\n\\t\\n\\t//now mw vector is sorted so have have to break it in Two parts . smaal in left & big in right \\n\\treturn inorderToBST(  0 , v.size()-1 , v ) ;\\n\\t                   // tart ,  end ,   vector \\n        \\n    }\\n\\t\\n\\t\\n\\tcredit : @love_Babbar @CodeHelp ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tvoid inorder(TreeNode* root , vector<int> &v )\\n    {\\n        if( root == NULL )\\n            return ;\\n\\n        inorder( root->left , v ) ;\\n        v.push_back( root->val ) ;\\n        inorder( root->right , v ) ;\\n    }\\n\\n\\n    TreeNode* inorderToBST(  int s , int e , vector<int> &v )\\n    {\\n        if( s > e  )\\n            return NULL ;\\n\\n        int mid = (s+e)/2 ;       //mid nikalakar left part me small element daal do right me \\n                                //mid ke right side wale (bade) elements daal do \\n\\n        TreeNode* root = new TreeNode( v[mid] ) ; //mid hi BST ka 1st root node banega aur baaki ke mids node bante jayege \\n        root->left = inorderToBST( s , mid-1 , v) ;     //left-call \\n        root->right = inorderToBST( mid+1 , e , v) ;    //right-call\\n        \\n        \\n        return root ;\\n    }\\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int>  v ;\\n\\tinorder( root , v ) ;\\n\\t\\n\\t//now mw vector is sorted so have have to break it in Two parts . smaal in left & big in right \\n\\treturn inorderToBST(  0 , v.size()-1 , v ) ;\\n\\t                   // tart ,  end ,   vector \\n        \\n    }\\n\\t\\n\\t\\n\\tcredit : @love_Babbar @CodeHelp ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830686,
                "title": "javascript-in-order-traverse-o-n",
                "content": "```\\nvar balanceBST = function(root) {\\n    var arr = [];\\n    traverse(root, arr);\\n    return construct(arr);\\n};\\n\\nvar construct = function(arr) {\\n    if (arr.length == 0) {\\n        return null;\\n    }\\n    \\n    var middle = parseInt(arr.length / 2);\\n    \\n    return new TreeNode(arr[middle], construct(arr.slice(0, middle)), construct(arr.slice(middle + 1)));\\n};\\n\\nvar traverse = function(root, arr) {\\n    if (root == null) {\\n        return;\\n    }\\n    \\n    traverse(root.left, arr);\\n    arr.push(root.val);\\n    traverse(root.right, arr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar balanceBST = function(root) {\\n    var arr = [];\\n    traverse(root, arr);\\n    return construct(arr);\\n};\\n\\nvar construct = function(arr) {\\n    if (arr.length == 0) {\\n        return null;\\n    }\\n    \\n    var middle = parseInt(arr.length / 2);\\n    \\n    return new TreeNode(arr[middle], construct(arr.slice(0, middle)), construct(arr.slice(middle + 1)));\\n};\\n\\nvar traverse = function(root, arr) {\\n    if (root == null) {\\n        return;\\n    }\\n    \\n    traverse(root.left, arr);\\n    arr.push(root.val);\\n    traverse(root.right, arr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1794229,
                "title": "c-inorder-traversal-clean-code",
                "content": "middle element of the inorder traversal becomes the root recursively\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    \\n    \\n    void iorder(TreeNode* root){\\n        if(root == NULL)return;\\n        iorder(root->left);\\n        inorder.push_back(root);\\n        iorder(root->right);\\n    }\\n    \\n    TreeNode* solve(int start,int end){\\n        if(start>end)return NULL;\\n        int mid = (start+end)/2;\\n        TreeNode* root = inorder[mid];\\n        root->left = solve(start,mid-1);\\n        root->right = solve(mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {     \\n        iorder(root);\\n        TreeNode* Root = solve(0,inorder.size()-1);\\n        return Root;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    \\n    \\n    void iorder(TreeNode* root){\\n        if(root == NULL)return;\\n        iorder(root->left);\\n        inorder.push_back(root);\\n        iorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1774926,
                "title": "c-inorder-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* &root,vector<TreeNode*>&in){\\n        if(!root)\\n            return ;\\n        inorder(root->left,in);\\n        in.push_back(root);\\n        inorder(root->right,in);\\n    }\\n    TreeNode* buildBst(vector<TreeNode*>&in,int start,int end){\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        \\n            TreeNode* root1=in[mid];//in is already storing the node so no need to create another new node;\\n            root1->left=buildBst(in,start,mid-1);//mid already taken in root1;\\n            root1->right=buildBst(in,mid+1,end);\\n            return root1;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>in;\\n        inorder(root,in);\\n        return buildBst(in,0,in.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* &root,vector<TreeNode*>&in){\\n        if(!root)\\n            return ;\\n        inorder(root->left,in);\\n        in.push_back(root);\\n        inorder(root->right,in);\\n    }\\n    TreeNode* buildBst(vector<TreeNode*>&in,int start,int end){\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        \\n            TreeNode* root1=in[mid];//in is already storing the node so no need to create another new node;\\n            root1->left=buildBst(in,start,mid-1);//mid already taken in root1;\\n            root1->right=buildBst(in,mid+1,end);\\n            return root1;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>in;\\n        inorder(root,in);\\n        return buildBst(in,0,in.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763118,
                "title": "c-simple-array-to-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> elems;\\n        collect(root, elems);\\n        return build(elems.cbegin(), elems.cend());\\n    }\\n    \\n    void collect(TreeNode *root, vector<int> &elems)\\n    {\\n        if (!root) return;\\n        collect(root->left, elems);\\n        elems.push_back(root->val);\\n        collect(root->right, elems);\\n    }\\n    \\n    TreeNode *build(vector<int>::const_iterator s, vector<int>::const_iterator e)\\n    {\\n        if (s >= e) return nullptr;\\n        const auto mid = s + (e - s) / 2;\\n        return new TreeNode(*mid, build(s, mid), build(next(mid), e));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> elems;\\n        collect(root, elems);\\n        return build(elems.cbegin(), elems.cend());\\n    }\\n    \\n    void collect(TreeNode *root, vector<int> &elems)\\n    {\\n        if (!root) return;\\n        collect(root->left, elems);\\n        elems.push_back(root->val);\\n        collect(root->right, elems);\\n    }\\n    \\n    TreeNode *build(vector<int>::const_iterator s, vector<int>::const_iterator e)\\n    {\\n        if (s >= e) return nullptr;\\n        const auto mid = s + (e - s) / 2;\\n        return new TreeNode(*mid, build(s, mid), build(next(mid), e));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734065,
                "title": "python-easy-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\n        def inorder_t(root):\\n            \\n            if not root: return []\\n            \\n            return inorder_t(root.left)+[root.val]+inorder_t(root.right)\\n                \\n        inorder=inorder_t(root)\\n        \\n        def balance_tree(s,e):\\n            \\n            if s>e:\\n                return None\\n            \\n            mid=(s+e)//2\\n            root=TreeNode(inorder[mid])\\n            root.left=balance_tree(s,mid-1)\\n            root.right=balance_tree(mid+1,e)\\n                \\n            return root\\n            \\n        return balance_tree(0,len(inorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\n        def inorder_t(root):\\n            \\n            if not root: return []\\n            \\n            return inorder_t(root.left)+[root.val]+inorder_t(root.right)\\n                \\n        inorder=inorder_t(root)\\n        \\n        def balance_tree(s,e):\\n            \\n            if s>e:\\n                return None\\n            \\n            mid=(s+e)//2\\n            root=TreeNode(inorder[mid])\\n            root.left=balance_tree(s,mid-1)\\n            root.right=balance_tree(mid+1,e)\\n                \\n            return root\\n            \\n        return balance_tree(0,len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731554,
                "title": "c-easy-solution-inorder-traversal",
                "content": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    \\n    void makeArr(TreeNode* root){// make Inorder array //O(N) TC\\n        if(!root)\\n            return;\\n        makeArr(root->left);\\n        inOrder.push_back(root);\\n        makeArr(root->right);\\n    }\\n    \\n    TreeNode* reArrange(int a, int b){\\n        if(a>b)\\n            return NULL;\\n        int mid = (a+b)/2;\\n        TreeNode* top = inOrder[mid];\\n        top->left = reArrange(a, mid-1);\\n        top->right = reArrange(mid+1, b);\\n        return top;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inOrder = {};\\n        makeArr(root);\\n        return reArrange(0, (int)(inOrder.size()-1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    \\n    void makeArr(TreeNode* root){// make Inorder array //O(N) TC\\n        if(!root)\\n            return;\\n        makeArr(root->left);\\n        inOrder.push_back(root);\\n        makeArr(root->right);\\n    }\\n    \\n    TreeNode* reArrange(int a, int b){\\n        if(a>b)\\n            return NULL;\\n        int mid = (a+b)/2;\\n        TreeNode* top = inOrder[mid];\\n        top->left = reArrange(a, mid-1);\\n        top->right = reArrange(mid+1, b);\\n        return top;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inOrder = {};\\n        makeArr(root);\\n        return reArrange(0, (int)(inOrder.size()-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725734,
                "title": "best-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nImagine a list of sorted nodes, if we wanted to use the nodes to form a balanced BST, which root should we use?\\nYes, the one in the middle, since it can evenly spread two groups of nodes. This is what `getRoot()` does.\\nAnd we do the same for the left half and right half. And so on. And so on...\\n\\nTime: O(N), N is the number of nodes.\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def balanceBST(self, root):\\n        def getInorderNodes(root):\\n            nodes = []\\n            stack = []\\n            node = root\\n            \\n            while node or stack:\\n                while node:\\n                    stack.append(node)\\n                    node = node.left\\n                \\n                node = stack.pop()\\n                nodes.append(node)\\n                node = node.right\\n            \\n            return nodes\\n                \\n        def getRoot(l, r):\\n            if l>r: return None\\n            m = (l+r)/2\\n            root = inorderNodes[m]\\n            root.left = getRoot(l, m-1)\\n            root.right = getRoot(m+1, r)\\n            return root\\n            \\n        inorderNodes = getInorderNodes(root)\\n        return getRoot(0, len(inorderNodes)-1)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nImagine a list of sorted nodes, if we wanted to use the nodes to form a balanced BST, which root should we use?\\nYes, the one in the middle, since it can evenly spread two groups of nodes. This is what `getRoot()` does.\\nAnd we do the same for the left half and right half. And so on. And so on...\\n\\nTime: O(N), N is the number of nodes.\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def balanceBST(self, root):\\n        def getInorderNodes(root):\\n            nodes = []\\n            stack = []\\n            node = root\\n            \\n            while node or stack:\\n                while node:\\n                    stack.append(node)\\n                    node = node.left\\n                \\n                node = stack.pop()\\n                nodes.append(node)\\n                node = node.right\\n            \\n            return nodes\\n                \\n        def getRoot(l, r):\\n            if l>r: return None\\n            m = (l+r)/2\\n            root = inorderNodes[m]\\n            root.left = getRoot(l, m-1)\\n            root.right = getRoot(m+1, r)\\n            return root\\n            \\n        inorderNodes = getInorderNodes(root)\\n        return getRoot(0, len(inorderNodes)-1)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720230,
                "title": "java-dfs-sorted-array-to-bst",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n\\tList<Integer> inOrder = new ArrayList<>();\\n\\tinOrder(root, inOrder);\\n\\treturn buildTree(0, inOrder.size()-1, inOrder);\\n}\\n\\nTreeNode buildTree(int left, int right, List<Integer> inOrder) {\\n\\n\\tif (left > right)\\n\\t\\treturn null;\\n\\n\\tint middle = (left+right)/2;\\n\\tInteger val = inOrder.get(middle);\\n\\n\\tTreeNode n = new TreeNode(val);\\n\\tn.left = buildTree(left, middle-1, inOrder);\\n\\tn.right = buildTree(middle+1, right, inOrder);\\n\\n\\treturn n;\\n\\n}\\n\\nvoid inOrder(TreeNode node, List<Integer> inOrder) {\\n\\n\\tif (node == null)\\n\\t\\treturn;\\n\\n\\tinOrder(node.left, inOrder);\\n\\tinOrder.add(node.val);\\n\\tinOrder(node.right, inOrder);\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n\\tList<Integer> inOrder = new ArrayList<>();\\n\\tinOrder(root, inOrder);\\n\\treturn buildTree(0, inOrder.size()-1, inOrder);\\n}\\n\\nTreeNode buildTree(int left, int right, List<Integer> inOrder) {\\n\\n\\tif (left > right)\\n\\t\\treturn null;\\n\\n\\tint middle = (left+right)/2;\\n\\tInteger val = inOrder.get(middle);\\n\\n\\tTreeNode n = new TreeNode(val);\\n\\tn.left = buildTree(left, middle-1, inOrder);\\n\\tn.right = buildTree(middle+1, right, inOrder);\\n\\n\\treturn n;\\n\\n}\\n\\nvoid inOrder(TreeNode node, List<Integer> inOrder) {\\n\\n\\tif (node == null)\\n\\t\\treturn;\\n\\n\\tinOrder(node.left, inOrder);\\n\\tinOrder.add(node.val);\\n\\tinOrder(node.right, inOrder);\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714873,
                "title": "c-inorder-traversal",
                "content": "```\\nclass Solution {\\nprivate:\\n    TreeNode *build(vector <TreeNode *> &nodes, int start , int end){\\n        if(start > end) return NULL;\\n\\n        int mid = (start + end)/2;\\n\\n        TreeNode *root = nodes[mid];\\n\\n        root -> left = build(nodes, start, mid -1);\\n        root -> right = build(nodes, mid + 1, end);\\n\\n        return root;\\n    }\\nprivate:\\n    void storeNodes(TreeNode *root, vector <TreeNode*> &nodes){\\n        if(root == NULL) return ;\\n\\n        storeNodes(root -> left, nodes);\\n\\n        nodes.push_back(root);\\n\\n        storeNodes(root -> right, nodes);\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n\\n        vector <TreeNode *> nodes;\\n\\n        storeNodes(root, nodes);\\n\\n        return build(nodes, 0, nodes.size() -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode *build(vector <TreeNode *> &nodes, int start , int end){\\n        if(start > end) return NULL;\\n\\n        int mid = (start + end)/2;\\n\\n        TreeNode *root = nodes[mid];\\n\\n        root -> left = build(nodes, start, mid -1);\\n        root -> right = build(nodes, mid + 1, end);\\n\\n        return root;\\n    }\\nprivate:\\n    void storeNodes(TreeNode *root, vector <TreeNode*> &nodes){\\n        if(root == NULL) return ;\\n\\n        storeNodes(root -> left, nodes);\\n\\n        nodes.push_back(root);\\n\\n        storeNodes(root -> right, nodes);\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n\\n        vector <TreeNode *> nodes;\\n\\n        storeNodes(root, nodes);\\n\\n        return build(nodes, 0, nodes.size() -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708380,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n        inorder(root->left);\\n        v.push_back(root);\\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* helper(int start,int end){\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = v[mid];\\n        root -> left = helper(start,mid - 1);\\n        root -> right = helper(mid + 1,end);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return helper(0,v.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n        inorder(root->left);\\n        v.push_back(root);\\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* helper(int start,int end){\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = v[mid];\\n        root -> left = helper(start,mid - 1);\\n        root -> right = helper(mid + 1,end);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return helper(0,v.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646200,
                "title": "java-using-in-order-traversal-beat-100",
                "content": "```\\nclass Solution {\\n    private List<Integer> list;\\n    private void inorder(TreeNode root){\\n        if(root == null) return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);   \\n    }\\n    \\n    private TreeNode balance(int left, int right){\\n        if(right<left) return null;\\n        else{\\n            int mid = left + (right - left)/2;\\n            TreeNode temp = new TreeNode(list.get(mid));\\n            temp.left = balance(left,mid-1);\\n            temp.right = balance(mid+1,right);\\n            return temp;\\n        }\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        \\n        TreeNode temp = balance(0,list.size()-1);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<Integer> list;\\n    private void inorder(TreeNode root){\\n        if(root == null) return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);   \\n    }\\n    \\n    private TreeNode balance(int left, int right){\\n        if(right<left) return null;\\n        else{\\n            int mid = left + (right - left)/2;\\n            TreeNode temp = new TreeNode(list.get(mid));\\n            temp.left = balance(left,mid-1);\\n            temp.right = balance(mid+1,right);\\n            return temp;\\n        }\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        \\n        TreeNode temp = balance(0,list.size()-1);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609536,
                "title": "c-inorder-building-balanced-bst-with-sorted-list",
                "content": "Logic : Run inorder traversal first to get the sorted list of nodes and then build a balanced BST with that list.\\nFor building balanced BST just pick the middle element to make root and then recurse with left part to build left subtree and recurse right part to build right subtree.\\n\\n```\\nvoid inorderTrav(TreeNode* root, vector<TreeNode*>& arr) {\\n        if (root == nullptr)\\n            return;\\n        inorderTrav(root->left, arr);\\n        arr.push_back(root);\\n        inorderTrav(root->right, arr);\\n    }\\n    \\n    TreeNode* CreateNewTree(vector<TreeNode*>& arr, int start, int end) {\\n        if (start > end)\\n            return nullptr;\\n        int mid = start + (end-start)/2;\\n        TreeNode* root = arr[mid];\\n        root->left = CreateNewTree(arr, start, mid-1);\\n        root->right = CreateNewTree(arr, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> arr;\\n        inorderTrav(root, arr);\\n        return CreateNewTree(arr, 0, arr.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nvoid inorderTrav(TreeNode* root, vector<TreeNode*>& arr) {\\n        if (root == nullptr)\\n            return;\\n        inorderTrav(root->left, arr);\\n        arr.push_back(root);\\n        inorderTrav(root->right, arr);\\n    }\\n    \\n    TreeNode* CreateNewTree(vector<TreeNode*>& arr, int start, int end) {\\n        if (start > end)\\n            return nullptr;\\n        int mid = start + (end-start)/2;\\n        TreeNode* root = arr[mid];\\n        root->left = CreateNewTree(arr, start, mid-1);\\n        root->right = CreateNewTree(arr, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> arr;\\n        inorderTrav(root, arr);\\n        return CreateNewTree(arr, 0, arr.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587660,
                "title": "in-place-by-converting-to-doubly-linked-list-o-nlogn",
                "content": "Idea:\\n1. Convert binary tree to Doubly Linked List in place\\n2. Partition the Linked list into three parts based on the middle element\\n3. Recursively build the tree from the linked list partitions\\n\\nTime complexity\\n=> T(n) = 2T(n / 2) + O(n)\\n=> O(nlogn)\\n\\nSpace complexity\\n=> O(h) due to recursion stack space\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # Time: O(n), Space: O(h)\\n        def to_dll(root):\\n            if root is None:\\n                return None, None\\n            \\n            lhead, ltail = to_dll(root.left)\\n            rhead, rtail = to_dll(root.right)\\n            \\n            if ltail is not None:\\n                ltail.right = root\\n                root.left = ltail\\n                \\n            if rhead is not None:\\n                root.right = rhead\\n                rhead.left = root\\n                \\n            head = lhead\\n            if head is None:\\n                head = root\\n            tail = rtail\\n            if tail is None:\\n                tail = root\\n            return head, tail\\n        \\n        # Time: O(n), Space: O(1)\\n        def partition(head, tail):\\n            slow = head\\n            fast = head\\n            while fast and fast.right:\\n                slow = slow.right\\n                fast = fast.right.right\\n            return head, slow, tail\\n        \\n        # Time: O(nlogn), space: O(h)\\n        def balance(head, tail):\\n            if head == tail:\\n                return head\\n            \\n            head, slow, tail = partition(head, tail)\\n            if slow.left is not None:\\n                slow.left.right = None\\n                slow.left = balance(head, slow.left)\\n            if slow.right is not None:\\n                slow.right.left = None\\n                slow.right = balance(slow.right, tail)\\n            return slow\\n        \\n        head, tail = to_dll(root)\\n        return balance(head, tail)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # Time: O(n), Space: O(h)\\n        def to_dll(root):\\n            if root is None:\\n                return None, None\\n            \\n            lhead, ltail = to_dll(root.left)\\n            rhead, rtail = to_dll(root.right)\\n            \\n            if ltail is not None:\\n                ltail.right = root\\n                root.left = ltail\\n                \\n            if rhead is not None:\\n                root.right = rhead\\n                rhead.left = root\\n                \\n            head = lhead\\n            if head is None:\\n                head = root\\n            tail = rtail\\n            if tail is None:\\n                tail = root\\n            return head, tail\\n        \\n        # Time: O(n), Space: O(1)\\n        def partition(head, tail):\\n            slow = head\\n            fast = head\\n            while fast and fast.right:\\n                slow = slow.right\\n                fast = fast.right.right\\n            return head, slow, tail\\n        \\n        # Time: O(nlogn), space: O(h)\\n        def balance(head, tail):\\n            if head == tail:\\n                return head\\n            \\n            head, slow, tail = partition(head, tail)\\n            if slow.left is not None:\\n                slow.left.right = None\\n                slow.left = balance(head, slow.left)\\n            if slow.right is not None:\\n                slow.right.left = None\\n                slow.right = balance(slow.right, tail)\\n            return slow\\n        \\n        head, tail = to_dll(root)\\n        return balance(head, tail)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568338,
                "title": "java-short-and-simple-code-o-n-2ms-faster-than-99-78",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> al = new ArrayList<>();\\n        inorder(root, al);\\n        return BalancedBST(0, al.size()-1, al);\\n    }\\n    public void inorder(TreeNode node, ArrayList<TreeNode> al){\\n        if(node == null) return;\\n        inorder(node.left, al);\\n        al.add(node);\\n        inorder(node.right, al);\\n    }\\n    public TreeNode BalancedBST(int left, int right, ArrayList<TreeNode> al){\\n        if(right<left) return null;\\n        int x = (int)((left+right)/2);\\n        TreeNode node = new TreeNode(al.get(x).val);\\n        node.left = BalancedBST(left, x-1, al);\\n        node.right = BalancedBST(x+1, right, al);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> al = new ArrayList<>();\\n        inorder(root, al);\\n        return BalancedBST(0, al.size()-1, al);\\n    }\\n    public void inorder(TreeNode node, ArrayList<TreeNode> al){\\n        if(node == null) return;\\n        inorder(node.left, al);\\n        al.add(node);\\n        inorder(node.right, al);\\n    }\\n    public TreeNode BalancedBST(int left, int right, ArrayList<TreeNode> al){\\n        if(right<left) return null;\\n        int x = (int)((left+right)/2);\\n        TreeNode node = new TreeNode(al.get(x).val);\\n        node.left = BalancedBST(left, x-1, al);\\n        node.right = BalancedBST(x+1, right, al);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557903,
                "title": "functional-way-in-scala-i-wanna-know-a-way-using-tail-recursion-someone-let-me-know",
                "content": "I wanna change inorder function to tail recursion\\n```\\n  def main(args: Array[String]): Unit = {\\n    /*\\n             5\\n          3     6\\n        2   4     7\\n      1\\n    */\\n    val n = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), TreeNode(6, null, TreeNode(7)))\\n    assert(inorder(n) == List(1, 2, 3, 4, 5, 6, 7))\\n  }\\n\\n  def balanceBST(root: TreeNode): TreeNode = buildBST(inorder(root))\\n\\n\\n  /*\\n      1. mid of list is root node\\n      2. leftList is left subTree, rightList is right subTree\\n\\n      odd nums\\n      List(1, 2, 3) -> List(1) List(2, 3)\\n      even nums\\n      List(1, 2, 3, 4) -> List(1, 2) List(3, 4)\\n  */\\n  def buildBST(ns: List[Int]): TreeNode = {\\n    ns match {\\n      case Nil => null\\n      case _ => ns.splitAt(ns.size / 2) match {\\n        case (l, m :: r) => TreeNode(m, buildBST(l), buildBST(r))\\n        case _ => throw new UnsupportedOperationException()\\n      }\\n    }\\n  }\\n\\n  /*\\n      left -> root -> right\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    // @annotation.tailrec\\n    if (n == null) List()\\n    else inorder(n.left) ::: n.value :: inorder(n.right)\\n\\n\\n    /*\\n    def inorder(n: TreeNode, acc: List[Int]): List[Int] =\\n      if (n == null) return acc\\n      else inorder(n.left, n.value :: inorder(n.right, acc))\\n\\n    inorder(n, List())\\n    */\\n  }\\n```\\n\\n### Updated\\nI find out tail recursive solution with case class.\\nTail recursion should be linear traversal.\\nIt\\'s smiliar to a way with while loop (iterative)\\n```\\n   /*\\n      reverse inorder traversal ( right -> root -> left )\\n      because prepend element to list not append\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    @annotation.tailrec\\n    def inorder(stk: List[TreeNode], acc: List[Int]): List[Int] =\\n      stk match {\\n        case Nil => acc\\n        case h :: t =>\\n          h match {\\n            // go right\\n            case TreeNode(_, _, r) if r != null => inorder(r :: TreeNode(h.value, h.left, null) :: t, acc)\\n            // add value\\n            case TreeNode(v, null, null) => inorder(t, v :: acc)\\n            // add value and go left\\n            case TreeNode(v, l, null) => inorder(l :: t, v :: acc)\\n          }\\n      }\\n\\n    inorder(List(n), List())\\n    /*\\n      if (n == null) List()\\n      else inorder(n.left) ::: n.value :: inorder(n.right)\\n    */\\n  }\\n ```",
                "solutionTags": [],
                "code": "```\\n  def main(args: Array[String]): Unit = {\\n    /*\\n             5\\n          3     6\\n        2   4     7\\n      1\\n    */\\n    val n = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), TreeNode(6, null, TreeNode(7)))\\n    assert(inorder(n) == List(1, 2, 3, 4, 5, 6, 7))\\n  }\\n\\n  def balanceBST(root: TreeNode): TreeNode = buildBST(inorder(root))\\n\\n\\n  /*\\n      1. mid of list is root node\\n      2. leftList is left subTree, rightList is right subTree\\n\\n      odd nums\\n      List(1, 2, 3) -> List(1) List(2, 3)\\n      even nums\\n      List(1, 2, 3, 4) -> List(1, 2) List(3, 4)\\n  */\\n  def buildBST(ns: List[Int]): TreeNode = {\\n    ns match {\\n      case Nil => null\\n      case _ => ns.splitAt(ns.size / 2) match {\\n        case (l, m :: r) => TreeNode(m, buildBST(l), buildBST(r))\\n        case _ => throw new UnsupportedOperationException()\\n      }\\n    }\\n  }\\n\\n  /*\\n      left -> root -> right\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    // @annotation.tailrec\\n    if (n == null) List()\\n    else inorder(n.left) ::: n.value :: inorder(n.right)\\n\\n\\n    /*\\n    def inorder(n: TreeNode, acc: List[Int]): List[Int] =\\n      if (n == null) return acc\\n      else inorder(n.left, n.value :: inorder(n.right, acc))\\n\\n    inorder(n, List())\\n    */\\n  }\\n```\n```\\n   /*\\n      reverse inorder traversal ( right -> root -> left )\\n      because prepend element to list not append\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    @annotation.tailrec\\n    def inorder(stk: List[TreeNode], acc: List[Int]): List[Int] =\\n      stk match {\\n        case Nil => acc\\n        case h :: t =>\\n          h match {\\n            // go right\\n            case TreeNode(_, _, r) if r != null => inorder(r :: TreeNode(h.value, h.left, null) :: t, acc)\\n            // add value\\n            case TreeNode(v, null, null) => inorder(t, v :: acc)\\n            // add value and go left\\n            case TreeNode(v, l, null) => inorder(l :: t, v :: acc)\\n          }\\n      }\\n\\n    inorder(List(n), List())\\n    /*\\n      if (n == null) List()\\n      else inorder(n.left) ::: n.value :: inorder(n.right)\\n    */\\n  }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1548699,
                "title": "clean-code-c",
                "content": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    void inorderTraverse(TreeNode* root) {\\n        if( root == nullptr)\\n            return; \\n       inorderTraverse(root->left);\\n      \\n       inOrder.push_back(root);\\n       inorderTraverse(root->right); \\n       root->left = root->right = nullptr;\\n    }\\n    \\n    \\n    TreeNode* formBalancedBinaryTree(int start , int end) {\\n        if( start > end)\\n            return nullptr;\\n        else if(start == end)\\n            return inOrder[start];\\n        else {\\n            int mid = (start + end)/2;\\n            inOrder[mid]->left = formBalancedBinaryTree(start, mid-1);\\n            inOrder[mid]->right = formBalancedBinaryTree(mid+1, end);\\n            return inOrder[mid];\\n        }\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n      inorderTraverse(root); \\n      return formBalancedBinaryTree(0, inOrder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    void inorderTraverse(TreeNode* root) {\\n        if( root == nullptr)\\n            return; \\n       inorderTraverse(root->left);\\n      \\n       inOrder.push_back(root);\\n       inorderTraverse(root->right); \\n       root->left = root->right = nullptr;\\n    }\\n    \\n    \\n    TreeNode* formBalancedBinaryTree(int start , int end) {\\n        if( start > end)\\n            return nullptr;\\n        else if(start == end)\\n            return inOrder[start];\\n        else {\\n            int mid = (start + end)/2;\\n            inOrder[mid]->left = formBalancedBinaryTree(start, mid-1);\\n            inOrder[mid]->right = formBalancedBinaryTree(mid+1, end);\\n            return inOrder[mid];\\n        }\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n      inorderTraverse(root); \\n      return formBalancedBinaryTree(0, inOrder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539052,
                "title": "python3-easy-to-understand",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tinorder = []\\n\\n\\t# Convert the tree to a sorted array \\n\\t# using an in-order traversal.\\n\\tdef dfs(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\n\\t\\tdfs(root.left)\\n\\t\\tinorder.append(root.val)\\n\\t\\tdfs(root.right)\\n\\n\\t# Construct a new balanced tree \\n\\t# from the sorted array recursively.\\n\\tdef constructBST(array):\\n\\t\\tif not array:\\n\\t\\t\\treturn None\\n\\t\\tmid = len(array) // 2\\n\\t\\troot = TreeNode(array[mid])\\n\\t\\troot.left = constructBST(array[:mid])\\n\\t\\troot.right = constructBST(array[mid+1:])\\n\\t\\treturn root\\n\\n\\tdfs(root)\\n\\treturn constructBST(inorder)\\n```",
                "solutionTags": [],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tinorder = []\\n\\n\\t# Convert the tree to a sorted array \\n\\t# using an in-order traversal.\\n\\tdef dfs(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\n\\t\\tdfs(root.left)\\n\\t\\tinorder.append(root.val)\\n\\t\\tdfs(root.right)\\n\\n\\t# Construct a new balanced tree \\n\\t# from the sorted array recursively.\\n\\tdef constructBST(array):\\n\\t\\tif not array:\\n\\t\\t\\treturn None\\n\\t\\tmid = len(array) // 2\\n\\t\\troot = TreeNode(array[mid])\\n\\t\\troot.left = constructBST(array[:mid])\\n\\t\\troot.right = constructBST(array[mid+1:])\\n\\t\\treturn root\\n\\n\\tdfs(root)\\n\\treturn constructBST(inorder)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530702,
                "title": "python3-time-o-n-space-o-n",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # [1] => [1]\\n        # [1,2] => [1,2]\\n        # [1,null,2,3] => [2,1,3]\\n        \\n        # Traverse in-order and store node values\\n        # create BST \\n        # Time: O(n)\\n        # Space: O(n)\\n        \\n        arr = []\\n        def createValuesArr(root):\\n            if not root:\\n                return\\n            createValuesArr(root.left)\\n            arr.append(root.val)\\n            createValuesArr(root.right)\\n            \\n        createValuesArr(root)\\n        \\n        def createBST(arr):\\n            if len(arr) == 0:\\n                return\\n            if len(arr) == 1:\\n                return TreeNode(arr[0])\\n            mid = (len(arr) - 1) // 2\\n\\n            node = TreeNode(arr[mid])\\n            node.left = createBST(arr[:mid])\\n            node.right = createBST(arr[mid+1:])\\n            return node\\n\\n        ans = createBST(arr)\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/29e6011e-bbc6-42e9-ac8a-f690d889a776_1634699880.074155.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # [1] => [1]\\n        # [1,2] => [1,2]\\n        # [1,null,2,3] => [2,1,3]\\n        \\n        # Traverse in-order and store node values\\n        # create BST \\n        # Time: O(n)\\n        # Space: O(n)\\n        \\n        arr = []\\n        def createValuesArr(root):\\n            if not root:\\n                return\\n            createValuesArr(root.left)\\n            arr.append(root.val)\\n            createValuesArr(root.right)\\n            \\n        createValuesArr(root)\\n        \\n        def createBST(arr):\\n            if len(arr) == 0:\\n                return\\n            if len(arr) == 1:\\n                return TreeNode(arr[0])\\n            mid = (len(arr) - 1) // 2\\n\\n            node = TreeNode(arr[mid])\\n            node.left = createBST(arr[:mid])\\n            node.right = createBST(arr[mid+1:])\\n            return node\\n\\n        ans = createBST(arr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530538,
                "title": "java-iterate-all-nodes-then-build-bst-coolkid",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // first iterate to get all values\\n        // then create BST\\n        List<Integer> lis = new ArrayList<>();\\n        inOrder(root,lis);\\n        return createBST(lis,0,lis.size()-1);\\n    }\\n    \\n    private void inOrder(TreeNode root,List<Integer> lis) {\\n        if(root!=null) {\\n            inOrder(root.left,lis);\\n            lis.add(root.val);\\n            inOrder(root.right,lis);\\n        }\\n    }\\n    \\n    private TreeNode createBST(List<Integer> lis, int start,int end) {\\n        if(start>end){\\n            return null;\\n        }\\n        int mid = (start + end)/2;\\n        TreeNode root = new TreeNode(lis.get(mid));\\n        root.left = createBST(lis,start,mid-1);\\n        root.right = createBST(lis,mid+1,end);\\n        return root;\\n    }\\n}\\n```\\nnot sure this is the best solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // first iterate to get all values\\n        // then create BST\\n        List<Integer> lis = new ArrayList<>();\\n        inOrder(root,lis);\\n        return createBST(lis,0,lis.size()-1);\\n    }\\n    \\n    private void inOrder(TreeNode root,List<Integer> lis) {\\n        if(root!=null) {\\n            inOrder(root.left,lis);\\n            lis.add(root.val);\\n            inOrder(root.right,lis);\\n        }\\n    }\\n    \\n    private TreeNode createBST(List<Integer> lis, int start,int end) {\\n        if(start>end){\\n            return null;\\n        }\\n        int mid = (start + end)/2;\\n        TreeNode root = new TreeNode(lis.get(mid));\\n        root.left = createBST(lis,start,mid-1);\\n        root.right = createBST(lis,mid+1,end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523960,
                "title": "simple-and-made-easy-approach-java",
                "content": "```\\nclass Solution {\\n    \\n    List<TreeNode> list = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        buildSortedArray(root);\\n        return constructBalBST(0,list.size()-1);\\n        \\n    }\\n    \\n    \\n    public void buildSortedArray(TreeNode root){\\n        if(root==null) return;\\n        buildSortedArray(root.left);\\n        list.add(root);\\n        buildSortedArray(root.right);\\n        \\n    }\\n    \\n    public TreeNode constructBalBST(int start, int end){\\n        if(start>end) return null;\\n        int mid = start + (end - start) / 2;\\n        TreeNode root = list.get(mid);\\n        root.left = constructBalBST(start, mid-1);\\n        root.right = constructBalBST(mid+1, end);    \\n        return root;\\n    } \\n    \\n}\\n```\\n\\n\\n-> s =0 ,e= 2 mid =1 , root = Node(2)\\n                                rL = s=0 end=0 Node(1)\\n                                               rLL = s=0 e=-1 = null \\n                                rR = s=2 e =2 Node(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  rRR = 3,end 2 = null\\n\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<TreeNode> list = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        buildSortedArray(root);\\n        return constructBalBST(0,list.size()-1);\\n        \\n    }\\n    \\n    \\n    public void buildSortedArray(TreeNode root){\\n        if(root==null) return;\\n        buildSortedArray(root.left);\\n        list.add(root);\\n        buildSortedArray(root.right);\\n        \\n    }\\n    \\n    public TreeNode constructBalBST(int start, int end){\\n        if(start>end) return null;\\n        int mid = start + (end - start) / 2;\\n        TreeNode root = list.get(mid);\\n        root.left = constructBalBST(start, mid-1);\\n        root.right = constructBalBST(mid+1, end);    \\n        return root;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576586,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568295,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1570366,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1934947,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1906089,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1906088,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1574823,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1976463,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]