[
    {
        "title": "Largest Triangle Area",
        "question_content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted.\n&nbsp;\nExample 1:\n\nInput: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\nOutput: 2.00000\nExplanation: The five points are shown in the above figure. The red triangle is the largest.\n\nExample 2:\n\nInput: points = [[1,0],[0,0],[0,1]]\nOutput: 0.50000\n\n&nbsp;\nConstraints:\n\n\t3 <= points.length <= 50\n\t-50 <= xi, yi <= 50\n\tAll the given points are unique.",
        "solutions": [
            {
                "id": 122711,
                "title": "c-java-python-solution-with-explanation-and-prove",
                "content": "**Explanaiton**\\nBurete force loop on all combinations of three points and calculate the area of these three points.\\nIf you google \"three pointes triangle area formula\", you can find the answer with the first result in second.\\n\\n**Time complexity**\\n```O(N^3)``` solution, but ```N <= 50```, so it\\'s fast enough.\\nYou may find convex hull first as @weidairpi replies. It help improve to O(M^3 + NlogN) in the best case where M is the number of points on the hull. \\nBut it make this easy problem complex and it stays same complexity in the worst case.\\n\\n**Prove 1**\\nWell, someone complains the situation without any formula.\\nIn fact the formula is not that difficult to find out.\\n\\nFor this case:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523209147.png)\\n\\nWe can calculate the area as follow:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523379988.png)\\n\\n\\nIn the result A,B,C are symmetrical, so it won\\'t matter what order we name it.\\nIn this case, we calculate the total area by addition three triangle.\\nIn the other cases, you may need to use substraction and it\\'s quite the same process.\\n\\n**Prove 2**\\nIf you are familar with vector product. The result is quite obvious.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1523380000.png)\\n\\n\\n**C++:**\\n```\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public double largestTriangleArea(int[][] p) {\\n        double res = 0;\\n        for (int[] i: p)\\n            for (int[] j: p)\\n                for (int[] k: p)\\n            res = Math.max(res, 0.5 * Math.abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\\n\\n**1-line Python**\\n```\\ndef largestTriangleArea(self, p):\\n        return max(0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1])\\n            for i, j, k in itertools.combinations(p, 3))\\n```",
                "solutionTags": [],
                "code": "```O(N^3)```\n```N <= 50```\n```\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\n```\\n    public double largestTriangleArea(int[][] p) {\\n        double res = 0;\\n        for (int[] i: p)\\n            for (int[] j: p)\\n                for (int[] k: p)\\n            res = Math.max(res, 0.5 * Math.abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n```\n```\\ndef largestTriangleArea(self, p):\\n        return max(0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1])\\n            for i, j, k in itertools.combinations(p, 3))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 124010,
                "title": "simple-java-easy-understand",
                "content": "How to pick all combinaitons from an array that consist of 3 points - \\nhttps://www.geeksforgeeks.org/print-all-possible-combinations-of-r-elements-in-a-given-array-of-size-n/\\n\\nHow to calculate the triangle area knowing the coordinates of the 3 points? \\nhttps://www.mathopenref.com/coordtrianglearea.html\\n\\n\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max = 0.0; \\n        for (int i = 0; i < points.length - 2; i++) \\n            for (int j = i + 1; j < points.length - 1; j++) \\n                for (int k = j + 1; k < points.length; k++) \\n                    max = Math.max(max, areaCal(points[i], points[j], points[k])); \\n        return max; \\n    }\\n    \\n    public double areaCal(int[] pt1, int[] pt2, int[] pt3) {\\n        return Math.abs(pt1[0] * (pt2[1] - pt3[1]) + pt2[0] * (pt3[1] - pt1[1]) + pt3[0] * (pt1[1] - pt2[1])) / 2.0; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max = 0.0; \\n        for (int i = 0; i < points.length - 2; i++) \\n            for (int j = i + 1; j < points.length - 1; j++) \\n                for (int k = j + 1; k < points.length; k++) \\n                    max = Math.max(max, areaCal(points[i], points[j], points[k])); \\n        return max; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1585033,
                "title": "python-faster-than-93-simple-maths-with-explanation",
                "content": "I used my highschool determinants formula of area of a triangle\\n if coordinates are given\\n        1/2(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n  Explanation link:    https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346989,
                "title": "c-brute-force-herone-s-formulae",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\n//812. Largest Triangle Area (Using brute force)\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& points) {\\n        int n=points.size();\\n        double maxArea=0;\\n             double d1,d2,d3,area,s;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n        d1=sqrt((double)pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));    \\n        d2=sqrt((double)pow(points[j][0]-points[k][0],2)+pow(points[j][1]-points[k][1],2));\\n        d3=sqrt((double)pow(points[i][0]-points[k][0],2)+pow(points[i][1]-points[k][1],2));\\n        s=(d1+d2+d3)/2.00000;\\n        area=(double)sqrt(s*(s-d1)*(s-d2)*(s-d3));\\n                    \\n                    if(maxArea<area)\\n                     maxArea=area;   \\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//812. Largest Triangle Area (Using brute force)\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& points) {\\n        int n=points.size();\\n        double maxArea=0;\\n             double d1,d2,d3,area,s;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n        d1=sqrt((double)pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));    \\n        d2=sqrt((double)pow(points[j][0]-points[k][0],2)+pow(points[j][1]-points[k][1],2));\\n        d3=sqrt((double)pow(points[i][0]-points[k][0],2)+pow(points[i][1]-points[k][1],2));\\n        s=(d1+d2+d3)/2.00000;\\n        area=(double)sqrt(s*(s-d1)*(s-d2)*(s-d3));\\n                    \\n                    if(maxArea<area)\\n                     maxArea=area;   \\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182897,
                "title": "easy-java-solution-beats-99-77",
                "content": "Just need to recall a formula to calculate a right trapezoid area (no angles or vectors math).\\n\\nEach triangle\\'s side forms a trapezoid with its projection on to Y=Ymin line:\\n![image](https://assets.leetcode.com/users/kirj/image_1539852429.png)\\nThen the triangle area can be calculated as a sum of 3 trapezoids area formed by the triangle sides:\\n\\nResult area = | A1 + A2 + A3 |, where \\nA1 = (X2 - X1) * ((Y2 - Ymin + Y1 - Ymin) / 2) \\nA2 = (X3 - X2) * ((Y3 - Ymin + Y2 - Ymin) / 2) \\nA3 = (X1 - X3) * ((Y1 - Ymin + Y3 - Ymin) / 2) \\n\\nThe order of the Xi coordinates is important here and it\\'s expected for some Ai to be negative. We deduct Ymin to ensure that the Y part is always positive.\\n\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max = 0;\\n        \\n        for (int i = 0; i < n; ++i) \\n            for (int j = i + 1; j < n; ++j)\\n                for (int k = j + 1; k < n; ++k) {\\n                    double area = area(points, i, j, k);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n        \\n        \\n        return max;\\n    }\\n    \\n    // triangle\\n    double area(int[][] points, int i, int j, int k) {\\n        int[] p1 = points[i];\\n        int[] p2 = points[j];\\n        int[] p3 = points[k];\\n        \\n        double area = 0;\\n        area += area(p1, p2);\\n        area += area(p2, p3);\\n        area += area(p3, p1);\\n        \\n        return Math.abs(area);\\n    }\\n    \\n    // right trapezoid\\n    double area(int[] p1, int[] p2) {\\n        int w = p2[0] - p1[0];\\n        double h = (p1[1] + p2[1] + 200) / 2.0;\\n        return w * h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max = 0;\\n        \\n        for (int i = 0; i < n; ++i) \\n            for (int j = i + 1; j < n; ++j)\\n                for (int k = j + 1; k < n; ++k) {\\n                    double area = area(points, i, j, k);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n        \\n        \\n        return max;\\n    }\\n    \\n    // triangle\\n    double area(int[][] points, int i, int j, int k) {\\n        int[] p1 = points[i];\\n        int[] p2 = points[j];\\n        int[] p3 = points[k];\\n        \\n        double area = 0;\\n        area += area(p1, p2);\\n        area += area(p2, p3);\\n        area += area(p3, p1);\\n        \\n        return Math.abs(area);\\n    }\\n    \\n    // right trapezoid\\n    double area(int[] p1, int[] p2) {\\n        int w = p2[0] - p1[0];\\n        double h = (p1[1] + p2[1] + 200) / 2.0;\\n        return w * h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179046,
                "title": "c",
                "content": "\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662FGraham\\u626B\\u63CF\\u6CD5\\uFF0C\\u5C06`int[]`\\u8868\\u793A\\u7684\\u70B9\\u5C01\\u88C5\\u6210\\u4E86`Vector3`\\uFF0C\\u5E76\\u5B9E\\u73B0\\u4E86\\u53C9\\u4E58\\u7B49\\u5E38\\u7528\\u65B9\\u6CD5\\u65B9\\u4FBF\\u8BA1\\u7B97\\u3002\\u867D\\u7136\\u66B4\\u529B\\u6CD5\\u53EF\\u4EE5\\u901A\\u8FC7\\uFF0C\\u4F46\\u662F\\u901A\\u8FC7\\u4F18\\u5316\\u53EF\\u4EE5\\u5B66\\u4E60\\u66F4\\u591A\\u65B0\\u7684\\u77E5\\u8BC6\\u548C\\u6280\\u672F\\uFF0C\\u63D0\\u9AD8\\u81EA\\u5DF1\\u89E3\\u51B3\\u95EE\\u9898\\u7684\\u80FD\\u529B\\uFF0C\\u4E0D\\u8981\\u4E3A\\u4E86\\u505A\\u9898\\u800C\\u505A\\u9898\\uFF01\\n```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        double maxArea = -1;\\n        points = Graham(points);\\n        // foreach(var p in resultArray) {\\n        //     Console.WriteLine(\"x:{0}, y:{1}\", p[0], p[1]);\\n        // }\\n        for (int i = 0; i < points.Length; i++) {\\n            for (int j = 0; j < points.Length; j++) {\\n                for (int k = 0; k < points.Length; k++) {\\n                    if (i != j && j != k && i != k) {\\n                        double area = GetTriArea(points[i],points[j],points[k]);\\n                        if (area > maxArea) {\\n                            maxArea = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int[][] Graham(int[][] pointsArray) {\\n        List<Vector3> points = new List<Vector3>(pointsArray.Length);\\n        foreach(var p in pointsArray) {\\n            points.Add(new Vector3(p));\\n        }\\n        List<Vector3> result = new List<Vector3>();\\n        for(int i = 0; i < points.Count; i++)\\n        {\\n            //grab the bottom-right point and move it to the head of the list\\n            if (points[i].z < points[0].z || points[i].z == points[0].z && points[i].x > points[0].x)\\n            {\\n                Vector3 temp = points[i];\\n                points[i] = points[0];\\n                points[0] = temp;\\n            }\\n        }\\n        //\\u6839\\u636E\\u6781\\u89D2\\u7531\\u5C0F\\u5230\\u5927\\u6392\\u5E8F\\n        PolarAngleComparer comparer = new PolarAngleComparer(points[0]);\\n        points.Sort(1, points.Count - 1, comparer);\\n        Stack<Vector3> s = new Stack<Vector3>();\\n        s.Push(points[0]);\\n        s.Push(points[1]);\\n        int index = 2;\\n        while (index < points.Count)\\n        {\\n            Vector3 lastPoint = s.Pop();\\n            Vector3 lastSecondPoint = s.Peek();\\n            s.Push(lastPoint);\\n            Vector3 curPoint = points[index];\\n            Vector3 p1 = lastPoint - lastSecondPoint;\\n            Vector3 p2 = curPoint - lastPoint;\\n            Vector3 cross = Vector3.Cross(p1, p2);\\n            //\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662F\\u5DE6\\u624B\\u5750\\u6807\\u7CFB\\n            if (cross.y < 0)    //\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Push(curPoint);\\n                index++;\\n            }\\n            else if (cross.y == 0) //\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\uFF0C\\u9009\\u53D6\\u79BB\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\u70B9\\u8F83\\u8FDC\\u7684\\u70B9\\n            {\\n                double dis1 = Vector3.Distance(lastPoint, lastSecondPoint);\\n                double dis2 = Vector3.Distance(curPoint, lastSecondPoint);\\n                if (dis2 > dis1)\\n                {\\n                    s.Pop();\\n                    s.Push(curPoint);\\n                }\\n                index++;\\n            }\\n            else                //\\u4E0D\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Pop();\\n            }\\n        }\\n        while (s.Count > 0)\\n        {\\n            result.Add(s.Pop());\\n        }\\n        int[][] resultArray = new int[result.Count][];\\n        for (int i = 0; i < result.Count; i++) {\\n            resultArray[i] = new int[2]{(int)result[i].x, (int)result[i].z};\\n        }\\n        return resultArray;\\n    }\\n    private double GetTriArea(int[] a, int[] b, int[] c)\\n    {\\n        //\\u53C9\\u4E58\\u8BA1\\u7B97\\u4E09\\u89D2\\u5F62\\u9762\\u79EF\\n        return (0.5 * Math.Abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1]- b[0] * a[1] - c[0] * b[1] - a[0] * c[1]));\\n    }\\n}\\n//\\u5750\\u6807\\u70B9\\u7ED3\\u6784\\u4F53\\u5C01\\u88C5\\npublic struct Vector3 {\\n    public double x;\\n    public double y;\\n    public double z;\\n    public Vector3(double x, double y, double z)\\n    {\\n        this.x = x;\\n        this.y = y;\\n        this.z = z;\\n    }\\n    public Vector3(int[] pointArray)\\n    {\\n        x = pointArray[0];\\n        y = 0;\\n        z = pointArray[1];\\n    }\\n    public static Vector3 zero => new Vector3(0,0,0);\\n    public static Vector3 right => new Vector3(1, 0, 0);\\n    public Vector3 normalized => Normalize(this);\\n    public static Vector3 Cross(Vector3 lhs, Vector3 rhs) \\n    {\\n        return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);\\n    }\\n    public static double Distance(Vector3 a, Vector3 b)\\n    {\\n        Vector3 vector = new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n        return Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\\n    }\\n    public static double Dot(Vector3 lhs, Vector3 rhs)\\n    {\\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\\n    }\\n    public static Vector3 Normalize(Vector3 value)\\n    {\\n        double num = Magnitude(value);\\n        if (num > 1E-05f)\\n        {\\n            return value / num;\\n        }\\n        return zero;\\n    }\\n    public static double Magnitude(Vector3 a)\\n    {\\n    \\treturn Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\\n    }\\n    public static Vector3 operator +(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a)\\n    {\\n    \\treturn new Vector3(0f - a.x, 0f - a.y, 0f - a.z);\\n    }\\n\\n    public static Vector3 operator *(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator *(float d, Vector3 a)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator /(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x / d, a.y / d, a.z / d);\\n    }\\n}\\n//\\u6781\\u89D2\\u6392\\u5E8F\\u5668\\npublic class PolarAngleComparer : IComparer<Vector3>\\n{\\n    public Vector3 basePoint = Vector3.zero;\\n    public PolarAngleComparer(Vector3 basePoint)\\n    {\\n        this.basePoint = basePoint;\\n    }\\n    public int Compare(Vector3 x, Vector3 y)\\n    {\\n        Vector3 v1 = x - basePoint;\\n        Vector3 v2 = y - basePoint;\\n        double cos1 = Vector3.Dot(v1.normalized, Vector3.right);\\n        double cos2 = Vector3.Dot(v2.normalized, Vector3.right);\\n        return cos1 < cos2 ? 1 : cos1 > cos2 ? -1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        double maxArea = -1;\\n        points = Graham(points);\\n        // foreach(var p in resultArray) {\\n        //     Console.WriteLine(\"x:{0}, y:{1}\", p[0], p[1]);\\n        // }\\n        for (int i = 0; i < points.Length; i++) {\\n            for (int j = 0; j < points.Length; j++) {\\n                for (int k = 0; k < points.Length; k++) {\\n                    if (i != j && j != k && i != k) {\\n                        double area = GetTriArea(points[i],points[j],points[k]);\\n                        if (area > maxArea) {\\n                            maxArea = area;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int[][] Graham(int[][] pointsArray) {\\n        List<Vector3> points = new List<Vector3>(pointsArray.Length);\\n        foreach(var p in pointsArray) {\\n            points.Add(new Vector3(p));\\n        }\\n        List<Vector3> result = new List<Vector3>();\\n        for(int i = 0; i < points.Count; i++)\\n        {\\n            //grab the bottom-right point and move it to the head of the list\\n            if (points[i].z < points[0].z || points[i].z == points[0].z && points[i].x > points[0].x)\\n            {\\n                Vector3 temp = points[i];\\n                points[i] = points[0];\\n                points[0] = temp;\\n            }\\n        }\\n        //\\u6839\\u636E\\u6781\\u89D2\\u7531\\u5C0F\\u5230\\u5927\\u6392\\u5E8F\\n        PolarAngleComparer comparer = new PolarAngleComparer(points[0]);\\n        points.Sort(1, points.Count - 1, comparer);\\n        Stack<Vector3> s = new Stack<Vector3>();\\n        s.Push(points[0]);\\n        s.Push(points[1]);\\n        int index = 2;\\n        while (index < points.Count)\\n        {\\n            Vector3 lastPoint = s.Pop();\\n            Vector3 lastSecondPoint = s.Peek();\\n            s.Push(lastPoint);\\n            Vector3 curPoint = points[index];\\n            Vector3 p1 = lastPoint - lastSecondPoint;\\n            Vector3 p2 = curPoint - lastPoint;\\n            Vector3 cross = Vector3.Cross(p1, p2);\\n            //\\u8FD9\\u91CC\\u4F7F\\u7528\\u7684\\u662F\\u5DE6\\u624B\\u5750\\u6807\\u7CFB\\n            if (cross.y < 0)    //\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Push(curPoint);\\n                index++;\\n            }\\n            else if (cross.y == 0) //\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\uFF0C\\u9009\\u53D6\\u79BB\\u5012\\u6570\\u7B2C\\u4E8C\\u4E2A\\u70B9\\u8F83\\u8FDC\\u7684\\u70B9\\n            {\\n                double dis1 = Vector3.Distance(lastPoint, lastSecondPoint);\\n                double dis2 = Vector3.Distance(curPoint, lastSecondPoint);\\n                if (dis2 > dis1)\\n                {\\n                    s.Pop();\\n                    s.Push(curPoint);\\n                }\\n                index++;\\n            }\\n            else                //\\u4E0D\\u662F\\u51F8\\u5305\\u4E0A\\u7684\\u70B9\\n            {\\n                s.Pop();\\n            }\\n        }\\n        while (s.Count > 0)\\n        {\\n            result.Add(s.Pop());\\n        }\\n        int[][] resultArray = new int[result.Count][];\\n        for (int i = 0; i < result.Count; i++) {\\n            resultArray[i] = new int[2]{(int)result[i].x, (int)result[i].z};\\n        }\\n        return resultArray;\\n    }\\n    private double GetTriArea(int[] a, int[] b, int[] c)\\n    {\\n        //\\u53C9\\u4E58\\u8BA1\\u7B97\\u4E09\\u89D2\\u5F62\\u9762\\u79EF\\n        return (0.5 * Math.Abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1]- b[0] * a[1] - c[0] * b[1] - a[0] * c[1]));\\n    }\\n}\\n//\\u5750\\u6807\\u70B9\\u7ED3\\u6784\\u4F53\\u5C01\\u88C5\\npublic struct Vector3 {\\n    public double x;\\n    public double y;\\n    public double z;\\n    public Vector3(double x, double y, double z)\\n    {\\n        this.x = x;\\n        this.y = y;\\n        this.z = z;\\n    }\\n    public Vector3(int[] pointArray)\\n    {\\n        x = pointArray[0];\\n        y = 0;\\n        z = pointArray[1];\\n    }\\n    public static Vector3 zero => new Vector3(0,0,0);\\n    public static Vector3 right => new Vector3(1, 0, 0);\\n    public Vector3 normalized => Normalize(this);\\n    public static Vector3 Cross(Vector3 lhs, Vector3 rhs) \\n    {\\n        return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);\\n    }\\n    public static double Distance(Vector3 a, Vector3 b)\\n    {\\n        Vector3 vector = new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n        return Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\\n    }\\n    public static double Dot(Vector3 lhs, Vector3 rhs)\\n    {\\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\\n    }\\n    public static Vector3 Normalize(Vector3 value)\\n    {\\n        double num = Magnitude(value);\\n        if (num > 1E-05f)\\n        {\\n            return value / num;\\n        }\\n        return zero;\\n    }\\n    public static double Magnitude(Vector3 a)\\n    {\\n    \\treturn Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\\n    }\\n    public static Vector3 operator +(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a, Vector3 b)\\n    {\\n    \\treturn new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\\n    }\\n\\n    public static Vector3 operator -(Vector3 a)\\n    {\\n    \\treturn new Vector3(0f - a.x, 0f - a.y, 0f - a.z);\\n    }\\n\\n    public static Vector3 operator *(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator *(float d, Vector3 a)\\n    {\\n    \\treturn new Vector3(a.x * d, a.y * d, a.z * d);\\n    }\\n\\n    public static Vector3 operator /(Vector3 a, double d)\\n    {\\n    \\treturn new Vector3(a.x / d, a.y / d, a.z / d);\\n    }\\n}\\n//\\u6781\\u89D2\\u6392\\u5E8F\\u5668\\npublic class PolarAngleComparer : IComparer<Vector3>\\n{\\n    public Vector3 basePoint = Vector3.zero;\\n    public PolarAngleComparer(Vector3 basePoint)\\n    {\\n        this.basePoint = basePoint;\\n    }\\n    public int Compare(Vector3 x, Vector3 y)\\n    {\\n        Vector3 v1 = x - basePoint;\\n        Vector3 v2 = y - basePoint;\\n        double cos1 = Vector3.Dot(v1.normalized, Vector3.right);\\n        double cos2 = Vector3.Dot(v2.normalized, Vector3.right);\\n        return cos1 < cos2 ? 1 : cos1 > cos2 ? -1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333629,
                "title": "two-solutions-in-python-3-shoelace-method-and-heron-s-formula",
                "content": "_Shoelace Method:_\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Shoelace(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Shoelace(a,b,c):\\n\\treturn abs(a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-(a[0]*c[1]+c[0]*b[1]+b[0]*a[1]))/2\\n\\t\\n\\n```\\n_Heron\\'s Formula:_\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Heron(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Heron(r,s,t):\\n\\ta, b, c = math.hypot(r[0]-s[0],r[1]-s[1]), math.hypot(r[0]-t[0],r[1]-t[1]), math.hypot(s[0]-t[0],s[1]-t[1])\\n\\ts = (a + b + c)/2\\n\\treturn (max(0,s*(s-a)*(s-b)*(s-c)))**.5\\n\\n\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        L, A = len(p), 0\\n        for i in range(L-2):\\n        \\tfor j in range(i+1,L-1):\\n        \\t\\tfor k in range(j+1,L):\\n        \\t\\t\\tR = Area_Shoelace(p[i],p[j],p[k])\\n        \\t\\t\\tA = max(A,R)\\n        return A\\n\\ndef Area_Shoelace(a,b,c):\\n\\treturn abs(a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-(a[0]*c[1]+c[0]*b[1]+b[0]*a[1]))/2\\n\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283662,
                "title": "simple-c-solution-using-heron-s-formula",
                "content": "https://www.cuemath.com/herons-formula/\\nRefer the above link to know about Heron\\'s Formula.\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        for(int i=0;i<points.size();++i){\\n           for(int j=i+1;j<points.size();++j){\\n               for(int k=j+1;k<points.size();++k){\\n                   double a=points[i][0];\\n                   double b=points[i][1];\\n                   double c=points[j][0];\\n                   double d=points[j][1];\\n                   double e=points[k][0];\\n                   double f=points[k][1];\\n                   double distance1=sqrt((a-c)*(a-c)+(b-d)*(b-d));\\n                   double distance2=sqrt((a-e)*(a-e)+(b-f)*(b-f));\\n                   double distance3=sqrt((c-e)*(c-e)+(d-f)*(d-f));\\n                   double s=(distance1+distance2+distance3)/2;\\n                   double area=sqrt(s*(s-distance1)*(s-distance2)*(s-distance3));\\n                   ans=max(ans,area);\\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        for(int i=0;i<points.size();++i){\\n           for(int j=i+1;j<points.size();++j){\\n               for(int k=j+1;k<points.size();++k){\\n                   double a=points[i][0];\\n                   double b=points[i][1];\\n                   double c=points[j][0];\\n                   double d=points[j][1];\\n                   double e=points[k][0];\\n                   double f=points[k][1];\\n                   double distance1=sqrt((a-c)*(a-c)+(b-d)*(b-d));\\n                   double distance2=sqrt((a-e)*(a-e)+(b-f)*(b-f));\\n                   double distance3=sqrt((c-e)*(c-e)+(d-f)*(d-f));\\n                   double s=(distance1+distance2+distance3)/2;\\n                   double area=sqrt(s*(s-distance1)*(s-distance2)*(s-distance3));\\n                   ans=max(ans,area);\\n               }\\n           } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210808,
                "title": "beats-100-of-java-sol-3ms-brute-force-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Calculate area of each data points and return the data points having maximum area.\\n- To Calculate the area of a triangle having vertices as *(x1,y1), (x2,y2) and (x3,y3)* we use the formula:\\n$$S=[x1(y2\\u2212y3)+x2(y3\\u2212y1)+x3(y1\\u2212y2)]/2$$\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }\\n    public static double area(int[] x1, int[] x2, int[] x3)\\n    {\\n        int t1 = x1[0] * ( x2[1] - x3[1]);\\n        int t2 = x2[0] * ( x3[1] - x1[1]);\\n        int t3 = x3[0] * ( x1[1] - x2[1]);\\n        return (double)( t1 + t2 + t3 )/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }\\n    public static double area(int[] x1, int[] x2, int[] x3)\\n    {\\n        int t1 = x1[0] * ( x2[1] - x3[1]);\\n        int t2 = x2[0] * ( x3[1] - x1[1]);\\n        int t3 = x3[0] * ( x1[1] - x2[1]);\\n        return (double)( t1 + t2 + t3 )/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847965,
                "title": "convex-hull-reduction-fast-c",
                "content": "If we are trying to find the largest triangle given some set of points, considering every set of 3 points gives **O(n^3)** triangles to consider.\\nIf we notice that any maximal triangle has points which lie on the convex hull (wrap an elastic band around all the points, the points that touch the elastic are on the convex hull) then we can substantially reduce the size of the problem and hence the overall time complexity by performing an **O(nlog(n))** operation.\\nIn the worst case, we are still **O(n^3)** however in the best case, we only need to consider 1 triangle.\\nSo, while our overall time complexity is the same **O(n^3)** our average performance will be much better than this.\\n\\n```\\ntypedef pair<int, int> pt;\\n#define x first\\n#define y second\\npt operator -(pt a, pt b) {\\n  return pt(a.x - b.x, a.y - b.y);\\n}\\n\\nclass Solution {\\n  int cross(pt a, pt b) { // 2d cross product\\n    return a.x*b.y - a.y*b.x;\\n  }\\n  bool ccw(pt a, pt b, pt c) { // counter clockwise rotation\\n    return cross(b - a, c - a) >= 0;\\n  }\\n  \\n  vector<pt> half_hull(vector<pt>& pts) {\\n    vector<pt> res;\\n    for (int i = 0; i < pts.size() ; i++) {\\n      while (res.size() >= 2 && ccw(pts[i], res[res.size()-1], res[res.size()-2]))\\n        res.pop_back();\\n      res.push_back (pts[i]);\\n    }\\n    return res;\\n  }\\n  \\n  vector<pt> convex_hull(vector<pt>& pts) {\\n    sort (pts.begin(), pts.end());\\n    vector<pt> top = half_hull(pts);\\n    reverse(pts.begin(), pts.end());\\n    vector<pt> bottom = half_hull(pts) ;\\n    top.pop_back() ;\\n    bottom.pop_back();\\n    vector<pt> res(top.begin(), top.end());\\n    res.insert(res.end(), bottom.begin(), bottom.end());\\n    return res;\\n  }\\n \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      int area = -1;\\n      vector<pt> pts;\\n      for (vector<int>& p : points) {\\n        pts.push_back({p[0], p[1]});\\n      }\\n      vector<pt> hull = convex_hull(pts);\\n\\n      for (int i = 0; i < hull.size(); i++) {\\n        for (int j = i + 1; j < hull.size(); j++) {\\n          for (int k = j + 1; k < hull.size(); k++) {\\n            area = max(area, abs(cross(hull[j]-hull[i], hull[k]-hull[i])));\\n          }\\n        }\\n      }\\n      return 0.5*area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef pair<int, int> pt;\\n#define x first\\n#define y second\\npt operator -(pt a, pt b) {\\n  return pt(a.x - b.x, a.y - b.y);\\n}\\n\\nclass Solution {\\n  int cross(pt a, pt b) { // 2d cross product\\n    return a.x*b.y - a.y*b.x;\\n  }\\n  bool ccw(pt a, pt b, pt c) { // counter clockwise rotation\\n    return cross(b - a, c - a) >= 0;\\n  }\\n  \\n  vector<pt> half_hull(vector<pt>& pts) {\\n    vector<pt> res;\\n    for (int i = 0; i < pts.size() ; i++) {\\n      while (res.size() >= 2 && ccw(pts[i], res[res.size()-1], res[res.size()-2]))\\n        res.pop_back();\\n      res.push_back (pts[i]);\\n    }\\n    return res;\\n  }\\n  \\n  vector<pt> convex_hull(vector<pt>& pts) {\\n    sort (pts.begin(), pts.end());\\n    vector<pt> top = half_hull(pts);\\n    reverse(pts.begin(), pts.end());\\n    vector<pt> bottom = half_hull(pts) ;\\n    top.pop_back() ;\\n    bottom.pop_back();\\n    vector<pt> res(top.begin(), top.end());\\n    res.insert(res.end(), bottom.begin(), bottom.end());\\n    return res;\\n  }\\n \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      int area = -1;\\n      vector<pt> pts;\\n      for (vector<int>& p : points) {\\n        pts.push_back({p[0], p[1]});\\n      }\\n      vector<pt> hull = convex_hull(pts);\\n\\n      for (int i = 0; i < hull.size(); i++) {\\n        for (int j = i + 1; j < hull.size(); j++) {\\n          for (int k = j + 1; k < hull.size(); k++) {\\n            area = max(area, abs(cross(hull[j]-hull[i], hull[k]-hull[i])));\\n          }\\n        }\\n      }\\n      return 0.5*area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918415,
                "title": "0ms-solution-2-different-solutions-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach)\\n```\\n\\n# (Approach 1) : 10 ms\\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) \\n    {\\n        double area=0;\\n        for(int[] A:points)\\n        {\\n            for(int[] B:points)\\n            {\\n                for(int[] C:points)\\n                {\\n                    area=Math.max(area,0.5*calcArea(A,B,C));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n    public double calcArea(int[] A,int[] B,int[] C)\\n    {\\n        int ABx=B[0]-A[0];\\n        int ACy=C[1]-A[1];\\n        int ABy=B[1]-A[1];\\n        int ACx=C[0]-A[0];\\n        return Math.abs(ABx*ACy-ABy*ACx);\\n    }\\n}\\n```\\n# (Approach 2) : 0 ms\\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) //fastest approach\\n    {\\n        int n = points.length;\\n        double max =0;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n\\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [0 ms] approach)\\n```\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) \\n    {\\n        double area=0;\\n        for(int[] A:points)\\n        {\\n            for(int[] B:points)\\n            {\\n                for(int[] C:points)\\n                {\\n                    area=Math.max(area,0.5*calcArea(A,B,C));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n    public double calcArea(int[] A,int[] B,int[] C)\\n    {\\n        int ABx=B[0]-A[0];\\n        int ACy=C[1]-A[1];\\n        int ABy=B[1]-A[1];\\n        int ACx=C[0]-A[0];\\n        return Math.abs(ABx*ACy-ABy*ACx);\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public double largestTriangleArea(int[][] points) //fastest approach\\n    {\\n        int n = points.length;\\n        double max =0;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n\\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258864,
                "title": "python-triangle-area",
                "content": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        res = 0\\n        for i in range(len(points)):\\n            x1, y1 = points[i]\\n            for j in range(i+1, len(points)):\\n                x2, y2 = points[j]\\n                for k in range(j+1, len(points)):\\n                    x3, y3 = points[k]\\n                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        res = 0\\n        for i in range(len(points)):\\n            x1, y1 = points[i]\\n            for j in range(i+1, len(points)):\\n                x2, y2 = points[j]\\n                for k in range(j+1, len(points)):\\n                    x3, y3 = points[k]\\n                    res = max(res, abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 122859,
                "title": "python-another-convex-hull-solution-44ms-to-reduce-the-search-space",
                "content": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        return self.largestTriangeAreaInConvexHull(self.convex_hull(points))\\n        \\n        \\n        \\n        \\n    def largestTriangeAreaInConvexHull(self, points):\\n        \\n        max_area = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    new_area = abs(0.5 * (points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1]\\n                   - points[i][0] * points[k][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1]))\\n                    max_area= max(max_area, new_area)\\n        return max_area\\n    \\n    \\n    def convex_hull(self, points):\\n        hull = []\\n        points = sorted(points,key=lambda l:l[1])\\n        ref_point= points[0]\\n        angle_points = []\\n        for p in points[1:]:\\n            angle = self.angle(ref_point, p)\\n            if angle < 0:\\n                angle = math.pi*2.0 + angle\\n            angle_points.append( [angle, p])\\n        \\n        \\n        angle_points.sort()\\n        hull.append(ref_point)\\n        hull.append(angle_points[0][1])\\n\\n        for angle_point in angle_points[1:]:\\n            top = hull.pop()\\n            while len(hull) > 0 and self.ccw(hull[-1], top, angle_point[1]) < 0: #it is not <= because we want to keep all points in the convex hull, even if the are in a line\\n                top = hull.pop()\\n                \\n            hull.append(top)\\n            hull.append(angle_point[1])\\n\\n        return hull\\n    \\n    def angle(self, reference, point):\\n        v1_x = point[0]-reference[0]\\n        v1_y = point[1] - reference[1]\\n        return math.atan2(v1_y, v1_x)\\n        \\n    def ccw(self, a, b, c):\\n        area2 = (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])\\n        if area2 < 0:\\n            return -1 #clockwise\\n        if area2 >0 :\\n            return 1 #counter clock wise\\n        return 0 #linear\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        return self.largestTriangeAreaInConvexHull(self.convex_hull(points))\\n        \\n        \\n        \\n        \\n    def largestTriangeAreaInConvexHull(self, points):\\n        \\n        max_area = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    new_area = abs(0.5 * (points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1]\\n                   - points[i][0] * points[k][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1]))\\n                    max_area= max(max_area, new_area)\\n        return max_area\\n    \\n    \\n    def convex_hull(self, points):\\n        hull = []\\n        points = sorted(points,key=lambda l:l[1])\\n        ref_point= points[0]\\n        angle_points = []\\n        for p in points[1:]:\\n            angle = self.angle(ref_point, p)\\n            if angle < 0:\\n                angle = math.pi*2.0 + angle\\n            angle_points.append( [angle, p])\\n        \\n        \\n        angle_points.sort()\\n        hull.append(ref_point)\\n        hull.append(angle_points[0][1])\\n\\n        for angle_point in angle_points[1:]:\\n            top = hull.pop()\\n            while len(hull) > 0 and self.ccw(hull[-1], top, angle_point[1]) < 0: #it is not <= because we want to keep all points in the convex hull, even if the are in a line\\n                top = hull.pop()\\n                \\n            hull.append(top)\\n            hull.append(angle_point[1])\\n\\n        return hull\\n    \\n    def angle(self, reference, point):\\n        v1_x = point[0]-reference[0]\\n        v1_y = point[1] - reference[1]\\n        return math.atan2(v1_y, v1_x)\\n        \\n    def ccw(self, a, b, c):\\n        area2 = (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])\\n        if area2 < 0:\\n            return -1 #clockwise\\n        if area2 >0 :\\n            return 1 #counter clock wise\\n        return 0 #linear\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605382,
                "title": "javascript-non-bruteforce-solution-dobkin-snyder-jarvis-march",
                "content": "**Complexity**\\n- **Space**\\n  - Jarvis March (Gift Wrapping Algorithm)\\n    - In all cases, the space complexity is `O(H)` where `H` is the size of the hull.\\n    - worst/average case: `H=N -> O(N)`; all the points are on the hull.\\n    - best case: `H=3 -> O(3) == O(1)`; the hull is a triangle.\\n\\n  - Dobkin & Snyder, Largest Triangle\\n    - worst/best/average case: `O(1)`; we allocate a fixed amount of space that doesn\\'t change relative to the size of the input.\\n\\n  - Combined\\n    - worst/average case: `O(JARVIS + DOBKIN_SNYDER) == O(N + 1) == O(N)`.\\n    - best case: `O(JARVIS + DOBKIN_SNYDER) == O(1 + 1) == O(1)`.\\n\\n- **Time**\\n  - Jarvis March (Gift Wrapping Algorithm)\\n    - In all cases, the time complexity is `O(H * N)` where `H` is the number of points on the hull.\\n    - worst/average case: `H=N -> O(N^2)`; all the points are on the hull.\\n    - best case: `H=3 -> O(3N) == O(N)`; the hull is a triangle.\\n\\n  - Dobkin & Snyder (Gift Wrapping Algorithm)\\n    - worst/average case: `O(N)`; `a`, `b`, and `c` each visit `N-2` points.\\n    - best case: `O(1)`; the largest triangle is formed by the first three points of the hull.\\n\\n  - Combined\\n    - worst/average case: `O(JARVIS + DOBKIN_SNYDER) == O(N^2 + N) == O(N^2)`.\\n    - best case: `O(JARVIS + DOBKIN_SNYDER) == O(N + 1) == O(N)`.\\n\\n```\\n// Heron\\'s Formula for the area of an arbitrary triangle\\n// https://en.wikipedia.org/wiki/Heron%27s_formula\\nlet areaOfTriangle = function(p1, p2, p3) {\\n  const a = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);\\n  const b = Math.sqrt((p3.x - p1.x)**2 + (p3.y - p1.y)**2);\\n  const c = Math.sqrt((p3.x - p2.x)**2 + (p3.y - p2.y)**2);\\n  \\n  // The \\'semi-perimeter\\'; ie. half the perimeter.\\n  const s = (a + b + c) / 2;\\n\\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\\n}\\n\\n// Gift-Wrapping Algorithm (Jarvis March) for computing the hull of a set of points.\\n// https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\\nlet computeHull = function(p) {\\n  const h = [];\\n  \\n  let leftMostPoint = p.reduce((acc, cur) => acc.x < cur.x ? acc : cur);\\n  \\n  let a = leftMostPoint;\\n  do {\\n    h.push(a);\\n    \\n    // The idea is to get any point other than `a`.\\n    let c = p[(p.indexOf(a) + 1) % p.length];\\n    for(const b of p) {\\n      if(b === a || b === c) continue;\\n      \\n      // Probably the least-intuitive part of this whole algorithm. Check the wiki article for a visual illustration.\\n      if(c.turnsRightRelativeTo(a, b) || (c.collinearWith(a, b) && b.lengthFrom(a) > c.lengthFrom(a))) {\\n        c = b;\\n      }\\n    }\\n    \\n    a = c;\\n  } while(a !== leftMostPoint);\\n  \\n  return h;\\n}\\n\\nlet crossProduct = function(p1, p2) {\\n  return p1.x * p2.y - p2.x * p1.y;\\n}\\n\\nlet Point = function([x, y]){\\n  this.x = x;\\n  this.y = y;\\n}\\n\\n// Assuming a line of three points, with p1 -> p2 -> p3, does p3 make a right turn relative to p1?\\nPoint.prototype.turnsRightRelativeTo = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is less than 0, `a` is counter-clockwise to `b`. When `a` is counter-clockwise to `b` that means this line makes a right turn.\\n  return crossProduct(a, b) < 0;\\n}\\n\\nPoint.prototype.collinearWith = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is equal to 0, `a` is collinear (on the same line as) `b`.\\n  return crossProduct(a, b) === 0;\\n}\\n\\nPoint.prototype.lengthFrom = function(p) {\\n  return Math.sqrt((this.x - p.x)**2 + (this.y - p.y)**2);\\n}\\n\\nlet toPoint = ([x, y]) => new Point([x, y]);\\n\\nlet largestTriangleArea = p => {\\n  // Convert the data to `Point` objects and compute the hull.\\n  const h = computeHull(p.map(toPoint));\\n  const area = (a, b, c) => areaOfTriangle(h[a], h[b], h[c]);\\n\\n  // Dobkin & Snyder\\'s largest-triangle algorithm.\\n  // https://arxiv.org/pdf/1705.11035.pdf (Algorithm 1, Page 4).\\n  let a = 0;\\n  let b = 1;\\n  let c = 2;\\n  let max = area(a, b, c);\\n\\n  for(; a < h.length; a++) {\\n    let cur = area(a, b, c);\\n    let cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n    let bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    while((cNext && cNext >= cur) || (bNext && bNext >= cur)) {\\n      if((cNext && cNext >= cur)) {\\n        c++;\\n      } else if((bNext && bNext >= cur)) {\\n        b++;\\n      }\\n      \\n      cur = area(a, b, c);\\n      cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n      bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    }\\n    \\n    max = Math.max(max, area(a, b, c));\\n  }\\n\\n  return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Heron\\'s Formula for the area of an arbitrary triangle\\n// https://en.wikipedia.org/wiki/Heron%27s_formula\\nlet areaOfTriangle = function(p1, p2, p3) {\\n  const a = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);\\n  const b = Math.sqrt((p3.x - p1.x)**2 + (p3.y - p1.y)**2);\\n  const c = Math.sqrt((p3.x - p2.x)**2 + (p3.y - p2.y)**2);\\n  \\n  // The \\'semi-perimeter\\'; ie. half the perimeter.\\n  const s = (a + b + c) / 2;\\n\\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\\n}\\n\\n// Gift-Wrapping Algorithm (Jarvis March) for computing the hull of a set of points.\\n// https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\\nlet computeHull = function(p) {\\n  const h = [];\\n  \\n  let leftMostPoint = p.reduce((acc, cur) => acc.x < cur.x ? acc : cur);\\n  \\n  let a = leftMostPoint;\\n  do {\\n    h.push(a);\\n    \\n    // The idea is to get any point other than `a`.\\n    let c = p[(p.indexOf(a) + 1) % p.length];\\n    for(const b of p) {\\n      if(b === a || b === c) continue;\\n      \\n      // Probably the least-intuitive part of this whole algorithm. Check the wiki article for a visual illustration.\\n      if(c.turnsRightRelativeTo(a, b) || (c.collinearWith(a, b) && b.lengthFrom(a) > c.lengthFrom(a))) {\\n        c = b;\\n      }\\n    }\\n    \\n    a = c;\\n  } while(a !== leftMostPoint);\\n  \\n  return h;\\n}\\n\\nlet crossProduct = function(p1, p2) {\\n  return p1.x * p2.y - p2.x * p1.y;\\n}\\n\\nlet Point = function([x, y]){\\n  this.x = x;\\n  this.y = y;\\n}\\n\\n// Assuming a line of three points, with p1 -> p2 -> p3, does p3 make a right turn relative to p1?\\nPoint.prototype.turnsRightRelativeTo = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is less than 0, `a` is counter-clockwise to `b`. When `a` is counter-clockwise to `b` that means this line makes a right turn.\\n  return crossProduct(a, b) < 0;\\n}\\n\\nPoint.prototype.collinearWith = function(p1, p2) {\\n  const p3 = this;\\n  \\n  const a = new Point([p2.x - p1.x, p2.y - p1.y]);\\n  const b = new Point([p3.x - p1.x, p3.y - p1.y]);\\n  \\n  // If the cross-product is equal to 0, `a` is collinear (on the same line as) `b`.\\n  return crossProduct(a, b) === 0;\\n}\\n\\nPoint.prototype.lengthFrom = function(p) {\\n  return Math.sqrt((this.x - p.x)**2 + (this.y - p.y)**2);\\n}\\n\\nlet toPoint = ([x, y]) => new Point([x, y]);\\n\\nlet largestTriangleArea = p => {\\n  // Convert the data to `Point` objects and compute the hull.\\n  const h = computeHull(p.map(toPoint));\\n  const area = (a, b, c) => areaOfTriangle(h[a], h[b], h[c]);\\n\\n  // Dobkin & Snyder\\'s largest-triangle algorithm.\\n  // https://arxiv.org/pdf/1705.11035.pdf (Algorithm 1, Page 4).\\n  let a = 0;\\n  let b = 1;\\n  let c = 2;\\n  let max = area(a, b, c);\\n\\n  for(; a < h.length; a++) {\\n    let cur = area(a, b, c);\\n    let cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n    let bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    while((cNext && cNext >= cur) || (bNext && bNext >= cur)) {\\n      if((cNext && cNext >= cur)) {\\n        c++;\\n      } else if((bNext && bNext >= cur)) {\\n        b++;\\n      }\\n      \\n      cur = area(a, b, c);\\n      cNext = c+1 < h.length ? area(a, b, c+1) : null;\\n      bNext = b+1 < h.length ? area(a, b+1, c) : null;\\n    }\\n    \\n    max = Math.max(max, area(a, b, c));\\n  }\\n\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158780,
                "title": "c-812-largest-triangle-area",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans = 0; \\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i+1; j < points.size(); ++j) {\\n                for (int k = j+1; k < points.size(); ++k ){\\n                    double a = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)), \\n                    b = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2)), \\n                    c = sqrt(pow(points[k][0] - points[i][0], 2) + pow(points[k][1] - points[i][1], 2)), \\n                    s = (a + b + c)/2; \\n                    ans = max(ans, sqrt(s*(s-a)*(s-b)*(s-c)));\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans = 0; \\n        for (int i = 0; i < points.size(); ++i) {\\n            for (int j = i+1; j < points.size(); ++j) {\\n                for (int k = j+1; k < points.size(); ++k ){\\n                    double a = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2)), \\n                    b = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2)), \\n                    c = sqrt(pow(points[k][0] - points[i][0], 2) + pow(points[k][1] - points[i][1], 2)), \\n                    s = (a + b + c)/2; \\n                    ans = max(ans, sqrt(s*(s-a)*(s-b)*(s-c)));\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700009,
                "title": "java-brute-force-using-function-mathematical-formula",
                "content": "### **Please Upvote** :D\\nArea of a triangle **```ABC```** with 3 given points **```A(x1, y1), B(x2, y2),```** and **```C(x3, y3)```** is:\\n**```(\\u0394ABC) = (1/2)|x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|```**\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```ABC```\n```A(x1, y1), B(x2, y2),```\n```C(x3, y3)```\n```(\\u0394ABC) = (1/2)|x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|```\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650043,
                "title": "python-solution-99-faster",
                "content": "Using the coordinate geometry area of triangle formula:\\nhttps://www.brainkart.com/article/Area-of-a-Triangle_39390/\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        area = 0\\n        \\n        for i in range(len(points)-2):\\n            x1,y1 = points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2 = points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3 = points[k]\\n                    curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if (curr_area > area):\\n                        area = curr_area\\n            \\n        return area\\n\\nUpvote if you liked the solution!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Using the coordinate geometry area of triangle formula:\\nhttps://www.brainkart.com/article/Area-of-a-Triangle_39390/\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        area = 0\\n        \\n        for i in range(len(points)-2):\\n            x1,y1 = points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2 = points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3 = points[k]\\n                    curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if (curr_area > area):\\n                        area = curr_area\\n            \\n        return area\\n\\nUpvote if you liked the solution!",
                "codeTag": "Java"
            },
            {
                "id": 1257766,
                "title": "faster-than-98-00-of-python3",
                "content": "```\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        def triangle_area(p1,p2,p3):\\n            area = abs(((p1[0] -p2[0])*(p1[1] -p3[1])) - ((p1[0] - p3[0])*(p1[1] - p2[1]))) *.5\\n            return area\\n        max_area =0\\n        for i, j, k in combinations(points,3):\\n            if max_area < triangle_area(i,j,k):\\n                max_area = triangle_area(i,j,k)\\n        return max_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \\n        def triangle_area(p1,p2,p3):\\n            area = abs(((p1[0] -p2[0])*(p1[1] -p3[1])) - ((p1[0] - p3[0])*(p1[1] - p2[1]))) *.5\\n            return area\\n        max_area =0\\n        for i, j, k in combinations(points,3):\\n            if max_area < triangle_area(i,j,k):\\n                max_area = triangle_area(i,j,k)\\n        return max_area\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1007970,
                "title": "easy-clear-solution-python",
                "content": "```\\nclass Solution:\\n    \\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        res=0\\n        n=len(p)\\n        r,l=0,0\\n        for i in range (1,n-1):\\n            for r in range(0,i):\\n                for l in range(i+1,n):\\n                    newArea=(p[i][0]*p[r][1] + p[r][0]*p[l][1] +p[l][0]*p[i][1] - p[i][0]*p[l][1] - p[r][0]*p[i][1] - p[l][0]*p[r][1] )/2\\n                    newArea=abs(newArea)\\n                    print(newArea)\\n                    if newArea>res:\\n                        res=newArea\\n        return res           \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        res=0\\n        n=len(p)\\n        r,l=0,0\\n        for i in range (1,n-1):\\n            for r in range(0,i):\\n                for l in range(i+1,n):\\n                    newArea=(p[i][0]*p[r][1] + p[r][0]*p[l][1] +p[l][0]*p[i][1] - p[i][0]*p[l][1] - p[r][0]*p[i][1] - p[l][0]*p[r][1] )/2\\n                    newArea=abs(newArea)\\n                    print(newArea)\\n                    if newArea>res:\\n                        res=newArea\\n        return res           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979217,
                "title": "johnoyegbite-simple-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def area_with_3points(self, three_points: List[List[int]]) -> float:\\n        \"\"\"\\n        If you care about the proof which is trivial, see link below.\\n        Link: https://mathinstructor.net/2012/08/how-to-find-area-of-triangle-given-three-vertices/\\n        y-axis |\\n               |           (x1, y1)\\n               |           /       \\\\\\n               |          /         \\\\\\n               |         /           \\\\\\n               |   (x2, y2)___________(x3, y3)\\n               |\\n               |__________________________________> x-axis\\n        \"\"\"\\n        x1, y1 = three_points[0]\\n        x2, y2 = three_points[1]\\n        x3, y3 = three_points[2]\\n        return abs((1/2) * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n    \\n        # How to remember this formular? \\n        # Pick your coordinate starting from x1 and move anticlockwise.\\n        # Example Pick -> x1 with y2 before y3 => x1 * (y2 - y3)\\n        #              -> x2 with y3 before y1 => x2 * (y3 - y1)\\n        #              -> x3 with y1 before y2 => x3 * (y1 - y2)\\n        # REMEMBER!!! (Anticlockwise movement)\\n        \\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest_area = 0\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    three_points = [points[i], points[j], points[k]]\\n                    curr_area = self.area_with_3points(three_points)\\n                    largest_area = max(largest_area, curr_area)\\n        return largest_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def area_with_3points(self, three_points: List[List[int]]) -> float:\\n        \"\"\"\\n        If you care about the proof which is trivial, see link below.\\n        Link: https://mathinstructor.net/2012/08/how-to-find-area-of-triangle-given-three-vertices/\\n        y-axis |\\n               |           (x1, y1)\\n               |           /       \\\\\\n               |          /         \\\\\\n               |         /           \\\\\\n               |   (x2, y2)___________(x3, y3)\\n               |\\n               |__________________________________> x-axis\\n        \"\"\"\\n        x1, y1 = three_points[0]\\n        x2, y2 = three_points[1]\\n        x3, y3 = three_points[2]\\n        return abs((1/2) * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n    \\n        # How to remember this formular? \\n        # Pick your coordinate starting from x1 and move anticlockwise.\\n        # Example Pick -> x1 with y2 before y3 => x1 * (y2 - y3)\\n        #              -> x2 with y3 before y1 => x2 * (y3 - y1)\\n        #              -> x3 with y1 before y2 => x3 * (y1 - y2)\\n        # REMEMBER!!! (Anticlockwise movement)\\n        \\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest_area = 0\\n        for i in range(len(points)):\\n            for j in range(i+1, len(points)):\\n                for k in range(j+1, len(points)):\\n                    three_points = [points[i], points[j], points[k]]\\n                    curr_area = self.area_with_3points(three_points)\\n                    largest_area = max(largest_area, curr_area)\\n        return largest_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494444,
                "title": "javascript-solution",
                "content": "```\\nvar largestTriangleArea = function(points) {\\n    const n = points.length;\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (k = j + 1; k < n; k++) {\\n                const area = calcArea(points[i], points[j], points[k]);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n\\n\\nfunction calcArea(coordA, coordB, coordC){\\n    const [xCoordA, yCoordA] = coordA;\\n    const [xCoordB, yCoordB] = coordB;\\n    const [xCoordC, yCoordC] = coordC;\\n    \\n    const sideA = xCoordA * (yCoordB - yCoordC);\\n    const sideB = xCoordB * (yCoordC - yCoordA);\\n    const sideC = xCoordC * (yCoordA - yCoordB);\\n    \\n    return Math.abs((sideA + sideB + sideC) / 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTriangleArea = function(points) {\\n    const n = points.length;\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (k = j + 1; k < n; k++) {\\n                const area = calcArea(points[i], points[j], points[k]);\\n                maxArea = Math.max(maxArea, area);\\n            }\\n        }\\n    }\\n\\n    return maxArea;\\n};\\n\\n\\nfunction calcArea(coordA, coordB, coordC){\\n    const [xCoordA, yCoordA] = coordA;\\n    const [xCoordB, yCoordB] = coordB;\\n    const [xCoordC, yCoordC] = coordC;\\n    \\n    const sideA = xCoordA * (yCoordB - yCoordC);\\n    const sideB = xCoordB * (yCoordC - yCoordA);\\n    const sideC = xCoordC * (yCoordA - yCoordB);\\n    \\n    return Math.abs((sideA + sideB + sideC) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238048,
                "title": "c-heron-s-formula",
                "content": "```\\ndouble getDis(int* pointA, int* pointB)\\n{\\n    return(sqrt(pow(pointA[0] - pointB[0], 2) + pow(pointA[1] - pointB[1], 2)));\\n}\\n\\ndouble getArea(int* pointA, int* pointB, int* pointC)\\n{\\n    double a, b, c, s;\\n    a = getDis(pointA, pointB);\\n    b = getDis(pointB, pointC);\\n    c = getDis(pointA, pointC);\\n    s = (a+b+c)/2;\\n    \\n    return(sqrt(s*(s-a)*(s-b)*(s-c)));\\n}\\n\\ndouble largestTriangleArea(int** points, int pointsRowSize, int *pointsColSizes) {\\n    double area, ans = 0;\\n    for(int i = 0; i < pointsRowSize - 2; i++)\\n    {\\n        for(int j = i+1; j < pointsRowSize -1; j++)\\n        {\\n            for(int k = j+1; k < pointsRowSize; k++)\\n            {\\n                area = getArea(points[i], points[j], points[k]);\\n                //printf(\"%f\\\\n\", area);\\n                if(area > ans) ans = area;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble getDis(int* pointA, int* pointB)\\n{\\n    return(sqrt(pow(pointA[0] - pointB[0], 2) + pow(pointA[1] - pointB[1], 2)));\\n}\\n\\ndouble getArea(int* pointA, int* pointB, int* pointC)\\n{\\n    double a, b, c, s;\\n    a = getDis(pointA, pointB);\\n    b = getDis(pointB, pointC);\\n    c = getDis(pointA, pointC);\\n    s = (a+b+c)/2;\\n    \\n    return(sqrt(s*(s-a)*(s-b)*(s-c)));\\n}\\n\\ndouble largestTriangleArea(int** points, int pointsRowSize, int *pointsColSizes) {\\n    double area, ans = 0;\\n    for(int i = 0; i < pointsRowSize - 2; i++)\\n    {\\n        for(int j = i+1; j < pointsRowSize -1; j++)\\n        {\\n            for(int k = j+1; k < pointsRowSize; k++)\\n            {\\n                area = getArea(points[i], points[j], points[k]);\\n                //printf(\"%f\\\\n\", area);\\n                if(area > ans) ans = area;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122737,
                "title": "python-simple-brute-force-solution",
                "content": "```\\ndef largestTriangleArea(self, points):\\n        N = len(points)\\n        ma = 0\\n        def calArea(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        for i in range(N-2):\\n            for j in range(i+1, N-1):\\n                for k in range(j+1, N):\\n                    ma = max(ma, calArea(points[i][0],points[i][1],points[j][0],points[j][1],points[k][0],points[k][1]))\\n        return ma\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\ndef largestTriangleArea(self, points):\\n        N = len(points)\\n        ma = 0\\n        def calArea(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        for i in range(N-2):\\n            for j in range(i+1, N-1):\\n                for k in range(j+1, N):\\n                    ma = max(ma, calArea(points[i][0],points[i][1],points[j][0],points[j][1],points[k][0],points[k][1]))\\n        return ma\\n\\t\\t\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 122721,
                "title": "short-straight-forward-c-solution",
                "content": "Math basics reference https://en.wikipedia.org/wiki/Triangle#Using_coordinates\\n```\\ndouble largestTriangleArea(vector<vector<int>>& points) {\\n    double res = 0;\\n    for (auto &i : points)\\n    for (auto &j : points)\\n    for (auto &k : points)\\n        res = max(res, fabs(0.5 * (i[0] * j[1] + j[0] * k[1] + k[0] * i[1]\\n                   - i[0] * k[1] - j[0] * i[1] - k[0] * j[1])));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestTriangleArea(vector<vector<int>>& points) {\\n    double res = 0;\\n    for (auto &i : points)\\n    for (auto &j : points)\\n    for (auto &k : points)\\n        res = max(res, fabs(0.5 * (i[0] * j[1] + j[0] * k[1] + k[0] * i[1]\\n                   - i[0] * k[1] - j[0] * i[1] - k[0] * j[1])));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692633,
                "title": "math-c-faster-easy-to-understand",
                "content": "* ***Apply Maths Of Triangle***\\n\\n* ***Time Complexity :- O(N * N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584913,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2353530,
                "title": "java-simple-math",
                "content": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    ans = Math.max(ans,0.5*Math.abs(points[i][0]*(points[j][1] - points[k][1]) + points[j][0]*( points[k][1] - points[i][1]) + points[k][0]*(points[i][1] - points[j][1])));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    ans = Math.max(ans,0.5*Math.abs(points[i][0]*(points[j][1] - points[k][1]) + points[j][0]*( points[k][1] - points[i][1]) + points[k][0]*(points[i][1] - points[j][1])));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2347730,
                "title": "o-n-3-80-t-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n    public double largestTriangleArea(int[][] p) {\\n        int l = p.length;\\n        double max = 0;\\n        for (int i = 0; i < l - 2; i++) {\\n            for (int j = i + 1; j < l - 1; j++) {\\n                for (int k = j + 1; k < l; k++) {\\n                    max = Math.max(max, 0.5 * Math.abs(\\n                                    p[i][0] * (p[j][1] - p[k][1]) +\\n                                    p[j][0] * (p[k][1] - p[i][1]) +\\n                                    p[k][0] * (p[i][1] - p[j][1])\\n                    ));\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965827,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n    int n = points.length;\\n    double max =0;\\n    \\n    for(int i =0; i<n; i++)\\n        for(int j =i+1; j<n; j++)\\n            for(int k =j+1; k<n; k++)\\n            {\\n                double area =0;\\n                int[] a=points[i];\\n                int[] b=points[j];\\n                int[] c=points[k];\\n                area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                if(area>max)\\n                    max=area;\\n            }\\n    return max;\\n\\t}\\n\\n    public double area(int[] a, int[] b)\\n\\t{\\n    int l = b[0]-a[0];\\n    double h = (a[1]+b[1]+200)/2.0;\\n    return l*h;\\n\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n    int n = points.length;\\n    double max =0;\\n    \\n    for(int i =0; i<n; i++)\\n        for(int j =i+1; j<n; j++)\\n            for(int k =j+1; k<n; k++)\\n            {\\n                double area =0;\\n                int[] a=points[i];\\n                int[] b=points[j];\\n                int[] c=points[k];\\n                area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                if(area>max)\\n                    max=area;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1757043,
                "title": "heron-s-formula-brute-force",
                "content": "So acc to class 9 maths we can calculate area of triangle as follows:\\ns=a+b+c/2\\narea=root(s*(s-a)*(s-b)*(s-c))\\nhere a,b,c are the lengths of different sides\\n\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    double length(vector<int>&a,vector<int>&b)\\n    {\\n        return pow((b[1]-a[1])*(b[1]-a[1])+(b[0]-a[0])*(b[0]-a[0]),0.5);\\n    }\\n    double area(vector<int>&a,vector<int>&b,vector<int>&c){\\n\\n        double x=length(a,b);\\n        double y=length(b,c);\\n        double z=length(a,c);\\n        \\n        double s=(double)(x+y+z)/(double)2;\\n        return pow(s*(s-x)*(s-y)*(s-z),0.5);\\n        \\n        \\n    \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n     \\n        double maxi=0;\\n        \\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double m=area(points[i],points[j],points[k]);\\n                    if(maxi<m)\\n                        maxi=m;\\n                }\\n            }\\n                \\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    double length(vector<int>&a,vector<int>&b)\\n    {\\n        return pow((b[1]-a[1])*(b[1]-a[1])+(b[0]-a[0])*(b[0]-a[0]),0.5);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1648159,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // The following function calculates the area of the triangle having three vertices as f,s, and t\\n    double area(vector<int>&f,vector<int>&s,vector<int>&t) {\\n        double p=(double)(f[0]*s[1]+s[0]*t[1]+t[0]*f[1]);\\n        double d=(double)(f[1]*s[0]+s[1]*t[0]+t[1]*f[0]);\\n        return 0.5*abs(p-d);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        // Generate all possible combinations of 3 points and calculate the area and take their maximum\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) {\\n                    ans=max(ans,area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // The following function calculates the area of the triangle having three vertices as f,s, and t\\n    double area(vector<int>&f,vector<int>&s,vector<int>&t) {\\n        double p=(double)(f[0]*s[1]+s[0]*t[1]+t[0]*f[1]);\\n        double d=(double)(f[1]*s[0]+s[1]*t[0]+t[1]*f[0]);\\n        return 0.5*abs(p-d);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        // Generate all possible combinations of 3 points and calculate the area and take their maximum\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) {\\n                    ans=max(ans,area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370840,
                "title": "java-solution",
                "content": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max =0;\\n        \\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }\\n        return max;\\n    }\\n    \\n    public double area(int[] a, int[] b)\\n    {\\n        int l = b[0]-a[0];\\n        double h = (a[1]+b[1]+200)/2.0;\\n        return l*h;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double max =0;\\n        \\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                {\\n                    double area =0;\\n                    int[] a=points[i];\\n                    int[] b=points[j];\\n                    int[] c=points[k];\\n                    area=Math.abs(area(a,b)+area(b,c)+area(c,a));\\n                    if(area>max)\\n                        max=area;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1352571,
                "title": "easy-python-solution-99-40",
                "content": "Runtime: 88 ms, faster than 99.40% of Python3 online submissions for Largest Triangle Area.\\nMemory Usage: 14.2 MB, less than 84.94% of Python3 online submissions for Largest Triangle Area.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        area = 0\\n        for i in range(len(points)-2):\\n            x1,y1=points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > area :\\n                        area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    \\n        return area",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 88 ms, faster than 99.40% of Python3 online submissions for Largest Triangle Area.\\nMemory Usage: 14.2 MB, less than 84.94% of Python3 online submissions for Largest Triangle Area.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        area = 0\\n        for i in range(len(points)-2):\\n            x1,y1=points[i]\\n            for j in range(i+1,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j+1,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > area :\\n                        area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    \\n        return area",
                "codeTag": "Java"
            },
            {
                "id": 949819,
                "title": "ruby-combinations-map-by-the-formula-select-max",
                "content": "##### Leetcode: 812. Largest Triangle Area.\\n\\nGet all combination of tree elements of the input array, calculate an area of an every triangle by the formula, select maximum value. https://www.mathopenref.com/coordtrianglearea.html url that stores the formula.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 812. Largest Triangle Area.\\n# https://leetcode.com/problems/largest-triangle-area/\\n# Runtime: 136 ms, faster than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# Memory Usage: 210.5 MB, less than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef largest_triangle_area(points)\\n   points.combination(3)\\n    .map{|((ax,ay),(bx,by),(cx,cy))| ((ax*(by-cy)+bx*(cy-ay)+cx*(ay-by)).fdiv(2)).abs}.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 812. Largest Triangle Area.\\n# https://leetcode.com/problems/largest-triangle-area/\\n# Runtime: 136 ms, faster than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# Memory Usage: 210.5 MB, less than 100.00% of Ruby online submissions for Largest Triangle Area.\\n# @param {Integer[][]} points\\n# @return {Float}\\ndef largest_triangle_area(points)\\n   points.combination(3)\\n    .map{|((ax,ay),(bx,by),(cx,cy))| ((ax*(by-cy)+bx*(cy-ay)+cx*(ay-by)).fdiv(2)).abs}.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550125,
                "title": "o-n-3-best-solution",
                "content": "## area of triangle = 1/2|x1(y2-y3) - x2(y1-y3) + x3(y1-y2)|\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans=0;\\n        for(int i=0;i<p.size()-2;i++){\\n            for(int j=i+1;j<p.size()-1;j++){\\n                for(int k=j+1;k<p.size();k++){\\n        int x1=p[i][0];\\n        int x2=p[j][0];\\n        int x3=p[k][0];\\n        int y1=p[i][1];\\n        int y2=p[j][1];\\n        int y3=p[k][1];\\n    ans = max(ans,0.5*(abs(x1*(y2-y3) - x2*(y1-y3) + x3*(y1-y2)))) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans=0;\\n        for(int i=0;i<p.size()-2;i++){\\n            for(int j=i+1;j<p.size()-1;j++){\\n                for(int k=j+1;k<p.size();k++){\\n        int x1=p[i][0];\\n        int x2=p[j][0];\\n        int x3=p[k][0];\\n        int y1=p[i][1];\\n        int y2=p[j][1];\\n        int y3=p[k][1];\\n    ans = max(ans,0.5*(abs(x1*(y2-y3) - x2*(y1-y3) + x3*(y1-y2)))) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357755,
                "title": "python-brute-force-solution-simple-math-proof",
                "content": "![image](https://assets.leetcode.com/users/magi003769/image_1565699964.png)\\n\\n1. Set our 3 points are respectively: `(x1, y1)`, `(x2,y2)` and `(x3,y3)`. The method is to calculate distance between one point and the line determined by the other two. Here we use `(x3,y3)` to form the (x0,y0) in formula and the other two points to determine parameter A, B and C in line equation: Ax + By + C = 0\\n![image](https://assets.leetcode.com/users/magi003769/image_1565698434.png)\\n\\n2. Using formula ![image](https://assets.leetcode.com/users/magi003769/image_1565699047.png), we express A, B and C with `(x1, y1)` and `(x2,y2)`: `A = (y2 - y1)`, `B = (x1 - x2)` and `C = x2y1 - x1y2`.\\n![image](https://assets.leetcode.com/users/magi003769/image_1565699860.png)\\n\\n3. Set the distance described above as `h` and the distance between `(x1, y1)` and `(x2,y2)` as `d`. The area `S` of triangle  can be obtained as `1/2 * h * d`. Fortunately, `d^2 = A^2 + B^2` which can eliminate the denominator in distance formula.\\n\\n\\n4. Finally, we obtain the area as `S = 1/2 * |Ax3 + By3 + C|`. If we unfold this expression, it is exactly what we have in code `0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1])`.\\n\\n```python\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        max_s = 0\\n        for i, j, k in itertools.combinations(points, 3):\\n            max_s = max(max_s, 0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1]))\\n        return max_s\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        max_s = 0\\n        for i, j, k in itertools.combinations(points, 3):\\n            max_s = max(max_s, 0.5 * abs(i[0]*k[1] + j[0]*i[1] + k[0]*j[1] - i[0]*j[1] - j[0]*k[1] - k[0]*i[1]))\\n        return max_s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233989,
                "title": "javascript-brute-force",
                "content": "```js\\nvar largestTriangleArea = function(points) {\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = 1; j < points.length; j++) {\\n            for (let k = 2; k < points.length; k++) {\\n                if (i !== j && i !== k && j !== k) {\\n                maxArea = Math.max(area(points[i], points[j], points[k]), maxArea);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return maxArea;\\n};\\n\\nvar area = function([x1, y1], [x2, y2], [x3, y3]) {\\n    return Math.abs(((x2 - x1)*(y3 - y1)) - ((x3 - x1)*(y2 - y1))) / 2;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar largestTriangleArea = function(points) {\\n    let maxArea = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = 1; j < points.length; j++) {\\n            for (let k = 2; k < points.length; k++) {\\n                if (i !== j && i !== k && j !== k) {\\n                maxArea = Math.max(area(points[i], points[j], points[k]), maxArea);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return maxArea;\\n};\\n\\nvar area = function([x1, y1], [x2, y2], [x3, y3]) {\\n    return Math.abs(((x2 - x1)*(y3 - y1)) - ((x3 - x1)*(y2 - y1))) / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032908,
                "title": "best-java-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static double helper(int arr1[], int arr2[], int arr3[]){\\n        double x1 = (double)arr1[0];\\n        double y1 = (double)arr1[1];\\n\\n        double x2 = (double)arr2[0];\\n        double y2 = (double)arr2[1];\\n\\n        double x3 = (double)arr3[0];\\n        double y3 = (double)arr3[1];\\n\\n        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))/2;\\n    }\\n    public double largestTriangleArea(int[][] arr) {\\n        \\n\\n        double ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    ans = Math.max(ans,helper(arr[i],arr[j],arr[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static double helper(int arr1[], int arr2[], int arr3[]){\\n        double x1 = (double)arr1[0];\\n        double y1 = (double)arr1[1];\\n\\n        double x2 = (double)arr2[0];\\n        double y2 = (double)arr2[1];\\n\\n        double x3 = (double)arr3[0];\\n        double y3 = (double)arr3[1];\\n\\n        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)))/2;\\n    }\\n    public double largestTriangleArea(int[][] arr) {\\n        \\n\\n        double ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n                for(int k=j+1; k<arr.length; k++){\\n                    ans = Math.max(ans,helper(arr[i],arr[j],arr[k]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794039,
                "title": "only-one-line-on-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n    \\n        return max(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) for [x1,y1], [x2,y2], [x3,y3] in combinations(points, 3))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n    \\n        return max(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) for [x1,y1], [x2,y2], [x3,y3] in combinations(points, 3))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658762,
                "title": "best-case-o-n-log-n-beats-100-spatial-algorithms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the points as a cluster. Some points lie towards the \"outside\", and most on the \"inside\" of the cluster. One could draw a convex polyhedra by connecting the \"outside\" points such that all the other points like inside the convex polyedra. This polyhedra is called the convex hull. \\nThe key idea is that the largest triangle will be made by 3 of the points that make up the convex hull. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe family of algorithms that- given an array of points, return the set of points that make up the convex hull, are known as \"[Gift Wrapping Algorithms](https://medium.com/@indemfeld/gift-wrapping-algorithms-graham-scan-b24ca814e403)\".\\n\\nI used the algorithm discussed in the article- Graham Scan; Actually I copy pasted most of the code from this Geeks for Geeks [link](https://www.geeksforgeeks.org/convex-hull-using-graham-scan/). \\n\\nThe algorithm outputs the set of points that make up the convex hull in O(NlogN) time. After, we use the brute force to find the largest triangle from among the points that make up the convex hull.\\n\\n# Complexity\\n**Time complexity:** Best case $O($N$log$N$)$. Worst Case: $O($N$^3)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The best case is when the convex hull of the input points is a triangle. In such a case, the graham scan algorithm will output only 3 points and thus the brute force loops only run once. Thus, the time complexity will be $O($N$)+O($N$log$N$)+ O(1)+O(1) = O($N$log$N$)$.\\n- The worst case is when the convex hull is a $n-$dimensional convex polyhedra made up by all of the $n$ input points. In this case the Graham scan does not filter out any points. The complexity will then be $O($N$)+O($N$log$N$)+O($N$)+O($N$^3) = O($N$^3)$.\\n\\nMost case, however, lie in between these extreme- where graham scan will filter out a large percentage of the points and thus performing significantly better. Here time complexity will be $O($N$log$N$) + O($M$^3)$, where N is number of input points and M is number of points that make up the convex hull.  \\n\\n**Space complexity:** $O($M$)$ where M is number of points that make up the convex hull.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nActually one could reduce it to constant space complexity but to clearly separate the convex hull part, I decided against that. \\n\\n# Code\\n```\\nfrom functools import cmp_to_key\\n\\n# A utility function to return square of distance\\n# between p1 and p2\\ndef distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n# To find orientation of ordered triplet (p, q, r).\\n# The function returns following values\\n# 0 --> p, q and r are collinear\\n# 1 --> Clockwise\\n# 2 --> Counterclockwise\\ndef orientation(p, q, r):\\n    val= ((q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]))\\n    if val == 0:\\n        return 0  # collinear\\n    elif val > 0:\\n        return 1  # clock wise\\n    else:\\n        return 2  # counterclock wise\\n\\nclass Solution(object):\\n    # A function used by cmp_to_key function to sort an array of\\n    # points with respect to the first point\\n    def compare(self, p1, p2):\\n        # Find orientation\\n        o = orientation(self.p0, p1, p2)\\n        if o == 0:\\n            if distSq(self.p0, p2) >= distSq(self.p0, p1):\\n                return -1\\n            else:\\n                return 1\\n        elif o == 2:\\n            return -1\\n        else:\\n            return 1\\n\\n    # Returns convex hull of a set of n points.\\n    def convexHull(self, points, n):\\n        # Find the bottommost point\\n        ymin = points[0][1]\\n        minIdx = 0\\n        for i in range(1, n):\\n            y = points[i][1] \\n            # Pick the bottom-most or choose the left\\n            # most point in case of tie\\n            if ((y < ymin) or (ymin == y and points[i][0] < points[minIdx][0])):\\n                ymin = points[i][1]\\n                min = i\\n \\n        # Place the bottom-most point at first position\\n        points[0], points[minIdx] = points[minIdx], points[0]\\n \\n        # Sort n-1 points with respect to the first point.\\n        # A point p1 comes before p2 in sorted output if p2\\n        # has larger polar angle (in counterclockwise\\n        # direction) than p1\\n        self.p0 = points[0]\\n        points = sorted(points, key=cmp_to_key(self.compare))\\n \\n        # If two or more points make same angle with p0,\\n        # Remove all but the one that is farthest from p0\\n        # Remember that, in above sorting, our criteria was\\n        # to keep the farthest point at the end when more than\\n        # one points have same angle.\\n        m = 1  # Initialize size of modified array\\n        for i in range(1, n):\\n            # Keep removing i while angle of i and i+1 is same\\n            # with respect to p0\\n            while ((i<n-1) and (orientation(self.p0,points[i],points[i+1])==0)):\\n                i += 1\\n            points[m] = points[i]\\n            m += 1  # Update size of modified array\\n \\n        # If modified array of points has less than 3 points,\\n        # convex hull is not possible\\n        if m < 3:\\n            return []\\n \\n        # Create an empty stack and push first three points to it.\\n        S = [points[0],points[1],points[2]]\\n \\n        # Process remaining n-3 points\\n        for i in range(3, m):\\n            # Keep removing top while the angle formed by\\n            # points next-to-top, top, and points[i] makes a non-left turn\\n            while (len(S)>1) and (orientation(S[-2],S[-1],points[i])!=2):\\n                S.pop()\\n            S.append(points[i])\\n        return S\\n\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        # Area of triangle between three points: \\n        # ( x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) ) / 2\\n\\n        n = len(points)\\n        S = self.convexHull(points,n)\\n        n = len(S)\\n        if n<3:\\n            return 0\\n            \\n        area = 0\\n        for a in range(n-2):\\n            x1,y1 = S[a]\\n            for b in range(a+1,n-1):\\n                x2,y2 = S[b]\\n                for c in range(b+1,n):\\n                    x3,y3 = S[c]\\n                    areaT = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n                    area = max (area, areaT)\\n        return round(float(area)/2,5)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom functools import cmp_to_key\\n\\n# A utility function to return square of distance\\n# between p1 and p2\\ndef distSq(p1, p2):\\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\\n \\n# To find orientation of ordered triplet (p, q, r).\\n# The function returns following values\\n# 0 --> p, q and r are collinear\\n# 1 --> Clockwise\\n# 2 --> Counterclockwise\\ndef orientation(p, q, r):\\n    val= ((q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]))\\n    if val == 0:\\n        return 0  # collinear\\n    elif val > 0:\\n        return 1  # clock wise\\n    else:\\n        return 2  # counterclock wise\\n\\nclass Solution(object):\\n    # A function used by cmp_to_key function to sort an array of\\n    # points with respect to the first point\\n    def compare(self, p1, p2):\\n        # Find orientation\\n        o = orientation(self.p0, p1, p2)\\n        if o == 0:\\n            if distSq(self.p0, p2) >= distSq(self.p0, p1):\\n                return -1\\n            else:\\n                return 1\\n        elif o == 2:\\n            return -1\\n        else:\\n            return 1\\n\\n    # Returns convex hull of a set of n points.\\n    def convexHull(self, points, n):\\n        # Find the bottommost point\\n        ymin = points[0][1]\\n        minIdx = 0\\n        for i in range(1, n):\\n            y = points[i][1] \\n            # Pick the bottom-most or choose the left\\n            # most point in case of tie\\n            if ((y < ymin) or (ymin == y and points[i][0] < points[minIdx][0])):\\n                ymin = points[i][1]\\n                min = i\\n \\n        # Place the bottom-most point at first position\\n        points[0], points[minIdx] = points[minIdx], points[0]\\n \\n        # Sort n-1 points with respect to the first point.\\n        # A point p1 comes before p2 in sorted output if p2\\n        # has larger polar angle (in counterclockwise\\n        # direction) than p1\\n        self.p0 = points[0]\\n        points = sorted(points, key=cmp_to_key(self.compare))\\n \\n        # If two or more points make same angle with p0,\\n        # Remove all but the one that is farthest from p0\\n        # Remember that, in above sorting, our criteria was\\n        # to keep the farthest point at the end when more than\\n        # one points have same angle.\\n        m = 1  # Initialize size of modified array\\n        for i in range(1, n):\\n            # Keep removing i while angle of i and i+1 is same\\n            # with respect to p0\\n            while ((i<n-1) and (orientation(self.p0,points[i],points[i+1])==0)):\\n                i += 1\\n            points[m] = points[i]\\n            m += 1  # Update size of modified array\\n \\n        # If modified array of points has less than 3 points,\\n        # convex hull is not possible\\n        if m < 3:\\n            return []\\n \\n        # Create an empty stack and push first three points to it.\\n        S = [points[0],points[1],points[2]]\\n \\n        # Process remaining n-3 points\\n        for i in range(3, m):\\n            # Keep removing top while the angle formed by\\n            # points next-to-top, top, and points[i] makes a non-left turn\\n            while (len(S)>1) and (orientation(S[-2],S[-1],points[i])!=2):\\n                S.pop()\\n            S.append(points[i])\\n        return S\\n\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        # Area of triangle between three points: \\n        # ( x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) ) / 2\\n\\n        n = len(points)\\n        S = self.convexHull(points,n)\\n        n = len(S)\\n        if n<3:\\n            return 0\\n            \\n        area = 0\\n        for a in range(n-2):\\n            x1,y1 = S[a]\\n            for b in range(a+1,n-1):\\n                x2,y2 = S[b]\\n                for c in range(b+1,n):\\n                    x3,y3 = S[c]\\n                    areaT = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\\n                    area = max (area, areaT)\\n        return round(float(area)/2,5)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477719,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: list[list[int]]) -> float:\\n        return max(\\n            abs(getVector(a, b, c)) / 2\\n            for a, b, c in combinations(getBoundary(points), 3)\\n        )\\ndef getBoundary(points):\\n    points = [(a, b) for a, b in points]\\n    points.sort(key=lambda x: (x[0], x[1]))\\n\\n    upper = []\\n    lower = []\\n\\n    for point in points:\\n\\n        while len(lower) >= 2 and getVector(lower[-2], lower[-1], point) < 0:\\n            lower.pop()\\n        lower.append(point)\\n\\n        while len(upper) >= 2 and getVector(upper[-2], upper[-1], point) > 0:\\n            upper.pop()\\n        upper.append(point)\\n\\n    return list(set(upper + lower))\\n\\ndef getVector(a, b, c):\\n    return (b[0] - a[0]) * (b[1] - c[1]) - (b[1] - a[1]) * (b[0] - c[0])\\n```\\n\\n```Java []\\nclass Solution {\\n    double maxArea = Integer.MIN_VALUE;\\n    int[] idxList = new int[3];\\n    int n, k;\\n\\n    public double largestTriangleArea(int[][] points) {\\n        if(points == null) return 0;\\n        n = points.length;\\n        k = 3;\\n        dfs(points, 0, 0);\\n        return maxArea;\\n    }\\n    public void dfs(int[][] points, int pre, int idx){\\n        if(idx >= k){\\n            maxArea = Math.max(getArea(points), maxArea);\\n            return;\\n        }\\n        for(int i = pre + 1; i <= n; i ++){\\n            idxList[idx] = i - 1;\\n            dfs(points, i, idx + 1);  \\n        }\\n    }\\n    public double getArea(int[][] points){\\n        return Math.abs(0.5 * (points[idxList[0]][0] * (points[idxList[1]][1] - points[idxList[2]][1]) +\\n                        points[idxList[1]][0] * (points[idxList[2]][1] - points[idxList[0]][1]) +\\n                        points[idxList[2]][0] * (points[idxList[0]][1] - points[idxList[1]][1])));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: list[list[int]]) -> float:\\n        return max(\\n            abs(getVector(a, b, c)) / 2\\n            for a, b, c in combinations(getBoundary(points), 3)\\n        )\\ndef getBoundary(points):\\n    points = [(a, b) for a, b in points]\\n    points.sort(key=lambda x: (x[0], x[1]))\\n\\n    upper = []\\n    lower = []\\n\\n    for point in points:\\n\\n        while len(lower) >= 2 and getVector(lower[-2], lower[-1], point) < 0:\\n            lower.pop()\\n        lower.append(point)\\n\\n        while len(upper) >= 2 and getVector(upper[-2], upper[-1], point) > 0:\\n            upper.pop()\\n        upper.append(point)\\n\\n    return list(set(upper + lower))\\n\\ndef getVector(a, b, c):\\n    return (b[0] - a[0]) * (b[1] - c[1]) - (b[1] - a[1]) * (b[0] - c[0])\\n```\n```Java []\\nclass Solution {\\n    double maxArea = Integer.MIN_VALUE;\\n    int[] idxList = new int[3];\\n    int n, k;\\n\\n    public double largestTriangleArea(int[][] points) {\\n        if(points == null) return 0;\\n        n = points.length;\\n        k = 3;\\n        dfs(points, 0, 0);\\n        return maxArea;\\n    }\\n    public void dfs(int[][] points, int pre, int idx){\\n        if(idx >= k){\\n            maxArea = Math.max(getArea(points), maxArea);\\n            return;\\n        }\\n        for(int i = pre + 1; i <= n; i ++){\\n            idxList[idx] = i - 1;\\n            dfs(points, i, idx + 1);  \\n        }\\n    }\\n    public double getArea(int[][] points){\\n        return Math.abs(0.5 * (points[idxList[0]][0] * (points[idxList[1]][1] - points[idxList[2]][1]) +\\n                        points[idxList[1]][0] * (points[idxList[2]][1] - points[idxList[0]][1]) +\\n                        points[idxList[2]][0] * (points[idxList[0]][1] - points[idxList[1]][1])));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405260,
                "title": "javascript-100-o-n-3-time-o-1-space-brute-force",
                "content": "![image.png](https://assets.leetcode.com/users/images/61c84a94-a4e7-4592-908d-7760aab176d6_1681226967.606129.png)\\n\\n# Approach\\nBrute force solution using the following formula:\\n\\n$$|a[0](b[1]-c[1]) + b[0](c[1]-a[1]) + c[0](a[1]-b[1])| / 2$$\\n\\n```\\nfunction largestTriangleArea(points) {\\n    let result = 0;\\n\\n    for (let i = 0; i in points; i++) {\\n        for (let j = i + 1; j in points; j++) {\\n            for (let k = j + 1; k in points; k++) {\\n                const area = getArea(\\n                    points[i],\\n                    points[j],\\n                    points[k],\\n                );\\n\\n                result = Math.max(result, area);\\n            }\\n        }\\n    }\\n\\n    return result;    \\n};\\n\\nfunction getArea(a, b, c) {\\n    return Math.abs(a[0] * (b[1] - c[1]) +\\n                    b[0] * (c[1] - a[1]) +\\n                    c[0] * (a[1] - b[1])) / 2;\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nfunction largestTriangleArea(points) {\\n    let result = 0;\\n\\n    for (let i = 0; i in points; i++) {\\n        for (let j = i + 1; j in points; j++) {\\n            for (let k = j + 1; k in points; k++) {\\n                const area = getArea(\\n                    points[i],\\n                    points[j],\\n                    points[k],\\n                );\\n\\n                result = Math.max(result, area);\\n            }\\n        }\\n    }\\n\\n    return result;    \\n};\\n\\nfunction getArea(a, b, c) {\\n    return Math.abs(a[0] * (b[1] - c[1]) +\\n                    b[0] * (c[1] - a[1]) +\\n                    c[0] * (a[1] - b[1])) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706764,
                "title": "loop-over-all-points-and-use-determinant",
                "content": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * \\n                      abs(+ i[0] * j[1] \\n                          + j[0] * k[1]\\n                          + k[0] * i[1]\\n                          - j[0] * i[1] \\n                          - k[0] * j[1] \\n                          - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     double largestTriangleArea(vector<vector<int>>& points) \\n     {\\n        double res = 0;\\n        for (auto &i : points)\\n            for (auto &j : points)\\n                for (auto &k : points)\\n            res = max(res, 0.5 * \\n                      abs(+ i[0] * j[1] \\n                          + j[0] * k[1]\\n                          + k[0] * i[1]\\n                          - j[0] * i[1] \\n                          - k[0] * j[1] \\n                          - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580416,
                "title": "c-first-comes-in-mind-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580405,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\n      \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n       for(int i=0;i<points.size();i++)\\n       {\\n           for(int j=i+1;j<points.size();j++)\\n           {\\n               for(int k=j+1;k<points.size();k++)\\n               {\\n                   double x1=points[i][0];\\n                   double y1=points[i][1];\\n                   double x2=points[j][0];\\n                   double y2=points[j][1];\\n                   double x3=points[k][0];\\n                   double y3=points[k][1];\\n                   double area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                   maxi=max(area,maxi);\\n               }\\n           }\\n       }\\n        return maxi;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n      \\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n       for(int i=0;i<points.size();i++)\\n       {\\n           for(int j=i+1;j<points.size();j++)\\n           {\\n               for(int k=j+1;k<points.size();k++)\\n               {\\n                   double x1=points[i][0];\\n                   double y1=points[i][1];\\n                   double x2=points[j][0];\\n                   double y2=points[j][1];\\n                   double x3=points[k][0];\\n                   double y3=points[k][1];\\n                   double area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                   maxi=max(area,maxi);\\n               }\\n           }\\n       }\\n        return maxi;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299824,
                "title": "python-3-brute-force-solution-98-50",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxA = 0\\n        for p1, p2, p3 in combinations(points, 3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            A=(1/2) * abs(x1*(y2 - y3) + x2*(y3 - y1)+ x3*(y1 - y2))\\n            if A > maxA: maxA = A\\n        return maxA\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxA = 0\\n        for p1, p2, p3 in combinations(points, 3):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            x3, y3 = p3\\n            A=(1/2) * abs(x1*(y2 - y3) + x2*(y3 - y1)+ x3*(y1 - y2))\\n            if A > maxA: maxA = A\\n        return maxA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151115,
                "title": "golang-solution-brute-force-using-heron-s-formula",
                "content": "Time: **O(N^3)**\\nSpace: **O(1)**\\n\\n```golang\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\n    // Heron\\'s formula\\n    // triangle\\'s lengths a, b, c\\n    // S = sqrt((a+b+c) * (a+b-c) * (a+c-b) * (b+c-a)) / 4\\n    md := make(map[int]float64)\\n    \\n    var res float64 = 0\\n    for i := 0; i < len(points); i++ {\\n        for j := i + 1; j < len(points); j++ {\\n            mask := (1<<i)|(1<<j)\\n            x := md[mask]\\n            if x == 0 {\\n                x = distance(points[i], points[j])\\n                md[mask] = x\\n            }\\n            for k := j + 1; k < len(points); k++ {\\n                mask = (1<<i)|(1<<k)\\n                y := md[mask]\\n                if y == 0 {\\n                    y = distance(points[i], points[k])\\n                    md[mask] = y\\n                }\\n                mask = (1<<j)|(1<<k)\\n                z := md[mask]\\n                if z == 0 {\\n                    z = distance(points[j], points[k])\\n                    md[mask] = z\\n                }\\n                \\n                if x + y < z || x + z < y || y + z < x {\\n                    continue\\n                }\\n                \\n                if v := (x+y+z)*(x+y-z)*(x+z-y)*(y+z-x); v > res {\\n                    res = v\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(res) / 4.0\\n}\\n\\nfunc distance(p1 []int, p2 []int) float64 {\\n    x := p1[0] - p2[0]\\n    y := p1[1] - p2[1]\\n    return math.Sqrt(float64(x*x + y*y))\\n}\\n```\\n\\nAnother way to caculate triangle area when you only get 3 points\\'s position: https://www.mathopenref.com/coordtrianglearea.html\\n`S = |Ax(By \\u2212 Cy) + Bx(Cy \\u2212 Ay) + Cx(Ay \\u2212 By)| / 2`\\n\\nwhen 3 points on one line, S = 0\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\n    // Heron\\'s formula\\n    // triangle\\'s lengths a, b, c\\n    // S = sqrt((a+b+c) * (a+b-c) * (a+c-b) * (b+c-a)) / 4\\n    md := make(map[int]float64)\\n    \\n    var res float64 = 0\\n    for i := 0; i < len(points); i++ {\\n        for j := i + 1; j < len(points); j++ {\\n            mask := (1<<i)|(1<<j)\\n            x := md[mask]\\n            if x == 0 {\\n                x = distance(points[i], points[j])\\n                md[mask] = x\\n            }\\n            for k := j + 1; k < len(points); k++ {\\n                mask = (1<<i)|(1<<k)\\n                y := md[mask]\\n                if y == 0 {\\n                    y = distance(points[i], points[k])\\n                    md[mask] = y\\n                }\\n                mask = (1<<j)|(1<<k)\\n                z := md[mask]\\n                if z == 0 {\\n                    z = distance(points[j], points[k])\\n                    md[mask] = z\\n                }\\n                \\n                if x + y < z || x + z < y || y + z < x {\\n                    continue\\n                }\\n                \\n                if v := (x+y+z)*(x+y-z)*(x+z-y)*(y+z-x); v > res {\\n                    res = v\\n                }\\n            }\\n        }\\n    }\\n    \\n    return math.Sqrt(res) / 4.0\\n}\\n\\nfunc distance(p1 []int, p2 []int) float64 {\\n    x := p1[0] - p2[0]\\n    y := p1[1] - p2[1]\\n    return math.Sqrt(float64(x*x + y*y))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046105,
                "title": "o-n-2-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        int len = points.size();\\n        vector<vector<double>> chart(len,vector<double>(len,0)); // store the length between two points\\n        for (int i=0;i<len-1;i++)\\n            for (int j=i+1;j<len;j++)\\n                chart[i][j] = sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n        for (int i=0;i<len-2;i++)\\n            for (int j=i+1;j<len-1;j++)\\n                for (int k=j+1;k<len;k++)\\n                {\\n                    double p=(chart[i][j] + chart[i][k] + chart[j][k])/2;\\n                    ans = max(ans,sqrt(p*(p-chart[i][j])*(p-chart[i][k])*(p-chart[j][k])));\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0;\\n        int len = points.size();\\n        vector<vector<double>> chart(len,vector<double>(len,0)); // store the length between two points\\n        for (int i=0;i<len-1;i++)\\n            for (int j=i+1;j<len;j++)\\n                chart[i][j] = sqrt(pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2));\\n        for (int i=0;i<len-2;i++)\\n            for (int j=i+1;j<len-1;j++)\\n                for (int k=j+1;k<len;k++)\\n                {\\n                    double p=(chart[i][j] + chart[i][k] + chart[j][k])/2;\\n                    ans = max(ans,sqrt(p*(p-chart[i][j])*(p-chart[i][k])*(p-chart[j][k])));\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038867,
                "title": "java-math",
                "content": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n^3) {@code n} is the length of {@prams points}\\n     * Space Complexity: O(1)\\n     * @topic Largest Triangle Area\\n     * @author ArtistS\\n     * @param points\\n     * @return\\n     */\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double ret = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n^3) {@code n} is the length of {@prams points}\\n     * Space Complexity: O(1)\\n     * @topic Largest Triangle Area\\n     * @author ArtistS\\n     * @param points\\n     * @return\\n     */\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double ret = 0.0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {\\n        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890947,
                "title": "largest-triangle-area-solution-java",
                "content": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double largestArea = 0;\\n        int length = points.length;\\n        for (int i = 0; i < length; i++) {\\n            int[] point1 = points[i];\\n            for (int j = i + 1; j < length; j++) {\\n                int[] point2 = points[j];\\n                for (int k = j + 1; k < length; k++) {\\n                    int[] point3 = points[k];\\n                    if (sameLine(point1, point2, point3))\\n                        continue;\\n                    double area = getArea(point1, point2, point3);\\n                    largestArea = Math.max(largestArea, area);\\n                }\\n            }\\n        }\\n        return largestArea;\\n    }\\n\\n    public boolean sameLine(int[] point1, int[] point2, int[] point3) {\\n        int delta1X = point2[0] - point1[0], delta1Y = point2[1] - point1[1];\\n        int delta2X = point3[0] - point2[0], delta2Y = point3[1] - point2[1];\\n        return delta1X * delta2Y == delta2X * delta1Y;\\n    }\\n\\n    public double getArea(int[] point1, int[] point2, int[] point3) {\\n        double side1 = getDistance(point1, point2);\\n        double side2 = getDistance(point2, point3);\\n        double side3 = getDistance(point3, point1);\\n        double halfPerimeter = (side1 + side2 + side3) / 2;\\n        double area = Math.sqrt(halfPerimeter * (halfPerimeter - side1) * (halfPerimeter - side2) * (halfPerimeter - side3));\\n        return area;\\n    }\\n\\n    public double getDistance(int[] point1, int[] point2) {\\n        return Math.sqrt(((double) point2[0] - (double) point1[0]) * ((double) point2[0] - (double) point1[0]) + ((double) point2[1] - (double) point1[1]) * ((double) point2[1] - (double) point1[1]));\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double largestArea = 0;\\n        int length = points.length;\\n        for (int i = 0; i < length; i++) {\\n            int[] point1 = points[i];\\n            for (int j = i + 1; j < length; j++) {\\n                int[] point2 = points[j];\\n                for (int k = j + 1; k < length; k++) {\\n                    int[] point3 = points[k];\\n                    if (sameLine(point1, point2, point3))\\n                        continue;\\n                    double area = getArea(point1, point2, point3);\\n                    largestArea = Math.max(largestArea, area);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1827111,
                "title": "very-easy-code-for-beginner-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int> &p1, vector<int> &p2){\\n        int d1 = abs(p2[0]-p1[0]), d2 = abs(p2[1]-p1[1]);\\n        d1 *= d1, d2 *= d2;\\n        return sqrt(d1+d2);\\n    }\\n    \\n    double area(double s, double a, double b, double c){\\n        double prod = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(prod);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans = 0.0;\\n        double a=0, b=0, c=0;\\n        int n = p.size();\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                a = distance(p[i], p[j]);\\n                for(int k=j+1; k<n; k++){\\n                    b = distance(p[i], p[k]);\\n                    c = distance(p[j], p[k]);\\n                    double s = (a+b+c)/2.0;\\n                    ans = max(ans, area(s, a, b, c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int> &p1, vector<int> &p2){\\n        int d1 = abs(p2[0]-p1[0]), d2 = abs(p2[1]-p1[1]);\\n        d1 *= d1, d2 *= d2;\\n        return sqrt(d1+d2);\\n    }\\n    \\n    double area(double s, double a, double b, double c){\\n        double prod = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(prod);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double ans = 0.0;\\n        double a=0, b=0, c=0;\\n        int n = p.size();\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                a = distance(p[i], p[j]);\\n                for(int k=j+1; k<n; k++){\\n                    b = distance(p[i], p[k]);\\n                    c = distance(p[j], p[k]);\\n                    double s = (a+b+c)/2.0;\\n                    ans = max(ans, area(s, a, b, c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692057,
                "title": "python-concise-solution-using-combinations-multi-unpacking-faster-and-less-memory-than-90",
                "content": "The formula being used for the area here is based on making 3 trapezoids using the x-axis as the base and triangles vertices as the end points.  Split the triangle, to make two trapezoids including its area, then subtract the area of the trapezoid between the triangle and the axis. \\n   The formula has been simplified here to remove terms to cancel out.\\n\\n```python\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        max_area = 0\\n        for [x1, y1], [x2, y2], [x3, y3] in combinations(points, 3):\\n            area = 0.5 * abs(y1 * (x2 - x3) + y2 * (x3 - x1) + y3 * (x1 - x2))\\n            if area > max_area: max_area = area\\n        \\n        return max_area     \\n```\\n\\n![image](https://assets.leetcode.com/users/images/a7b37783-b8be-4acf-81ef-f59293bce02b_1642263009.0722857.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        max_area = 0\\n        for [x1, y1], [x2, y2], [x3, y3] in combinations(points, 3):\\n            area = 0.5 * abs(y1 * (x2 - x3) + y2 * (x3 - x1) + y3 * (x1 - x2))\\n            if area > max_area: max_area = area\\n        \\n        return max_area     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597637,
                "title": "rust-triangular-code-solution",
                "content": "```\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n        let mut s = f64::MIN;\\n        for (i, p1) in points.iter().enumerate() {\\n            for (j, p2) in points[i + 1..].iter().enumerate() {\\n                for p3 in points[j + 1..].iter() {\\n                    if let [x1, y1] = p1[..] {\\n                        if let [x2, y2] = p2[..] {\\n                            if let [x3, y3] = p3[..] {\\n                                s = s.max(\\n                                    0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)).abs()\\n                                        as f64,\\n                                );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n        let mut s = f64::MIN;\\n        for (i, p1) in points.iter().enumerate() {\\n            for (j, p2) in points[i + 1..].iter().enumerate() {\\n                for p3 in points[j + 1..].iter() {\\n                    if let [x1, y1] = p1[..] {\\n                        if let [x2, y2] = p2[..] {\\n                            if let [x3, y3] = p3[..] {\\n                                s = s.max(\\n                                    0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)).abs()\\n                                        as f64,\\n                                );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557937,
                "title": "simple-way-in-python-with-permutation",
                "content": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = float(\\'-inf\\')\\n        list_3p = itertools.permutations(points,3)\\n        for p1, p2, p3 in list_3p:\\n            area = max(area, 0.5*abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1])))\\n            \\n        return area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = float(\\'-inf\\')\\n        list_3p = itertools.permutations(points,3)\\n        for p1, p2, p3 in list_3p:\\n            area = max(area, 0.5*abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1])))\\n            \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530214,
                "title": "c-simple-code",
                "content": "class Solution {\\npublic:\\n    \\n    double Area(vector<int> A, vector<int> B, vector<int> C)\\n    {\\n         return (double)abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1]))/2;\\n    }\\n    \\n    \\n    double largestTriangleArea(vector<vector<int>>& points) \\n\\t{\\n        int n = points.size();\\n        double maxarea = INT_MIN;\\n        for(int i=0 ; i<n-2 ; ++i){\\n            for(int j=i ; j<n-1 ; ++j){\\n                for(int k=j ; k<n ; ++k){\\n                    maxarea = max(maxarea, Area(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return maxarea;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    double Area(vector<int> A, vector<int> B, vector<int> C)\\n    {\\n         return (double)abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1]))/2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1280268,
                "title": "python-3",
                "content": "from itertools import combinations\\nclass Solution:\\n    \\n\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxArea=0       \\n\\t\\t\\t\\n        def Area(a,b,c):\\n            return 0.5*abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))\\n\\t\\t\\t\\t\\t\\n        return max(map(lambda x: Area(*x),combinations(points,3)))",
                "solutionTags": [],
                "code": "from itertools import combinations\\nclass Solution:\\n    \\n\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n        maxArea=0       \\n\\t\\t\\t\\n        def Area(a,b,c):\\n            return 0.5*abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))\\n\\t\\t\\t\\t\\t\\n        return max(map(lambda x: Area(*x),combinations(points,3)))",
                "codeTag": "Java"
            },
            {
                "id": 1254653,
                "title": "c-4ms",
                "content": "```C++\\nclass Solution {\\npublic:\\n  double largestTriangleArea(std::vector<std::vector<int>>& points) {\\n    double max_area = std::numeric_limits<double>::min();\\n    for (int i = 0; i < points.size(); ++i) {\\n      for (int j = i + 1; j < points.size(); ++j) {\\n        for (int k = j + 1; k < points.size(); ++k) {\\n          double m = areaOfTriangle(points[i], points[j], points[k]);\\n          if (m > max_area) {\\n            max_area = m;\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n\\n  double areaOfTriangle(const std::vector<int> &a, const std::vector<int> &b,\\n                        const std::vector<int> &c) {\\n    return .5 * std::abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) +\\n                         c[0] * (a[1] - b[1]));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n  double largestTriangleArea(std::vector<std::vector<int>>& points) {\\n    double max_area = std::numeric_limits<double>::min();\\n    for (int i = 0; i < points.size(); ++i) {\\n      for (int j = i + 1; j < points.size(); ++j) {\\n        for (int k = j + 1; k < points.size(); ++k) {\\n          double m = areaOfTriangle(points[i], points[j], points[k]);\\n          if (m > max_area) {\\n            max_area = m;\\n          }\\n        }\\n      }\\n    }\\n    return max_area;\\n  }\\n\\n  double areaOfTriangle(const std::vector<int> &a, const std::vector<int> &b,\\n                        const std::vector<int> &c) {\\n    return .5 * std::abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) +\\n                         c[0] * (a[1] - b[1]));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254376,
                "title": "java-brute-force-calculation-area-with-explanation",
                "content": "Since the points.length < 50, maybe we can use a O(n^3) solution pass.\\nUsing the vector product formula.\\nthree points: (x1, y1), (x2, y2), (x3, y3), \\n`area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2`\\nbrute-force can pass.\\n\\n```java\\n// AC: Runtime: 4 ms, faster than 83.33% of Java online submissions for Largest Triangle Area.\\n// Memory Usage: 36.5 MB, less than 87.14% of Java online submissions for Largest Triangle Area.\\n// thought: using the vector product formula: (x1, y1), (x2, y2), (x3, y3), \\n//       area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2\\n// T:O(n^3), S:O(1)\\n//\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int size = points.length;\\n        double ret = 0;\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size - 1; j++) {\\n                int x = points[i][0] - points[j][0];\\n                int y = points[i][1] - points[j][1];\\n                for (int k = j + 1; k < size; k++) {\\n                    int x1 = points[i][0] - points[k][0];\\n                    int y1 = points[i][1] - points[k][1];\\n                    double area = Math.abs(x * y1 - y * x1) / (2 * 1.000000);\\n                    if (area > ret) {\\n                        ret = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 4 ms, faster than 83.33% of Java online submissions for Largest Triangle Area.\\n// Memory Usage: 36.5 MB, less than 87.14% of Java online submissions for Largest Triangle Area.\\n// thought: using the vector product formula: (x1, y1), (x2, y2), (x3, y3), \\n//       area = Math.abs((x1 -x2) * (y1 - y3) - (x1 - x3) * (x1 - x2)) / 2\\n// T:O(n^3), S:O(1)\\n//\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int size = points.length;\\n        double ret = 0;\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size - 1; j++) {\\n                int x = points[i][0] - points[j][0];\\n                int y = points[i][1] - points[j][1];\\n                for (int k = j + 1; k < size; k++) {\\n                    int x1 = points[i][0] - points[k][0];\\n                    int y1 = points[i][1] - points[k][1];\\n                    double area = Math.abs(x * y1 - y * x1) / (2 * 1.000000);\\n                    if (area > ret) {\\n                        ret = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239538,
                "title": "python-triangle-areas-based-on-combinations-itertools-recursive-iterative",
                "content": "I used 4 different approaches to generate all combinations, the itertools.combinations() is by far the fastest method among all. All have O(n^3) time complexity and O(n) space complexity due to stack (recursive or iterative) usage except using triple loops which has O(1) space complexity.\\n\\nI personally think that the hardest part of this problem is to derive the triangle area formula on the spot, because I do not remember such a long formula with so many details.\\n\\nNote that math.sqrt(x) raised Math Domain Error when x<0 , which is possible in our Heron\\'s formula calculation due to floating point epsilon rounding errors. Used numpy.sqrt(x) which returns numpy.nan when x<0.\\n\\nNote that max(iter, * , default) returns nan if first argument is math.nan or numpy.nan because 1st arg is considered the max seen so far value which is compared against all subsequent values in iter. any number compares to nan returns False.\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def triple_loops():\\n            for i in range(len(points)-2):\\n                # BUG 4: range(i,len(points)-1)\\n                for j in range(i+1,len(points)-1):\\n                    for k in range(j+1,len(points)):\\n                        yield [points[i],points[j],points[k]]\\n                        \\n        def comb_recr(idx,res):\\n            if len(res)==3:\\n                yield res\\n                return  # critical. return is needed, otherwise, inf loop\\n            elif idx==len(points):\\n                return\\n            # BUG 1. off yb 1\\uFF1Acomb(idx,res) \\n            # BUG 2. forgot that comb() returns a iterator, more specifically a generator, so simply comb(idx+1,res) won\\'t do it\\n            for i in comb_recr(idx+1,res):\\n                yield i\\n            for j in comb_recr(idx+1,res+[points[idx]]):\\n                yield j\\n                        \\n        def comb_iter():\\n            stack=[[0,0]] if points else  []\\n            res=[]\\n            # My first attempt was to use a forward=True flag to indicate whether we are advancing or backtracking to current top element of the stack. This will not work as we need more info than a bool\\n            # we basically visit each element three times, 1st time is to go forward without selecting current, 2nd time is backtracked and forward with current selected, thrid is backtracked again and clean up, so these 3 status can not be represented using a bool var. If a bool can do the trick, then there is actually no need for it because we can safely pop the current top before pushing its successor, knowning that when we backtrack to current, the only thing we do is to pop it, we can do the popping before appending its successor.\\n            while stack:\\n                stack[-1][1]+=1\\n                i,s=stack[-1]\\n                if len(points)==i:\\n                        stack.pop()\\n                elif s==1: #first time , do not select current elem\\n                    stack.append([i+1,0])\\n                elif s==2: #second time, backtracked, select current elem and forward\\n                    res.append(points[i]) \\n                    if len(res)==3:\\n                        yield res\\n                    else:\\n                        stack.append([i+1,0])\\n                else: #s==3 , backtracked, done with current elem\\n                    stack.pop()\\n                    res.pop()\\n            \\n        maxarea=area=0\\n        #for p in comb_recr(0,[]): # performance 14%\\n        #for p in comb_iter(): #performance 26%\\n        for p in triple_loops(): #performance 45%\\n        #for p in itertools.combinations(points,3): # performance 84%\\n            (xa,ya),(xb,yb),(xc,yc)=p # xa,ya is a better name than ax,ay\\n            #use shoelace formula with abs() works\\n            #area=abs((xa*yb+xb*yc+xc*ya-xa*yc-xb*ya-xc*yb)/2)  # abs()needed because the relative position of A,B,C are unknown and negative value is likely ,eg if point b is to the right of line AC\\n            # BUG 3. sort does not work (xa,ya),(xb,yb),(xc,yc)=(p:=sorted(p,key=lambda e:(e[1],-e[0]),reverse=True) ), there are too many cases that ordering 3 points to yield only positive numbers could be difficult\\n            #alt. way is to use Heron\\'s formula\\n            import numpy as np\\n            def getlen(xa,ya,xb,yb):\\n                return np.sqrt((xa-xb)**2+(ya-yb)**2)\\n            def heron(a,b,c):\\n                s=1/2*sum([a,b,c])   # sum(iter,*,start=intONly) only , not sum(*iter), start can not be str, use \\'\\'.join(seq) for str\\n                t=s*(s-a)*(s-b)*(s-c)\\n                if t<0: # [[-19, -3], [-21, -4], [23, 18]] then t=-3.670178492160762e-11 <sys.float_info.epsilon\\n                        print(\\'float epsilon in Python\\',sys.float_info.epsilon)\\n                        print(\\'value found:\\',t, \\'for :\\',p)\\n                        #raise ValueError(t)\\n                        #t=0  #if we use math.sqrt, we need to set any t<0 to 0 to avoid Math Domain Error\\n                return np.sqrt(t) # if use math.sqrt(t) for t=-3.670178492160762e-11 will cause Math Domain Error\\n            area=heron(getlen(xa,ya,xb,yb),getlen(xa,ya,xc,yc),getlen(xb,yb,xc,yc))\\n            maxarea=max(maxarea,area)  #max(0,np.nan)==0, max(np.nan,0)==nan ! if first arg is nan, the max() returns nan; if nan appears in nth arg, it is ignored. https://stackoverflow.com/questions/47788361/why-does-max-sometimes-return-nan-and-sometimes-ignores-it\\n        return maxarea\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def triple_loops():\\n            for i in range(len(points)-2):\\n                # BUG 4: range(i,len(points)-1)\\n                for j in range(i+1,len(points)-1):\\n                    for k in range(j+1,len(points)):\\n                        yield [points[i],points[j],points[k]]\\n                        \\n        def comb_recr(idx,res):\\n            if len(res)==3:\\n                yield res\\n                return  # critical. return is needed, otherwise, inf loop\\n            elif idx==len(points):\\n                return\\n            # BUG 1. off yb 1\\uFF1Acomb(idx,res) \\n            # BUG 2. forgot that comb() returns a iterator, more specifically a generator, so simply comb(idx+1,res) won\\'t do it\\n            for i in comb_recr(idx+1,res):\\n                yield i\\n            for j in comb_recr(idx+1,res+[points[idx]]):\\n                yield j\\n                        \\n        def comb_iter():\\n            stack=[[0,0]] if points else  []\\n            res=[]\\n            # My first attempt was to use a forward=True flag to indicate whether we are advancing or backtracking to current top element of the stack. This will not work as we need more info than a bool\\n            # we basically visit each element three times, 1st time is to go forward without selecting current, 2nd time is backtracked and forward with current selected, thrid is backtracked again and clean up, so these 3 status can not be represented using a bool var. If a bool can do the trick, then there is actually no need for it because we can safely pop the current top before pushing its successor, knowning that when we backtrack to current, the only thing we do is to pop it, we can do the popping before appending its successor.\\n            while stack:\\n                stack[-1][1]+=1\\n                i,s=stack[-1]\\n                if len(points)==i:\\n                        stack.pop()\\n                elif s==1: #first time , do not select current elem\\n                    stack.append([i+1,0])\\n                elif s==2: #second time, backtracked, select current elem and forward\\n                    res.append(points[i]) \\n                    if len(res)==3:\\n                        yield res\\n                    else:\\n                        stack.append([i+1,0])\\n                else: #s==3 , backtracked, done with current elem\\n                    stack.pop()\\n                    res.pop()\\n            \\n        maxarea=area=0\\n        #for p in comb_recr(0,[]): # performance 14%\\n        #for p in comb_iter(): #performance 26%\\n        for p in triple_loops(): #performance 45%\\n        #for p in itertools.combinations(points,3): # performance 84%\\n            (xa,ya),(xb,yb),(xc,yc)=p # xa,ya is a better name than ax,ay\\n            #use shoelace formula with abs() works\\n            #area=abs((xa*yb+xb*yc+xc*ya-xa*yc-xb*ya-xc*yb)/2)  # abs()needed because the relative position of A,B,C are unknown and negative value is likely ,eg if point b is to the right of line AC\\n            # BUG 3. sort does not work (xa,ya),(xb,yb),(xc,yc)=(p:=sorted(p,key=lambda e:(e[1],-e[0]),reverse=True) ), there are too many cases that ordering 3 points to yield only positive numbers could be difficult\\n            #alt. way is to use Heron\\'s formula\\n            import numpy as np\\n            def getlen(xa,ya,xb,yb):\\n                return np.sqrt((xa-xb)**2+(ya-yb)**2)\\n            def heron(a,b,c):\\n                s=1/2*sum([a,b,c])   # sum(iter,*,start=intONly) only , not sum(*iter), start can not be str, use \\'\\'.join(seq) for str\\n                t=s*(s-a)*(s-b)*(s-c)\\n                if t<0: # [[-19, -3], [-21, -4], [23, 18]] then t=-3.670178492160762e-11 <sys.float_info.epsilon\\n                        print(\\'float epsilon in Python\\',sys.float_info.epsilon)\\n                        print(\\'value found:\\',t, \\'for :\\',p)\\n                        #raise ValueError(t)\\n                        #t=0  #if we use math.sqrt, we need to set any t<0 to 0 to avoid Math Domain Error\\n                return np.sqrt(t) # if use math.sqrt(t) for t=-3.670178492160762e-11 will cause Math Domain Error\\n            area=heron(getlen(xa,ya,xb,yb),getlen(xa,ya,xc,yc),getlen(xb,yb,xc,yc))\\n            maxarea=max(maxarea,area)  #max(0,np.nan)==0, max(np.nan,0)==nan ! if first arg is nan, the max() returns nan; if nan appears in nth arg, it is ignored. https://stackoverflow.com/questions/47788361/why-does-max-sometimes-return-nan-and-sometimes-ignores-it\\n        return maxarea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224082,
                "title": "simple-determinant-solution-java",
                "content": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max=0;\\n        int n=points.length;\\n        for(int fp=0;fp<n-2;fp++){\\n            for(int sp=fp+1;sp<n-1;sp++){\\n                for(int tp=sp+1;tp<n;tp++){\\n                    double area=calc(points[fp],points[sp],points[tp]);\\n                    max=Math.max(max,area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public double calc(int[]a,int[]b,int[]c){\\n        double t=(a[0]*(b[1]-c[1])-b[0]*(a[1]-c[1])+c[0]*(a[1]-b[1]))/2.0;\\n        return t > 0 ? t : -t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double max=0;\\n        int n=points.length;\\n        for(int fp=0;fp<n-2;fp++){\\n            for(int sp=fp+1;sp<n-1;sp++){\\n                for(int tp=sp+1;tp<n;tp++){\\n                    double area=calc(points[fp],points[sp],points[tp]);\\n                    max=Math.max(max,area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public double calc(int[]a,int[]b,int[]c){\\n        double t=(a[0]*(b[1]-c[1])-b[0]*(a[1]-c[1])+c[0]*(a[1]-b[1]))/2.0;\\n        return t > 0 ? t : -t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146805,
                "title": "php",
                "content": "$count = count($points);\\n        $max = 0;\\n        for ($i = 0; $i < $count; $i++) {\\n            for ($j = $i + 1; $j < $count; $j++) {\\n                for ($k = $j + 1; $k < $count; $k++) {\\n                    $s = 0.5 * abs(($points[$j][0] - $points[$i][0]) * ($points[$k][1] - $points[$i][1]) - ($points[$k][0] - $points[$i][0]) * ($points[$j][1] - $points[$i][1]));\\n                    if ($s > $max) {\\n                        $max =  $s;\\n                    }\\n                }\\n            }\\n        }\\n        return $max;",
                "solutionTags": [],
                "code": "$count = count($points);\\n        $max = 0;\\n        for ($i = 0; $i < $count; $i++) {\\n            for ($j = $i + 1; $j < $count; $j++) {\\n                for ($k = $j + 1; $k < $count; $k++) {\\n                    $s = 0.5 * abs(($points[$j][0] - $points[$i][0]) * ($points[$k][1] - $points[$i][1]) - ($points[$k][0] - $points[$i][0]) * ($points[$j][1] - $points[$i][1]));\\n                    if ($s > $max) {\\n                        $max =  $s;\\n                    }\\n                }\\n            }\\n        }\\n        return $max;",
                "codeTag": "Unknown"
            },
            {
                "id": 1055253,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int N = points.size();\\n        double ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = i+1; j < N; ++j) {\\n                for (int k = j+1; k < N; ++k) {\\n                    ans = max(ans, area(points[i], points[j], points[k]));\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    double area(vector<int> P, vector<int> Q, vector<int> R) {\\n        return 0.5 * abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int N = points.size();\\n        double ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            for (int j = i+1; j < N; ++j) {\\n                for (int k = j+1; k < N; ++k) {\\n                    ans = max(ans, area(points[i], points[j], points[k]));\\n                }\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    double area(vector<int> P, vector<int> Q, vector<int> R) {\\n        return 0.5 * abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040805,
                "title": "surprisingly-fast-100",
                "content": "```\\nclass Solution {\\n    double area(vector<int>& p1, vector<int>& p2, vector<int>& p3)\\n    {\\n        return abs((p1[0] * (p2[1]-p3[1]) + p2[0] * (p3[1]-p1[1]) + p3[0] * (p1[1]-p2[1])) / 2.0);\\n    }\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max_area = 0.0;\\n        for (auto point1 = points.begin(); point1 != points.end(); point1++)\\n            for (auto point2 = next(point1); point2 != points.end(); point2++)\\n                for (auto point3 = next(point2); point3 != points.end(); point3++)\\n                    max_area = max(max_area, area(*point1, *point2, *point3));\\n        return max_area;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    double area(vector<int>& p1, vector<int>& p2, vector<int>& p3)\\n    {\\n        return abs((p1[0] * (p2[1]-p3[1]) + p2[0] * (p3[1]-p1[1]) + p3[0] * (p1[1]-p2[1])) / 2.0);\\n    }\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max_area = 0.0;\\n        for (auto point1 = points.begin(); point1 != points.end(); point1++)\\n            for (auto point2 = next(point1); point2 != points.end(); point2++)\\n                for (auto point3 = next(point2); point3 != points.end(); point3++)\\n                    max_area = max(max_area, area(*point1, *point2, *point3));\\n        return max_area;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863701,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    double area(vector<int> p1,vector<int> p2,vector<int> p3){\\n        double a=sqrt((p2[1]-p1[1])*(p2[1]-p1[1])+(p2[0]-p1[0])*(p2[0]-p1[0]));\\n        double b=sqrt((p3[1]-p1[1])*(p3[1]-p1[1])+(p3[0]-p1[0])*(p3[0]-p1[0]));\\n        double c=sqrt((p3[1]-p2[1])*(p3[1]-p2[1])+(p3[0]-p2[0])*(p3[0]-p2[0]));\\n        double s=(a+b+c)/2;\\n        return sqrt(s*(s-b)*(s-c)*(s-a));\\n        \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=INT_MIN;\\n        for(int i=0;i<points.size();i++)\\n            for(int j=0;j<points.size();j++)\\n                for(int k=0;k<points.size();k++)\\n                {\\n                    double a=area(points[i],points[j],points[k]);\\n                    if(a>max)\\n                        max=a;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double area(vector<int> p1,vector<int> p2,vector<int> p3){\\n        double a=sqrt((p2[1]-p1[1])*(p2[1]-p1[1])+(p2[0]-p1[0])*(p2[0]-p1[0]));\\n        double b=sqrt((p3[1]-p1[1])*(p3[1]-p1[1])+(p3[0]-p1[0])*(p3[0]-p1[0]));\\n        double c=sqrt((p3[1]-p2[1])*(p3[1]-p2[1])+(p3[0]-p2[0])*(p3[0]-p2[0]));\\n        double s=(a+b+c)/2;\\n        return sqrt(s*(s-b)*(s-c)*(s-a));\\n        \\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=INT_MIN;\\n        for(int i=0;i<points.size();i++)\\n            for(int j=0;j<points.size();j++)\\n                for(int k=0;k<points.size();k++)\\n                {\\n                    double a=area(points[i],points[j],points[k]);\\n                    if(a>max)\\n                        max=a;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749640,
                "title": "java-solution-using-hero-rule-in-math",
                "content": "```\\n double max=0;\\n        \\n        for(int x=0;x<points.length-2;x++)\\n        for(int j=0;j<points.length;j++){\\n        for(int i=0;i<points.length;i++){\\n            if(i==j)continue;\\n            if(Area(points[x],points[j],points[i])>max)\\n                max=Area(points[x],points[j],points[i]);\\n           // System.out.print(Area(points[x],points[j],points[i])+\"  \");\\n        }\\n        }\\n       // (Area(points[0],points[1],points[2]));\\n        return max;\\n    }\\n    double Area(int p1[],int p2[],int []p3){\\n        double l1=Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\\n        double l2=Math.sqrt((p2[0]-p3[0])*(p2[0]-p3[0]) + (p2[1]-p3[1])*(p2[1]-p3[1]));\\n        double l3=Math.sqrt((p3[0]-p1[0])*(p3[0]-p1[0]) + (p3[1]-p1[1])*(p3[1]-p1[1]));\\n        \\n        double Halfofpremiter=(l1+l2+l3)/2;\\n        // calaculating Area of rectangle using Hero rule.\\n        return Math.sqrt(Halfofpremiter*(Halfofpremiter-l1)*(Halfofpremiter-l2)*(Halfofpremiter-l3));\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n double max=0;\\n        \\n        for(int x=0;x<points.length-2;x++)\\n        for(int j=0;j<points.length;j++){\\n        for(int i=0;i<points.length;i++){\\n            if(i==j)continue;\\n            if(Area(points[x],points[j],points[i])>max)\\n                max=Area(points[x],points[j],points[i]);\\n           // System.out.print(Area(points[x],points[j],points[i])+\"  \");\\n        }\\n        }\\n       // (Area(points[0],points[1],points[2]));\\n        return max;\\n    }\\n    double Area(int p1[],int p2[],int []p3){\\n        double l1=Math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) + (p2[1]-p1[1])*(p2[1]-p1[1]));\\n        double l2=Math.sqrt((p2[0]-p3[0])*(p2[0]-p3[0]) + (p2[1]-p3[1])*(p2[1]-p3[1]));\\n        double l3=Math.sqrt((p3[0]-p1[0])*(p3[0]-p1[0]) + (p3[1]-p1[1])*(p3[1]-p1[1]));\\n        \\n        double Halfofpremiter=(l1+l2+l3)/2;\\n        // calaculating Area of rectangle using Hero rule.\\n        return Math.sqrt(Halfofpremiter*(Halfofpremiter-l1)*(Halfofpremiter-l2)*(Halfofpremiter-l3));\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 736658,
                "title": "c-herons-formula-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double side(vector<int> a, vector<int> b){\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return sqrt(x * x + y * y);\\n    }\\n    \\n    double A(double a, double b, double c){\\n        double s = (a + b + c) / 2.0;\\n        double area = sqrt(s * (s - a) * (s - b) * (s - c));\\n        return area;\\n    }\\n    \\n    bool isValid(double a, double b, double c){\\n        return (a + b > c && a + c > b && b + c > a);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int i = 0;i<points.size();i++){\\n            for(int j = i + 1;j<points.size();j++){\\n                for(int k = j + 1;k<points.size();k++){\\n                    double a = side(points[i], points[j]);\\n                    double b = side(points[j], points[k]);\\n                    double c = side(points[i], points[k]);\\n                    \\n                    if(isValid(a, b, c)){\\n                        double area = A(a, b, c);\\n\\n                        result = max(area, result);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double side(vector<int> a, vector<int> b){\\n        int x = a[0] - b[0];\\n        int y = a[1] - b[1];\\n        return sqrt(x * x + y * y);\\n    }\\n    \\n    double A(double a, double b, double c){\\n        double s = (a + b + c) / 2.0;\\n        double area = sqrt(s * (s - a) * (s - b) * (s - c));\\n        return area;\\n    }\\n    \\n    bool isValid(double a, double b, double c){\\n        return (a + b > c && a + c > b && b + c > a);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int i = 0;i<points.size();i++){\\n            for(int j = i + 1;j<points.size();j++){\\n                for(int k = j + 1;k<points.size();k++){\\n                    double a = side(points[i], points[j]);\\n                    double b = side(points[j], points[k]);\\n                    double c = side(points[i], points[k]);\\n                    \\n                    if(isValid(a, b, c)){\\n                        double area = A(a, b, c);\\n\\n                        result = max(area, result);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584112,
                "title": "c-clean-solution",
                "content": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var n = points.Length;\\n        var max = 0.0;\\n        for (var i = 0; i < n; i++) {\\n            for (var j = i + 1; j < n; j++) {\\n                for (var k = j + 1; k < n; k++) {\\n                    var area = Area(points[i], points[j], points[k]);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    double Area(int[] p0, int[] p1, int[] p2) {\\n        var v1x = p1[0] - p0[0];\\n        var v1y = p1[1] - p0[1];\\n        var v2x = p2[0] - p0[0];\\n        var v2y = p2[1] - p0[1];\\n        return Math.Abs(v1x * v2y - v1y * v2x) / 2.0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var n = points.Length;\\n        var max = 0.0;\\n        for (var i = 0; i < n; i++) {\\n            for (var j = i + 1; j < n; j++) {\\n                for (var k = j + 1; k < n; k++) {\\n                    var area = Area(points[i], points[j], points[k]);\\n                    if (area > max) {\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    double Area(int[] p0, int[] p1, int[] p2) {\\n        var v1x = p1[0] - p0[0];\\n        var v1y = p1[1] - p0[1];\\n        var v2x = p2[0] - p0[0];\\n        var v2y = p2[1] - p0[1];\\n        return Math.Abs(v1x * v2y - v1y * v2x) / 2.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525638,
                "title": "python-3-2-simple-solutions",
                "content": "```\\n## Solution 1\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use itertools.combinations to save code amount\\n# S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n        def f(p1, p2, p3):\\n            (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(f(a, b, c) for a, b, c in itertools.combinations(points, 3))\\n\\n## Solution 2\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use formula and don\\'t forget to use absolute value\\n        res = 0\\n        N = len(points)\\n        for i in range(N - 2):\\n            for j in range(i + 1, N - 1):\\n                for k in range(i + 2, N):\\n                    (x1, y1), (x2, y2), (x3, y3) = points[i], points[j], points[k]\\n                    res = max(res, 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## Solution 1\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use itertools.combinations to save code amount\\n# S=(1/2)*(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n        def f(p1, p2, p3):\\n            (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(f(a, b, c) for a, b, c in itertools.combinations(points, 3))\\n\\n## Solution 2\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n# use formula and don\\'t forget to use absolute value\\n        res = 0\\n        N = len(points)\\n        for i in range(N - 2):\\n            for j in range(i + 1, N - 1):\\n                for k in range(i + 2, N):\\n                    (x1, y1), (x2, y2), (x3, y3) = points[i], points[j], points[k]\\n                    res = max(res, 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505207,
                "title": "c-ugly-task-all-about-knowing-formula-or-proving-formula",
                "content": "Inspired by post [[C++/Java/Python] Solution with Explanation and Prove](https://leetcode.com/problems/largest-triangle-area/discuss/122711/C%2B%2BJavaPython-Solution-with-Explanation-and-Prove)\\n\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double area = 0;\\n        for (int i = 0; i < p.size() - 2; i++)\\n            for (int j = i + 1; j < p.size() - 1; j++)\\n                for (int k = j + 1; k < p.size(); k++)\\n                    area = max(area, 0.5 * abs(\\n                        p[i][0] * p[j][1] + p[j][0] * p[k][1] + p[k][0] * p[i][1] -\\n                        p[i][0] * p[k][1] - p[j][0] * p[i][1] - p[k][0] * p[j][1]\\n                    ));\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n        double area = 0;\\n        for (int i = 0; i < p.size() - 2; i++)\\n            for (int j = i + 1; j < p.size() - 1; j++)\\n                for (int k = j + 1; k < p.size(); k++)\\n                    area = max(area, 0.5 * abs(\\n                        p[i][0] * p[j][1] + p[j][0] * p[k][1] + p[k][0] * p[i][1] -\\n                        p[i][0] * p[k][1] - p[j][0] * p[i][1] - p[k][0] * p[j][1]\\n                    ));\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476143,
                "title": "my-swift-brute-force-solution-beats-100-runtime-and-memory",
                "content": "My Swift brute force solution beats 100% runtime and memory\\n\\n![image](https://assets.leetcode.com/users/yamironov/image_1578666188.png)\\n\\n```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        let c = points.count\\n        var result: Double = 0.0\\n        for i in 0...(c - 3) {\\n            for j in (i + 1)...(c - 2) {\\n                for k in (j + 1)...(c - 1) {\\n                    let s: Double = Double(abs((points[j][0] - points[i][0]) * (points[k][1] - points[i][1]) - (points[k][0] - points[i][0]) * (points[j][1] - points[i][1]))) / 2\\n                    if s > result { result = s }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        let c = points.count\\n        var result: Double = 0.0\\n        for i in 0...(c - 3) {\\n            for j in (i + 1)...(c - 2) {\\n                for k in (j + 1)...(c - 1) {\\n                    let s: Double = Double(abs((points[j][0] - points[i][0]) * (points[k][1] - points[i][1]) - (points[k][0] - points[i][0]) * (points[j][1] - points[i][1]))) / 2\\n                    if s > result { result = s }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426250,
                "title": "c-beats-98-88-time-100-space",
                "content": "basically, it is a math problem rather than a programming problem. It uses below formula to get size of triangle through 3 vertexes:\\nS=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n \\n        double max = 0;\\n        for(int i=0; i<points.size()-2; i++)\\n            for(int j=i+1; j<points.size()-1; j++)\\n                for(int k=j+1; k<points.size(); k++)\\n                {\\n                    //S=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n                    double cur = 0.5*abs(points[i][0]*points[j][1]+points[j][0]*points[k][1]+\\n                                        points[k][0]*points[i][1]-points[i][0]*points[k][1]-\\n                                        points[j][0]*points[i][1]-points[k][0]*points[j][1]);\\n                    if(cur > max)\\n                        max = cur;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n \\n        double max = 0;\\n        for(int i=0; i<points.size()-2; i++)\\n            for(int j=i+1; j<points.size()-1; j++)\\n                for(int k=j+1; k<points.size(); k++)\\n                {\\n                    //S=(1/2)*abs(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)\\n                    double cur = 0.5*abs(points[i][0]*points[j][1]+points[j][0]*points[k][1]+\\n                                        points[k][0]*points[i][1]-points[i][0]*points[k][1]-\\n                                        points[j][0]*points[i][1]-points[k][0]*points[j][1]);\\n                    if(cur > max)\\n                        max = cur;\\n                }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409313,
                "title": "easy-understandable-concise-code-beats-95",
                "content": "\\tdef LTA(m, n, o):\\n\\t\\tar = abs(((m[0]-o[0])*(n[1]-m[1])) - ((m[0] - n[0])*(o[1] - m[1])))\\n\\t\\treturn 0.5*ar\\n\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tmaxarea = 0\\n\\t\\t\\tfor i in range(len(points)-2):\\n\\t\\t\\t\\tfor j in range(i+1, len(points)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1, len(points)):\\n\\t\\t\\t\\t\\t\\tarea = LTA(points[i], points[j], points[k])\\n\\t\\t\\t\\t\\t\\tif area>maxarea:\\n\\t\\t\\t\\t\\t\\t\\tmaxarea = area\\n\\t\\t\\treturn maxarea\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef LTA(m, n, o):\\n\\t\\tar = abs(((m[0]-o[0])*(n[1]-m[1])) - ((m[0] - n[0])*(o[1] - m[1])))\\n\\t\\treturn 0.5*ar\\n\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tmaxarea = 0\\n\\t\\t\\tfor i in range(len(points)-2):\\n\\t\\t\\t\\tfor j in range(i+1, len(points)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1, len(points)):\\n\\t\\t\\t\\t\\t\\tarea = LTA(points[i], points[j], points[k])\\n\\t\\t\\t\\t\\t\\tif area>maxarea:\\n\\t\\t\\t\\t\\t\\t\\tmaxarea = area\\n\\t\\t\\treturn maxarea\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 280808,
                "title": "python-short-and-sweet-brute-force-heron-s-formula",
                "content": "```\\n\\nimport itertools\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def d(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**.5\\n        \\n        def area(a,b,c):\\n            p=.5*(d(a,b)+d(a,c)+d(b,c))\\n            sq=p*(p-d(a,b))*(p-d(a,c))*(p-d(b,c))\\n            return 0 if sq<0 else sq**.5\\n        \\n        ans=0\\n        for a,b,c in itertools.combinations(points,3):\\n            ans=max(ans,area(a,b,c))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nimport itertools\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def d(x,y):\\n            return ((x[0]-y[0])**2+(x[1]-y[1])**2)**.5\\n        \\n        def area(a,b,c):\\n            p=.5*(d(a,b)+d(a,c)+d(b,c))\\n            sq=p*(p-d(a,b))*(p-d(a,c))*(p-d(b,c))\\n            return 0 if sq<0 else sq**.5\\n        \\n        ans=0\\n        for a,b,c in itertools.combinations(points,3):\\n            ans=max(ans,area(a,b,c))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274503,
                "title": "fast-c-solution",
                "content": "\\n```\\n   double largestTriangleArea(vector<vector<int>>& points) {\\n        auto det = [&](int i, int j) {\\n            return points[i][0] * points[j][1] -\\n                   points[j][0] * points[i][1];     \\n        };\\n            \\n        // double of the max area.\\n        int area = 0;\\n        int n = points.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            for (int j = i + 1; j < n - 1; ++j) {\\n                for (int k = j + 1; k < n; ++k) {\\n                    // Determinant formula:\\n                    // https://people.richland.edu/james/lecture/m116/matrices/applications.html\\n                    int t = det(j, k) - det(i, k) + det(i, j);\\n                    area = max(area, max(-t, t));\\n                }\\n            }\\n        }\\n        \\n        // only do division in the end.\\n        return area / 2.0f;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   double largestTriangleArea(vector<vector<int>>& points) {\\n        auto det = [&](int i, int j) {\\n            return points[i][0] * points[j][1] -\\n                   points[j][0] * points[i][1];     \\n        };\\n            \\n        // double of the max area.\\n        int area = 0;\\n        int n = points.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            for (int j = i + 1; j < n - 1; ++j) {\\n                for (int k = j + 1; k < n; ++k) {\\n                    // Determinant formula:\\n                    // https://people.richland.edu/james/lecture/m116/matrices/applications.html\\n                    int t = det(j, k) - det(i, k) + det(i, j);\\n                    area = max(area, max(-t, t));\\n                }\\n            }\\n        }\\n        \\n        // only do division in the end.\\n        return area / 2.0f;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247182,
                "title": "brute-force-outer-product-8-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    double area(vector<int>& a, vector<int>&b, vector<int>& c) {\\n        return abs((double)((a[0]-b[0])*(a[1]-c[1])-(a[1]-b[1])*(a[0]-c[0]))/2.0);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int size = points.size();\\n        double tmpArea = 0, output = 0;\\n        for (int i = 0; i < size; ++i) \\n            for (int j = i+1; j < size; ++j) \\n                for (int k = j+1; k < size; ++k) {\\n                    tmpArea = area(points[i],points[j],points[k]);\\n                    if (tmpArea > output)\\n                        output = tmpArea;\\n                }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double area(vector<int>& a, vector<int>&b, vector<int>& c) {\\n        return abs((double)((a[0]-b[0])*(a[1]-c[1])-(a[1]-b[1])*(a[0]-c[0]))/2.0);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int size = points.size();\\n        double tmpArea = 0, output = 0;\\n        for (int i = 0; i < size; ++i) \\n            for (int j = i+1; j < size; ++j) \\n                for (int k = j+1; k < size; ++k) {\\n                    tmpArea = area(points[i],points[j],points[k]);\\n                    if (tmpArea > output)\\n                        output = tmpArea;\\n                }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134351,
                "title": "kotlin-o-n-3-solution",
                "content": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        var maxArea = 0.0\\n        for (i in 0 until points.size) {\\n            for (j in i + 1 until points.size) {\\n                for (k in j + 1 until points.size) {\\n                    maxArea = Math.max(maxArea, area(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n\\n    private fun area(a: IntArray, b: IntArray, c: IntArray): Double {\\n        return 0.5 * Math.abs((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        var maxArea = 0.0\\n        for (i in 0 until points.size) {\\n            for (j in i + 1 until points.size) {\\n                for (k in j + 1 until points.size) {\\n                    maxArea = Math.max(maxArea, area(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n\\n    private fun area(a: IntArray, b: IntArray, c: IntArray): Double {\\n        return 0.5 * Math.abs((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123555,
                "title": "c-simple-9ms-solution-without-complex-formulas",
                "content": "```\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double res=0.0;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) res=max(res, cal(points[i], points[j], points[k]));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    double cal(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        double base=sqrt((a[1]-b[1])*(a[1]-b[1])+(a[0]-b[0])*(a[0]-b[0]));\\n        double A=(a[1]-c[1])*(a[1]-c[1])+(a[0]-c[0])*(a[0]-c[0]);\\n        double B=(c[1]-b[1])*(c[1]-b[1])+(c[0]-b[0])*(c[0]-b[0]);\\n        double temp=base/2-(A-B)/(2*base);\\n        double height=sqrt(B-temp*temp);\\n        return base*height/2;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double res=0.0;\\n        for(int i=0;i<points.size();i++) {\\n            for(int j=i+1;j<points.size();j++) {\\n                for(int k=j+1;k<points.size();k++) res=max(res, cal(points[i], points[j], points[k]));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    double cal(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        double base=sqrt((a[1]-b[1])*(a[1]-b[1])+(a[0]-b[0])*(a[0]-b[0]));\\n        double A=(a[1]-c[1])*(a[1]-c[1])+(a[0]-c[0])*(a[0]-c[0]);\\n        double B=(c[1]-b[1])*(c[1]-b[1])+(c[0]-b[0])*(c[0]-b[0]);\\n        double temp=base/2-(A-B)/(2*base);\\n        double height=sqrt(B-temp*temp);\\n        return base*height/2;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4088862,
                "title": "triple-loop-to-find-the-biggest-triangle",
                "content": "# Intuition\\nThe problem requires finding the largest possible area of a triangle formed by three points from the given set of points. A brute-force approach is used to iterate through all possible combinations of three points and calculate the area of each triangle formed by them. The maximum area found among all triangles is the result.\\n\\n# Approach\\n1. Initialize a variable `res` to store the maximum area, initially set to 0.\\n2. Use three nested loops to iterate through all possible combinations of three points from the given array `points`.\\n3. For each combination of three points (i, j, k), calculate the area of the triangle formed by these points using the formula for the area of a triangle given its vertices.\\n4. Update the `res` variable with the maximum of its current value and the area calculated in step 3.\\n5. After all combinations have been checked, `res` will contain the maximum area of a triangle formed by any three points in the array.\\n6. Return the value of `res` as the result.\\n\\n# Complexity\\n- Time complexity: O(n^3) where n is the number of points in the input array. This is because we have three nested loops to generate all combinations of three points.\\n- Space complexity: O(1) as we are using a constant amount of extra space regardless of the input size.\\n\\n\\n# Code\\n```\\nfunction largestTriangleArea(points: number[][]): number {\\n    let res = 0;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            for (let k = j + 1; k < points.length; k++) {\\n                const area = 0.5 * Math.abs(\\n                    points[i][0] * (points[j][1] - points[k][1]) +\\n                    points[j][0] * (points[k][1] - points[i][1]) +\\n                    points[k][0] * (points[i][1] - points[j][1])\\n                );\\n\\n                res = Math.max(res, area);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestTriangleArea(points: number[][]): number {\\n    let res = 0;\\n\\n    for (let i = 0; i < points.length; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            for (let k = j + 1; k < points.length; k++) {\\n                const area = 0.5 * Math.abs(\\n                    points[i][0] * (points[j][1] - points[k][1]) +\\n                    points[j][0] * (points[k][1] - points[i][1]) +\\n                    points[k][0] * (points[i][1] - points[j][1])\\n                );\\n\\n                res = Math.max(res, area);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061297,
                "title": "just-the-heron-s-formula-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double distance(vector<int>& p1, vector<int>& p2){\\n        double d1=abs(p1[0]-p2[0]);\\n        double d2=abs(p1[1]-p2[1]);\\n        d1*=d1;\\n        d2*=d2;\\n        return sqrt(d1+d2);\\n    }\\n    double area(double a, double b, double c){\\n        double s=(a+b+c)/2.0;\\n        return sqrt(s*(s-a)*(s-b)*(s-c));\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0.0;\\n        double a=0,b=0,c=0;\\n        int n=points.size();\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                a=distance(points[i],points[j]);\\n                for(int k=j+1;k<n;k++){\\n                    b=distance(points[j],points[k]);\\n                    c=distance(points[i],points[k]);\\n                    ans=max(ans,area(a,b,c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double distance(vector<int>& p1, vector<int>& p2){\\n        double d1=abs(p1[0]-p2[0]);\\n        double d2=abs(p1[1]-p2[1]);\\n        d1*=d1;\\n        d2*=d2;\\n        return sqrt(d1+d2);\\n    }\\n    double area(double a, double b, double c){\\n        double s=(a+b+c)/2.0;\\n        return sqrt(s*(s-a)*(s-b)*(s-c));\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double ans=0.0;\\n        double a=0,b=0,c=0;\\n        int n=points.size();\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                a=distance(points[i],points[j]);\\n                for(int k=j+1;k<n;k++){\\n                    b=distance(points[j],points[k]);\\n                    c=distance(points[i],points[k]);\\n                    ans=max(ans,area(a,b,c));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058296,
                "title": "simple-with-unit-tests",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \"\"\"\\n        Calculate the surface of the largest triangle from 3 points on 2-D plain from the list.\\n\\n        Triangle size is height/2 * b. Height is perpendicular to on the b side and touches the vertex.\\n        There is a formula for triangle from coordinates also called determinant: `A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|`\\n\\n        The simplest solution is iterating over all combinations with time complexity of O(N**3).\\n        There are more complex solutions involving Gift Wrapping Algorithms.\\n\\n        >>> Solution().largestTriangleArea([[0,0],[0,1],[1,0],[0,2],[2,0]])\\n        2.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0],[0,1]])\\n        0.5\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0]])\\n        0.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0], [0,0]])\\n        0.0\\n\\n        \"\"\"\\n\\n        if len(points) < 3:\\n            return 0.0\\n\\n        max_area = 0.0\\n        for (x1, y1) in points:\\n            for (x2, y2) in points:\\n                for (x3, y3) in points:\\n                    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\\n                    if area > max_area:\\n                        max_area = area\\n\\n        return max_area\\n\\n\\n```\\n\\n\\n## Follow me for more software and machine learning at https://vaclavkosar.com/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        \"\"\"\\n        Calculate the surface of the largest triangle from 3 points on 2-D plain from the list.\\n\\n        Triangle size is height/2 * b. Height is perpendicular to on the b side and touches the vertex.\\n        There is a formula for triangle from coordinates also called determinant: `A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|`\\n\\n        The simplest solution is iterating over all combinations with time complexity of O(N**3).\\n        There are more complex solutions involving Gift Wrapping Algorithms.\\n\\n        >>> Solution().largestTriangleArea([[0,0],[0,1],[1,0],[0,2],[2,0]])\\n        2.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0],[0,1]])\\n        0.5\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0]])\\n        0.0\\n\\n        >>> Solution().largestTriangleArea([[1,0],[0,0], [0,0]])\\n        0.0\\n\\n        \"\"\"\\n\\n        if len(points) < 3:\\n            return 0.0\\n\\n        max_area = 0.0\\n        for (x1, y1) in points:\\n            for (x2, y2) in points:\\n                for (x3, y3) in points:\\n                    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\\n                    if area > max_area:\\n                        max_area = area\\n\\n        return max_area\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047307,
                "title": "shoelace",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\ndouble calculateArea(double x1, double y1, double x2, double y2, double x3, double y3) {\\n    return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\\n}\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      double res = 0;\\n      int n = points.size();\\n      for (int i = 0; i < n-2; ++i) {\\n        for (int j = i+1; j < n-1; ++j) {\\n          for (int k = j+1; k < n; ++k) {\\n            vector<int> p1 = points[i];\\n            vector<int> p2 = points[j];\\n            vector<int> p3 = points[k];\\n            double area = calculateArea(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\\n            res = max(res,area);\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\ndouble calculateArea(double x1, double y1, double x2, double y2, double x3, double y3) {\\n    return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\\n}\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n      double res = 0;\\n      int n = points.size();\\n      for (int i = 0; i < n-2; ++i) {\\n        for (int j = i+1; j < n-1; ++j) {\\n          for (int k = j+1; k < n; ++k) {\\n            vector<int> p1 = points[i];\\n            vector<int> p2 = points[j];\\n            vector<int> p3 = points[k];\\n            double area = calculateArea(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\\n            res = max(res,area);\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032967,
                "title": "excellent-solution-very-quick-and-takes-up-very-little-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def calc_area(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        \\n        max_area = 0\\n        n = len(points)\\n        \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    curr_area = calc_area(x1, y1, x2, y2, x3, y3)\\n                    max_area = max(max_area, curr_area)\\n        \\n        return max_area\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def calc_area(x1, y1, x2, y2, x3, y3):\\n            return abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\\n        \\n        max_area = 0\\n        n = len(points)\\n        \\n        for i in range(n):\\n            x1, y1 = points[i]\\n            for j in range(i + 1, n):\\n                x2, y2 = points[j]\\n                for k in range(j + 1, n):\\n                    x3, y3 = points[k]\\n                    curr_area = calc_area(x1, y1, x2, y2, x3, y3)\\n                    max_area = max(max_area, curr_area)\\n        \\n        return max_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012074,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\n\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992307,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964680,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\n O(n^3)\\n- Space complexity:\\n O(1)\\n# Code\\n```\\nclass Solution {\\n    double calculateTriangleArea(List<List<int>> points, int i, int j, int k) {\\n    return 0.5 * (points[i][0] * (points[j][1] - points[k][1]) +\\n        points[j][0] * (points[k][1] - points[i][1]) +\\n        points[k][0] * (points[i][1] - points[j][1])).abs();\\n  }\\n\\n  double largestTriangleArea(List<List<int>> points) {\\n    double maxArea = 0.0;\\n    int n = points.length;\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          double area = calculateTriangleArea(points, i, j, k);\\n          maxArea = max(maxArea, area);\\n        }\\n      }\\n    }\\n\\n    return maxArea;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    double calculateTriangleArea(List<List<int>> points, int i, int j, int k) {\\n    return 0.5 * (points[i][0] * (points[j][1] - points[k][1]) +\\n        points[j][0] * (points[k][1] - points[i][1]) +\\n        points[k][0] * (points[i][1] - points[j][1])).abs();\\n  }\\n\\n  double largestTriangleArea(List<List<int>> points) {\\n    double maxArea = 0.0;\\n    int n = points.length;\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      for (int j = i + 1; j < n - 1; j++) {\\n        for (int k = j + 1; k < n; k++) {\\n          double area = calculateTriangleArea(points, i, j, k);\\n          maxArea = max(maxArea, area);\\n        }\\n      }\\n    }\\n\\n    return maxArea;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954482,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] p) {\\n        int n=p.length;\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x1=p[i][0];\\n                    int y1=p[i][1];\\n                    int x2=p[j][0];\\n                    int y2=p[j][1];\\n                    int x3=p[k][0];\\n                    int y3=p[k][1];\\n                    double x=Math.abs(((x1)*(y2-y3))+((x2)*(y3-y1))+((x3)*(y1-y2)));\\n                    x/=2;\\n                    ans=Math.max(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886601,
                "title": "java-math-formula",
                "content": "# Intuition\\n**Area = (1/2) (x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2))**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double area=0;\\n        for(int i=0;i<points.length;i++)\\n            for(int j=i+1;j<points.length;j++)\\n                for(int k=j+1;k<points.length;k++)\\n                   area=Math.max(area,Math.abs(findArea(points[i],points[j],points[k])));\\n        return area;\\n    }\\n\\n    private double findArea(int[] x,int[] y,int[] z){\\n        return (double)(x[0]*(y[1]-z[1]) + y[0]*(z[1]-x[1]) + z[0]*(x[1]-y[1]))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864092,
                "title": "easy-solution-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a simple Brute Force question using a simple Mathematical formula for finding the Area.\\nFormula used : `Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double Area = 0;\\n        double Maxi = -1;\\n        for(int i=0;i<points.size()-2;i++) {\\n            for(int j=i+1;j<points.size()-1;j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    // A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\n                    int i1 = points[i][0];\\n                    int j1 = points[i][1];\\n                    int i2 = points[j][0];\\n                    int j2 = points[j][1];\\n                    int i3 = points[k][0];\\n                    int j3 = points[k][1];\\n                    \\n                    Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    // Area = ((1/2)* abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    Maxi = max(Maxi,Area);\\n                }\\n            }\\n        }       \\n        return Maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double Area = 0;\\n        double Maxi = -1;\\n        for(int i=0;i<points.size()-2;i++) {\\n            for(int j=i+1;j<points.size()-1;j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    // A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\n                    int i1 = points[i][0];\\n                    int j1 = points[i][1];\\n                    int i2 = points[j][0];\\n                    int j2 = points[j][1];\\n                    int i3 = points[k][0];\\n                    int j3 = points[k][1];\\n                    \\n                    Area = ((1.0/2) * abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    // Area = ((1/2)* abs(i1*(j2-j3) + i2*(j3-j1) + i3*(j1-j2)));\\n                    Maxi = max(Maxi,Area);\\n                }\\n            }\\n        }       \\n        return Maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853712,
                "title": "c-solution",
                "content": "```\\ndouble largestTriangleArea(vector<vector<int>>& p) {\\n\\tdouble res = DBL_MIN;\\n\\tfor (int i = 0; i < p.size(); i++)\\n\\t\\tfor (int j = i + 1; j < p.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k < p.size(); k++) {\\n\\t\\t\\t\\tdouble area = 0.5 * abs(p[i][0] * (p[j][1] - p[k][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[j][0] * (p[k][1] - p[i][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[k][0] * (p[i][1] - p[j][1]));\\n\\t\\t\\t\\tres = max(res, area);\\n\\t\\t\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ndouble largestTriangleArea(vector<vector<int>>& p) {\\n\\tdouble res = DBL_MIN;\\n\\tfor (int i = 0; i < p.size(); i++)\\n\\t\\tfor (int j = i + 1; j < p.size(); j++)\\n\\t\\t\\tfor (int k = j + 1; k < p.size(); k++) {\\n\\t\\t\\t\\tdouble area = 0.5 * abs(p[i][0] * (p[j][1] - p[k][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[j][0] * (p[k][1] - p[i][1]) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp[k][0] * (p[i][1] - p[j][1]));\\n\\t\\t\\t\\tres = max(res, area);\\n\\t\\t\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847518,
                "title": "kp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def find(points):\\n            a = points[0]\\n            b = points[1]\\n            c = points[2]\\n            x1, y1 = a[0], a[1]\\n            x2, y2 = b[0], b[1]\\n            x3, y3 = c[0], c[1]\\n            pre_area = x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)\\n            final_area = 0.5*abs(pre_area)\\n            return final_area\\n        if len(points)==3:\\n            return find(points)\\n        else:\\n            a = list(combinations(points, 3))\\n            c = []\\n            for i in a:\\n                c.append(find(i))\\n            return max(c)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def find(points):\\n            a = points[0]\\n            b = points[1]\\n            c = points[2]\\n            x1, y1 = a[0], a[1]\\n            x2, y2 = b[0], b[1]\\n            x3, y3 = c[0], c[1]\\n            pre_area = x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)\\n            final_area = 0.5*abs(pre_area)\\n            return final_area\\n        if len(points)==3:\\n            return find(points)\\n        else:\\n            a = list(combinations(points, 3))\\n            c = []\\n            for i in a:\\n                c.append(find(i))\\n            return max(c)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841640,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1,len(points)):\\n                for k in range(j+1,len(points)):\\n                    one = ((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)**0.5\\n                    two = ((points[k][0]-points[i][0])**2+(points[k][1]-points[i][1])**2)**0.5\\n                    three = ((points[k][0]-points[j][0])**2+(points[k][1]-points[j][1])**2)**0.5\\n                    s = (one+two+three)/2\\n                    largest = max((s*(round(s-one, 8))*(round(s-two, 8))*(round(s-three, 8)))**0.5, largest)\\n        \\n        return largest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        largest = 0\\n        \\n        for i in range(len(points)):\\n            for j in range(i+1,len(points)):\\n                for k in range(j+1,len(points)):\\n                    one = ((points[j][0]-points[i][0])**2+(points[j][1]-points[i][1])**2)**0.5\\n                    two = ((points[k][0]-points[i][0])**2+(points[k][1]-points[i][1])**2)**0.5\\n                    three = ((points[k][0]-points[j][0])**2+(points[k][1]-points[j][1])**2)**0.5\\n                    s = (one+two+three)/2\\n                    largest = max((s*(round(s-one, 8))*(round(s-two, 8))*(round(s-three, 8)))**0.5, largest)\\n        \\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824181,
                "title": "simple-c-solution-using-heron-s-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double hammingDistance(vector<int> x1, vector<int> x2) {\\n        double sq = pow((x1[0]-x2[0]), 2)+pow((x1[1]- x2[1]), 2);\\n        return sqrt(sq);\\n    }\\n    double getArea(vector<int> p0, vector<int> p1, vector<int> p2){\\n        double a = hammingDistance(p0, p1);\\n        double b = hammingDistance(p1, p2);\\n        double c = hammingDistance(p2, p0);\\n        double s = (a+b+c)/2;\\n        double sq = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(sq);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<int> res;\\n        double area = 0;\\n        int m = points.size();\\n        \\n        for(int i=0;i<m-2;i++){\\n            \\n            for(int j=i+1;j<m-1;j++){\\n                \\n                for(int k=j+1;k<m;k++){\\n                    \\n                    double finalArea = getArea(points[i], points[j], points[k]);\\n                    if(finalArea>area)\\n                        area=finalArea;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/f1e70f93-6634-4144-87cf-d02ad247260a_1690467810.4240024.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double hammingDistance(vector<int> x1, vector<int> x2) {\\n        double sq = pow((x1[0]-x2[0]), 2)+pow((x1[1]- x2[1]), 2);\\n        return sqrt(sq);\\n    }\\n    double getArea(vector<int> p0, vector<int> p1, vector<int> p2){\\n        double a = hammingDistance(p0, p1);\\n        double b = hammingDistance(p1, p2);\\n        double c = hammingDistance(p2, p0);\\n        double s = (a+b+c)/2;\\n        double sq = s*(s-a)*(s-b)*(s-c);\\n        return sqrt(sq);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<int> res;\\n        double area = 0;\\n        int m = points.size();\\n        \\n        for(int i=0;i<m-2;i++){\\n            \\n            for(int j=i+1;j<m-1;j++){\\n                \\n                for(int k=j+1;k<m;k++){\\n                    \\n                    double finalArea = getArea(points[i], points[j], points[k]);\\n                    if(finalArea>area)\\n                        area=finalArea;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750383,
                "title": "simple-mathematics-brute-force",
                "content": "```\\ndouble findArea(double a, double b, double c) \\n   {  \\n    if (a < 0 || b < 0 || c < 0 || \\n       (a + b <= c) || a + c <= b || \\n                       b + c <= a) {\\n        return 0.0;\\n    }\\n    double s = (a + b + c) / 2; \\n    return sqrt(s * (s - a) * \\n                    (s - b) * (s - c)); \\n    }\\n    double func(int x1,int y1,int x2,int y2)\\n    {\\n        double a=(x1-x2)*(x1-x2);\\n        double b=(y1-y2)*(y1-y2);\\n        \\n        return sqrt(a+b);\\n    }\\n    double solve(vector<int>&a,vector<int>&b,vector<int>&c)\\n    {   \\n        double x=func(a[0],a[1],b[0],b[1]);\\n        double y=func(c[0],c[1],b[0],b[1]);\\n        double z=func(a[0],a[1],c[0],c[1]);\\n        return findArea(x,y,z);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points)\\n    {   \\n        double ans=0.0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    ans=max(ans,solve(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndouble findArea(double a, double b, double c) \\n   {  \\n    if (a < 0 || b < 0 || c < 0 || \\n       (a + b <= c) || a + c <= b || \\n                       b + c <= a) {\\n        return 0.0;\\n    }\\n    double s = (a + b + c) / 2; \\n    return sqrt(s * (s - a) * \\n                    (s - b) * (s - c)); \\n    }\\n    double func(int x1,int y1,int x2,int y2)\\n    {\\n        double a=(x1-x2)*(x1-x2);\\n        double b=(y1-y2)*(y1-y2);\\n        \\n        return sqrt(a+b);\\n    }\\n    double solve(vector<int>&a,vector<int>&b,vector<int>&c)\\n    {   \\n        double x=func(a[0],a[1],b[0],b[1]);\\n        double y=func(c[0],c[1],b[0],b[1]);\\n        double z=func(a[0],a[1],c[0],c[1]);\\n        return findArea(x,y,z);\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points)\\n    {   \\n        double ans=0.0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    ans=max(ans,solve(points[i],points[j],points[k]));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702727,
                "title": "largest-triangle-area-js-clear-solution",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    result = 0\\n\\n    for (a of points)\\n        for (b of points)\\n            for (c of points) {\\n                x1 = a[0]\\n                x2 = b[0]\\n                x3 = c[0]\\n                y1 = a[1]\\n                y2 = b[1]\\n                y3 = c[1]\\n                area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))/2                \\n                result = Math.max(area, result)\\n            }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    result = 0\\n\\n    for (a of points)\\n        for (b of points)\\n            for (c of points) {\\n                x1 = a[0]\\n                x2 = b[0]\\n                x3 = c[0]\\n                y1 = a[1]\\n                y2 = b[1]\\n                y3 = c[1]\\n                area = ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))/2                \\n                result = Math.max(area, result)\\n            }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668671,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def largestTriangleArea(points: Array[Array[Int]]): Double = {\\n      def area(p1: Array[Int], p2: Array[Int], p3: Array[Int]): Double =\\n        math.abs((p1(0)*p2(1) + p2(0)*p3(1) + p3(0)*p1(1) - p1(0)*p3(1) - p2(0)*p1(1) - p3(0)*p2(1))/2.0)\\n\\n      (for {\\n        i <- points.indices\\n        j <- i+1 until points.length\\n        k <- j+1 until points.length\\n      } yield area(points(i), points(j), points(k))).max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def largestTriangleArea(points: Array[Array[Int]]): Double = {\\n      def area(p1: Array[Int], p2: Array[Int], p3: Array[Int]): Double =\\n        math.abs((p1(0)*p2(1) + p2(0)*p3(1) + p3(0)*p1(1) - p1(0)*p3(1) - p2(0)*p1(1) - p3(0)*p2(1))/2.0)\\n\\n      (for {\\n        i <- points.indices\\n        j <- i+1 until points.length\\n        k <- j+1 until points.length\\n      } yield area(points(i), points(j), points(k))).max\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3602149,
                "title": "simple-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst youhave to select 3 coordinates from the list,\\nAfter That The formula of area of triangle formula in coordinate geometry is: A = (1/2) |x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2)|\\nApply it You will win. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n            area = 0\\n    \\n            for i in range(len(points)-2):\\n                x1,y1 = points[i]\\n                for j in range(i+1,len(points)-1):\\n                    x2,y2 = points[j]\\n                    for k in range(j+1,len(points)):\\n                        x3,y3 = points[k]\\n                        curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                        if (curr_area > area):\\n                            area = curr_area\\n        \\n            return area\\n```\\nIf you Like \\nPlz Up vote :)))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n            area = 0\\n    \\n            for i in range(len(points)-2):\\n                x1,y1 = points[i]\\n                for j in range(i+1,len(points)-1):\\n                    x2,y2 = points[j]\\n                    for k in range(j+1,len(points)):\\n                        x3,y3 = points[k]\\n                        curr_area = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                        if (curr_area > area):\\n                            area = curr_area\\n        \\n            return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601315,
                "title": "java-faster-than-95-bits-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double calculateArea(int i,int j,int k,int[][] points){\\n        int x1=points[i][0];\\n        int x2=points[j][0];\\n        int x3=points[k][0];\\n        int y1=points[i][1];\\n        int y2=points[j][1];\\n        int y3=points[k][1];\\n\\n        double ans;\\n        ans=Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))*0.5);\\n        return ans;\\n    }\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double ans=0;\\n        for(int i=0;i<points.length;i++){\\n            for(int j=i+1;j<=points.length;j++){\\n                for(int k=j+1;k<points.length;k++){\\n                    double area=calculateArea(i,j,k,points);\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double calculateArea(int i,int j,int k,int[][] points){\\n        int x1=points[i][0];\\n        int x2=points[j][0];\\n        int x3=points[k][0];\\n        int y1=points[i][1];\\n        int y2=points[j][1];\\n        int y3=points[k][1];\\n\\n        double ans;\\n        ans=Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))*0.5);\\n        return ans;\\n    }\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double ans=0;\\n        for(int i=0;i<points.length;i++){\\n            for(int j=i+1;j<=points.length;j++){\\n                for(int k=j+1;k<points.length;k++){\\n                    double area=calculateArea(i,j,k,points);\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557653,
                "title": "java-brute-force",
                "content": "# Intuition\\nInitialize a variable maxArea to keep track of the maximum triangle area found. Initially, set it to 0.\\n\\nIterate over the array of points using three nested loops. The outer loop selects the first point, the middle loop selects the second point, and the inner loop selects the third point.\\n\\nFor each combination of three points, calculate the area of the triangle formed by these points using the calculateArea method.\\n\\nUpdate the maxArea if the calculated area is greater than the current maximum.\\n\\nAfter checking all possible combinations, return the maxArea as the result.\\n\\nThe calculateArea method implements the shoelace formula, also known as the formula for the area of a triangle given three points. It takes three points as input and calculates the area using the absolute value of the sum of the products of the coordinates of the points.\\n\\n# Complexity\\n- Time complexity:\\n\\no(n)cube\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n\\n       double maxArea = 0.0;\\n        int n = points.length;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p1 = points[i];\\n                    int[] p2 = points[j];\\n                    int[] p3 = points[k];\\n\\n                    double area = calculateArea(p1, p2, p3);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n      static double calculateArea(int[] p1, int[] p2, int[] p3) {\\n        double area = 0.5 * Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n        );\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n\\n       double maxArea = 0.0;\\n        int n = points.length;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    int[] p1 = points[i];\\n                    int[] p2 = points[j];\\n                    int[] p3 = points[k];\\n\\n                    double area = calculateArea(p1, p2, p3);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n      static double calculateArea(int[] p1, int[] p2, int[] p3) {\\n        double area = 0.5 * Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n        );\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538681,
                "title": "sumit",
                "content": "# Intuition\\neassy approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        n=len(points)\\n        h=[]\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    h.append(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))))\\n\\n        \\n            \\n        h.sort(reverse=True)\\n        return(h[0])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        n=len(points)\\n        h=[]\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    h.append(abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))))\\n\\n        \\n            \\n        h.sort(reverse=True)\\n        return(h[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519913,
                "title": "python-one-liner",
                "content": "# Intuition\\nUse formula for the area of triangle when 3 points are given.\\nJust check every tripplet and take the max.\\n$$\\nArea = 1/2[x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)]\\n$$\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        return max(abs(p[i][0]*(p[j][1]-p[k][1])+p[j][0]*(p[k][1]-p[i][1])+p[k][0]*(p[i][1]-p[j][1]))for i in range(len(p)-2) for j in range(i+1,len(p)-1)for k in range(j+1,len(p)))/2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        return max(abs(p[i][0]*(p[j][1]-p[k][1])+p[j][0]*(p[k][1]-p[i][1])+p[k][0]*(p[i][1]-p[j][1]))for i in range(len(p)-2) for j in range(i+1,len(p)-1)for k in range(j+1,len(p)))/2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475593,
                "title": "simple-javascript-solution",
                "content": "Please Upvote My Solution. Thankyou \\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0;\\n    for(let i of points) {\\n        for(let j of points){\\n            for(let k of points) {\\n                area = Math.max(area , Math.abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n            }\\n        }\\n    }\\n    return area;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0;\\n    for(let i of points) {\\n        for(let j of points){\\n            for(let k of points) {\\n                area = Math.max(area , Math.abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n            }\\n        }\\n    }\\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430757,
                "title": "better-3-line-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430754,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404863,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0\\n    const len = points.length;\\n    for (let i=0; i<len; i++) {\\n      [a1, b1] = points[i];\\n      for (let j = i+1; j<len; j++){\\n        [a2, b2] = points[j];\\n        for (let k = j+1; k<len; k++) {\\n          [a3, b3] = points[k];\\n          let value = Math.abs(0.5*(a1*(b2-b3)+a2*(b3-b1)+a3*(b1-b2)))\\n          if (value >area) area = value; \\n        }\\n      }\\n    }\\n    return area;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar largestTriangleArea = function(points) {\\n    let area = 0\\n    const len = points.length;\\n    for (let i=0; i<len; i++) {\\n      [a1, b1] = points[i];\\n      for (let j = i+1; j<len; j++){\\n        [a2, b2] = points[j];\\n        for (let k = j+1; k<len; k++) {\\n          [a3, b3] = points[k];\\n          let value = Math.abs(0.5*(a1*(b2-b3)+a2*(b3-b1)+a3*(b1-b2)))\\n          if (value >area) area = value; \\n        }\\n      }\\n    }\\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404579,
                "title": "beat-93percent-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying heroines formula of mathematics by taking 3 points at a time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398151,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        double largestTriangleArea(vector<vector<int>>& p) {\\n        double res = 0;\\n        for (auto &i : p)\\n            for (auto &j : p)\\n                for (auto &k : p)\\n            res = max(res, 0.5 * abs(i[0] * j[1] + j[0] * k[1] + k[0] * i[1]- j[0] * i[1] - k[0] * j[1] - i[0] * k[1]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396586,
                "title": "java-simple-solution-brutefroce-geometry",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    maxArea = Math.max(\\n                            maxArea,\\n                            Math.abs(area(points[i], points[j], points[k])));\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n\\n    public static double area(int[] x1, int[] x2, int[] x3) {\\n        int t1 = x1[0] * (x2[1] - x3[1]);\\n        int t2 = x2[0] * (x3[1] - x1[1]);\\n        int t3 = x3[0] * (x1[1] - x2[1]);\\n\\n        return (t1 + t2 + t3) / 2.;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0;\\n        int n = points.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    maxArea = Math.max(\\n                            maxArea,\\n                            Math.abs(area(points[i], points[j], points[k])));\\n                }\\n            }\\n        }\\n\\n        return maxArea;\\n    }\\n\\n    public static double area(int[] x1, int[] x2, int[] x3) {\\n        int t1 = x1[0] * (x2[1] - x3[1]);\\n        int t2 = x2[0] * (x3[1] - x1[1]);\\n        int t3 = x3[0] * (x1[1] - x2[1]);\\n\\n        return (t1 + t2 + t3) / 2.;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393583,
                "title": "c-short-code-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    using Point = std::vector<int32_t>;\\n\\n    double triangleArea(Point const& p0, Point const& p1, Point const& p2) {\\n        return 0.5 * std::abs((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]));\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int32_t i = 0; i < points.size(); i++) {\\n            for(int32_t j = i + 1; j < points.size(); j++) {\\n                for(int32_t k = j + 1; k < points.size(); k++) {\\n                    double area = triangleArea(points[i], points[j], points[k]);\\n                    result = std::max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using Point = std::vector<int32_t>;\\n\\n    double triangleArea(Point const& p0, Point const& p1, Point const& p2) {\\n        return 0.5 * std::abs((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]));\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0.0;\\n        for(int32_t i = 0; i < points.size(); i++) {\\n            for(int32_t j = i + 1; j < points.size(); j++) {\\n                for(int32_t k = j + 1; k < points.size(); k++) {\\n                    double area = triangleArea(points[i], points[j], points[k]);\\n                    result = std::max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380846,
                "title": "go-brute-force-o-n-3-please-let-me-know-if-you-find-faster-way-to-do-that",
                "content": "I fill like it is not optimal way, but it works. Let me know of you find better way to do that.\\n\\n# Code\\n```\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\tMAX := func(v1, v2 float64) float64 {\\n\\t\\tif v1 > v2 {\\n\\t\\t\\treturn v1\\n\\t\\t}\\n\\t\\treturn v2\\n\\t}\\n\\n\\tvar result float64\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// s = 1/2 (X2 * X1)(Y3-Y1) - (X3-X1)(Y2-Y1)\\n\\t\\t\\t\\tx1 := float64(points[i][0])\\n\\t\\t\\t\\ty1 := float64(points[i][1])\\n\\n\\t\\t\\t\\tx2 := float64(points[j][0])\\n\\t\\t\\t\\ty2 := float64(points[j][1])\\n\\n\\t\\t\\t\\tx3 := float64(points[k][0])\\n\\t\\t\\t\\ty3 := float64(points[k][1])\\n\\n\\t\\t\\t\\tresult = MAX(result, 0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n\\tMAX := func(v1, v2 float64) float64 {\\n\\t\\tif v1 > v2 {\\n\\t\\t\\treturn v1\\n\\t\\t}\\n\\t\\treturn v2\\n\\t}\\n\\n\\tvar result float64\\n\\tfor i := 0; i < len(points); i++ {\\n\\t\\tfor j := 0; j < len(points); j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 0; k < len(points); k++ {\\n\\t\\t\\t\\tif i == k || j == k {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// s = 1/2 (X2 * X1)(Y3-Y1) - (X3-X1)(Y2-Y1)\\n\\t\\t\\t\\tx1 := float64(points[i][0])\\n\\t\\t\\t\\ty1 := float64(points[i][1])\\n\\n\\t\\t\\t\\tx2 := float64(points[j][0])\\n\\t\\t\\t\\ty2 := float64(points[j][1])\\n\\n\\t\\t\\t\\tx3 := float64(points[k][0])\\n\\t\\t\\t\\ty3 := float64(points[k][1])\\n\\n\\t\\t\\t\\tresult = MAX(result, 0.5*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361483,
                "title": "java-easy-and-fastest",
                "content": "\\tclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0.0;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i+1; j < points.length; j++) {\\n                for (int k = j+1; k < points.length; k++) {\\n                    double area = getTriangleArea(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, area);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n    private double getTriangleArea(int[] p1, int[] p2, int[] p3) {\\n        return 0.5 * Math.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]));\\n    }\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "class Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double maxArea = 0.0;\\n        for (int i = 0; i < points.length; i++) {\\n            for (int j = i+1; j < points.length; j++) {\\n                for (int k = j+1; k < points.length; k++) {\\n                    double area = getTriangleArea(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, area);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3352507,
                "title": "largest-triangle-area-problem-c",
                "content": "\\n\\n# Approach\\nThis is a C++ code that calculates the largest possible area of a triangle using the coordinates of given points. The function largestTriangleArea takes a 2D vector points as input, where each element is a 2D vector representing the (x, y) coordinates of a point on a plane.\\n\\nThe code uses a brute-force approach to calculate the area of all possible triangles that can be formed using the given points. It does this by iterating through all possible combinations of three points and calculating the area of the triangle formed by them using the formula for the area of a triangle:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxarea=INT_MIN;\\n        double area=0;\\n        int i,j,k;\\n        double x1,x2,y1,y2,x3,y3;\\n        int n=points.size();\\n        for(i=0;i<n;i++)\\n        {\\n            x1=points[i][0];\\n            y1=points[i][1];\\n            for(j=i+1;j<n;j++)\\n            {\\n                x2=points[j][0];\\n                y2=points[j][1];\\n                for(k=j+1;k<n;k++)\\n                {\\n                    x3=points[k][0];\\n                    y3=points[k][1];\\n                    area=0.5*(abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)));\\n                    if(area>maxarea)\\n                    {\\n                        maxarea=area;\\n                    }\\n                }\\n            }\\n        }\\n        return maxarea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328508,
                "title": "3-nested-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ar=0\\n        for i in range(0,len(points)-2):\\n            x1,y1=points[i]\\n            for j in range (i,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > ar:\\n                        ar=abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        return ar\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ar=0\\n        for i in range(0,len(points)-2):\\n            x1,y1=points[i]\\n            for j in range (i,len(points)-1):\\n                x2,y2=points[j]\\n                for k in range(j,len(points)):\\n                    x3,y3=points[k]\\n                    if abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))) > ar:\\n                        ar=abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n        return ar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274960,
                "title": "code-for-find-the-maximum-area-of-the-triangle",
                "content": "# Code for find Maximum area of the triangle.\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }\\n    \\n    // function for finding area of a triangle using Heron\\'s formula\\n    \\n    double find_area(double a, double b, double c)\\n    {\\n        double s = (a + b + c) / 2;\\n        \\n        double area = s * (s - a) * (s - b) * (s - c);\\n        \\n        return sqrt(area);\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        \\n        int n = points.size();\\n        \\n        double maxi = 0;\\n        \\n        // find the area of triangle using every triplet and then take maximum of it\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double x1 = points[i][0];\\n                    \\n            double y1 = points[i][1];\\n            \\n            for(int j = i + 1; j < n; j++)\\n            {\\n                double x2 = points[j][0];\\n                    \\n                double y2 = points[j][1];\\n                \\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    double x3 = points[k][0];\\n                    \\n                    double y3 = points[k][1];\\n                    \\n                    // find sides of the triangle\\n                    \\n                    double a = find_side(x1, y1, x2, y2);\\n                    \\n                    double b = find_side(x1, y1, x3, y3);\\n                    \\n                    double c = find_side(x2, y2, x3, y3);\\n                    \\n                    // find area of the triangle\\n                    \\n                    double area = find_area(a, b, c);\\n                    \\n                    // update maxi\\n                    \\n                    maxi = max(maxi, area);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // function for finding the side of triangle\\n    \\n    double find_side(double x1, double y1, double x2, double y2)\\n    {\\n        double side = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\\n        \\n        return side;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3225804,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int n = points.length;\\n        double maxArea = 0.0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++) {\\n                    double currArea = area(points[i], points[j], points[k]);\\n                    maxArea = Math.max(maxArea, currArea);\\n                }\\n\\n        return maxArea;\\n    }\\n\\n    public double area(int[] p1, int[] p2, int[] p3) {\\n        return \\n            Math.abs(\\n                p1[0] * (p2[1] - p3[1]) +\\n                p2[0] * (p3[1] - p1[1]) +\\n                p3[0] * (p1[1] - p2[1])\\n            ) / 2.0 ;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188955,
                "title": "math-approach",
                "content": "# Intuition\\nTake all points one by one and calculate the area of each triangle.\\n\\n# Approach\\nTake variable to store area.\\nIterate on all points and apply area formula.\\nNext compare area by max function and find max area.\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(int i = 0 ; i < points.size() ; i++)\\n        {\\n            for(int j = i + 1 ; j < points.size() ; j++)\\n            {\\n                for(int k = j + 1 ; k < points.size() ; k++)\\n                {\\n                    area = max(area , abs(0.5 * (points[i][0] * (points[j][1] - points[k][1]) + points[j][0] * (points[k][1] - points[i][1]) + points[k][0] * (points[i][1] - points[j][1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```*Italic*\\n---\\n\\n```javascript []\\nconsole.log(\\'Hello world!\\')\\n```javascript []\\n```\\n```\\nconsole.log(\\'Hello world!\\')\\n```javascript []\\n> ``$$[[console.log(\\'Hello world!\\')]()]()$$``\\n![Screenshot 2023-01-24 093700.png](https://assets.leetcode.com/users/images/978ea4d6-3655-4e90-9dc7-75f4605f0edb_1676462373.1911116.png)\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n```\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(int i = 0 ; i < points.size() ; i++)\\n        {\\n            for(int j = i + 1 ; j < points.size() ; j++)\\n            {\\n                for(int k = j + 1 ; k < points.size() ; k++)\\n                {\\n                    area = max(area , abs(0.5 * (points[i][0] * (points[j][1] - points[k][1]) + points[j][0] * (points[k][1] - points[i][1]) + points[k][0] * (points[i][1] - points[j][1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\n```javascript []\\nconsole.log(\\'Hello world!\\')\\n```\n```\\n```\n```javascript []\\n> ``$$[[console.log(\\'Hello world!\\')]()]()$$``\\n![Screenshot 2023-01-24 093700.png](https://assets.leetcode.com/users/images/978ea4d6-3655-4e90-9dc7-75f4605f0edb_1676462373.1911116.png)\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188881,
                "title": "math-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double area = 0;\\n        \\n        for(auto &i : points)\\n        {\\n            for(auto &j : points)\\n            {\\n                for(auto &k : points)\\n                {\\n                    area = max(area , abs(0.5 * (i[0] * (j[1] - k[1]) + j[0] * (k[1] - i[1]) + k[0] * (i[1] - j[1]))));\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188838,
                "title": "python-beats-92-with-explanation",
                "content": "# Intuition\\nAs there are at most 50 point, a brute force search should work. Given a triplet of points (x_1,y_1), (x_2,y_2) and (x_3,y_3), the area of the triangle with vertices these 3 points is \\n\\nA = 2^(-1)|x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|.\\n# Approach\\nWe run a brute force approach using the above formula and updating the answer if we find a larger area \\n\\n# Complexity\\n- Time complexity:\\nWe consider all the triples so we get O(n^3)\\n\\n- Space complexity:\\nO(1) as we keep track only of the largest area. \\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        ans  = 0\\n\\n        n = len(points)\\n\\n        for i in range(n):\\n            x_1,y_1 = points[i]\\n            for j in range(i+1,n):\\n                x_2,y_2 = points[j]\\n                for k in range(j+1,n):\\n                    x_3,y_3 = points[k]\\n\\n                    area0 = abs((x_1*(y_2-y_3) + x_2*(y_3-y_1) + x_3*(y_1-y_2))/2)\\n\\n                    if area0>= ans:\\n                        ans = area0\\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        ans  = 0\\n\\n        n = len(points)\\n\\n        for i in range(n):\\n            x_1,y_1 = points[i]\\n            for j in range(i+1,n):\\n                x_2,y_2 = points[j]\\n                for k in range(j+1,n):\\n                    x_3,y_3 = points[k]\\n\\n                    area0 = abs((x_1*(y_2-y_3) + x_2*(y_3-y_1) + x_3*(y_1-y_2))/2)\\n\\n                    if area0>= ans:\\n                        ans = area0\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161130,
                "title": "python-easy-solutions-3-for",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        area = 0\\n\\n        for i in points:\\n            for j in points:\\n                for k in points:\\n                    if i!=j and i!=k and j!=k:\\n                        r = ( (i[0]*j[1]) + (j[0]*k[1]) + (k[0]*i[1])) - ((i[0]*k[1]) + (k[0]*j[1]) + (j[0]*i[1]) )\\n                        r=r/2\\n                        if r>area:\\n                            area=r\\n        \\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\n        area = 0\\n\\n        for i in points:\\n            for j in points:\\n                for k in points:\\n                    if i!=j and i!=k and j!=k:\\n                        r = ( (i[0]*j[1]) + (j[0]*k[1]) + (k[0]*i[1])) - ((i[0]*k[1]) + (k[0]*j[1]) + (j[0]*i[1]) )\\n                        r=r/2\\n                        if r>area:\\n                            area=r\\n        \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149786,
                "title": "easy-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    double getArea(vector<int> a, vector<int> b, vector<int> c){\\n        return( a[0]* (b[1]-c[1]) + b[0] * (c[1]-a[1])+ c[0] * (a[1]-b[1]))/2.0;\\n    }\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double max=0.0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                    double area=abs(getArea(points[i],points[j],points[k]));\\n                    if(area>max){\\n                        max=area;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120108,
                "title": "easy-c-solution-using-array-math-geometry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solve this question using using Array + Math  + Geometry.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple we have check the area of every 3 point combination and return the maximum area and we have given cordination of geometry so we have apply the formula of the triangle area with 3 coordinates\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(N^3), where N is the length of points(Array).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: O(1) Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity: O(N^3), where N is the length of points(Array).\\n    Space Complexity: O(1) Constant Space.\\n                        \\n    Solved Using Array + Math + Geometry;\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size();\\n        double areaOfLargestTriangle = INT_MIN;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    double area = abs((1/2.0)*(points[i][0]*(points[j][1]-points[k][1]) + \\n                    points[j][0]*(points[k][1]-points[i][1]) + points[k][0]*(points[i][1]-points[j][1])));\\n                    areaOfLargestTriangle = max(areaOfLargestTriangle, area);\\n                }\\n            }\\n        }\\n        return areaOfLargestTriangle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity: O(N^3), where N is the length of points(Array).\\n    Space Complexity: O(1) Constant Space.\\n                        \\n    Solved Using Array + Math + Geometry;\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size();\\n        double areaOfLargestTriangle = INT_MIN;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    double area = abs((1/2.0)*(points[i][0]*(points[j][1]-points[k][1]) + \\n                    points[j][0]*(points[k][1]-points[i][1]) + points[k][0]*(points[i][1]-points[j][1])));\\n                    areaOfLargestTriangle = max(areaOfLargestTriangle, area);\\n                }\\n            }\\n        }\\n        return areaOfLargestTriangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117700,
                "title": "clean-solution",
                "content": "# Intuition\\nWe have to use three for loops here and complexity will be $$O(n^3)$$.\\n\\n# Approach\\nWe iterate through all points combination and take the max area. \\nTriangle area is calculated using the three points formulae.\\n\\n$$1/2 [x1 (y2 \\u2013 y3 ) + x2 (y3 \\u2013 y1 ) + x3(y1 \\u2013 y2)]$$\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double maxa=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double x1=points[i][0],y1=points[i][1];\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                double x2=points[j][0],y2=points[j][1];\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    double x3=points[k][0],y3=points[k][1];\\n                    maxa=max(maxa, 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                }\\n            }\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double maxa=0;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            double x1=points[i][0],y1=points[i][1];\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                double x2=points[j][0],y2=points[j][1];\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    double x3=points[k][0],y3=points[k][1];\\n                    maxa=max(maxa, 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                }\\n            }\\n        }\\n        return maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113567,
                "title": "simple-solution-brute-force-without-using-square-root-and-floating-point-variables",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size(), x1, y1, x2, y2, x3, y3, area, max_area = 0;\\n        for(int i = 0; i < n; i++) {\\n            x1 = points[i][0], y1 = points[i][1];\\n            for(int j = 0; j < n; j++) {\\n                x2 = points[j][0], y2 = points[j][1];\\n                for(int k = 0; k < n; k++) {\\n                    x3 = points[k][0], y3 = points[k][1];\\n                    area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\\n                    max_area = max(abs(area), max_area);\\n                }\\n            }\\n        }\\n        return 0.5 * double(max_area);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int n = points.size(), x1, y1, x2, y2, x3, y3, area, max_area = 0;\\n        for(int i = 0; i < n; i++) {\\n            x1 = points[i][0], y1 = points[i][1];\\n            for(int j = 0; j < n; j++) {\\n                x2 = points[j][0], y2 = points[j][1];\\n                for(int k = 0; k < n; k++) {\\n                    x3 = points[k][0], y3 = points[k][1];\\n                    area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);\\n                    max_area = max(abs(area), max_area);\\n                }\\n            }\\n        }\\n        return 0.5 * double(max_area);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107761,
                "title": "easy-c-solution-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n   class Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                     \\n                     double x1=points[i][0];\\n                     double y1=points[i][1];\\n                     double x2=points[j][0];\\n                     double y2=points[j][1];\\n                     double x3=points[k][0];\\n                     double y3=points[k][1];\\n\\n                     double area=0.5 * (abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                    maxi=max(area,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};  \\n\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double maxi=0;\\n        for(int i=0;i<points.size();i++){\\n            for(int j=i+1;j<points.size();j++){\\n                for(int k=j+1;k<points.size();k++){\\n                     \\n                     double x1=points[i][0];\\n                     double y1=points[i][1];\\n                     double x2=points[j][0];\\n                     double y2=points[j][1];\\n                     double x3=points[k][0];\\n                     double y3=points[k][1];\\n\\n                     double area=0.5 * (abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)));\\n                    maxi=max(area,maxi);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3091654,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0;\\n        for (auto i = 0; i < points.size() - 2; ++i) {\\n            for (auto j = i + 1; j < points.size() - 1; ++j) {\\n                for (auto k = j + 1; k < points.size(); ++k) {\\n                    auto ij = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\\n                    auto ik = sqrt(pow(points[i][0] - points[k][0], 2) + pow(points[i][1] - points[k][1], 2));\\n                    auto jk = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2));\\n                    if (ij < ik + jk && ik < ij + jk && jk < ij + ik) {\\n                        auto s = (ij + ik + jk) / 2;\\n                        result = max(result, sqrt(s * (s - ij) * (s - ik) * (s - jk)));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double result = 0;\\n        for (auto i = 0; i < points.size() - 2; ++i) {\\n            for (auto j = i + 1; j < points.size() - 1; ++j) {\\n                for (auto k = j + 1; k < points.size(); ++k) {\\n                    auto ij = sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));\\n                    auto ik = sqrt(pow(points[i][0] - points[k][0], 2) + pow(points[i][1] - points[k][1], 2));\\n                    auto jk = sqrt(pow(points[j][0] - points[k][0], 2) + pow(points[j][1] - points[k][1], 2));\\n                    if (ij < ik + jk && ik < ij + jk && jk < ij + ik) {\\n                        auto s = (ij + ik + jk) / 2;\\n                        result = max(result, sqrt(s * (s - ij) * (s - ik) * (s - jk)));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071226,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        \\n        double ans = 0.0d;\\n\\n        for(int i=0; i<points.length-2; i++){\\n            for(int j=i+1; j<points.length-1; j++){\\n                for(int k=j+1; k<points.length; k++){\\n\\n                    double x1 = points[i][0]; double y1 = points[i][1];\\n                    double x2 = points[j][0]; double y2 = points[j][1];\\n                    double x3 = points[k][0]; double y3 = points[k][1];\\n\\n                    double area = Math.abs( (x1*(y2-y3)) + (x2*(y3-y1)) + (x3*(y1-y2)) ) / 2;\\n                    ans = Math.max(ans,area);\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        \\n        double ans = 0.0d;\\n\\n        for(int i=0; i<points.length-2; i++){\\n            for(int j=i+1; j<points.length-1; j++){\\n                for(int k=j+1; k<points.length; k++){\\n\\n                    double x1 = points[i][0]; double y1 = points[i][1];\\n                    double x2 = points[j][0]; double y2 = points[j][1];\\n                    double x3 = points[k][0]; double y3 = points[k][1];\\n\\n                    double area = Math.abs( (x1*(y2-y3)) + (x2*(y3-y1)) + (x3*(y1-y2)) ) / 2;\\n                    ans = Math.max(ans,area);\\n                    \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060722,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double result = 0;\\n        for (int x = 0; x < points.length; x++) {\\n            for (int y = x + 1; y < points.length; y++) {\\n                for (int z = y + 1; z < points.length; z++) {\\n                    double area = Math.abs((points[x][0] * points[y][1] +\\n                                            points[y][0] * points[z][1] +\\n                                            points[z][0] * points[x][1]) - \\n                            \\n                                            (points[x][1] * points[y][0] + \\n                                            points[y][1] * points[z][0] +\\n                                            points[z][1] * points[x][0])) / (double) 2;\\n                    result = Math.max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double result = 0;\\n        for (int x = 0; x < points.length; x++) {\\n            for (int y = x + 1; y < points.length; y++) {\\n                for (int z = y + 1; z < points.length; z++) {\\n                    double area = Math.abs((points[x][0] * points[y][1] +\\n                                            points[y][0] * points[z][1] +\\n                                            points[z][0] * points[x][1]) - \\n                            \\n                                            (points[x][1] * points[y][0] + \\n                                            points[y][1] * points[z][0] +\\n                                            points[z][1] * points[x][0])) / (double) 2;\\n                    result = Math.max(result, area);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060398,
                "title": "python-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the largest area of a triangle that can be formed using a given list of points.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem by using the shoelace formula to calculate the area of each triangle that can be formed using 3 points from the list of points. The shoelace formula is a mathematical formula that can be used to calculate the area of a polygon by summing the product of the coordinates of the vertices of the polygon.\\n\\nWe can use the itertools.combinations function to generate all possible combinations of 3 points from the list of points. We can then use the shoelace formula to calculate the area of each triangle and keep track of the largest area.\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area(a, b, c):\\n            return 0.5 * abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1] - a[1] * b[0] - b[1] * c[0] - c[1] * a[0])\\n        return max(area(*triangle) for triangle in itertools.combinations(points, 3))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area(a, b, c):\\n            return 0.5 * abs(a[0] * b[1] + b[0] * c[1] + c[0] * a[1] - a[1] * b[0] - b[1] * c[0] - c[1] * a[0])\\n        return max(area(*triangle) for triangle in itertools.combinations(points, 3))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053691,
                "title": "basic-area-of-triangle-formula",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = 0.0\\n\\n        def calc_area(p1, p2, p3):\\n            return abs(0.5*( p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]) ))\\n\\n        for i in range(0,len(points)-2):\\n            for j in range(i+1, len(points)-1):\\n                for k in range(j+1, len(points)):\\n                    area = max(area, calc_area(points[i], points[j], points[k]))\\n\\n        print(area)\\n        return area\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestTriangleArea(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        area = 0.0\\n\\n        def calc_area(p1, p2, p3):\\n            return abs(0.5*( p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]) ))\\n\\n        for i in range(0,len(points)-2):\\n            for j in range(i+1, len(points)-1):\\n                for k in range(j+1, len(points)):\\n                    area = max(area, calc_area(points[i], points[j], points[k]))\\n\\n        print(area)\\n        return area\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030146,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        val n = points.size\\n        var max = 0.0\\n        for (i in 0..n-3) {\\n            for (j in i+1..n-2) {\\n                for (k in j+1..n-1) {\\n                    max = maxOf(max, calArea(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return max\\n    }\\n\\n    private fun calArea(p1: IntArray, p2: IntArray, p3: IntArray): Double {\\n        return Math.abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1]))/2.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestTriangleArea(points: Array<IntArray>): Double {\\n        val n = points.size\\n        var max = 0.0\\n        for (i in 0..n-3) {\\n            for (j in i+1..n-2) {\\n                for (k in j+1..n-1) {\\n                    max = maxOf(max, calArea(points[i], points[j], points[k]))\\n                }\\n            }\\n        }\\n        return max\\n    }\\n\\n    private fun calArea(p1: IntArray, p2: IntArray, p3: IntArray): Double {\\n        return Math.abs(p1[0]*(p2[1]-p3[1])+p2[0]*(p3[1]-p1[1])+p3[0]*(p1[1]-p2[1]))/2.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009209,
                "title": "c-area-of-triangle-math-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was to obviously look for methods to find the area of triangle using geometry \\nSo, i found three methods to go around the solution and chose the one suitable for me\\n\\nIf you want to read and look at the methods\\n\\n[Methods To Find area of triangle using math](https://byjus.com/maths/area-triangle-coordinate-geometry/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn above link you will be able to find 3 methods to solve this specific problem and i went with the method 3, so you can take a look at that method before reading the approach\\n\\nNow we need 3 pair of points in minimum to create a triangle in the cartesian plane, \\n\\n1) so we create three for loop so we can take 3 pair of points from the given points vector. now because we need three pair minimum and in cartesian plane no pair can be repeated we take a gap of 1 pair between each thats why we take  <i < points.size()-2 >, <j < points.size()-1> and <i < points.size()>\\n\\n2) now we pass these pair of points to 3 different vector named <pointX> , <pointY> and <pointZ>, so that we can access the individual index of each pair\\n\\n3) then we use are Method 3 formula to find the area and save it to temp\\n\\n4) using max function we compare <maxArea> and <temp> and check for max value , we do this till be have found the maximum area and finally return it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n3 for loop used for nesting so time complexity will be O(N^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nno extra space used so space complexity will be O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        float maxArea=0.0;\\n        for(int i=0;i<points.size()-2;i++)\\n        {\\n            for(int j=i+1;j<points.size()-1;j++)\\n            {\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    vector <int> pointX =points[i];\\n                    vector <int> pointY=points[j];\\n                    vector <int> pointZ=points[k];\\n                    float tempArea=0;\\n                    tempArea = 0.5*abs(pointX[0]*(pointY[1]-pointZ[1])+pointY[0]*(pointZ[1]-pointX[1])+pointZ[0]*(pointX[1]-pointY[1]));\\n                    maxArea = max(tempArea,maxArea);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        float maxArea=0.0;\\n        for(int i=0;i<points.size()-2;i++)\\n        {\\n            for(int j=i+1;j<points.size()-1;j++)\\n            {\\n                for(int k=j+1;k<points.size();k++)\\n                {\\n                    vector <int> pointX =points[i];\\n                    vector <int> pointY=points[j];\\n                    vector <int> pointZ=points[k];\\n                    float tempArea=0;\\n                    tempArea = 0.5*abs(pointX[0]*(pointY[1]-pointZ[1])+pointY[0]*(pointZ[1]-pointX[1])+pointZ[0]*(pointX[1]-pointY[1]));\\n                    maxArea = max(tempArea,maxArea);\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007770,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        \\n        func area(_ x: [Double], _ y: [Double], _ z: [Double]) -> Double {\\n            \\n            let a = ((x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1])).squareRoot()\\n            let b = ((z[0] - y[0]) * (z[0] - y[0]) + (z[1] - y[1]) * (z[1] - y[1])).squareRoot()\\n            let c = ((z[0] - x[0]) * (z[0] - x[0]) + (z[1] - x[1]) * (z[1] - x[1])).squareRoot()\\n            \\n            let s = (a + b + c) / 2\\n            \\n            return (s * (s - a) * (s - b) * (s - c)).squareRoot()\\n        }\\n        \\n        let p = points.map { $0.map(Double.init) }\\n        \\n        var res = 0.0\\n        \\n        for i in 0..<p.count {\\n            for j in 0..<p.count where j != i {\\n                for l in 0..<p.count where l != i && l != j {\\n                    res = max(res, area(p[i], p[j], p[l]))\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestTriangleArea(_ points: [[Int]]) -> Double {\\n        \\n        func area(_ x: [Double], _ y: [Double], _ z: [Double]) -> Double {\\n            \\n            let a = ((x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1])).squareRoot()\\n            let b = ((z[0] - y[0]) * (z[0] - y[0]) + (z[1] - y[1]) * (z[1] - y[1])).squareRoot()\\n            let c = ((z[0] - x[0]) * (z[0] - x[0]) + (z[1] - x[1]) * (z[1] - x[1])).squareRoot()\\n            \\n            let s = (a + b + c) / 2\\n            \\n            return (s * (s - a) * (s - b) * (s - c)).squareRoot()\\n        }\\n        \\n        let p = points.map { $0.map(Double.init) }\\n        \\n        var res = 0.0\\n        \\n        for i in 0..<p.count {\\n            for j in 0..<p.count where j != i {\\n                for l in 0..<p.count where l != i && l != j {\\n                    res = max(res, area(p[i], p[j], p[l]))\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947888,
                "title": "very-inefficient-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEz, just calculate the area of all the triangles formed and return the largest value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBRUTE FORCE! the area calculation with 3 $for$ loops, one for each point. Get the formula for area of a triangle in cartesian coordinates from your high school math textbook.\\n\\n# Complexity\\n- Time complexity: _Extremely_ inefficient O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ans = 0\\n        for x in range(len(points)):\\n            for y in range(1, len(points)):\\n                for z in range(2, len(points)):\\n                    ans = max(ans, \\n                    abs(1/2 * (points[x][0]* (points[y][1] - points[z][1]) + points[y][0] * \\n                    (points[z][1] - points[x][1]) + points[z][0] * (points[x][1] - points[y][1]))))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        ans = 0\\n        for x in range(len(points)):\\n            for y in range(1, len(points)):\\n                for z in range(2, len(points)):\\n                    ans = max(ans, \\n                    abs(1/2 * (points[x][0]* (points[y][1] - points[z][1]) + points[y][0] * \\n                    (points[z][1] - points[x][1]) + points[z][0] * (points[x][1] - points[y][1]))))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947437,
                "title": "99-faster-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int len=points.length;\\n        double ar=Integer.MIN_VALUE;\\n        for(int i=0;i<len-2;i++)\\n        {\\n            for(int j=i+1;j<len-1;j++)\\n            {\\n                for(int k=j+1;k<len;k++)\\n\\n{\\n    ar=Math.max(ar,area(points[i],points[j],points[k]));\\n}            }\\n        }\\n        return ar;\\n    }\\npublic double area(int[] a,int[] b,int[] c)\\n{\\n    return Math.abs(((a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-a[0]*c[1]-b[0]*a[1]-c[0]*b[1])*1.0)/2.0);\\n}\\n    \\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        int len=points.length;\\n        double ar=Integer.MIN_VALUE;\\n        for(int i=0;i<len-2;i++)\\n        {\\n            for(int j=i+1;j<len-1;j++)\\n            {\\n                for(int k=j+1;k<len;k++)\\n\\n{\\n    ar=Math.max(ar,area(points[i],points[j],points[k]));\\n}            }\\n        }\\n        return ar;\\n    }\\npublic double area(int[] a,int[] b,int[] c)\\n{\\n    return Math.abs(((a[0]*b[1]+b[0]*c[1]+c[0]*a[1]-a[0]*c[1]-b[0]*a[1]-c[0]*b[1])*1.0)/2.0);\\n}\\n    \\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939234,
                "title": "python3-concise-solution-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:        \\n       \\n        area = 0\\n        n = len(points)\\n        for i in range(n):\\n            x1,y1 = points[i]\\n            for j in range(i+1,n):\\n                x2,y2 = points[j]\\n                for k in range(j+1,n):\\n                    x3,y3 = points[k]\\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\\n                    if curr>area:\\n                        area = curr\\n        return area\\n                    \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933195,
                "title": "simple-solution-using-basic-math-formulae-100ms",
                "content": "# Intuition\\nThis question seems easy at first when you think you have to use formulae of finding area of a triangle but becomes tricky when you realise it area of a triangle using coordinates not length sides etc.\\nso formulae here would be |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|and not(1/2*base*height) or if you try solving it using s = (a + b + c)/2\\n\\u221A[s \\xD7 (s \\u2013 a) \\xD7 (s \\u2013 b) \\xD7 (s \\u2013 c)] then the calculation becomes a little lengthier. Hence simple approach is to use |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)| formulae all you need to do is get the coordinates of the triangle ad put in the formulae.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area_cal(corr1, corr2, corr3):\\n            (x1, y1), (x2, y2), (x3, y3) = corr1, corr2, corr3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(area_cal(corr1, corr2, corr3) for corr1, corr2, corr3 in itertools.combinations(points, 3))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        def area_cal(corr1, corr2, corr3):\\n            (x1, y1), (x2, y2), (x3, y3) = corr1, corr2, corr3\\n            return 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\\n        return max(area_cal(corr1, corr2, corr3) for corr1, corr2, corr3 in itertools.combinations(points, 3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864041,
                "title": "c-easy-pure-math-formula-nothing-special",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var s = -1.0;\\n        for(int i=0;i<points.Length-2;i++){\\n            for(int j=i+1;j<points.Length-1;j++){\\n                for(int k=j+1;k<points.Length;k++){\\n                    var currentArea = GetArea(new int[][]{points[i], points[j], points[k]});\\n                    if(s < currentArea){\\n                        s = currentArea;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n\\n    private double GetArea(int[][] point){\\n        var a = Math.Sqrt(Math.Pow(point[0][0] - point[1][0], 2) + Math.Pow(point[0][1] - point[1][1], 2));\\n        var b = Math.Sqrt(Math.Pow(point[1][0] - point[2][0], 2) + Math.Pow(point[1][1] - point[2][1], 2));\\n        var c = Math.Sqrt(Math.Pow(point[2][0] - point[0][0], 2) + Math.Pow(point[2][1] - point[0][1], 2));\\n        var avg = (a+b+c)/2;\\n        var s = Math.Sqrt(avg*(avg-a)*(avg-b)*(avg-c));\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double LargestTriangleArea(int[][] points) {\\n        var s = -1.0;\\n        for(int i=0;i<points.Length-2;i++){\\n            for(int j=i+1;j<points.Length-1;j++){\\n                for(int k=j+1;k<points.Length;k++){\\n                    var currentArea = GetArea(new int[][]{points[i], points[j], points[k]});\\n                    if(s < currentArea){\\n                        s = currentArea;\\n                    }\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n\\n    private double GetArea(int[][] point){\\n        var a = Math.Sqrt(Math.Pow(point[0][0] - point[1][0], 2) + Math.Pow(point[0][1] - point[1][1], 2));\\n        var b = Math.Sqrt(Math.Pow(point[1][0] - point[2][0], 2) + Math.Pow(point[1][1] - point[2][1], 2));\\n        var c = Math.Sqrt(Math.Pow(point[2][0] - point[0][0], 2) + Math.Pow(point[2][1] - point[0][1], 2));\\n        var avg = (a+b+c)/2;\\n        var s = Math.Sqrt(avg*(avg-a)*(avg-b)*(avg-c));\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847374,
                "title": "c",
                "content": "```\\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double max = 0;\\n\\n    for(int i = 0; i < pointsSize-2; i++){\\n        for(int j = i+1; j < pointsSize-1; j++){\\n            for(int k = j+1; k < pointsSize; k++){\\n                   int x1 = points[i][0], y1 = points[i][1];\\n                   int x2 = points[j][0], y2 = points[j][1];\\n                   int x3 = points[k][0], y3 = points[k][1];\\n                   double area = fabs(0.5 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                   max = fmax(max, area);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble largestTriangleArea(int** points, int pointsSize, int* pointsColSize){\\n    double max = 0;\\n\\n    for(int i = 0; i < pointsSize-2; i++){\\n        for(int j = i+1; j < pointsSize-1; j++){\\n            for(int k = j+1; k < pointsSize; k++){\\n                   int x1 = points[i][0], y1 = points[i][1];\\n                   int x2 = points[j][0], y2 = points[j][1];\\n                   int x3 = points[k][0], y3 = points[k][1];\\n                   double area = fabs(0.5 * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3));\\n                   max = fmax(max, area);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2845874,
                "title": "python-simple-fromula-based",
                "content": "This is a brute force based approach where we iterate over all three sets of points and find the maximum area of traingles formed by all these sets of points.\\n**Time Complexity: O(n^3)\\nSpace Complexity: O(1)**\\n\\nArea of a triangle when three points of its vertices are given, is represented in matrix form as:\\n```\\nArea= (1/2)*abs(determinant(\\n[x1,y1,1],\\n[x2,y2,1],\\n[x3,y3,1]))\\n```\\nThis is expanded and used in a function as shown below\\n```\\ndef area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n```\\nThe complete solution is\\n```\\nclass Solution:\\n    def area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        maxarea=0\\n        for i in range(len(p)-2):\\n            for j in range(i+1,len(p)-1):\\n                for k in range(j+1,len(p)):\\n                    maxarea=max(maxarea,self.area(p[i][0],p[i][1],p[j][0],p[j][1],p[k][0],p[k][1]))\\n        return maxarea\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nArea= (1/2)*abs(determinant(\\n[x1,y1,1],\\n[x2,y2,1],\\n[x3,y3,1]))\\n```\n```\\ndef area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n```\n```\\nclass Solution:\\n    def area(self,x1,y1,x2,y2,x3,y3):\\n        return 0.5*abs((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\\n    def largestTriangleArea(self, p: List[List[int]]) -> float:\\n        maxarea=0\\n        for i in range(len(p)-2):\\n            for j in range(i+1,len(p)-1):\\n                for k in range(j+1,len(p)):\\n                    maxarea=max(maxarea,self.area(p[i][0],p[i][1],p[j][0],p[j][1],p[k][0],p[k][1]))\\n        return maxarea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844274,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double ans=0.0;\\n        int i=0;\\n        while(i<points.size())\\n        {\\n          int j=i+1;\\n          while(j<points.size())\\n          {\\n            int k=j+1;\\n            while(k<points.size())\\n            {\\n               //x1(y2-y3)\\n               double a=points[i][0]*(points[j][1]-points[k][1]);\\n               //x2(y3-y1)\\n               double b=points[j][0]*(points[k][1]-points[i][1]);\\n               //x3(y1-y2)\\n               double c=points[k][0]*(points[i][1]-points[j][1]);\\n               double x=0.5;\\n               long double area=(x)*(abs(a+b+c));\\n               if(area>ans)\\n               ans=area;\\n              //  cout<<\"area: \"<<area<<endl;\\n              //  v.push_back(area);\\n               k++;\\n            }\\n            j++;\\n          }\\n          i++;\\n        }\\n        //we cant use this below function as this max and min function is for int data types only.\\n        //int max=*max_element(v.begin(),v.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) \\n    {\\n        double ans=0.0;\\n        int i=0;\\n        while(i<points.size())\\n        {\\n          int j=i+1;\\n          while(j<points.size())\\n          {\\n            int k=j+1;\\n            while(k<points.size())\\n            {\\n               //x1(y2-y3)\\n               double a=points[i][0]*(points[j][1]-points[k][1]);\\n               //x2(y3-y1)\\n               double b=points[j][0]*(points[k][1]-points[i][1]);\\n               //x3(y1-y2)\\n               double c=points[k][0]*(points[i][1]-points[j][1]);\\n               double x=0.5;\\n               long double area=(x)*(abs(a+b+c));\\n               if(area>ans)\\n               ans=area;\\n              //  cout<<\"area: \"<<area<<endl;\\n              //  v.push_back(area);\\n               k++;\\n            }\\n            j++;\\n          }\\n          i++;\\n        }\\n        //we cant use this below function as this max and min function is for int data types only.\\n        //int max=*max_element(v.begin(),v.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2842832,
                "title": "optimized-brute-force-approach-10ms-89-7-5mb-90-c",
                "content": "1. Use formula to calculate triangle area given 3 points.\\n2. For each loop-shell, store the pointer to data of the specific point to reduce repeated access to vector.\\n3. Use integer operations all the time, store area result with 2x (so you don\\'t need to x0.5 and can keep using integer). Only need to do x0.5 for return.\\n4. Do not use function calls.\\n5. Area could be negative but you don\\'t need to use abs(), just negate the value if it is negative.\\n```\\nclass Solution {\\n    // Given the 3 points, calculate triangle area using formula:\\n    // area = 1/2 * abs[x1(y2-y3)+x2(y3-y1)+x3(y1-y2)]\\n    // Reference: https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int maxArea;\\n        int i, j, k, n;\\n        int *p0, *p1, *p2;\\n        int area;\\n        \\n        n = points.size();\\n        maxArea = 0;\\n        // Full search, need n*(n-1)*(n-2)/6 operations.\\n        for (i=0;i<n-2;i++) {\\n            p0 = points[i].data();\\n            for (j=i+1;j<n-1;j++) {\\n                p1 = points[j].data();\\n                for (k=j+1;k<n;k++) {\\n                    p2 = points[k].data();\\n                    area = p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]);\\n                    if (area < 0)\\n                        area = -area;\\n                    if (area > maxArea) {\\n                        maxArea = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (double) maxArea * 0.5;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    // Given the 3 points, calculate triangle area using formula:\\n    // area = 1/2 * abs[x1(y2-y3)+x2(y3-y1)+x3(y1-y2)]\\n    // Reference: https://www.cuemath.com/geometry/area-of-triangle-in-coordinate-geometry/\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        int maxArea;\\n        int i, j, k, n;\\n        int *p0, *p1, *p2;\\n        int area;\\n        \\n        n = points.size();\\n        maxArea = 0;\\n        // Full search, need n*(n-1)*(n-2)/6 operations.\\n        for (i=0;i<n-2;i++) {\\n            p0 = points[i].data();\\n            for (j=i+1;j<n-1;j++) {\\n                p1 = points[j].data();\\n                for (k=j+1;k<n;k++) {\\n                    p2 = points[k].data();\\n                    area = p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]);\\n                    if (area < 0)\\n                        area = -area;\\n                    if (area > maxArea) {\\n                        maxArea = area;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2829991,
                "title": "easy-c-solution-faster-than-58",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n         int l = p.size();\\n    double mx = 0;\\n    for (int i = 0; i < l - 2; i++) {\\n        for (int j = i + 1; j < l - 1; j++) {\\n            for (int k = j + 1; k < l; k++) {\\n                mx = max(mx, 0.5 * abs(\\n                                p[i][0] * (p[j][1] - p[k][1]) +\\n                                p[j][0] * (p[k][1] - p[i][1]) +\\n                                p[k][0] * (p[i][1] - p[j][1])\\n                ));\\n            }\\n        }\\n    }\\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double largestTriangleArea(vector<vector<int>>& p) {\\n         int l = p.size();\\n    double mx = 0;\\n    for (int i = 0; i < l - 2; i++) {\\n        for (int j = i + 1; j < l - 1; j++) {\\n            for (int k = j + 1; k < l; k++) {\\n                mx = max(mx, 0.5 * abs(\\n                                p[i][0] * (p[j][1] - p[k][1]) +\\n                                p[j][0] * (p[k][1] - p[i][1]) +\\n                                p[k][0] * (p[i][1] - p[j][1])\\n                ));\\n            }\\n        }\\n    }\\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801630,
                "title": "rust-not-so-fast-but-easy-to-understand",
                "content": "\\n}\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n\\t\\n\\t\\tfn find_area(a: Vec<i32>, b: Vec<i32>, c:Vec<i32>) ->f64{\\n\\t\\t\\tlet sum = a[0]*(b[1]-c[1]) + b[0] * (c[1]-a[1]) + c[0] * (a[1] - b[1]);\\n\\t\\t\\tlet sum = sum as f64 / 2.;\\n\\n\\t\\t\\tsum\\n        let mut highest = 0 as f64;\\n        for a in 0..points.len()-2{\\n            for b in 1+a..points.len()-1{\\n                for c in 1+b..points.len(){\\n                    let mut after = find_area(points[a].to_vec(), points[b].to_vec(), points[c].to_vec()).abs();\\n                    let out = f64::trunc(after  * 100000.0) / 100000.0;\\n                    if out > highest{\\n                        highest = out;\\n                    }\\n                }\\n            }\\n        }\\n        highest\\n    }\\n}",
                "solutionTags": [],
                "code": "\\n}\\nimpl Solution {\\n    pub fn largest_triangle_area(points: Vec<Vec<i32>>) -> f64 {\\n\\t\\n\\t\\tfn find_area(a: Vec<i32>, b: Vec<i32>, c:Vec<i32>) ->f64{\\n\\t\\t\\tlet sum = a[0]*(b[1]-c[1]) + b[0] * (c[1]-a[1]) + c[0] * (a[1] - b[1]);\\n\\t\\t\\tlet sum = sum as f64 / 2.;\\n\\n\\t\\t\\tsum\\n        let mut highest = 0 as f64;\\n        for a in 0..points.len()-2{\\n            for b in 1+a..points.len()-1{\\n                for c in 1+b..points.len(){\\n                    let mut after = find_area(points[a].to_vec(), points[b].to_vec(), points[c].to_vec()).abs();\\n                    let out = f64::trunc(after  * 100000.0) / 100000.0;\\n                    if out > highest{\\n                        highest = out;\\n                    }\\n                }\\n            }\\n        }\\n        highest\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2783108,
                "title": "python-clean-and-simple-solution",
                "content": "```\\nfrom itertools import combinations\\n\\nPoint = tuple[int, int]\\nTriangle = tuple[Point, Point, Point]\\n\\n\\nclass Solution:\\n\\n    def largestTriangleArea(self, points: list[Point]) -> float:\\n        \"\"\"\\n        @posted Solution: https://leetcode.com/problems/largest-triangle-area/discuss/2783108/Python-oror-Clean-and-Simple-Solution\\n        :param points:\\n        :return:\\n        \"\"\"\\n        # return max(self.area1(p) for p in combinations(points, 3))\\n        return max(self.area2(p) for p in combinations(points, 3))\\n\\n    @staticmethod\\n    def area2(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        (x1, y1), (x2, y2), (x3, y3) = p\\n\\n        return abs(\\n            x1 * (y2 - y3) +\\n            x2 * (y3 - y1) +\\n            x3 * (y1 - y2)\\n        ) / 2\\n\\n    @staticmethod\\n    def area1(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        #         x[i]  * (y[(i + 1) % 3]    -   y[(i + 2) % 3])\\n        a = sum(p[i][0] * (p[(i + 1) % 3][1] - p[(i + 2) % 3][1]) for i in range(3))\\n        return abs(a) / 2\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nPoint = tuple[int, int]\\nTriangle = tuple[Point, Point, Point]\\n\\n\\nclass Solution:\\n\\n    def largestTriangleArea(self, points: list[Point]) -> float:\\n        \"\"\"\\n        @posted Solution: https://leetcode.com/problems/largest-triangle-area/discuss/2783108/Python-oror-Clean-and-Simple-Solution\\n        :param points:\\n        :return:\\n        \"\"\"\\n        # return max(self.area1(p) for p in combinations(points, 3))\\n        return max(self.area2(p) for p in combinations(points, 3))\\n\\n    @staticmethod\\n    def area2(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        (x1, y1), (x2, y2), (x3, y3) = p\\n\\n        return abs(\\n            x1 * (y2 - y3) +\\n            x2 * (y3 - y1) +\\n            x3 * (y1 - y2)\\n        ) / 2\\n\\n    @staticmethod\\n    def area1(p: Triangle) -> float:\\n        \"\"\"\\n        @see https://flexbooks.ck12.org/cbook/ck-12-cbse-math-class-10/section/7.4/primary/lesson/references-for-advanced-understanding/\\n        :param p:\\n        :return:\\n        \"\"\"\\n        #         x[i]  * (y[(i + 1) % 3]    -   y[(i + 2) % 3])\\n        a = sum(p[i][0] * (p[(i + 1) % 3][1] - p[(i + 2) % 3][1]) for i in range(3))\\n        return abs(a) / 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767886,
                "title": "c-o-n-3-solution-approach-explained-with-equations",
                "content": "# Intuition\\nThe intuition behind solving this problem is to check the knowledge of basic geometry. We will be given some co-ordinates. And we need to make a triangle that has larger area. Just leave the `larger` portion for now. If we have any 3 co-ordinate what do we do to form a triangle? \\n - Draw lines between all 3 co-ordinates.\\n - Calculate side length of all 3 lines.\\n - Then apply Heron\\'s formula (https://www.mathopenref.com/heronsformula.html) to find out the area. \\n\\nRight?\\nHere we will do the same thing. By drawing lines, here we will calculate the distance among the co-ordinates. To calculate the distance between any two co-ordinate, we will use - $$sqrt{( (x_1-x_2)^2 + (y_1-y_2))^2}$$ formula.\\n\\nAfter having length of all three sides, we will use **Heron\\'s** formula which is - \\n$$s * (s-a) * (s-b) *(s-c)$$ where $$a, b, c = Length \\\\space of \\\\space sides$$ and $$ s = (a+b+c)\\\\div 2$$.\\n\\n# Approach\\n- We will run 3 nested loops which will denote selection of any three co-ordinates.\\n- Draw lines between those three co-ordinates which means calculate distance between any two points using abovementioned rule.\\n- Apply **Heron\\'s** formula to calculate area mentioned above.\\n- Calculate max among areas.\\n- Return the Max Area.\\n\\n# Complexity\\n- Time complexity: $$O(n*n*n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double get_distance(int x1, int y1, int x2, int y2){\\n        double x_dist = (x1 * 1.0) - (x2 * 1.0);\\n        x_dist *= x_dist;\\n        double y_dist = (y1 * 1.0) - (y2 * 1.0);\\n        y_dist *= y_dist;\\n        double dist = sqrt(x_dist + y_dist);\\n        return dist;\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<double>distance;\\n        int n = points.size();\\n        double ans_area = 0.0, side_a, side_b, side_c, sum, area;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    side_a = get_distance(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                    side_b = get_distance(points[i][0], points[i][1], points[k][0], points[k][1]);\\n                    side_c = get_distance(points[j][0], points[j][1], points[k][0], points[k][1]);\\n                    sum = (side_a + side_b + side_c)/2.0;\\n                    side_a = sum - side_a;\\n                    side_b = sum - side_b;\\n                    side_c = sum - side_c;\\n                    area = sqrt(sum * side_a * side_b * side_c);\\n                    ans_area = max(ans_area, area);\\n                }\\n            }\\n        }\\n        return ans_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double get_distance(int x1, int y1, int x2, int y2){\\n        double x_dist = (x1 * 1.0) - (x2 * 1.0);\\n        x_dist *= x_dist;\\n        double y_dist = (y1 * 1.0) - (y2 * 1.0);\\n        y_dist *= y_dist;\\n        double dist = sqrt(x_dist + y_dist);\\n        return dist;\\n    }\\n\\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        vector<double>distance;\\n        int n = points.size();\\n        double ans_area = 0.0, side_a, side_b, side_c, sum, area;\\n        for(int i=0; i<n-2; i++){\\n            for(int j=i+1; j<n-1; j++){\\n                for(int k=j+1; k<n; k++){\\n                    side_a = get_distance(points[i][0], points[i][1], points[j][0], points[j][1]);\\n                    side_b = get_distance(points[i][0], points[i][1], points[k][0], points[k][1]);\\n                    side_c = get_distance(points[j][0], points[j][1], points[k][0], points[k][1]);\\n                    sum = (side_a + side_b + side_c)/2.0;\\n                    side_a = sum - side_a;\\n                    side_b = sum - side_b;\\n                    side_c = sum - side_c;\\n                    area = sqrt(sum * side_a * side_b * side_c);\\n                    ans_area = max(ans_area, area);\\n                }\\n            }\\n        }\\n        return ans_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735179,
                "title": "go-brute-force",
                "content": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n    area := 0.0\\n    l := len(points)\\n    \\n    for  p1 := 0; p1 < l; p1++ {\\n        for p2 := p1 + 1; p2 < l; p2++ {\\n            for p3 := p2 + 1; p3 < l; p3++ {\\n                    area = math.Max(area, getArea(points[p1], points[p2], points[p3]))\\n                }\\n            }\\n        }\\n    \\n    return area\\n}\\n\\nfunc getArea(p1, p2, p3 []int) float64 {\\n        return math.Abs(float64(p2[0] - p1[0]) * float64(p3[1] - p1[1]) - \\n                        float64(0.5) * float64(p2[0] - p1[0]) * float64(p2[1] - p1[1]) - \\n                       float64(0.5) * float64(p3[0] - p1[0]) * float64(p3[1] - p1[1]) -\\n                       float64(0.5) * float64(p2[0] - p3[0]) * float64(p3[1] - p2[1]))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc largestTriangleArea(points [][]int) float64 {\\n    area := 0.0\\n    l := len(points)\\n    \\n    for  p1 := 0; p1 < l; p1++ {\\n        for p2 := p1 + 1; p2 < l; p2++ {\\n            for p3 := p2 + 1; p3 < l; p3++ {\\n                    area = math.Max(area, getArea(points[p1], points[p2], points[p3]))\\n                }\\n            }\\n        }\\n    \\n    return area\\n}\\n\\nfunc getArea(p1, p2, p3 []int) float64 {\\n        return math.Abs(float64(p2[0] - p1[0]) * float64(p3[1] - p1[1]) - \\n                        float64(0.5) * float64(p2[0] - p1[0]) * float64(p2[1] - p1[1]) - \\n                       float64(0.5) * float64(p3[0] - p1[0]) * float64(p3[1] - p1[1]) -\\n                       float64(0.5) * float64(p2[0] - p3[0]) * float64(p3[1] - p2[1]))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714619,
                "title": "easy-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    inline double triangleSquare(int x1, int y1, int x2, int y2, int x3, int y3)\\n    {\\n        return 0.5 * abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1));\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double square = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i; j < points.size(); j++)\\n            {\\n                for(int k = j; k < points.size(); k++)\\n                {\\n                    double s = triangleSquare(points[i][0], points[i][1], points[j][0], points[j][1],\\n                                              points[k][0], points[k][1]);\\n                    if(square < s)\\n                    {\\n                        square = s;\\n                    }\\n                }\\n            }\\n        }\\n        return square;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline double triangleSquare(int x1, int y1, int x2, int y2, int x3, int y3)\\n    {\\n        return 0.5 * abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1));\\n    }\\n    \\n    double largestTriangleArea(vector<vector<int>>& points) {\\n        double square = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            for(int j = i; j < points.size(); j++)\\n            {\\n                for(int k = j; k < points.size(); k++)\\n                {\\n                    double s = triangleSquare(points[i][0], points[i][1], points[j][0], points[j][1],\\n                                              points[k][0], points[k][1]);\\n                    if(square < s)\\n                    {\\n                        square = s;\\n                    }\\n                }\\n            }\\n        }\\n        return square;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707027,
                "title": "js-please-help-with-my-js-code-failed-two-test-case",
                "content": "i have passed 55 test case out of 57 with the below code , please help with this code about the other tw test case\\n\\n```\\nvar largestTriangleArea = function(points) {\\n    let pos = []\\n    let side_arr = []\\n    let arr = []\\n    \\n    \\n    for(let i = 0; i<points.length-2; i++){\\n        for(let j = i+1; j<points.length; j++){\\n            for(let k= j+1; k<points.length; k++){\\n                pos.push([points[i],points[j],points[k]])\\n            }\\n        }\\n    }\\n    \\n    for(let i=0; i<pos.length; i++){\\n         let a = Math.sqrt( ((pos[i][0][0]-pos[i][1][0])**2) + ((pos[i][0][1]-pos[i][1][1])**2) )\\n         let b = Math.sqrt( ((pos[i][1][0]-pos[i][2][0])**2) + ((pos[i][1][1]-pos[i][2][1])**2) )\\n         let c = Math.sqrt( ((pos[i][0][0]-pos[i][2][0])**2) + ((pos[i][0][1]-pos[i][2][1])**2) )\\n         \\n        side_arr.push([a,b,c])                           \\n    }\\n    \\n    for(let i=0; i<side_arr.length; i++){\\n        let p = (side_arr[i][0] + side_arr[i][1] + side_arr[i][2])/2\\n        let area = Math.sqrt( p*(p-side_arr[i][0])*(p-side_arr[i][1])*(p-side_arr[i][2]) )\\n        arr.push(area)\\n    }\\n    \\n    let ans = arr.sort((a,b)=>b-a)\\n    \\n    return ans[0]\\n\\t\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar largestTriangleArea = function(points) {\\n    let pos = []\\n    let side_arr = []\\n    let arr = []\\n    \\n    \\n    for(let i = 0; i<points.length-2; i++){\\n        for(let j = i+1; j<points.length; j++){\\n            for(let k= j+1; k<points.length; k++){\\n                pos.push([points[i],points[j],points[k]])\\n            }\\n        }\\n    }\\n    \\n    for(let i=0; i<pos.length; i++){\\n         let a = Math.sqrt( ((pos[i][0][0]-pos[i][1][0])**2) + ((pos[i][0][1]-pos[i][1][1])**2) )\\n         let b = Math.sqrt( ((pos[i][1][0]-pos[i][2][0])**2) + ((pos[i][1][1]-pos[i][2][1])**2) )\\n         let c = Math.sqrt( ((pos[i][0][0]-pos[i][2][0])**2) + ((pos[i][0][1]-pos[i][2][1])**2) )\\n         \\n        side_arr.push([a,b,c])                           \\n    }\\n    \\n    for(let i=0; i<side_arr.length; i++){\\n        let p = (side_arr[i][0] + side_arr[i][1] + side_arr[i][2])/2\\n        let area = Math.sqrt( p*(p-side_arr[i][0])*(p-side_arr[i][1])*(p-side_arr[i][2]) )\\n        arr.push(area)\\n    }\\n    \\n    let ans = arr.sort((a,b)=>b-a)\\n    \\n    return ans[0]\\n\\t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704241,
                "title": "python-using-3-loop",
                "content": "\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        # base theory: Ax(By-Cy)+Bx(Cy-Ay)+Cx(Ay-By)\\n        def triangle(A,B,C):\\n            return abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1])) / 2\\n        largestArea = 0\\n        length = len(points)\\n        for i in range(length):  \\n            for j in range(i+1, length):\\n                for k in range(j+1, length):\\n                    largestArea = max(largestArea, triangle(points[i],points[j],points[k]))\\n        return largestArea",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def largestTriangleArea(self, points: List[List[int]]) -> float:\\n        # base theory: Ax(By-Cy)+Bx(Cy-Ay)+Cx(Ay-By)\\n        def triangle(A,B,C):\\n            return abs(A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1])) / 2\\n        largestArea = 0\\n        length = len(points)\\n        for i in range(length):  \\n            for j in range(i+1, length):\\n                for k in range(j+1, length):\\n                    largestArea = max(largestArea, triangle(points[i],points[j],points[k]))\\n        return largestArea",
                "codeTag": "Python3"
            },
            {
                "id": 2696584,
                "title": "python-straightforward-solution-faster-than-6-time-o-n-3-space-o-1",
                "content": "\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tnum_points = len(points)\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tlengths_list = list()\\n\\t\\t\\tfor i in range(num_points-2): \\n\\t\\t\\t\\tfor j in range(i+1, num_points-1): \\n\\t\\t\\t\\t\\tfor k in range(j+1, num_points): \\n\\t\\t\\t\\t\\t\\txi, yi = points[i]\\n\\t\\t\\t\\t\\t\\txj, yj = points[j]\\n\\t\\t\\t\\t\\t\\txk, yk = points[k]\\n\\t\\t\\t\\t\\t\\tside_a = ((xi - xj)**2 + (yi - yj)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_b = ((xi - xk)**2 + (yi - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_c = ((xj - xk)**2 + (yj - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tshort_side = min(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tlong_side = max(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tmid_side = (side_a+side_b+side_c)-short_side-long_side                                     \\n\\t\\t\\t\\t\\t\\tif short_side+mid_side>long_side:\\n\\t\\t\\t\\t\\t\\t\\tp = (side_a+side_b+side_c)/2\\n\\t\\t\\t\\t\\t\\t\\t# print(p, side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\t\\tcurr_area = (p*(p-side_a)*(p-side_b)*(p-side_c))**0.5\\n\\t\\t\\t\\t\\t\\t\\tif res<curr_area:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = curr_area\\n\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestTriangleArea(self, points: List[List[int]]) -> float:\\n\\t\\t\\tnum_points = len(points)\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tlengths_list = list()\\n\\t\\t\\tfor i in range(num_points-2): \\n\\t\\t\\t\\tfor j in range(i+1, num_points-1): \\n\\t\\t\\t\\t\\tfor k in range(j+1, num_points): \\n\\t\\t\\t\\t\\t\\txi, yi = points[i]\\n\\t\\t\\t\\t\\t\\txj, yj = points[j]\\n\\t\\t\\t\\t\\t\\txk, yk = points[k]\\n\\t\\t\\t\\t\\t\\tside_a = ((xi - xj)**2 + (yi - yj)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_b = ((xi - xk)**2 + (yi - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tside_c = ((xj - xk)**2 + (yj - yk)**2)**0.5\\n\\t\\t\\t\\t\\t\\tshort_side = min(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tlong_side = max(side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\tmid_side = (side_a+side_b+side_c)-short_side-long_side                                     \\n\\t\\t\\t\\t\\t\\tif short_side+mid_side>long_side:\\n\\t\\t\\t\\t\\t\\t\\tp = (side_a+side_b+side_c)/2\\n\\t\\t\\t\\t\\t\\t\\t# print(p, side_a, side_b, side_c)\\n\\t\\t\\t\\t\\t\\t\\tcurr_area = (p*(p-side_a)*(p-side_b)*(p-side_c))**0.5\\n\\t\\t\\t\\t\\t\\t\\tif res<curr_area:\\n\\t\\t\\t\\t\\t\\t\\t\\tres = curr_area\\n\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2696109,
                "title": "c-1-liner-math",
                "content": "The general idea is to try all combinations of 3 points, compute the area, then pick the largest computed value.\\n\\nRather than useing nested `for` loops, we use nested `Max` expressions.\\n\\nThe formula for computing thea area of a triangle is not something that most people are going to have memorized, so we look it up. The more common approach uses an absolute value, however because we are trying all points in all positions, we do not need to do this. We could have used array slicing to avoid trying all points in all positions, but it doesn\\'t affect the overall runtime of `O(n ^ 3)`\\n\\n```cs\\npublic double LargestTriangleArea(int[][] P) =>\\n    P.Max(a => P.Max(b => P.Max(c =>\\n        a[0] * b[1] + b[0] * c[1] + c[0] * a[1] -\\n        a[1] * b[0] - b[1] * c[0] - c[1] * a[0]\\n    ))) / 2D;\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cs\\npublic double LargestTriangleArea(int[][] P) =>\\n    P.Max(a => P.Max(b => P.Max(c =>\\n        a[0] * b[1] + b[0] * c[1] + c[0] * a[1] -\\n        a[1] * b[0] - b[1] * c[0] - c[1] * a[0]\\n    ))) / 2D;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564791,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1565978,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1571906,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1571957,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 2068494,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 2012738,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            },
            {
                "id": 1783232,
                "content": [
                    {
                        "username": "xitizzz",
                        "content": "This is a bad problem. I don\\'t think any major company will ask this. It\\'s labeled easy, because the solution if brute force. When you are going to brute force then any problem is easy and unrepresentative of one\\'s algorithmic thinking and programming skills. \\n\\nI know there are more optimal solutions, but as I understand they are quite complex for \\'easy\\' problem and are more like \\'tricks\\' instead of a pure algorithms. Don\\'t waste your time on finding a better solution like I did."
                    },
                    {
                        "username": "Triquetra",
                        "content": "It can be easily estimated from the input limits that the maximal number of triangles is less than 50<sup>3</sup>=125000. It is also clear that not brute-forcing the solution requires something that's at least as complex as a convex hull. If you wasted time on trying to find a superior solution without realizing that brute force is sufficient, that's a judgment error on your part, since input limits are part of the problem statement."
                    },
                    {
                        "username": "wzrthhj",
                        "content": "https://arxiv.org/pdf/1705.11035.pdf"
                    },
                    {
                        "username": "jjecii",
                        "content": "I cannot believe straight brute force algorithm could pass, so I spent some time to see if I can implement some thing like convex hull algorithm and use the result to speed up. In the end I give up this problem and work on other problems.\\n"
                    },
                    {
                        "username": "manhongxiang",
                        "content": "It takes me much time to think about a skilled way. \\nFailed, hahahahaha"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "\"The red triangle is the largest.\". I\\'m either color-blind, or that triangle is for sure not red."
                    },
                    {
                        "username": "senuzulme",
                        "content": "I understand nothing"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The problem is easy, but it serves no purpose in learning something new. Just did it with brute force O(n^3) and I think that\\'s what the majority of people did."
                    }
                ]
            }
        ]
    }
]