[
    {
        "title": "Count Nodes With the Highest Score",
        "question_content": "There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1.\nEach node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees.\nReturn the number of nodes that have the highest score.\n&nbsp;\nExample 1:\n\nInput: parents = [-1,2,0,2,0]\nOutput: 3\nExplanation:\n- The score of node 0 is: 3 * 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 * 1 * 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n\nExample 2:\n\nInput: parents = [-1,2,0]\nOutput: 2\nExplanation:\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 * 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n\n&nbsp;\nConstraints:\n\n\tn == parents.length\n\t2 <= n <= 105\n\tparents[0] == -1\n\t0 <= parents[i] <= n - 1 for i != 0\n\tparents represents a valid binary tree.",
        "solutions": [
            {
                "id": 1537603,
                "title": "python-3-graph-dfs-post-order-traversal-o-n-explanation",
                "content": "### Explanation\\n- Intuition: Maximum product of 3 branches, need to know how many nodes in each branch, use `DFS` to start with\\n- Build graph\\n- Find left, right, up (number of nodes) for each node\\n\\t- left: use recursion\\n\\t- right: use recursion\\n\\t- up: `n - 1 - left - right`\\n- Calculate score store in a dictinary\\n- Return count of max key\\n- Time: `O(n)`\\n### Implementation     \\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        for node, parent in enumerate(parents):  # build graph\\n            graph[parent].append(node)\\n        n = len(parents)                         # total number of nodes\\n        d = collections.Counter()\\n        def count_nodes(node):                   # number of children node + self\\n            p, s = 1, 0                          # p: product, s: sum\\n            for child in graph[node]:            # for each child (only 2 at maximum)\\n                res = count_nodes(child)         # get its nodes count\\n                p *= res                         # take the product\\n                s += res                         # take the sum\\n            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)\\n            d[p] += 1                            # count the product\\n            return s + 1                         # return number of children node + 1 (self)\\n        count_nodes(0)                           # starting from root (0)\\n        return d[max(d.keys())]                  # return max count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        for node, parent in enumerate(parents):  # build graph\\n            graph[parent].append(node)\\n        n = len(parents)                         # total number of nodes\\n        d = collections.Counter()\\n        def count_nodes(node):                   # number of children node + self\\n            p, s = 1, 0                          # p: product, s: sum\\n            for child in graph[node]:            # for each child (only 2 at maximum)\\n                res = count_nodes(child)         # get its nodes count\\n                p *= res                         # take the product\\n                s += res                         # take the sum\\n            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)\\n            d[p] += 1                            # count the product\\n            return s + 1                         # return number of children node + 1 (self)\\n        count_nodes(0)                           # starting from root (0)\\n        return d[max(d.keys())]                  # return max count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537471,
                "title": "dfs",
                "content": "The value of a node is the product of:\\n1. number of nodes in the left subtree, \\n2. number of nodes in the right subtree,\\n3. number of all other nodes, excluding the current one (n - left - right - 1)\\n\\nWe can just use DFS to count child nodes for (1) and (2), and we can then compute (3) as we know the total nubers of nodes.\\n\\n**C++**\\n```cpp\\nint dfs(vector<vector<int>> &al, vector<long long> &s, int i) {\\n    long long prod = 1, sum = 1;\\n    for (int j : al[i]) {\\n        int cnt = dfs(al, s, j);\\n        prod *= cnt;\\n        sum += cnt;\\n    }\\n    s[i] = prod * (max(1ll, (long long)al.size() - sum));\\n    return i != 0 ? sum : count(begin(s), end(s), *max_element(begin(s), end(s)));\\n}\\nint countHighestScoreNodes(vector<int>& p) {\\n    vector<vector<int>> al(p.size());\\n    vector<long long> s(p.size());\\n    for (int i = 1; i < p.size(); ++i)\\n        al[p[i]].push_back(i);\\n    return dfs(al, s, 0);\\n}\\n```\\n**Java**\\n```java\\nlong dfs(List<List<Integer>> al, long[] s, int i) {\\n    long prod = 1, sum = 1;\\n    for (int j : al.get(i)) {\\n        long cnt = dfs(al, s, j);\\n        prod *= cnt;\\n        sum += cnt;\\n    }\\n    s[i] = prod * (Math.max(1, al.size() - sum));\\n    return sum;\\n}    \\npublic int countHighestScoreNodes(int[] p) {\\n    List<List<Integer>> al = new ArrayList<>();\\n    for (int i = 0; i < p.length; ++i)\\n        al.add(new ArrayList<Integer>());         \\n    long[] s = new long[p.length];\\n    for (int i = 1; i < p.length; ++i)\\n        al.get(p[i]).add(i);\\n    dfs(al, s, 0);\\n    long max_val = Arrays.stream(s).max().getAsLong();\\n    return (int)Arrays.stream(s).filter(v -> v == max_val).count();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint dfs(vector<vector<int>> &al, vector<long long> &s, int i) {\\n    long long prod = 1, sum = 1;\\n    for (int j : al[i]) {\\n        int cnt = dfs(al, s, j);\\n        prod *= cnt;\\n        sum += cnt;\\n    }\\n    s[i] = prod * (max(1ll, (long long)al.size() - sum));\\n    return i != 0 ? sum : count(begin(s), end(s), *max_element(begin(s), end(s)));\\n}\\nint countHighestScoreNodes(vector<int>& p) {\\n    vector<vector<int>> al(p.size());\\n    vector<long long> s(p.size());\\n    for (int i = 1; i < p.size(); ++i)\\n        al[p[i]].push_back(i);\\n    return dfs(al, s, 0);\\n}\\n```\n```java\\nlong dfs(List<List<Integer>> al, long[] s, int i) {\\n    long prod = 1, sum = 1;\\n    for (int j : al.get(i)) {\\n        long cnt = dfs(al, s, j);\\n        prod *= cnt;\\n        sum += cnt;\\n    }\\n    s[i] = prod * (Math.max(1, al.size() - sum));\\n    return sum;\\n}    \\npublic int countHighestScoreNodes(int[] p) {\\n    List<List<Integer>> al = new ArrayList<>();\\n    for (int i = 0; i < p.length; ++i)\\n        al.add(new ArrayList<Integer>());         \\n    long[] s = new long[p.length];\\n    for (int i = 1; i < p.length; ++i)\\n        al.get(p[i]).add(i);\\n    dfs(al, s, 0);\\n    long max_val = Arrays.stream(s).max().getAsLong();\\n    return (int)Arrays.stream(s).filter(v -> v == max_val).count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537530,
                "title": "java-simple-dfs-solution-generalised-for-any-tree-with-detailed-comments-t-o-v-e-s-o-v-e",
                "content": "```\\n/*\\n    This solution is generalised to perform for any tree, not only binary tree. \\n    To calculate score for each node, we need the number of nodes in the subtrees whose root is a child of the current node \\n    and also the number of nodes in the remaining tree excluding the subtree with root at the current node.\\n    Once we have these values we find the product of the non-zero values among them and update the maximum score \\n    and the count of the number of nodes with the maximum score.\\n*/\\nclass Solution {\\n    long maxScore; // stores the maximum score\\n    int count; // store the count of maximum score\\n    public int countHighestScoreNodes(int[] parent) {\\n        int n=parent.length;\\n        \\n        // creating the tree\\n        List<Integer> list[]=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            list[parent[i]].add(i);\\n        }\\n        \\n        maxScore=0l;\\n        count=0;\\n        \\n        dfs(0,list,n);\\n        \\n        return count;\\n    }\\n    \\n    // returns the number of nodes in the subtree with root u.\\n    public int dfs(int u, List<Integer> list[], int n){        \\n        \\n        int total=0; // stores total number of nodes in the subtree with root u, excluding u.\\n        long prod=1l,rem,val;\\n        \\n        // traversing children in the subtree\\n        for(int v:list[u]){\\n            val=dfs(v,list,n); // number of nodes in the subtree with root v.\\n            total+=val;\\n            prod*=val;\\n        }\\n        rem=(long)(n-total-1); // number of nodes in the remaining tree excluding the subtree with root u.\\n        \\n        if(rem>0)// only count the remaining part if there is at least one node.\\n            prod*=rem;\\n        \\n        // updating maxScore and count.\\n        if(prod>maxScore){\\n            maxScore=prod;\\n            count=1;            \\n        }\\n        else if(prod==maxScore){\\n            count++;\\n        }\\n        \\n        return total+1; // returning total number of nodes in the subtree with node u.\\n    }\\n}\\n```\\nT = O(V+E)\\nS = O(V+E)\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\n/*\\n    This solution is generalised to perform for any tree, not only binary tree. \\n    To calculate score for each node, we need the number of nodes in the subtrees whose root is a child of the current node \\n    and also the number of nodes in the remaining tree excluding the subtree with root at the current node.\\n    Once we have these values we find the product of the non-zero values among them and update the maximum score \\n    and the count of the number of nodes with the maximum score.\\n*/\\nclass Solution {\\n    long maxScore; // stores the maximum score\\n    int count; // store the count of maximum score\\n    public int countHighestScoreNodes(int[] parent) {\\n        int n=parent.length;\\n        \\n        // creating the tree\\n        List<Integer> list[]=new ArrayList[n];\\n        for(int i=0;i<n;i++)\\n            list[i]=new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            list[parent[i]].add(i);\\n        }\\n        \\n        maxScore=0l;\\n        count=0;\\n        \\n        dfs(0,list,n);\\n        \\n        return count;\\n    }\\n    \\n    // returns the number of nodes in the subtree with root u.\\n    public int dfs(int u, List<Integer> list[], int n){        \\n        \\n        int total=0; // stores total number of nodes in the subtree with root u, excluding u.\\n        long prod=1l,rem,val;\\n        \\n        // traversing children in the subtree\\n        for(int v:list[u]){\\n            val=dfs(v,list,n); // number of nodes in the subtree with root v.\\n            total+=val;\\n            prod*=val;\\n        }\\n        rem=(long)(n-total-1); // number of nodes in the remaining tree excluding the subtree with root u.\\n        \\n        if(rem>0)// only count the remaining part if there is at least one node.\\n            prod*=rem;\\n        \\n        // updating maxScore and count.\\n        if(prod>maxScore){\\n            maxScore=prod;\\n            count=1;            \\n        }\\n        else if(prod==maxScore){\\n            count++;\\n        }\\n        \\n        return total+1; // returning total number of nodes in the subtree with node u.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537504,
                "title": "c-dfs-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\\n         int ans = 1;\\n         for(auto child:g[src]){\\n             ans += helper(child,g,size);\\n         }\\n         return size[src] = ans; \\n     }\\n    \\n    \\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\\n        vector<vector<int>> g(n); // storing left and right child of a node\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n        }\\n        helper(0,g,size);  // calculating size of each subtree\\n        long long cnt = 0, maxi = 0;\\n        for(int i=0;i<n;i++){\\n            long long pro = 1; \\n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \\n            for(auto node:g[i]){\\n                pro = pro * size[node]; // multiplying with size of subtree\\n            }\\n            if(pro > maxi){\\n                maxi = pro;\\n                cnt = 1;\\n            }\\n            else if(pro == maxi){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Hit upvote if you like it :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\\n         int ans = 1;\\n         for(auto child:g[src]){\\n             ans += helper(child,g,size);\\n         }\\n         return size[src] = ans; \\n     }\\n    \\n    \\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\\n        vector<vector<int>> g(n); // storing left and right child of a node\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n        }\\n        helper(0,g,size);  // calculating size of each subtree\\n        long long cnt = 0, maxi = 0;\\n        for(int i=0;i<n;i++){\\n            long long pro = 1; \\n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \\n            for(auto node:g[i]){\\n                pro = pro * size[node]; // multiplying with size of subtree\\n            }\\n            if(pro > maxi){\\n                maxi = pro;\\n                cnt = 1;\\n            }\\n            else if(pro == maxi){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537511,
                "title": "python3-post-order-dfs",
                "content": "\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = [[] for _ in parents]\\n        for i, x in enumerate(parents): \\n            if x >= 0: tree[x].append(i)\\n                \\n        freq = defaultdict(int)\\n        \\n        def fn(x): \\n            \"\"\"Return count of tree nodes.\"\"\"\\n            left = right = 0\\n            if tree[x]: left = fn(tree[x][0])\\n            if len(tree[x]) > 1: right = fn(tree[x][1])\\n            score = (left or 1) * (right or 1) * (len(parents) - 1 - left - right or 1)\\n            freq[score] += 1\\n            return 1 + left + right\\n        \\n        fn(0)\\n        return freq[max(freq)]\\n```\\n\\nAlternatively \\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = [[] for _ in parents]\\n        for i, x in enumerate(parents): \\n            if x >= 0: tree[x].append(i)\\n        \\n        def fn(x): \\n            \"\"\"Return count of tree nodes.\"\"\"\\n            count = score = 1\\n            for xx in tree[x]: \\n                cc = fn(xx)\\n                count += cc\\n                score *= cc\\n            score *= len(parents) - count or 1\\n            freq[score] += 1\\n            return count\\n        \\n        freq = defaultdict(int)\\n        fn(0)\\n        return freq[max(freq)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = [[] for _ in parents]\\n        for i, x in enumerate(parents): \\n            if x >= 0: tree[x].append(i)\\n                \\n        freq = defaultdict(int)\\n        \\n        def fn(x): \\n            \"\"\"Return count of tree nodes.\"\"\"\\n            left = right = 0\\n            if tree[x]: left = fn(tree[x][0])\\n            if len(tree[x]) > 1: right = fn(tree[x][1])\\n            score = (left or 1) * (right or 1) * (len(parents) - 1 - left - right or 1)\\n            freq[score] += 1\\n            return 1 + left + right\\n        \\n        fn(0)\\n        return freq[max(freq)]\\n```\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = [[] for _ in parents]\\n        for i, x in enumerate(parents): \\n            if x >= 0: tree[x].append(i)\\n        \\n        def fn(x): \\n            \"\"\"Return count of tree nodes.\"\"\"\\n            count = score = 1\\n            for xx in tree[x]: \\n                cc = fn(xx)\\n                count += cc\\n                score *= cc\\n            score *= len(parents) - count or 1\\n            freq[score] += 1\\n            return count\\n        \\n        freq = defaultdict(int)\\n        fn(0)\\n        return freq[max(freq)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594865,
                "title": "c-clean-code-graph-dfs-easy-explanation-with-comments",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n     \\n    // Steps : \\n    // 1 - For each node, you need to find the sizes of the subtrees rooted in each of its children.\\n    \\n    // 2 - How to determine the number of nodes in the rest of the tree? \\n\\t// Can you subtract the size of the subtree rooted at the node from the total number of nodes of the tree?\\n    \\n    // 3 - Use these values to compute the score of the node. Track the maximum score, and how many nodes achieve such score. \\n    \\n\\t// calculating size of each subtree by standing at every node  \\'0\\' to \\'n-1\\'\\n    int dfs(int src,vector<vector<int>>& g,vector<int>& size)\\n    {\\n         int ans = 1;// for curent node\\n         for(auto child : g[src]){\\n             ans += dfs(child,g,size);\\n         }\\n         return size[src] = ans; \\n     }\\n    \\n    // This code can also be work for generalized tree not only for Binary tree\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {    \\n        int n=parents.size();\\n        vector<int>size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\\n        vector<vector<int>>g(n);  // storing left and right child of a node\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i); // \\'There is no parent for 0th node\\'\\n        }\\n        \\n        dfs(0,g,size); //calculating size of each subtree(rooted at ith node)\\n\\n        long long int maxCount = 0; // To avoid overflow  because perform product below you should take \"long long int\"\\n        long long int maxScore = 0;\\n        for(int i=0;i<n;i++) // Nodes from \\'0\\' to \\'n-1\\'\\n        {\\n            // calculate score of each node after removal their \\'edge\\' or \\'node itself\\'.\\n            long long int product = 1;\\n            product = max(product, (long long int)(n - size[i])); // calculating leftover nodes excluding child nodes \\n            for(auto x : g[i])\\n            {\\n                product = product*size[x];\\n            }\\n            \\n            if(product > maxScore){\\n                maxScore = product;\\n                maxCount = 1;\\n            }\\n            else if(product == maxScore){\\n                maxCount++; // store count of nodes which have maximum score equal to \"maxScore\"\\n            }\\n        }\\n            \\n        return maxCount;\\n    }\\n};\\n```\\n**Hit the upvote if you like it : )**\\n**Happy Coding**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     \\n    // Steps : \\n    // 1 - For each node, you need to find the sizes of the subtrees rooted in each of its children.\\n    \\n    // 2 - How to determine the number of nodes in the rest of the tree? \\n\\t// Can you subtract the size of the subtree rooted at the node from the total number of nodes of the tree?\\n    \\n    // 3 - Use these values to compute the score of the node. Track the maximum score, and how many nodes achieve such score. \\n    \\n\\t// calculating size of each subtree by standing at every node  \\'0\\' to \\'n-1\\'\\n    int dfs(int src,vector<vector<int>>& g,vector<int>& size)\\n    {\\n         int ans = 1;// for curent node\\n         for(auto child : g[src]){\\n             ans += dfs(child,g,size);\\n         }\\n         return size[src] = ans; \\n     }\\n    \\n    // This code can also be work for generalized tree not only for Binary tree\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {    \\n        int n=parents.size();\\n        vector<int>size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\\n        vector<vector<int>>g(n);  // storing left and right child of a node\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i); // \\'There is no parent for 0th node\\'\\n        }\\n        \\n        dfs(0,g,size); //calculating size of each subtree(rooted at ith node)\\n\\n        long long int maxCount = 0; // To avoid overflow  because perform product below you should take \"long long int\"\\n        long long int maxScore = 0;\\n        for(int i=0;i<n;i++) // Nodes from \\'0\\' to \\'n-1\\'\\n        {\\n            // calculate score of each node after removal their \\'edge\\' or \\'node itself\\'.\\n            long long int product = 1;\\n            product = max(product, (long long int)(n - size[i])); // calculating leftover nodes excluding child nodes \\n            for(auto x : g[i])\\n            {\\n                product = product*size[x];\\n            }\\n            \\n            if(product > maxScore){\\n                maxScore = product;\\n                maxCount = 1;\\n            }\\n            else if(product == maxScore){\\n                maxCount++; // store count of nodes which have maximum score equal to \"maxScore\"\\n            }\\n        }\\n            \\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538012,
                "title": "intuitive-java-solution-faster-than-100",
                "content": "I used the most straightforward way to solve this problem.\\nIt can be divided into 3 steps.\\n* Construct tree by using the parents[] array.\\n* Find the highest score\\n* Count nodes with the highest score\\n\\n```\\nclass Solution {\\n    long highest = 0;\\n    \\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        int res = 0;\\n        Node[] arr = new Node[n];\\n        //construct tree\\n        for (int i = 0; i < parents.length; i++) {\\n            arr[i] = new Node();\\n        }\\n        \\n        for (int i = 1; i < parents.length; i++) {\\n            int parentId = parents[i];\\n            if (arr[parentId].left == null) {\\n                arr[parentId].left = arr[i];\\n            } else {\\n                arr[parentId].right = arr[i];\\n            }\\n        }\\n\\n        findSize(arr[0]);\\n        \\n\\t\\t//find the highest score\\n        for (int i = 0; i < parents.length; i++) {\\n            long product = 1; \\n            int leftCnt = arr[i].left == null ? 0 : arr[i].left.cnt;\\n            int rightCnt = arr[i].right == null ? 0 : arr[i].right.cnt;\\n            int restCnt = n - 1 - leftCnt - rightCnt;\\n            \\n            if (leftCnt > 0) {\\n                product *= leftCnt;\\n            }\\n            if (rightCnt > 0) {\\n                product *= rightCnt;\\n            }\\n            if (restCnt > 0) {\\n                product *= restCnt;\\n            }\\n            arr[i].product = product;\\n            highest = Math.max(highest, product);\\n        }\\n        \\n\\t\\t//count nodes\\n        for (int i = 0; i < parents.length; i++) {\\n            if (arr[i].product == highest) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class Node {\\n        Node left;\\n        Node right;\\n        long product = 0L;\\n        int cnt = 0;  \\n        public Node() {}\\n    }\\n    \\n    private int findSize (Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int size = findSize(root.left) + findSize(root.right) + 1;\\n        root.cnt = size;\\n        return size;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long highest = 0;\\n    \\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        int res = 0;\\n        Node[] arr = new Node[n];\\n        //construct tree\\n        for (int i = 0; i < parents.length; i++) {\\n            arr[i] = new Node();\\n        }\\n        \\n        for (int i = 1; i < parents.length; i++) {\\n            int parentId = parents[i];\\n            if (arr[parentId].left == null) {\\n                arr[parentId].left = arr[i];\\n            } else {\\n                arr[parentId].right = arr[i];\\n            }\\n        }\\n\\n        findSize(arr[0]);\\n        \\n\\t\\t//find the highest score\\n        for (int i = 0; i < parents.length; i++) {\\n            long product = 1; \\n            int leftCnt = arr[i].left == null ? 0 : arr[i].left.cnt;\\n            int rightCnt = arr[i].right == null ? 0 : arr[i].right.cnt;\\n            int restCnt = n - 1 - leftCnt - rightCnt;\\n            \\n            if (leftCnt > 0) {\\n                product *= leftCnt;\\n            }\\n            if (rightCnt > 0) {\\n                product *= rightCnt;\\n            }\\n            if (restCnt > 0) {\\n                product *= restCnt;\\n            }\\n            arr[i].product = product;\\n            highest = Math.max(highest, product);\\n        }\\n        \\n\\t\\t//count nodes\\n        for (int i = 0; i < parents.length; i++) {\\n            if (arr[i].product == highest) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class Node {\\n        Node left;\\n        Node right;\\n        long product = 0L;\\n        int cnt = 0;  \\n        public Node() {}\\n    }\\n    \\n    private int findSize (Node root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int size = findSize(root.left) + findSize(root.right) + 1;\\n        root.cnt = size;\\n        return size;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537494,
                "title": "c-post-order-traversal",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Post-order Traversal\\n\\nPost-order traverse the tree. For each node, calculate its score by multiplying the node count of its left subtree, right subtree and nodes not in the current subtree (ignoring `0`). Count the nodes with the maximum score.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& P) {\\n        long N = P.size(), ans = 0, maxScore = 0;\\n        vector<vector<int>> G(N); // build the graph -- G[i] is a list of the children of node `i`.\\n        for (int i = 1; i < N; ++i) G[P[i]].push_back(i);\\n        function<int(int)> dfs = [&](int u) { // Post-order traversal. Returns the size of the subtree rooted at node `u`.\\n            long score = 1, cnt = 1;\\n            for (int v : G[u]) {\\n                int c = dfs(v);\\n                cnt += c;\\n                score *= c;\\n            }\\n            long other = N - cnt; // The count of nodes not in this subtree rooted at node `u`.\\n            if (other) score *= other;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                ans = 0;\\n            }\\n            if (score == maxScore) ++ans;\\n            return cnt;\\n        };\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& P) {\\n        long N = P.size(), ans = 0, maxScore = 0;\\n        vector<vector<int>> G(N); // build the graph -- G[i] is a list of the children of node `i`.\\n        for (int i = 1; i < N; ++i) G[P[i]].push_back(i);\\n        function<int(int)> dfs = [&](int u) { // Post-order traversal. Returns the size of the subtree rooted at node `u`.\\n            long score = 1, cnt = 1;\\n            for (int v : G[u]) {\\n                int c = dfs(v);\\n                cnt += c;\\n                score *= c;\\n            }\\n            long other = N - cnt; // The count of nodes not in this subtree rooted at node `u`.\\n            if (other) score *= other;\\n            if (score > maxScore) {\\n                maxScore = score;\\n                ans = 0;\\n            }\\n            if (score == maxScore) ++ans;\\n            return cnt;\\n        };\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537878,
                "title": "java-solution-subnodes-count-with-explanation",
                "content": "Counts array is having the counts of subnodes for each node.\\nNow removing a node , remaining can be easily get with product of subnodes of that node\\'s subnodes and upper nodes (total - counts[node])\\nIn case of parent we dont have any upper nodes so we dont do it when i==0.\\nStore all products along with thier frequency in a HashMap then return the max one.\\n```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        List<Integer>[] tree = new ArrayList[n];\\n        \\n\\t\\tfor(int i=0;i<n;i++)\\n            tree[i] = new ArrayList<>();\\n       \\n\\t    for(int i=1;i<n;i++)\\n            tree[parents[i]].add(i);\\n       \\n\\t    int counts[] = new int[n];\\n        Arrays.fill(counts,1);\\n        \\n\\t\\tdfs(0,tree,counts);\\n        \\n\\t\\tlong max = 0, res = 0;\\n        HashMap<Long,Long> map = new HashMap<>();        \\n        \\n\\t\\tfor(int i=0;i<n;i++){\\n            long prod = 1;\\n            for(int u : tree[i]) {\\n                prod *= counts[u];\\n            }\\n\\t\\t\\t\\n            if(i!=0) prod *= n-counts[i];\\n            map.put(prod,map.getOrDefault(prod,0L)+1L);\\n\\t\\t\\t\\n            if(prod >= max) {\\n                max = prod;\\n                res = map.get(prod);\\n            }\\n        }\\n\\t\\t\\n        return (int)res;\\n    }\\n\\t\\n    private int dfs(int node,List<Integer>[] tree,int counts[]){ \\n\\t\\n        for(int next : tree[node])\\n            counts[node] += dfs(next,tree,counts);\\n    \\n\\t    return counts[node];\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        List<Integer>[] tree = new ArrayList[n];\\n        \\n\\t\\tfor(int i=0;i<n;i++)\\n            tree[i] = new ArrayList<>();\\n       \\n\\t    for(int i=1;i<n;i++)\\n            tree[parents[i]].add(i);\\n       \\n\\t    int counts[] = new int[n];\\n        Arrays.fill(counts,1);\\n        \\n\\t\\tdfs(0,tree,counts);\\n        \\n\\t\\tlong max = 0, res = 0;\\n        HashMap<Long,Long> map = new HashMap<>();        \\n        \\n\\t\\tfor(int i=0;i<n;i++){\\n            long prod = 1;\\n            for(int u : tree[i]) {\\n                prod *= counts[u];\\n            }\\n\\t\\t\\t\\n            if(i!=0) prod *= n-counts[i];\\n            map.put(prod,map.getOrDefault(prod,0L)+1L);\\n\\t\\t\\t\\n            if(prod >= max) {\\n                max = prod;\\n                res = map.get(prod);\\n            }\\n        }\\n\\t\\t\\n        return (int)res;\\n    }\\n\\t\\n    private int dfs(int node,List<Integer>[] tree,int counts[]){ \\n\\t\\n        for(int next : tree[node])\\n            counts[node] += dfs(next,tree,counts);\\n    \\n\\t    return counts[node];\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213105,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**Observation** : \\nscore = ```number of above nodes * number of nodes of 1 child * number of nodes ofother child```\\n\\nWe are provided with the parents of nodes, For convenience we keep mapping of chilren of nodes.\\n\\n* First task : Create a dictionary to keep the children of nodes.\\n* Secondly, with recurssion we find number of nodes below and including itself for ```node i``` and store in ```nums```\\n\\nNow use formula :\\n* Number of nodes above node i = Total nodes - ```nums[i]``` . -> nums [ i ] is number of nodes below it + 1.\\n* Number of nodes for children are provided directly stored in nums dictionary.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        def fin(n):\\n            k=1\\n            for i in child[n]:\\n                k += fin(i)\\n            nums[n]=k\\n            return k\\n        \\n        child = {}\\n        for i in range(len(parents)):\\n            child[i]=[]\\n        for i in range(1,len(parents)):\\n            child[parents[i]].append(i)\\n        \\n        nums={}\\n        fin(0)\\n        k=1\\n        for i in child[0]:\\n            k*=nums[i]\\n        score=[k]\\n        for i in range(1,len(nums)):\\n            k=1\\n            k*=(nums[0]-nums[i])\\n            for j in child[i]:\\n                k*=nums[j]\\n            score.append(k)\\n            \\n        return score.count(max(score))\\n```\\n![Uploading file...]()\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```number of above nodes * number of nodes of 1 child * number of nodes ofother child```\n```node i```\n```nums```\n```nums[i]```\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        def fin(n):\\n            k=1\\n            for i in child[n]:\\n                k += fin(i)\\n            nums[n]=k\\n            return k\\n        \\n        child = {}\\n        for i in range(len(parents)):\\n            child[i]=[]\\n        for i in range(1,len(parents)):\\n            child[parents[i]].append(i)\\n        \\n        nums={}\\n        fin(0)\\n        k=1\\n        for i in child[0]:\\n            k*=nums[i]\\n        score=[k]\\n        for i in range(1,len(nums)):\\n            k=1\\n            k*=(nums[0]-nums[i])\\n            for j in child[i]:\\n                k*=nums[j]\\n            score.append(k)\\n            \\n        return score.count(max(score))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537490,
                "title": "easy-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        //--build tree start--\\n        Node[] arr = new Node[parents.length];\\n        for(int i = 0;i<parents.length;i++)\\n            arr[i] = new Node();\\n        \\n        for(int i = 1;i<parents.length;i++){\\n            arr[i].parent = arr[parents[i]];\\n            arr[i].id = i;\\n            if(arr[parents[i]].left==null){\\n                arr[parents[i]].left = arr[i];\\n            }else\\n                arr[parents[i]].right = arr[i];\\n        }\\n        // --build tree complete---\\n        \\n        countLeftAndRightScoreNodes(arr[0]);// build node\\'s left and right count maps\\n\\n        for(Node node: arr){//calculate product of all subtrees for given node\\n            long parentSide = 1, rightSide = rcMap.getOrDefault(node.id,0), leftSide = lcMap.getOrDefault(node.id,0);\\n            parentSide = (rcMap.getOrDefault(0,0)+lcMap.getOrDefault(0,0)+1) - (rightSide+leftSide+1); // root\\'s left count + root\\'s right count - (current node and below count)\\n            long product = Math.max(parentSide,1)*Math.max(rightSide,1)*Math.max(leftSide,1);\\n            tm.put(product,tm.getOrDefault(product, 0)+1);\\n        }\\n        return tm.get(tm.lastKey());\\n    }\\n    \\n    TreeMap<Long, Integer> tm = new TreeMap<>();\\n    Map<Integer,Integer> lcMap = new HashMap<>();//left count\\n    Map<Integer,Integer> rcMap = new HashMap<>();\\n\\n    void countLeftAndRightScoreNodes(Node root){//post order traversal to build left and right node counts\\n        if(root == null)\\n            return;\\n        countLeftAndRightScoreNodes(root.left);\\n        countLeftAndRightScoreNodes(root.right);\\n\\n        int currentCount = (root.left!=null?lcMap.getOrDefault(root.id,0):0)+(root.right!=null?rcMap.getOrDefault(root.id,0):0)+1;\\n        if(root.parent==null)\\n            return;\\n        if(root==root.parent.left){\\n            lcMap.put(root.parent.id,currentCount);\\n        }else{\\n            rcMap.put(root.parent.id,currentCount);\\n        }\\n    }\\n   \\n}\\nclass Node{\\n    Node left;\\n    Node right;\\n    Node parent;\\n    int id = 0;//index\\n    public Node(){\\n    }\\n    public Node(Node left, Node right, Node parent){\\n        this.left = left;\\n        this.right = right;\\n        this.parent = parent;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        //--build tree start--\\n        Node[] arr = new Node[parents.length];\\n        for(int i = 0;i<parents.length;i++)\\n            arr[i] = new Node();\\n        \\n        for(int i = 1;i<parents.length;i++){\\n            arr[i].parent = arr[parents[i]];\\n            arr[i].id = i;\\n            if(arr[parents[i]].left==null){\\n                arr[parents[i]].left = arr[i];\\n            }else\\n                arr[parents[i]].right = arr[i];\\n        }\\n        // --build tree complete---\\n        \\n        countLeftAndRightScoreNodes(arr[0]);// build node\\'s left and right count maps\\n\\n        for(Node node: arr){//calculate product of all subtrees for given node\\n            long parentSide = 1, rightSide = rcMap.getOrDefault(node.id,0), leftSide = lcMap.getOrDefault(node.id,0);\\n            parentSide = (rcMap.getOrDefault(0,0)+lcMap.getOrDefault(0,0)+1) - (rightSide+leftSide+1); // root\\'s left count + root\\'s right count - (current node and below count)\\n            long product = Math.max(parentSide,1)*Math.max(rightSide,1)*Math.max(leftSide,1);\\n            tm.put(product,tm.getOrDefault(product, 0)+1);\\n        }\\n        return tm.get(tm.lastKey());\\n    }\\n    \\n    TreeMap<Long, Integer> tm = new TreeMap<>();\\n    Map<Integer,Integer> lcMap = new HashMap<>();//left count\\n    Map<Integer,Integer> rcMap = new HashMap<>();\\n\\n    void countLeftAndRightScoreNodes(Node root){//post order traversal to build left and right node counts\\n        if(root == null)\\n            return;\\n        countLeftAndRightScoreNodes(root.left);\\n        countLeftAndRightScoreNodes(root.right);\\n\\n        int currentCount = (root.left!=null?lcMap.getOrDefault(root.id,0):0)+(root.right!=null?rcMap.getOrDefault(root.id,0):0)+1;\\n        if(root.parent==null)\\n            return;\\n        if(root==root.parent.left){\\n            lcMap.put(root.parent.id,currentCount);\\n        }else{\\n            rcMap.put(root.parent.id,currentCount);\\n        }\\n    }\\n   \\n}\\nclass Node{\\n    Node left;\\n    Node right;\\n    Node parent;\\n    int id = 0;//index\\n    public Node(){\\n    }\\n    public Node(Node left, Node right, Node parent){\\n        this.left = left;\\n        this.right = right;\\n        this.parent = parent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615363,
                "title": "c-simple-dfs-with-explanation",
                "content": "class Solution {\\npublic:\\n   \\n    \\n    int dfs(vector<int> adj[], int n,int i, vector<int>&dp)\\n    {\\n        int ans=1;\\n       \\n       // ans+=adj[i].size();\\n        \\n        for(auto it:adj[i])\\n        {\\n           ans+= dfs(adj,n,it,dp);\\n        }\\n        \\n        return dp[i]=ans;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       \\n        int n=parents.size();\\n        \\n        vector<int>dp(n+1,-1);\\n        \\n       vector<int>adj[n+1];\\n        \\n       for(int i=0;i<n;i++)\\n       {\\n           if(parents[i]!=-1)\\n           {\\n               adj[parents[i]].push_back(i);\\n           }\\n       }\\n        long long mn=0;\\n        int id=0;\\n        \\n        dfs(adj,n,0,dp); // dfs for calculating the size of each subtree\\n        \\n        \\n       for(int i=0;i<n;i++)\\n       {\\n           long long a=0,b=0,prod=0;\\n           \\n           if(adj[i].size()==2)    // if it has two size thn there will be three comp in prod\\n           {\\n              a= dp[adj[i][0]];\\n              b= dp[adj[i][1]];\\n               \\n              prod=a*b*(n-a-b-1);\\n              if(i==0){ prod=a*b;}\\n           }\\n           else if(adj[i].size()==1){  // else 2 comp would be there\\n              \\n               a=dp[adj[i][0]];\\n               prod=a*(n-a-1);\\n               if(i==0){ prod=a;}\\n           }\\n           else{                 // if no size thn must be leaf, so size is n-1\\n              prod=n-1; \\n           }\\n           \\n         //  cout<<a<<\" \"<<b<<\" \"<<prod<<endl;\\n           if(prod>mn){\\n               mn=prod;           // cal mx prod\\n               id=1;          // if new mx prod found,initiase it ti 1, as this is only elemnt\\n           }\\n           else if(prod==mn)\\n           {\\n               id++;            // else increase its val\\n           }\\n           \\n       }\\n        \\n        \\n        return id;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    \\n    int dfs(vector<int> adj[], int n,int i, vector<int>&dp)\\n    {\\n        int ans=1;\\n       \\n       // ans+=adj[i].size();\\n        \\n        for(auto it:adj[i])\\n        {\\n           ans+= dfs(adj,n,it,dp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1537478,
                "title": "c-post-order-solution",
                "content": "\\nGet the number of nodes of L subtree and R subtree. and score = l * r * rest. (if l, r, rest == 0 then set to 1)\\n```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long cnt = 0;\\n    vector<vector<int> > adj;\\n    int n;\\n    long long dfs(int node) {\\n        long long l = 0, r = 0;\\n        if(adj[node].size() >= 1) {\\n            l = dfs(adj[node][0]);\\n        }\\n        if(adj[node].size() >= 2) {\\n            r = dfs(adj[node][1]);\\n        }\\n        long long rest = n - 1 - r - l;\\n        long long score = (l == 0 ? 1 : l) * (r == 0 ? 1 : r) * (rest == 0 ? 1 : rest);\\n        if(score == ans) {\\n            ++cnt;\\n        }else if(score > ans) {\\n            ans = score;\\n            cnt = 1;\\n        }\\n        return l + r + 1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        adj.resize(n);\\n        for(int i = 1; i < parents.size(); i++ ){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```\\n\\nWe can also use for-loop:\\n```\\n\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long cnt = 0;\\n    vector<vector<int> > adj;\\n    int n;\\n    long long dfs(int node) {\\n        long long rest = n - 1;\\n        long long score = 1;\\n        for(int child : adj[node]) {\\n            long long subtreeCount = dfs(child);\\n            rest -= subtreeCount;\\n            score *= subtreeCount ? subtreeCount : 1;\\n        }\\n        score *= rest ? rest : 1;\\n        if(score == ans) {\\n            ++cnt;\\n        }else if(score > ans) {\\n            ans = score;\\n            cnt = 1;\\n        }\\n        return n - rest;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        adj.resize(n);\\n        for(int i = 1; i < parents.size(); i++ ){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long cnt = 0;\\n    vector<vector<int> > adj;\\n    int n;\\n    long long dfs(int node) {\\n        long long l = 0, r = 0;\\n        if(adj[node].size() >= 1) {\\n            l = dfs(adj[node][0]);\\n        }\\n        if(adj[node].size() >= 2) {\\n            r = dfs(adj[node][1]);\\n        }\\n        long long rest = n - 1 - r - l;\\n        long long score = (l == 0 ? 1 : l) * (r == 0 ? 1 : r) * (rest == 0 ? 1 : rest);\\n        if(score == ans) {\\n            ++cnt;\\n        }else if(score > ans) {\\n            ans = score;\\n            cnt = 1;\\n        }\\n        return l + r + 1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        adj.resize(n);\\n        for(int i = 1; i < parents.size(); i++ ){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    long long cnt = 0;\\n    vector<vector<int> > adj;\\n    int n;\\n    long long dfs(int node) {\\n        long long rest = n - 1;\\n        long long score = 1;\\n        for(int child : adj[node]) {\\n            long long subtreeCount = dfs(child);\\n            rest -= subtreeCount;\\n            score *= subtreeCount ? subtreeCount : 1;\\n        }\\n        score *= rest ? rest : 1;\\n        if(score == ans) {\\n            ++cnt;\\n        }else if(score > ans) {\\n            ans = score;\\n            cnt = 1;\\n        }\\n        return n - rest;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        adj.resize(n);\\n        for(int i = 1; i < parents.size(); i++ ){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540239,
                "title": "cpp-easy-solution-using-recursion",
                "content": "```\\nclass treeNode{\\n    public:\\n        treeNode* left,*right;\\n        int val;\\n    \\n    treeNode(int val){\\n        this->val=val;\\n        left=right=NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<long long int,int>ans;\\n    int func(treeNode* root,int n){\\n        if(!root)return 0;\\n        \\n        int a=0,b=0;\\n        a=func(root->left,n);\\n        b=func(root->right,n);\\n        \\n        long long int t=1,m=n-(a+b+1);\\n        if(a!=0)t*=a;\\n        if(b!=0)t*=b;\\n        if(m!=0)t*=m;\\n        \\n       \\n        ans[t]++;\\n        \\n        return a+b+1;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        unordered_map<int,treeNode*>m;\\n        \\n        for(int i=0;i<n;i++){\\n            treeNode* root=new treeNode(i);\\n            m[i]=root;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int ele=parents[i];\\n            if(m[ele]->left==NULL)m[ele]->left=m[i];\\n            else m[ele]->right=m[i];\\n        }\\n        \\n        func(m[0],n);\\n        \\n        long long int maxi=0,t=0;\\n        for(auto ele:ans){\\n            if(ele.first>=maxi){\\n                t=ele.second;\\n                maxi=ele.first;\\n            }\\n        }\\n        return t;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<long long int,int>ans;\\n    int func(treeNode* root,int n){\\n        if(!root)return 0;\\n        \\n        int a=0,b=0;\\n        a=func(root->left,n);\\n        b=func(root->right,n);\\n        \\n        long long int t=1,m=n-(a+b+1);\\n        if(a!=0)t*=a;\\n        if(b!=0)t*=b;\\n        if(m!=0)t*=m;\\n        \\n       \\n        ans[t]++;\\n        \\n        return a+b+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1780948,
                "title": "dfs-straight-simple-approach-faster-than-95-74-of-c-online-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/d534c859-fce6-4240-b019-0a7723dab477_1636388292.4804392.png)\\n\\nStep 1: Make tree from parent array.\\n[you can learn how to make it from other resources like gfg]\\nStep 2: Think how you traverse binary tree and hence you can have value for each node using DFS which you can store in value array.\\n**Note:** if you are not able to get what is **c**, comment please!\\nAlso value of product can be large thats why we use **long long**\\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node *left,*right;\\n        Node(int i){\\n            val=i;\\n            left=right=NULL;\\n        }\\n    };\\n    long long int maxv=0;\\n    int func(Node *root, vector<long long int>&val){\\n        if(!root)return 0;\\n        int n=val.size();\\n        long long int l=func(root->left,val), r= func(root->right,val);\\n        if(root->val==0){ //for root c is 0\\n            if(l==0||r==0){\\n            val[root->val]=(l==0?r:l);\\n            }\\n            else{\\n                val[root->val]=l*r;\\n            }\\n            maxv=max(maxv,val[root->val]);\\n        return l+r+1;\\n        }\\n        int c=n-l-r-1;\\n        if(l==0&&r==0){\\n            val[root->val]=c;\\n        }\\n        else if(l==0||r==0){\\n            val[root->val]=(l==0?c*r:c*l);\\n        }\\n        else val[root->val]=c*l*r;\\n        \\n        maxv=max(maxv,val[root->val]);\\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<Node*>v(n,NULL);\\n        for(int i=0;i<n;i++){\\n            v[i]=new Node(i); //v[i] is pointer to node i\\n        }\\n        //now we will make tree\\n        Node *root=NULL;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1){\\n                root=v[i];\\n            }\\n            else if(v[parents[i]]->left==NULL){\\n                v[parents[i]]->left=v[i];\\n            }\\n            else v[parents[i]]->right=v[i];\\n        }\\n        //now we will calculate value for each node\\n        vector<long long int>val(n,0);\\n        long long int f=func(root,val);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(val[i]==maxv)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node *left,*right;\\n        Node(int i){\\n            val=i;\\n            left=right=NULL;\\n        }\\n    };\\n    long long int maxv=0;\\n    int func(Node *root, vector<long long int>&val){\\n        if(!root)return 0;\\n        int n=val.size();\\n        long long int l=func(root->left,val), r= func(root->right,val);\\n        if(root->val==0){ //for root c is 0\\n            if(l==0||r==0){\\n            val[root->val]=(l==0?r:l);\\n            }\\n            else{\\n                val[root->val]=l*r;\\n            }\\n            maxv=max(maxv,val[root->val]);\\n        return l+r+1;\\n        }\\n        int c=n-l-r-1;\\n        if(l==0&&r==0){\\n            val[root->val]=c;\\n        }\\n        else if(l==0||r==0){\\n            val[root->val]=(l==0?c*r:c*l);\\n        }\\n        else val[root->val]=c*l*r;\\n        \\n        maxv=max(maxv,val[root->val]);\\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<Node*>v(n,NULL);\\n        for(int i=0;i<n;i++){\\n            v[i]=new Node(i); //v[i] is pointer to node i\\n        }\\n        //now we will make tree\\n        Node *root=NULL;\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1){\\n                root=v[i];\\n            }\\n            else if(v[parents[i]]->left==NULL){\\n                v[parents[i]]->left=v[i];\\n            }\\n            else v[parents[i]]->right=v[i];\\n        }\\n        //now we will calculate value for each node\\n        vector<long long int>val(n,0);\\n        long long int f=func(root,val);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(val[i]==maxv)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538415,
                "title": "java-o-n-dfs-concise",
                "content": "\\n```\\nclass Solution {\\n    long max = 0, res = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n        Map<Integer, List<Integer>> hm = new HashMap();\\n        for(int i = 0; i < parents.length; i++) {   // build the tree\\n            hm.computeIfAbsent(parents[i], x ->new ArrayList<>()).add(i);\\n        }\\n        dfs(0, parents.length, hm); // traverse the tree to get the result\\n        return (int)res;\\n    }\\n    int dfs(int s, int n, Map<Integer, List<Integer>> hm) {\\n        int sum = 1;\\n        long mult = 1L;\\n        for(int child : hm.getOrDefault(s, new ArrayList<>())) {\\n            int count = dfs(child, n, hm); // subtree node count\\n            sum += count;\\n            mult *= count; // multiply the result by children size\\n        }     \\n        mult *= (s == 0 ? 1L : n - sum); // multiply the result by remain size except self and children size(the nodes through parent)\\n        if(mult > max) {\\n            max = mult;\\n            res = 1;\\n        } else if (mult == max) {\\n            res++;\\n        }\\n        return sum; // return the node count of the tree rooted at s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    long max = 0, res = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n        Map<Integer, List<Integer>> hm = new HashMap();\\n        for(int i = 0; i < parents.length; i++) {   // build the tree\\n            hm.computeIfAbsent(parents[i], x ->new ArrayList<>()).add(i);\\n        }\\n        dfs(0, parents.length, hm); // traverse the tree to get the result\\n        return (int)res;\\n    }\\n    int dfs(int s, int n, Map<Integer, List<Integer>> hm) {\\n        int sum = 1;\\n        long mult = 1L;\\n        for(int child : hm.getOrDefault(s, new ArrayList<>())) {\\n            int count = dfs(child, n, hm); // subtree node count\\n            sum += count;\\n            mult *= count; // multiply the result by children size\\n        }     \\n        mult *= (s == 0 ? 1L : n - sum); // multiply the result by remain size except self and children size(the nodes through parent)\\n        if(mult > max) {\\n            max = mult;\\n            res = 1;\\n        } else if (mult == max) {\\n            res++;\\n        }\\n        return sum; // return the node count of the tree rooted at s\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941755,
                "title": "2-dfs-c",
                "content": "```\\nclass Solution {\\n    int dfs1(int node, int pre, vector<int> adj[], vector<int> &cnt) {\\n        int c = 1;\\n        for(int ad : adj[node]) {\\n            if(ad == pre) continue;\\n            c += dfs1(ad, node, adj, cnt);\\n        }\\n        return cnt[node] = c;\\n    }\\n    void dfs2(int node, int pre, vector<int> adj[], vector<int> &cnt, int n, unordered_map<long long, int> &m) {\\n        long long p = 1;\\n        for(int ad : adj[node]) {\\n            if(ad == pre) {\\n                p *= n - cnt[node];\\n                continue;\\n            }\\n            p *= cnt[ad];\\n            dfs2(ad, node, adj, cnt, n, m);\\n        }\\n        m[p]++;\\n    }\\n\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(), ans;\\n        long long mx = 0;\\n        vector<int> adj[n];\\n        for(int i=1; i<n; i++) adj[i].push_back(parents[i]), adj[parents[i]].push_back(i);\\n\\n        vector<int> cnt(n);\\n        dfs1(0, -1, adj, cnt);\\n        \\n        unordered_map<long long, int> m;\\n        dfs2(0, -1, adj, cnt, n, m);\\n\\n        for(auto i : m) {\\n            if(i.first > mx) ans = i.second, mx = i.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dfs1(int node, int pre, vector<int> adj[], vector<int> &cnt) {\\n        int c = 1;\\n        for(int ad : adj[node]) {\\n            if(ad == pre) continue;\\n            c += dfs1(ad, node, adj, cnt);\\n        }\\n        return cnt[node] = c;\\n    }\\n    void dfs2(int node, int pre, vector<int> adj[], vector<int> &cnt, int n, unordered_map<long long, int> &m) {\\n        long long p = 1;\\n        for(int ad : adj[node]) {\\n            if(ad == pre) {\\n                p *= n - cnt[node];\\n                continue;\\n            }\\n            p *= cnt[ad];\\n            dfs2(ad, node, adj, cnt, n, m);\\n        }\\n        m[p]++;\\n    }\\n\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(), ans;\\n        long long mx = 0;\\n        vector<int> adj[n];\\n        for(int i=1; i<n; i++) adj[i].push_back(parents[i]), adj[parents[i]].push_back(i);\\n\\n        vector<int> cnt(n);\\n        dfs1(0, -1, adj, cnt);\\n        \\n        unordered_map<long long, int> m;\\n        dfs2(0, -1, adj, cnt, n, m);\\n\\n        for(auto i : m) {\\n            if(i.first > mx) ans = i.second, mx = i.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751415,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\n// if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public HashMap<Long,Integer> hash;\\n    public int dfs(int i,List<Integer>[] adj,int totalNodes)\\n    {\\n        int sumOfNodes=0;\\n        long product=1l;\\n        for(int curr : adj[i])\\n        {\\n            int currNodes=dfs(curr,adj,totalNodes);\\n            sumOfNodes+=currNodes;\\n            product*=currNodes;\\n        }\\n        int upNodes=(totalNodes-sumOfNodes-1);\\n        if(upNodes>0) product*=upNodes;\\n        hash.put(product,hash.getOrDefault(product,0)+1);\\n        return sumOfNodes+1;\\n    }\\n    public int countHighestScoreNodes(int[] parents) \\n    {\\n        List<Integer>[] adj=new ArrayList[parents.length];\\n        for(int i=0;i<parents.length;i++)  adj[i]=new ArrayList();\\n        for(int i=1;i<parents.length;i++)\\n        {\\n            adj[parents[i]].add(i);\\n        }\\n        hash=new HashMap<>();\\n        dfs(0,adj,parents.length);\\n        long max=0;\\n        for(long i : hash.keySet()) max=Math.max(max,i);\\n        return hash.get(max);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public HashMap<Long,Integer> hash;\\n    public int dfs(int i,List<Integer>[] adj,int totalNodes)\\n    {\\n        int sumOfNodes=0;\\n        long product=1l;\\n        for(int curr : adj[i])\\n        {\\n            int currNodes=dfs(curr,adj,totalNodes);\\n            sumOfNodes+=currNodes;\\n            product*=currNodes;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2523803,
                "title": "java-solution-hashmap-dfs-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) \\n    {\\n        int total_nodes=parents.length;\\n        \\n        //stores parent node---> child nodes\\n        Map<Integer,List<Integer>> parent_child=new HashMap<>();\\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            if(!parent_child.containsKey(parents[i]))\\n            parent_child.put(parents[i],new ArrayList<>());\\n            \\n            List<Integer> temp=parent_child.get(parents[i]);\\n            temp.add(i);\\n            parent_child.put(parents[i],temp);\\n        }\\n        \\n        \\n        //count[i]=num of nodes with ith node as a subTree\\n        int count[]=new int[total_nodes];\\n        int x=1;\\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            if(count[i]==0)\\n            x=fill_count_array(i,parent_child,count);\\n        }\\n        \\n        \\n        long max=0;int ans=0;\\n        \\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            List<Integer> child=parent_child.get(i);\\n            long curr=1;\\n            \\n            if(child!=null)\\n            {\\n              for(int j=0;j<child.size();j++)\\n              curr=curr*(long)count[child.get(j)];\\n            }\\n            \\n            if(parents[i]!=-1)\\n            curr=curr*(long)(total_nodes-count[i]);\\n            \\n            \\n            if(curr>max)\\n            {\\n                max=curr;\\n                ans=1;\\n            }\\n            \\n            else if(curr==max)\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int fill_count_array(int node,Map<Integer,List<Integer>> map,int count[])\\n    {\\n        if(count[node]!=0)\\n        return count[node];\\n        \\n        List<Integer> child=map.get(node);\\n        int total=1;\\n        \\n        if(child==null)\\n        return count[node]=1;\\n        \\n        for(int i=0;i<child.size();i++)\\n        {\\n            total+=fill_count_array(child.get(i),map,count);\\n        }\\n            \\n        count[node]=total;\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) \\n    {\\n        int total_nodes=parents.length;\\n        \\n        //stores parent node---> child nodes\\n        Map<Integer,List<Integer>> parent_child=new HashMap<>();\\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            if(!parent_child.containsKey(parents[i]))\\n            parent_child.put(parents[i],new ArrayList<>());\\n            \\n            List<Integer> temp=parent_child.get(parents[i]);\\n            temp.add(i);\\n            parent_child.put(parents[i],temp);\\n        }\\n        \\n        \\n        //count[i]=num of nodes with ith node as a subTree\\n        int count[]=new int[total_nodes];\\n        int x=1;\\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            if(count[i]==0)\\n            x=fill_count_array(i,parent_child,count);\\n        }\\n        \\n        \\n        long max=0;int ans=0;\\n        \\n        for(int i=0;i<total_nodes;i++)\\n        {\\n            List<Integer> child=parent_child.get(i);\\n            long curr=1;\\n            \\n            if(child!=null)\\n            {\\n              for(int j=0;j<child.size();j++)\\n              curr=curr*(long)count[child.get(j)];\\n            }\\n            \\n            if(parents[i]!=-1)\\n            curr=curr*(long)(total_nodes-count[i]);\\n            \\n            \\n            if(curr>max)\\n            {\\n                max=curr;\\n                ans=1;\\n            }\\n            \\n            else if(curr==max)\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int fill_count_array(int node,Map<Integer,List<Integer>> map,int count[])\\n    {\\n        if(count[node]!=0)\\n        return count[node];\\n        \\n        List<Integer> child=map.get(node);\\n        int total=1;\\n        \\n        if(child==null)\\n        return count[node]=1;\\n        \\n        for(int i=0;i<child.size();i++)\\n        {\\n            total+=fill_count_array(child.get(i),map,count);\\n        }\\n            \\n        count[node]=total;\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828786,
                "title": "c-solution-using-binary-tree-creation-then-dfs-for-finding-answer",
                "content": "struct TreeNode\\n     {\\n        TreeNode* left =NULL;\\n             TreeNode* right=NULL ;\\n             int val;\\n             int totalcount=0;\\n     };\\n       \\n       int func(TreeNode* root , int n)\\n       {\\n               if(root==NULL)\\n               {\\n                       return 0;\\n               }\\n               \\n               int x=func(root->left,n) + func(root->right,n)+1;\\n               root->totalcount=x;\\n               \\n               return x;\\n       }\\n        \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n            unordered_map<int ,TreeNode*> mp;\\n            \\n            //TreeNode* root=new TreeNode(0);\\n            for(int i=0;i<n;i++)\\n            {\\n                 TreeNode* node=new TreeNode();\\n                    node->val=i;\\n                    mp[i]=node;\\n            }\\n            for(int i=0;i<parents.size();i++)\\n            {\\n                    if(parents[i]!=-1)\\n                    {\\n                            TreeNode* node=mp[parents[i]];\\n                            if(node->left==NULL)\\n                            {\\n                                    node->left=mp[i];\\n                            }\\n                            else\\n                            {\\n                                    node->right=mp[i];\\n                            }\\n                            \\n                    }\\n            }\\n            TreeNode* root=mp[0];\\n            func(root,n);\\n            \\n            long long ans=0;\\n            int count=0;\\n            long long currval;\\n            int x1,x2;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                    TreeNode* node=it->second;\\n                    TreeNode* s1=node->left;\\n                    TreeNode* s2=node->right;\\n                     int nodeval=it->first;\\n                    if(s1==NULL)\\n                            x1=0;\\n                    else\\n                            x1=s1->totalcount;\\n                    \\n                    if(s2==NULL)\\n                            x2=0;\\n                    else\\n                            x2=s2->totalcount;\\n                    \\n                    \\n                  if(x1==0 && x2==0)\\n                  {\\n                          currval=n-1;\\n                          if(nodeval==0)\\n                                  currval=1;\\n                  }\\n                    else\\n                            if(x1==0)\\n                            {\\n                                    currval=(long long)x2*(n-x2-1);\\n                                    if(nodeval==0)\\n                                            currval=x2;\\n                            }\\n                    else\\n                            if(x2==0)\\n                            {\\n                                   currval=(long long)x1*(n-x1-1);\\n                                    if(nodeval==0)\\n                                            currval=x1;\\n                            }\\n                    else\\n                    {\\n                            currval=(long long)((long long)x1*(x2)*(long long)(n-x1-x2-1));\\n                            if(nodeval==0)\\n                                    currval=(long long)x1*x2;\\n                    }\\n                    \\n                 \\n                    if(currval==ans)\\n                    {\\n                            count++;\\n                    }\\n\\t\\t\\t\\t\\t   if(currval>ans)\\n                    {\\n                            ans=currval;\\n                            count=1;\\n                    }\\n                    \\n                    \\n            }\\n            \\n            return count;\\n            \\n              \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "struct TreeNode\\n     {\\n        TreeNode* left =NULL;\\n             TreeNode* right=NULL ;\\n             int val;\\n             int totalcount=0;\\n     };\\n       \\n       int func(TreeNode* root , int n)\\n       {\\n               if(root==NULL)\\n               {\\n                       return 0;\\n               }\\n               \\n               int x=func(root->left,n) + func(root->right,n)+1;\\n               root->totalcount=x;\\n               \\n               return x;\\n       }\\n        \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n            unordered_map<int ,TreeNode*> mp;\\n            \\n            //TreeNode* root=new TreeNode(0);\\n            for(int i=0;i<n;i++)\\n            {\\n                 TreeNode* node=new TreeNode();\\n                    node->val=i;\\n                    mp[i]=node;\\n            }\\n            for(int i=0;i<parents.size();i++)\\n            {\\n                    if(parents[i]!=-1)\\n                    {\\n                            TreeNode* node=mp[parents[i]];\\n                            if(node->left==NULL)\\n                            {\\n                                    node->left=mp[i];\\n                            }\\n                            else\\n                            {\\n                                    node->right=mp[i];\\n                            }\\n                            \\n                    }\\n            }\\n            TreeNode* root=mp[0];\\n            func(root,n);\\n            \\n            long long ans=0;\\n            int count=0;\\n            long long currval;\\n            int x1,x2;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                    TreeNode* node=it->second;\\n                    TreeNode* s1=node->left;\\n                    TreeNode* s2=node->right;\\n                     int nodeval=it->first;\\n                    if(s1==NULL)\\n                            x1=0;\\n                    else\\n                            x1=s1->totalcount;\\n                    \\n                    if(s2==NULL)\\n                            x2=0;\\n                    else\\n                            x2=s2->totalcount;\\n                    \\n                    \\n                  if(x1==0 && x2==0)\\n                  {\\n                          currval=n-1;\\n                          if(nodeval==0)\\n                                  currval=1;\\n                  }\\n                    else\\n                            if(x1==0)\\n                            {\\n                                    currval=(long long)x2*(n-x2-1);\\n                                    if(nodeval==0)\\n                                            currval=x2;\\n                            }\\n                    else\\n                            if(x2==0)\\n                            {\\n                                   currval=(long long)x1*(n-x1-1);\\n                                    if(nodeval==0)\\n                                            currval=x1;\\n                            }\\n                    else\\n                    {\\n                            currval=(long long)((long long)x1*(x2)*(long long)(n-x1-x2-1));\\n                            if(nodeval==0)\\n                                    currval=(long long)x1*x2;\\n                    }\\n                    \\n                 \\n                    if(currval==ans)\\n                    {\\n                            count++;\\n                    }\\n\\t\\t\\t\\t\\t   if(currval>ans)\\n                    {\\n                            ans=currval;\\n                            count=1;\\n                    }\\n                    \\n                    \\n            }\\n            \\n            return count;\\n            \\n              \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1809528,
                "title": "dynamic-programming-on-graphs",
                "content": "I used dp on trees to solve this problem.\\nThe concept is simple. \\nFirst you calculate size of each subtree for every node. Here dp on trees is applied for that. Size of subtrees added and +1 to get total size of that current node.\\nTo calculate score for current node, you subtract size of root node subtracted with size of current node and that is multiplied with sizes of subtree nodes.\\n\\n        \\n\\t\\tint countHighestScoreNodes(vector<int>& parent) {\\n        \\n        int n=parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        vector<ll> sz(n,0),score(n,0);\\n        dfs(0,adj,sz);\\n        ll max_score=INT_MIN;\\n        ll s=1;\\n        for(auto j: adj[0])\\n            s*=sz[j];\\n        score[0]=s;\\n        for(int i=1;i<n;i++)\\n        {\\n            s=1;\\n            s*=(sz[0]-sz[i]);\\n            for(auto j: adj[i])\\n            {\\n                s*=sz[j];\\n            }\\n            score[i]=s;\\n          //  cout<<score[i]<<\" \";\\n        }\\n        int count=0;\\n        max_score=*max_element(score.begin(),score.end());\\n        for(auto i: score)\\n        {\\n            if(max_score==i)\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n    void dfs(int i, vector<vector<int>> &adj, vector<ll> &sz)\\n    {\\n        sz[i]++;\\n        for(auto j: adj[i])\\n        {\\n            dfs(j,adj,sz);\\n            sz[i]+=sz[j];\\n        }\\n      //  cout<<sz[i]<<endl;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "I used dp on trees to solve this problem.\\nThe concept is simple. \\nFirst you calculate size of each subtree for every node. Here dp on trees is applied for that. Size of subtrees added and +1 to get total size of that current node.\\nTo calculate score for current node, you subtract size of root node subtracted with size of current node and that is multiplied with sizes of subtree nodes.\\n\\n        \\n\\t\\tint countHighestScoreNodes(vector<int>& parent) {\\n        \\n        int n=parent.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=1;i<n;i++)\\n        {\\n            adj[parent[i]].push_back(i);\\n        }\\n        vector<ll> sz(n,0),score(n,0);\\n        dfs(0,adj,sz);\\n        ll max_score=INT_MIN;\\n        ll s=1;\\n        for(auto j: adj[0])\\n            s*=sz[j];\\n        score[0]=s;\\n        for(int i=1;i<n;i++)\\n        {\\n            s=1;\\n            s*=(sz[0]-sz[i]);\\n            for(auto j: adj[i])\\n            {\\n                s*=sz[j];\\n            }\\n            score[i]=s;\\n          //  cout<<score[i]<<\" \";\\n        }\\n        int count=0;\\n        max_score=*max_element(score.begin(),score.end());\\n        for(auto i: score)\\n        {\\n            if(max_score==i)\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n    void dfs(int i, vector<vector<int>> &adj, vector<ll> &sz)\\n    {\\n        sz[i]++;\\n        for(auto j: adj[i])\\n        {\\n            dfs(j,adj,sz);\\n            sz[i]+=sz[j];\\n        }\\n      //  cout<<sz[i]<<endl;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1556557,
                "title": "calculate-subtree-size-at-every-node",
                "content": "**Calculate subtree size at every node.**\\nThen, score of a node = (product of size of subtree from every child) * (size of FULL tree - size of subtree at node).\\n\\n```\\nclass Solution {\\npublic:\\n    int getSize(int cur, vector<int> children[], int subSize[]) {\\n        subSize[cur] = 1;\\n        \\n        for(auto c : children[cur])\\n            subSize[cur] += getSize(c, children, subSize);\\n        \\n        return subSize[cur];\\n    }   \\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        int subSize[n];\\n        vector<int> children[n];\\n        \\n        for(int i=0; i<n; i++) \\n            if(parents[i]!=-1) children[parents[i]].push_back(i);\\n        \\n        getSize(0, children, subSize);\\n        \\n        long long int maxProduct = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            long long int curProduct = max(n - subSize[i], 1);\\n                // above condition given for root\\n            for(auto c : children[i]) curProduct *= subSize[c];\\n            \\n            if(curProduct > maxProduct) {\\n                maxProduct = curProduct;\\n                ans = 1;\\n            } else if(curProduct == maxProduct) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getSize(int cur, vector<int> children[], int subSize[]) {\\n        subSize[cur] = 1;\\n        \\n        for(auto c : children[cur])\\n            subSize[cur] += getSize(c, children, subSize);\\n        \\n        return subSize[cur];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1548239,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    void find(int x,int p,vector<int>&sub)\\n    {\\n        for(auto it:dp[x])\\n        {\\n            if(it!=p)\\n            {\\n               find(it,x,sub);\\n               sub[x]+=sub[it];\\n            }\\n        }\\n        \\n    }\\n    int countHighestScoreNodes(vector<int>& parents)\\n    {\\n        int n=parents.size();\\n        dp.resize(n);\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[parents[i]].push_back(i);\\n        }\\n        vector<int>subtree(n,1);\\n        find(0,-1,subtree);\\n        map<long long ,int,greater<long long>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long  pro=max(1,n-subtree[i]);\\n            for(auto it:dp[i])\\n            {\\n                pro=1ll*pro*subtree[it];\\n            }\\n            mp[pro]++;\\n        }\\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    void find(int x,int p,vector<int>&sub)\\n    {\\n        for(auto it:dp[x])\\n        {\\n            if(it!=p)\\n            {\\n               find(it,x,sub);\\n               sub[x]+=sub[it];\\n            }\\n        }\\n        \\n    }\\n    int countHighestScoreNodes(vector<int>& parents)\\n    {\\n        int n=parents.size();\\n        dp.resize(n);\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[parents[i]].push_back(i);\\n        }\\n        vector<int>subtree(n,1);\\n        find(0,-1,subtree);\\n        map<long long ,int,greater<long long>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long  pro=max(1,n-subtree[i]);\\n            for(auto it:dp[i])\\n            {\\n                pro=1ll*pro*subtree[it];\\n            }\\n            mp[pro]++;\\n        }\\n        return mp.begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548003,
                "title": "python-simple-dfs-solution-with-explanation",
                "content": "for each node, when we remove it, we have the following parts:\\n1. child subtree if any\\n2. parent subtree if any\\n\\nwe use dfs to count the number of node in each child subtree (no.1) and calculate the number of node in the parent subtree by `N - sum(child_subtree) - 1(node itself)`. We use `memo` to aovid duplicated calculation in dfs.\\n\\n```python\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        children = collections.defaultdict(list)\\n        for i, par in enumerate(parents):\\n            children[par].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(root):\\n            count = 1\\n            for child in children[root]:\\n                count += dfs(child)\\n            return count\\n\\n        N = len(parents)\\n        max_score = 0\\n        score_counter = collections.defaultdict(int)\\n\\n        for root in range(N):\\n            child = children[root]\\n            _sum = 0\\n            score = 1\\n\\n            # score of the child tree\\n            for c in child:\\n                count = dfs(c)\\n                score *= count\\n                _sum += count\\n\\n            curr_score = score * max(1, N-_sum-1) # score of the parent subtree\\n            score_counter[curr_score] += 1\\n            max_score = max(max_score, curr_score)\\n\\n        return score_counter[max_score]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        children = collections.defaultdict(list)\\n        for i, par in enumerate(parents):\\n            children[par].append(i)\\n\\n        @lru_cache(None)\\n        def dfs(root):\\n            count = 1\\n            for child in children[root]:\\n                count += dfs(child)\\n            return count\\n\\n        N = len(parents)\\n        max_score = 0\\n        score_counter = collections.defaultdict(int)\\n\\n        for root in range(N):\\n            child = children[root]\\n            _sum = 0\\n            score = 1\\n\\n            # score of the child tree\\n            for c in child:\\n                count = dfs(c)\\n                score *= count\\n                _sum += count\\n\\n            curr_score = score * max(1, N-_sum-1) # score of the parent subtree\\n            score_counter[curr_score] += 1\\n            max_score = max(max_score, curr_score)\\n\\n        return score_counter[max_score]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1538790,
                "title": "golang-postorder-traversal-solution",
                "content": "```go\\ntype cs struct {\\n\\tchildren []int\\n\\tsummary  int\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tmagic := make([]*cs, len(parents))\\n\\tfor i := range magic {\\n\\t\\tmagic[i] = &cs{\\n\\t\\t\\tchildren: make([]int, 0, 2),\\n\\t\\t\\tsummary:  1,\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(parents); i++ {\\n\\t\\tmagic[parents[i]].children = append(magic[parents[i]].children, i)\\n\\t}\\n\\tpostOrderTraversal(magic, 0)\\n\\thighestScore := 1\\n\\tfor _, v := range magic[0].children {\\n\\t\\thighestScore *= magic[v].summary\\n\\t}\\n\\thighestCount := 1\\n\\tfor i := 1; i < len(parents); i++ {\\n\\t\\tcurrentScore := 1\\n\\t\\tfor _, v := range magic[i].children {\\n\\t\\t\\tcurrentScore *= magic[v].summary\\n\\t\\t}\\n\\t\\tcurrentScore *= magic[0].summary - magic[i].summary\\n\\t\\tif currentScore > highestScore {\\n\\t\\t\\thighestScore = currentScore\\n\\t\\t\\thighestCount = 1\\n\\t\\t} else if currentScore == highestScore {\\n\\t\\t\\thighestCount++\\n\\t\\t}\\n\\t}\\n\\treturn highestCount\\n}\\n\\nfunc postOrderTraversal(magic []*cs, i int) {\\n\\tfor _, v := range magic[i].children {\\n\\t\\tpostOrderTraversal(magic, v)\\n\\t\\tmagic[i].summary += magic[v].summary\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype cs struct {\\n\\tchildren []int\\n\\tsummary  int\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tmagic := make([]*cs, len(parents))\\n\\tfor i := range magic {\\n\\t\\tmagic[i] = &cs{\\n\\t\\t\\tchildren: make([]int, 0, 2),\\n\\t\\t\\tsummary:  1,\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(parents); i++ {\\n\\t\\tmagic[parents[i]].children = append(magic[parents[i]].children, i)\\n\\t}\\n\\tpostOrderTraversal(magic, 0)\\n\\thighestScore := 1\\n\\tfor _, v := range magic[0].children {\\n\\t\\thighestScore *= magic[v].summary\\n\\t}\\n\\thighestCount := 1\\n\\tfor i := 1; i < len(parents); i++ {\\n\\t\\tcurrentScore := 1\\n\\t\\tfor _, v := range magic[i].children {\\n\\t\\t\\tcurrentScore *= magic[v].summary\\n\\t\\t}\\n\\t\\tcurrentScore *= magic[0].summary - magic[i].summary\\n\\t\\tif currentScore > highestScore {\\n\\t\\t\\thighestScore = currentScore\\n\\t\\t\\thighestCount = 1\\n\\t\\t} else if currentScore == highestScore {\\n\\t\\t\\thighestCount++\\n\\t\\t}\\n\\t}\\n\\treturn highestCount\\n}\\n\\nfunc postOrderTraversal(magic []*cs, i int) {\\n\\tfor _, v := range magic[i].children {\\n\\t\\tpostOrderTraversal(magic, v)\\n\\t\\tmagic[i].summary += magic[v].summary\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537725,
                "title": "javascript-dfs-372ms",
                "content": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\n\\nlet g, n, res, cnt;\\nconst countHighestScoreNodes = (parents) => {\\n    res = -1, cnt = 0, n = parents.length, g = initializeGraph(n);\\n    for (let i = 0; i < n; i++) {\\n        if (parents[i] == -1) continue;\\n        g[parents[i]].push(i);\\n    }\\n    dfs(0);\\n    return cnt;\\n};\\n\\nconst dfs = (x) => {\\n    let subtree = 0, p = 1;\\n    for (const child of g[x]) {\\n        let tmp = dfs(child);\\n        subtree += tmp;\\n        p *= tmp;\\n    }\\n    if (subtree < n - 1) p *= n - 1 - subtree;\\n    if (p > res) { // larger score comes, update res and reset cnt = 1\\n        res = p;\\n        cnt = 1;\\n    } else if (p == res) { // equal largest score\\n        cnt++;\\n    }\\n    return subtree + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\n\\nlet g, n, res, cnt;\\nconst countHighestScoreNodes = (parents) => {\\n    res = -1, cnt = 0, n = parents.length, g = initializeGraph(n);\\n    for (let i = 0; i < n; i++) {\\n        if (parents[i] == -1) continue;\\n        g[parents[i]].push(i);\\n    }\\n    dfs(0);\\n    return cnt;\\n};\\n\\nconst dfs = (x) => {\\n    let subtree = 0, p = 1;\\n    for (const child of g[x]) {\\n        let tmp = dfs(child);\\n        subtree += tmp;\\n        p *= tmp;\\n    }\\n    if (subtree < n - 1) p *= n - 1 - subtree;\\n    if (p > res) { // larger score comes, update res and reset cnt = 1\\n        res = p;\\n        cnt = 1;\\n    } else if (p == res) { // equal largest score\\n        cnt++;\\n    }\\n    return subtree + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537669,
                "title": "c-post-order-dfs-100-100",
                "content": "```\\npublic class Solution {\\n    \\n    int dfs(int[,] leaves, int[,] nums, int node)\\n    {\\n        int left = leaves[node, 0] == -1? 0: dfs(leaves, nums, leaves[node, 0]);\\n        int right = leaves[node, 1] == -1? 0: dfs(leaves, nums, leaves[node, 1]);\\n        nums[node, 0] = left;\\n        nums[node, 1] = right;\\n        return left + right + 1;\\n    }\\n    \\n    public int CountHighestScoreNodes(int[] parents) {\\n        int len = parents.Length;\\n        if (len < 2)\\n            return 0;\\n        \\n        int root = 0;\\n        int[,] nums= new int[len,2];\\n        int[,] leaves = new int[len, 2];\\n        \\n        for (int i = 0; i < len; i++){\\n            leaves[i,0] = -1;\\n            leaves[i,1] = -1;\\n        }\\n        \\n        for (int i = 0; i < len; i++){\\n            if (parents[i] == -1){\\n                root = i;\\n                continue;\\n            }\\n                \\n            if (leaves[parents[i], 0] == -1)\\n                leaves[parents[i], 0] = i;\\n            else\\n                leaves[parents[i], 1] = i;\\n        }\\n        \\n        dfs (leaves, nums, root);\\n        \\n        int result = 0;\\n        long max = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            long left = nums[i,0];\\n            long right = nums[i,1];\\n            long rest = len - left - right - 1 == 0? 1 : len - left - right - 1;\\n            if (left == 0)\\n                left = 1;\\n            if (right == 0)\\n                right = 1;\\n            \\n            long p = left * right * rest;\\n            \\n            if (p > max){\\n                max = p;\\n                result = 1;\\n            }else if (p == max){\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    int dfs(int[,] leaves, int[,] nums, int node)\\n    {\\n        int left = leaves[node, 0] == -1? 0: dfs(leaves, nums, leaves[node, 0]);\\n        int right = leaves[node, 1] == -1? 0: dfs(leaves, nums, leaves[node, 1]);\\n        nums[node, 0] = left;\\n        nums[node, 1] = right;\\n        return left + right + 1;\\n    }\\n    \\n    public int CountHighestScoreNodes(int[] parents) {\\n        int len = parents.Length;\\n        if (len < 2)\\n            return 0;\\n        \\n        int root = 0;\\n        int[,] nums= new int[len,2];\\n        int[,] leaves = new int[len, 2];\\n        \\n        for (int i = 0; i < len; i++){\\n            leaves[i,0] = -1;\\n            leaves[i,1] = -1;\\n        }\\n        \\n        for (int i = 0; i < len; i++){\\n            if (parents[i] == -1){\\n                root = i;\\n                continue;\\n            }\\n                \\n            if (leaves[parents[i], 0] == -1)\\n                leaves[parents[i], 0] = i;\\n            else\\n                leaves[parents[i], 1] = i;\\n        }\\n        \\n        dfs (leaves, nums, root);\\n        \\n        int result = 0;\\n        long max = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            long left = nums[i,0];\\n            long right = nums[i,1];\\n            long rest = len - left - right - 1 == 0? 1 : len - left - right - 1;\\n            if (left == 0)\\n                left = 1;\\n            if (right == 0)\\n                right = 1;\\n            \\n            long p = left * right * rest;\\n            \\n            if (p > max){\\n                max = p;\\n                result = 1;\\n            }else if (p == max){\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537578,
                "title": "o-n-solution-using-simple-tree-traversal-c-with-explanation-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n// first form a tree data structure to build your tree later in the q.\\n\\n    struct TreeNode\\n    {\\n        int val;\\n        TreeNode *left=NULL;\\n        TreeNode *right=NULL;\\n    };\\n    \\n    map<int,long long> score;\\n    long long maxScore=0;\\n    \\n\\t// use this function to return the size, however, also keep updating the score simulatneously\\n\\t// store the score corresponding to each node in a map called score, declared above, also \\n\\t// keep a note of the largest score so far!\\n\\t\\n    long long sizeHunt(TreeNode* node,int n)\\n    {\\n        if(!node) return 0;\\n        if(!node->left&&!node->right) // incase of a leaf node\\n        {\\n            score[node->val]=n-1;\\n            maxScore=max(maxScore,(long long) n-1);\\n            return 1;\\n        }\\n        \\n\\t\\t// incase it\\'s a non-leaf node, you need to get the size of the left and right subtree and also, the nodes, other than that.\\n\\t\\t\\n        long long left=sizeHunt(node->left,n);\\n        long long right=sizeHunt(node->right,n);\\n        \\n\\t\\t// remaining calculates the nodes other than the left and right subtrees.\\n\\t\\t\\n        long long rem=n-(left+right+1);\\n        long long s=0;\\n        if(left&&right) s=left*right;\\n        else if(left) s=left;\\n        else s=right;\\n        \\n        if(rem) s*=rem;\\n        \\n        score[node->val]=s;\\n        maxScore=max(maxScore,score[node->val]);\\n        \\n\\t\\t// return the size of this subtree\\n\\t\\t\\n        return left+right+1;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        map<int,TreeNode*> mp;\\n        \\n\\t\\t// store the node correspoding to the node value in the map\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            TreeNode* node=new TreeNode();\\n            node->val=i;\\n            mp[i]=node;\\n        }\\n        \\n\\t\\t// use the parent array to assign the children to its parent.\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n        {\\n            int p=parents[i];\\n            TreeNode* prt=mp[p];\\n            if(!prt->left) prt->left=mp[i];\\n            else prt->right=mp[i];\\n            \\n            mp[p]=prt;\\n        }\\n        \\n        TreeNode *root=mp[0];\\n        \\n        sizeHunt(root,n);\\n        int ans=0;\\n        \\n\\t\\t// go through the whole score map to see how many nodes have got the maxScore.\\n\\t\\t\\n        for(auto it=score.begin();it!=score.end();it++)\\n        {\\n            if(it->second==maxScore) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// first form a tree data structure to build your tree later in the q.\\n\\n    struct TreeNode\\n    {\\n        int val;\\n        TreeNode *left=NULL;\\n        TreeNode *right=NULL;\\n    };\\n    \\n    map<int,long long> score;\\n    long long maxScore=0;\\n    \\n\\t// use this function to return the size, however, also keep updating the score simulatneously\\n\\t// store the score corresponding to each node in a map called score, declared above, also \\n\\t// keep a note of the largest score so far!\\n\\t\\n    long long sizeHunt(TreeNode* node,int n)\\n    {\\n        if(!node) return 0;\\n        if(!node->left&&!node->right) // incase of a leaf node\\n        {\\n            score[node->val]=n-1;\\n            maxScore=max(maxScore,(long long) n-1);\\n            return 1;\\n        }\\n        \\n\\t\\t// incase it\\'s a non-leaf node, you need to get the size of the left and right subtree and also, the nodes, other than that.\\n\\t\\t\\n        long long left=sizeHunt(node->left,n);\\n        long long right=sizeHunt(node->right,n);\\n        \\n\\t\\t// remaining calculates the nodes other than the left and right subtrees.\\n\\t\\t\\n        long long rem=n-(left+right+1);\\n        long long s=0;\\n        if(left&&right) s=left*right;\\n        else if(left) s=left;\\n        else s=right;\\n        \\n        if(rem) s*=rem;\\n        \\n        score[node->val]=s;\\n        maxScore=max(maxScore,score[node->val]);\\n        \\n\\t\\t// return the size of this subtree\\n\\t\\t\\n        return left+right+1;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        map<int,TreeNode*> mp;\\n        \\n\\t\\t// store the node correspoding to the node value in the map\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n            TreeNode* node=new TreeNode();\\n            node->val=i;\\n            mp[i]=node;\\n        }\\n        \\n\\t\\t// use the parent array to assign the children to its parent.\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n        {\\n            int p=parents[i];\\n            TreeNode* prt=mp[p];\\n            if(!prt->left) prt->left=mp[i];\\n            else prt->right=mp[i];\\n            \\n            mp[p]=prt;\\n        }\\n        \\n        TreeNode *root=mp[0];\\n        \\n        sizeHunt(root,n);\\n        int ans=0;\\n        \\n\\t\\t// go through the whole score map to see how many nodes have got the maxScore.\\n\\t\\t\\n        for(auto it=score.begin();it!=score.end();it++)\\n        {\\n            if(it->second==maxScore) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537554,
                "title": "c-dp-on-tree-easy-solution-dfs",
                "content": "* Calculate size of subtree for each node using DFS\\n* Now we have to remove each vertex **i** , there might be three possibility-\\n        1. we remove leaf node\\n        2. we remove node having one child\\n        3. we remove node having two child      \\n```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& par) {\\n        long long int n = par.size();\\n        vector<long long int> adj[n];\\n        for(long long int i=1;i<par.size();i++)\\n        {\\n            adj[par[i]].push_back(i);\\n        }\\n        vector<long long int>dp(n,0);\\n        map<long long int,long long int>mp;\\n        dfs(adj,0,-1,dp);\\n        long long int ans = -1;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            long long int left , right , rem;\\n            if(adj[i].size()==0)\\n            {\\n                left = 1;\\n                right = 1;\\n                rem = n-1;\\n            }\\n            if(adj[i].size()==1)\\n            {\\n                left = dp[adj[i][0]];\\n                right = 1;\\n                rem = n-1-left;\\n                if(rem==0)\\n                    rem=1;\\n            }\\n            \\n            if(adj[i].size()==2)\\n            {\\n                 left = dp[adj[i][0]];\\n                 right = dp[adj[i][1]];\\n                 rem = n-1-left-right;\\n                 if(rem==0)\\n                     rem=1;\\n            }\\n            // cout<<left*right*rem<<\" \";\\n            mp[left*right*rem]++;\\n        }\\n        return mp.rbegin()->second;\\n    }\\n    \\n    void dfs(vector<long long int>adj[] ,long long int src , long long int par , vector<long long int>&dp )\\n    {\\n        dp[src]=1;\\n        for(auto xt : adj[src])\\n        {\\n            if(xt!=par)\\n            {\\n                dfs(adj,xt,src,dp);\\n                dp[src]+=dp[xt];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& par) {\\n        long long int n = par.size();\\n        vector<long long int> adj[n];\\n        for(long long int i=1;i<par.size();i++)\\n        {\\n            adj[par[i]].push_back(i);\\n        }\\n        vector<long long int>dp(n,0);\\n        map<long long int,long long int>mp;\\n        dfs(adj,0,-1,dp);\\n        long long int ans = -1;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            long long int left , right , rem;\\n            if(adj[i].size()==0)\\n            {\\n                left = 1;\\n                right = 1;\\n                rem = n-1;\\n            }\\n            if(adj[i].size()==1)\\n            {\\n                left = dp[adj[i][0]];\\n                right = 1;\\n                rem = n-1-left;\\n                if(rem==0)\\n                    rem=1;\\n            }\\n            \\n            if(adj[i].size()==2)\\n            {\\n                 left = dp[adj[i][0]];\\n                 right = dp[adj[i][1]];\\n                 rem = n-1-left-right;\\n                 if(rem==0)\\n                     rem=1;\\n            }\\n            // cout<<left*right*rem<<\" \";\\n            mp[left*right*rem]++;\\n        }\\n        return mp.rbegin()->second;\\n    }\\n    \\n    void dfs(vector<long long int>adj[] ,long long int src , long long int par , vector<long long int>&dp )\\n    {\\n        dp[src]=1;\\n        for(auto xt : adj[src])\\n        {\\n            if(xt!=par)\\n            {\\n                dfs(adj,xt,src,dp);\\n                dp[src]+=dp[xt];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1537550,
                "title": "c-2049-count-nodes-with-the-highest-score",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(); \\n        vector<vector<int>> tree(n); \\n        for (int i = 0; i < n; ++i) \\n            if (parents[i] >= 0) tree[parents[i]].push_back(i); \\n        \\n        map<long, int> freq; \\n        \\n        function<int(int)> fn = [&](int x) {\\n            int left = 0, right = 0; \\n            if (tree[x].size()) left = fn(tree[x][0]); \\n            if (tree[x].size() > 1) right = fn(tree[x][1]); \\n            long score = 1; \\n            if (left) score *= left; \\n            if (right) score *= right; \\n            if (n - 1 - left - right) score *= n - 1 - left - right; \\n            ++freq[score]; \\n            return 1 + left + right; \\n        };\\n        \\n        fn(0); \\n        return freq.rbegin()->second; \\n    }\\n};\\n```\\n\\nAlternative implementation\\n```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(); \\n        vector<vector<int>> tree(n); \\n        for (int i = 0; i < n; ++i) \\n            if (parents[i] >= 0) tree[parents[i]].push_back(i); \\n        \\n        map<long, int> freq; \\n        \\n        function<int(int)> fn = [&](int x) {\\n            long count = 1, score = 1; \\n            for (auto& xx : tree[x]) {\\n                int cc = fn(xx); \\n                count += cc; \\n                score *= cc; \\n            }\\n            score *= max(1l, n - count); \\n            ++freq[score]; \\n            return count; \\n        };\\n        \\n        fn(0); \\n        return freq.rbegin()->second; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(); \\n        vector<vector<int>> tree(n); \\n        for (int i = 0; i < n; ++i) \\n            if (parents[i] >= 0) tree[parents[i]].push_back(i); \\n        \\n        map<long, int> freq; \\n        \\n        function<int(int)> fn = [&](int x) {\\n            int left = 0, right = 0; \\n            if (tree[x].size()) left = fn(tree[x][0]); \\n            if (tree[x].size() > 1) right = fn(tree[x][1]); \\n            long score = 1; \\n            if (left) score *= left; \\n            if (right) score *= right; \\n            if (n - 1 - left - right) score *= n - 1 - left - right; \\n            ++freq[score]; \\n            return 1 + left + right; \\n        };\\n        \\n        fn(0); \\n        return freq.rbegin()->second; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size(); \\n        vector<vector<int>> tree(n); \\n        for (int i = 0; i < n; ++i) \\n            if (parents[i] >= 0) tree[parents[i]].push_back(i); \\n        \\n        map<long, int> freq; \\n        \\n        function<int(int)> fn = [&](int x) {\\n            long count = 1, score = 1; \\n            for (auto& xx : tree[x]) {\\n                int cc = fn(xx); \\n                count += cc; \\n                score *= cc; \\n            }\\n            score *= max(1l, n - count); \\n            ++freq[score]; \\n            return count; \\n        };\\n        \\n        fn(0); \\n        return freq.rbegin()->second; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023952,
                "title": "easy-c-solution-dfs-graph",
                "content": "# Intuition\\nSince TreeNode class is not previously declared so it is a hint we dont need that. It is just a simple problem of graph and selecting the maximum.\\n\\n# Approach\\nCreate adjacency matrix and take the product of the components after disconnection. If its is max update max and reset count to 1, else update count.\\n\\n# Complexity\\n- Time complexity:\\nO(n)-->Since we are iterating each nodes only once.\\n\\n- Space complexity:\\nO(n)-->For creating adjacency matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    long long maxi=-1, count=0;\\n    int solver(vector<vector<int>>& adj, int node) {\\n        long long score = 1;\\n        int childs = adj[node].size();\\n\\n        int leftNodes = 0, rightNodes = 0;\\n        if (childs > 0) leftNodes = solver(adj, adj[node][0]);\\n        if (childs > 1) rightNodes = solver(adj, adj[node][1]);\\n\\n        if (leftNodes > 0) score *=leftNodes;\\n        if (rightNodes > 0) score *=rightNodes;\\n\\n        int parentNodes = n-leftNodes-rightNodes-1;\\n        if (parentNodes > 0) score *= parentNodes;\\n\\n        if (score > maxi) {\\n            maxi = score;\\n            count = 1;\\n        }\\n\\n        else if (score == maxi) count++;\\n\\n        return leftNodes + rightNodes + 1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        vector<vector<int>> adj(n);\\n        for (int i=1; i<n; i++) {\\n            adj[parents[i]].push_back(i);\\n        }\\n\\n        solver(adj, 0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long maxi=-1, count=0;\\n    int solver(vector<vector<int>>& adj, int node) {\\n        long long score = 1;\\n        int childs = adj[node].size();\\n\\n        int leftNodes = 0, rightNodes = 0;\\n        if (childs > 0) leftNodes = solver(adj, adj[node][0]);\\n        if (childs > 1) rightNodes = solver(adj, adj[node][1]);\\n\\n        if (leftNodes > 0) score *=leftNodes;\\n        if (rightNodes > 0) score *=rightNodes;\\n\\n        int parentNodes = n-leftNodes-rightNodes-1;\\n        if (parentNodes > 0) score *= parentNodes;\\n\\n        if (score > maxi) {\\n            maxi = score;\\n            count = 1;\\n        }\\n\\n        else if (score == maxi) count++;\\n\\n        return leftNodes + rightNodes + 1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        vector<vector<int>> adj(n);\\n        for (int i=1; i<n; i++) {\\n            adj[parents[i]].push_back(i);\\n        }\\n\\n        solver(adj, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036966,
                "title": "c-simple-dfs-on-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    long long N;\\n    long long maxi;\\n    long long count;\\n    int dfs(vector<vector<int>>& g, int src){\\n        \\n        int l = 0,r = 0;\\n        \\n        if(g[src].size() > 0){\\n            l = dfs(g,g[src][0]);\\n        }\\n        \\n        if(g[src].size() > 1){\\n            r = dfs(g,g[src][1]);\\n        }\\n        \\n        long long res = 1;\\n        \\n        if(l)res *= l;\\n        if(r)res *= r;\\n        \\n        long long left = N-(l+r)-1;\\n        \\n        if(left)res *= left;\\n        if(maxi < res){\\n            count=1;\\n            maxi=res;\\n        }\\n        \\n        else if(maxi == res){\\n            count++;\\n        }\\n        \\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        int n = size(parents);\\n        \\n        maxi = -1;\\n        count = 0;\\n        N=n;\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            g[parents[i]].push_back(i);\\n        }\\n        \\n        dfs(g,0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long N;\\n    long long maxi;\\n    long long count;\\n    int dfs(vector<vector<int>>& g, int src){\\n        \\n        int l = 0,r = 0;\\n        \\n        if(g[src].size() > 0){\\n            l = dfs(g,g[src][0]);\\n        }\\n        \\n        if(g[src].size() > 1){\\n            r = dfs(g,g[src][1]);\\n        }\\n        \\n        long long res = 1;\\n        \\n        if(l)res *= l;\\n        if(r)res *= r;\\n        \\n        long long left = N-(l+r)-1;\\n        \\n        if(left)res *= left;\\n        if(maxi < res){\\n            count=1;\\n            maxi=res;\\n        }\\n        \\n        else if(maxi == res){\\n            count++;\\n        }\\n        \\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        int n = size(parents);\\n        \\n        maxi = -1;\\n        count = 0;\\n        N=n;\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            g[parents[i]].push_back(i);\\n        }\\n        \\n        dfs(g,0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978589,
                "title": "python3-solution-dfs-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        scores = [1] * n\\n        graph = [[] for _ in range(n)]\\n        for e, i in enumerate(parents):\\n            if e: graph[i].append(e)\\n        def dfs(i):\\n            res = 1\\n            for j in graph[i]:\\n                val = dfs(j)\\n                res += val\\n                scores[i] *= val\\n            if i: scores[i] *= (n - res)\\n            return res\\n        dfs(0)\\n        return scores.count(max(scores))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        scores = [1] * n\\n        graph = [[] for _ in range(n)]\\n        for e, i in enumerate(parents):\\n            if e: graph[i].append(e)\\n        def dfs(i):\\n            res = 1\\n            for j in graph[i]:\\n                val = dfs(j)\\n                res += val\\n                scores[i] *= val\\n            if i: scores[i] *= (n - res)\\n            return res\\n        dfs(0)\\n        return scores.count(max(scores))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896444,
                "title": "python-easy-recursive-solution",
                "content": "## Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        sizes = [[0]*2 for _ in range(len(parents))]\\n        dic = defaultdict(list)\\n\\n        def rec(root):\\n\\n            if not dic[root]:\\n                return 1\\n\\n            if len(dic[root]) == 1:\\n                sizes[root][0] = rec(dic[root][0])\\n            elif len(dic[root]) == 2:\\n                sizes[root][0] = rec(dic[root][0])\\n                sizes[root][1] = rec(dic[root][1])\\n\\n            return 1 + sizes[root][0] + sizes[root][1]\\n\\n        for i in range(1,len(parents)):\\n            dic[parents[i]].append(i)\\n\\n        total = rec(0)\\n\\n        res = []\\n        for x,y in sizes:\\n            res.append(max(x,1) * max(y,1) * max(total-x-y-1,1))\\n\\n        return res.count(max(res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        sizes = [[0]*2 for _ in range(len(parents))]\\n        dic = defaultdict(list)\\n\\n        def rec(root):\\n\\n            if not dic[root]:\\n                return 1\\n\\n            if len(dic[root]) == 1:\\n                sizes[root][0] = rec(dic[root][0])\\n            elif len(dic[root]) == 2:\\n                sizes[root][0] = rec(dic[root][0])\\n                sizes[root][1] = rec(dic[root][1])\\n\\n            return 1 + sizes[root][0] + sizes[root][1]\\n\\n        for i in range(1,len(parents)):\\n            dic[parents[i]].append(i)\\n\\n        total = rec(0)\\n\\n        res = []\\n        for x,y in sizes:\\n            res.append(max(x,1) * max(y,1) * max(total-x-y-1,1))\\n\\n        return res.count(max(res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762362,
                "title": "java-solution-hashtables-dfs-o-n-time",
                "content": "```java\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length; // no. of nodes\\n        \\n        //for storing left and right child of each node\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        \\n        for(int i=0;i<n;i++)\\n            a[i]=new ArrayList<Integer>();\\n        \\n        for(int i=1;i<n;i++)\\n            a[parents[i]].add(i);\\n        \\n        //store total number of children of each node\\n        int[] child = new int[n]; \\n        Arrays.fill(child,-1);\\n        \\n        dfs(0,a,child); //calculating all childrens at each node\\n    \\n        //storing scores of each node\\n        long[] scores = new long[a.length];\\n        \\n        long maxScore=0; //maxScore\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long res=1; // calculating score for a particular node\\n            for(int y:a[i])\\n                res*=child[y]+1;\\n            \\n            res*=Math.max(1,n-child[i]-1);\\n            scores[i]=res;\\n            if(res>maxScore)\\n                maxScore=res;\\n        }\\n    \\n        int c=0; // count of maxScores\\n        for(long score:scores)\\n            if(score==maxScore)\\n                c++;\\n        \\n        return c;\\n    }\\n    \\n    private int dfs(int x,ArrayList<Integer>[] a,int[] child)\\n    {\\n        int c=0;\\n        for(int y:a[x])\\n            c+=dfs(y,a,child);\\n\\n        return child[x]=c+a[x].size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length; // no. of nodes\\n        \\n        //for storing left and right child of each node\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        \\n        for(int i=0;i<n;i++)\\n            a[i]=new ArrayList<Integer>();\\n        \\n        for(int i=1;i<n;i++)\\n            a[parents[i]].add(i);\\n        \\n        //store total number of children of each node\\n        int[] child = new int[n]; \\n        Arrays.fill(child,-1);\\n        \\n        dfs(0,a,child); //calculating all childrens at each node\\n    \\n        //storing scores of each node\\n        long[] scores = new long[a.length];\\n        \\n        long maxScore=0; //maxScore\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            long res=1; // calculating score for a particular node\\n            for(int y:a[i])\\n                res*=child[y]+1;\\n            \\n            res*=Math.max(1,n-child[i]-1);\\n            scores[i]=res;\\n            if(res>maxScore)\\n                maxScore=res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2719332,
                "title": "ez-python-dfs",
                "content": "```\\nclass Node:\\n    \\n    \\n    def __init__(self, n):\\n        self.n = n\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        MAX_COUNT = 0\\n        MAX_NUM = -inf\\n        TOTAL = len(parents)\\n        \\n        \\n        nodes = {}\\n        for i in range(TOTAL):\\n            nodes[i] = Node(i)\\n        \\n        for i in range(1, TOTAL):\\n            parent_node = nodes[parents[i]]\\n            if parent_node.left == None:\\n                parent_node.left = nodes[i]\\n            else:\\n                parent_node.right = nodes[i]\\n        \\n        \\n        def dfs(node):\\n            \\n            nonlocal MAX_NUM\\n            nonlocal MAX_COUNT\\n            nonlocal TOTAL\\n            \\n            if not node:\\n                return 0\\n            \\n            l = dfs(node.left)\\n            r = dfs(node.right)\\n            total_child = l+r\\n            top = TOTAL - total_child - 1\\n            \\n            l_temp = l if l !=0 else 1\\n            r_temp = r if r!=0 else 1\\n            top_temp = top if top !=0 else 1\\n            \\n            count = l_temp * r_temp * top_temp\\n\\n            \\n            if count > MAX_NUM :\\n                MAX_NUM = count\\n                MAX_COUNT = 1\\n            elif count == MAX_NUM:\\n                MAX_COUNT += 1\\n            \\n            return 1 + l + r \\n        \\n        dfs(nodes[0])\\n        \\n        return MAX_COUNT\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node:\\n    \\n    \\n    def __init__(self, n):\\n        self.n = n\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        MAX_COUNT = 0\\n        MAX_NUM = -inf\\n        TOTAL = len(parents)\\n        \\n        \\n        nodes = {}\\n        for i in range(TOTAL):\\n            nodes[i] = Node(i)\\n        \\n        for i in range(1, TOTAL):\\n            parent_node = nodes[parents[i]]\\n            if parent_node.left == None:\\n                parent_node.left = nodes[i]\\n            else:\\n                parent_node.right = nodes[i]\\n        \\n        \\n        def dfs(node):\\n            \\n            nonlocal MAX_NUM\\n            nonlocal MAX_COUNT\\n            nonlocal TOTAL\\n            \\n            if not node:\\n                return 0\\n            \\n            l = dfs(node.left)\\n            r = dfs(node.right)\\n            total_child = l+r\\n            top = TOTAL - total_child - 1\\n            \\n            l_temp = l if l !=0 else 1\\n            r_temp = r if r!=0 else 1\\n            top_temp = top if top !=0 else 1\\n            \\n            count = l_temp * r_temp * top_temp\\n\\n            \\n            if count > MAX_NUM :\\n                MAX_NUM = count\\n                MAX_COUNT = 1\\n            elif count == MAX_NUM:\\n                MAX_COUNT += 1\\n            \\n            return 1 + l + r \\n        \\n        dfs(nodes[0])\\n        \\n        return MAX_COUNT\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478835,
                "title": "python-simple-dfs",
                "content": "\\n    def countHighestScoreNodes(self, parents):\\n        dict1 = defaultdict(list)\\n        \\n        for node, parent in enumerate(parents):\\n            dict1[parent].append(node)\\n            \\n        n, dict2 = len(parents), defaultdict(int)\\n        \\n        def dfs(node):\\n            product, total = 1, 0\\n            \\n            for child in dict1[node]:\\n                res = dfs(child)\\n                product *= res\\n                total += res\\n                \\n            product *= max(1, n-1-total)\\n            \\n            dict2[product] += 1\\n            \\n            return total + 1\\n        \\n        dfs(0)\\n    \\n        return dict2[max(dict2.keys())]\\n",
                "solutionTags": [],
                "code": "\\n    def countHighestScoreNodes(self, parents):\\n        dict1 = defaultdict(list)\\n        \\n        for node, parent in enumerate(parents):\\n            dict1[parent].append(node)\\n            \\n        n, dict2 = len(parents), defaultdict(int)\\n        \\n        def dfs(node):\\n            product, total = 1, 0\\n            \\n            for child in dict1[node]:\\n                res = dfs(child)\\n                product *= res\\n                total += res\\n                \\n            product *= max(1, n-1-total)\\n            \\n            dict2[product] += 1\\n            \\n            return total + 1\\n        \\n        dfs(0)\\n    \\n        return dict2[max(dict2.keys())]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2298480,
                "title": "standard-dfs-template-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    long long mx=0;\\n    int n;\\n    int dfs(vector<vector<int>>& g,int src=0){\\n        long long temp=1;\\n        int node=1;\\n        for(auto x:g[src]){\\n             int count=dfs(g,x);\\n             temp*=(long long)count;\\n             node+=count;\\n        }\\n         temp*=max(n-node,1);\\n        if(temp==mx)\\n            ans++;\\n        else if(temp>mx){\\n            ans=1;\\n            mx=temp;\\n        }\\n        \\n        return node;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n=parents.size();\\n        vector<vector<int>> g(n);\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n        } \\n        dfs(g);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    long long mx=0;\\n    int n;\\n    int dfs(vector<vector<int>>& g,int src=0){\\n        long long temp=1;\\n        int node=1;\\n        for(auto x:g[src]){\\n             int count=dfs(g,x);\\n             temp*=(long long)count;\\n             node+=count;\\n        }\\n         temp*=max(n-node,1);\\n        if(temp==mx)\\n            ans++;\\n        else if(temp>mx){\\n            ans=1;\\n            mx=temp;\\n        }\\n        \\n        return node;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n=parents.size();\\n        vector<vector<int>> g(n);\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n        } \\n        dfs(g);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207110,
                "title": "java-35ms-dfs-95-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm/Theory\\n        1. An efficient first step is to build the tree. This way, we can post-order traverse it and determine the product of non-empty subtrees\\n        2. Use a simple Node[] array to map node order/value to Node content.\\n           set node[0] to be the parent.\\n           loop from 1 to n and if the current node[i] is null, set it as new node. If the parent is null, initialize node[parent[i]].\\n           set node[parent[i]].left or .right to node[i], depending if left or right is already set.\\n        3. Continue post-order traversal. \\n            - if on a leaf, that leaf will make a score of total -1. Check against the current highest score and set. Return 1 as that leaft has only 1 node\\n            - if not on a leaf, apply post-oder to left and right.\\n        4. After 3b) for each parent node, determine its number of nodes from its subtree: 1 + left + right.\\n        6. Once 5 is done, determine the highest score that node will generate.\\n           This will be Math.max(1, onLeft) * Math.max(1, onRight) * Math.max(1, (totalNodes - nrOfNodesFromSubtree)).\\n           Basically we are multiplying the remaining 3 groups of nodes that are formed from the removal of that node (left, right, above).\\n           Pay attention to multiply with 1 (not with 0). The root will have no \"above\" nodes so total - nodesOnSubtree will return 0.\\n    */\\n   public int countHighestScoreNodes(int[] parents) {\\n        Node[] nodes = buildTree(parents);\\n        long[] highestScore = {0,0};\\n        countHighestScore(nodes[0], highestScore, parents.length);\\n        return (int)highestScore[1];\\n    }\\n\\n    private int countHighestScore(Node node, long[] highestScore, int total) {\\n        if (node != null) {\\n            if (node.left == null && node.right == null) {\\n                // a leaf will have 1 node under(itself) and will produce a total nodes - 1 score.\\n                if (highestScore[0] == total - 1) {\\n                    highestScore[1]++;\\n                } else if (highestScore[0] < total - 1) {\\n                    highestScore[0] = total - 1;\\n                    highestScore[1] = 1;\\n                }\\n                return 1;\\n            } else {\\n                // apply post-order and see how many nodes are left and right\\n                int onLeft = countHighestScore(node.left, highestScore, total);\\n                int onRight = countHighestScore(node.right, highestScore, total);\\n                int totalSubtree = onLeft + onRight + 1;\\n                // if left or right is null, replace it with 1, multiplication by 1\\n                long possibleScore = (long) (Math.max(1, onLeft)) * Math.max(onRight, 1)\\n                        * Math.max(1, total - totalSubtree);\\n                if (highestScore[0] == possibleScore) {\\n                    highestScore[1]++;\\n                } else if (highestScore[0] < possibleScore) {\\n                    highestScore[0] = possibleScore;\\n                    highestScore[1] = 1;\\n                }\\n                return totalSubtree;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    private Node[] buildTree(int[] parents) {\\n        Node[] nodes = new Node[parents.length];\\n        nodes[0] = new Node();\\n        for (int i = 1; i < parents.length; i++) {\\n            // create current node\\n            if (nodes[i] == null) {\\n                nodes[i] = new Node();\\n            }\\n            // create parent node\\n            if (nodes[parents[i]] == null) {\\n                nodes[parents[i]] = new Node();\\n            }\\n            // link parent node left or right to this child node.\\n            if (nodes[parents[i]].left == null) {\\n                nodes[parents[i]].left = nodes[i];\\n            } else {\\n                nodes[parents[i]].right = nodes[i];\\n            }\\n        }\\n        return nodes;\\n    }\\n\\n    private static class Node {\\n        Node left;\\n        Node right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm/Theory\\n        1. An efficient first step is to build the tree. This way, we can post-order traverse it and determine the product of non-empty subtrees\\n        2. Use a simple Node[] array to map node order/value to Node content.\\n           set node[0] to be the parent.\\n           loop from 1 to n and if the current node[i] is null, set it as new node. If the parent is null, initialize node[parent[i]].\\n           set node[parent[i]].left or .right to node[i], depending if left or right is already set.\\n        3. Continue post-order traversal. \\n            - if on a leaf, that leaf will make a score of total -1. Check against the current highest score and set. Return 1 as that leaft has only 1 node\\n            - if not on a leaf, apply post-oder to left and right.\\n        4. After 3b) for each parent node, determine its number of nodes from its subtree: 1 + left + right.\\n        6. Once 5 is done, determine the highest score that node will generate.\\n           This will be Math.max(1, onLeft) * Math.max(1, onRight) * Math.max(1, (totalNodes - nrOfNodesFromSubtree)).\\n           Basically we are multiplying the remaining 3 groups of nodes that are formed from the removal of that node (left, right, above).\\n           Pay attention to multiply with 1 (not with 0). The root will have no \"above\" nodes so total - nodesOnSubtree will return 0.\\n    */\\n   public int countHighestScoreNodes(int[] parents) {\\n        Node[] nodes = buildTree(parents);\\n        long[] highestScore = {0,0};\\n        countHighestScore(nodes[0], highestScore, parents.length);\\n        return (int)highestScore[1];\\n    }\\n\\n    private int countHighestScore(Node node, long[] highestScore, int total) {\\n        if (node != null) {\\n            if (node.left == null && node.right == null) {\\n                // a leaf will have 1 node under(itself) and will produce a total nodes - 1 score.\\n                if (highestScore[0] == total - 1) {\\n                    highestScore[1]++;\\n                } else if (highestScore[0] < total - 1) {\\n                    highestScore[0] = total - 1;\\n                    highestScore[1] = 1;\\n                }\\n                return 1;\\n            } else {\\n                // apply post-order and see how many nodes are left and right\\n                int onLeft = countHighestScore(node.left, highestScore, total);\\n                int onRight = countHighestScore(node.right, highestScore, total);\\n                int totalSubtree = onLeft + onRight + 1;\\n                // if left or right is null, replace it with 1, multiplication by 1\\n                long possibleScore = (long) (Math.max(1, onLeft)) * Math.max(onRight, 1)\\n                        * Math.max(1, total - totalSubtree);\\n                if (highestScore[0] == possibleScore) {\\n                    highestScore[1]++;\\n                } else if (highestScore[0] < possibleScore) {\\n                    highestScore[0] = possibleScore;\\n                    highestScore[1] = 1;\\n                }\\n                return totalSubtree;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    private Node[] buildTree(int[] parents) {\\n        Node[] nodes = new Node[parents.length];\\n        nodes[0] = new Node();\\n        for (int i = 1; i < parents.length; i++) {\\n            // create current node\\n            if (nodes[i] == null) {\\n                nodes[i] = new Node();\\n            }\\n            // create parent node\\n            if (nodes[parents[i]] == null) {\\n                nodes[parents[i]] = new Node();\\n            }\\n            // link parent node left or right to this child node.\\n            if (nodes[parents[i]].left == null) {\\n                nodes[parents[i]].left = nodes[i];\\n            } else {\\n                nodes[parents[i]].right = nodes[i];\\n            }\\n        }\\n        return nodes;\\n    }\\n\\n    private static class Node {\\n        Node left;\\n        Node right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125380,
                "title": "simple-java-solution-dfs-build-tree",
                "content": "```\\nclass Solution {\\n    static class TreeNode {\\n        int val;\\n        TreeNode left,right;\\n        TreeNode() {\\n            \\n        }\\n        TreeNode(int val) {\\n            this.val=val;\\n        }\\n    }\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n=parents.length;\\n        HashMap<Integer,TreeNode> map=new HashMap<>();\\n        for(int i=0;i<n;i++) {\\n            map.put(i,new TreeNode(i));\\n        }\\n        TreeNode root=null;\\n        for(int i=0;i<n;i++) {\\n            if(parents[i]==-1) {\\n                root=map.get(i);\\n            }\\n            else {\\n                TreeNode parent=map.get(parents[i]);\\n                TreeNode child=map.get(i);\\n                if(parent.left==null) {\\n                    parent.left=child;\\n                }\\n                else {\\n                    parent.right=child;\\n                }\\n                    \\n            }\\n        }\\n        Queue<Long> queue=new LinkedList<>();\\n        getScore(root,queue,n);\\n        long max=0;\\n        int count=0;\\n        while(n-->0) {\\n            long temp=queue.poll();\\n            max=Math.max(max,temp);\\n            queue.offer(temp);\\n        }\\n        while(!queue.isEmpty()) {\\n            if(max==queue.poll())\\n                ++count;\\n        }\\n        return count;\\n        \\n        \\n    }\\n    long getScore(TreeNode root,Queue<Long> queue,int size) {\\n        if(root==null)\\n            return 0;\\n        long left=getScore(root.left,queue,size);\\n        long right=getScore(root.right,queue,size);\\n        long up=size-left-right-1;\\n        long temp=0;\\n        if(left==0&&right==0&&up==0) {\\n            temp=0;\\n        }\\n        else {\\n            long tempLeft=left==0?1:left;\\n            long tempRight=right==0?1:right;\\n            up=up==0?1:up;\\n            temp=tempLeft*tempRight*up;\\n        }\\n        \\n        queue.offer(temp);\\n        return 1+left+right;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static class TreeNode {\\n        int val;\\n        TreeNode left,right;\\n        TreeNode() {\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2070070,
                "title": "two-dfs-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<long long int>counter;\\n    long long int res=0;\\n    int countt=0;\\n    void dfs(int src)\\n    {\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int u=adj[src][i];\\n            dfs(u);\\n            counter[src]+=counter[u];\\n        }\\n        counter[src]++;\\n    }\\n    \\n    void dfs2(int src,vector<int>& parents)\\n    {\\n        long long int p=1;\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int u=adj[src][i];\\n            p=p*counter[u];\\n\\n            dfs2(u,parents);\\n            \\n            \\n            \\n        }\\n        if(parents[src] != -1)\\n        {\\n            p=p*(counter.size()-counter[src]);\\n\\n        }\\n       \\n        \\n        if(p > res)\\n        {\\n            res=p;\\n            countt=1;\\n        }\\n        else if(p == res)\\n        {\\n            countt++;\\n        }\\n       \\n        \\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        adj.resize(n);\\n        int root;\\n        for(int u=0;u<n;u++)\\n        {\\n            int v=parents[u];\\n            if(v == -1)\\n            {\\n                root=u;\\n                continue;\\n            }\\n            adj[v].push_back(u);\\n        }\\n        counter.resize(n,0);\\n        dfs(root);\\n\\n        dfs2(root,parents);\\n        return countt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<long long int>counter;\\n    long long int res=0;\\n    int countt=0;\\n    void dfs(int src)\\n    {\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int u=adj[src][i];\\n            dfs(u);\\n            counter[src]+=counter[u];\\n        }\\n        counter[src]++;\\n    }\\n    \\n    void dfs2(int src,vector<int>& parents)\\n    {\\n        long long int p=1;\\n        for(int i=0;i<adj[src].size();i++)\\n        {\\n            int u=adj[src][i];\\n            p=p*counter[u];\\n\\n            dfs2(u,parents);\\n            \\n            \\n            \\n        }\\n        if(parents[src] != -1)\\n        {\\n            p=p*(counter.size()-counter[src]);\\n\\n        }\\n       \\n        \\n        if(p > res)\\n        {\\n            res=p;\\n            countt=1;\\n        }\\n        else if(p == res)\\n        {\\n            countt++;\\n        }\\n       \\n        \\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        adj.resize(n);\\n        int root;\\n        for(int u=0;u<n;u++)\\n        {\\n            int v=parents[u];\\n            if(v == -1)\\n            {\\n                root=u;\\n                continue;\\n            }\\n            adj[v].push_back(u);\\n        }\\n        counter.resize(n,0);\\n        dfs(root);\\n\\n        dfs2(root,parents);\\n        return countt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893615,
                "title": "c-easy-postorder-traversal-85-time-beat",
                "content": "**LOGIC : **\\n\\nSimply get the count of left nodes and right nodes recursively and get the remaining nodes(after removing the current nodes by doing n-(l+r)-1. Now we multiply them and check if it is same as our current multiplication or greater than. If equal, we just increase the counter and if greater, we update our ansvalue and set counter to 1.\\nThere is a thing to keep in mind. \\'l\\', \\'r\\' and \\'rem\\' can be \\'0\\'. If so happens then set it to 1 so that when multiplying it won\\'t make the answer \\'0\\'.\\n\\nHere\\'s the code\\n\\n```\\nclass Solution {\\npublic:\\n    long long val = 0, cnt = 0;\\n    int traversal(TreeNode* root, int n)\\n    {\\n        if(!root) return 0;\\n        int l = traversal(root->left, n);\\n        int r = traversal(root->right, n);\\n        int nl = l, nr = r, rem = n-l-r-1;\\n        if(l == 0) \\n        {\\n            nl++;\\n        }\\n        if(r == 0)\\n        {\\n            nr++;\\n        }\\n        if(rem == 0)\\n        {\\n            rem++;\\n        }\\n        long long ans = 1L*nl*nr*rem;\\n        if(ans > val)\\n        {\\n            val = ans;\\n            cnt=1;\\n        }\\n        else if(ans == val)\\n        {\\n            cnt++;\\n        }\\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        TreeNode* root;\\n        vector<TreeNode*> temp(parents.size());\\n        for(int i = 0; i < temp.size(); i++)\\n        {\\n            temp[i] = new TreeNode(i);\\n        }\\n        for(int i = 1; i < temp.size(); i++)\\n        {\\n            if(temp[parents[i]]->left) temp[parents[i]]->right = temp[i];\\n            else temp[parents[i]]->left = temp[i];\\n        }\\n        root = temp[0];\\n        traversal(root, parents.size());\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long val = 0, cnt = 0;\\n    int traversal(TreeNode* root, int n)\\n    {\\n        if(!root) return 0;\\n        int l = traversal(root->left, n);\\n        int r = traversal(root->right, n);\\n        int nl = l, nr = r, rem = n-l-r-1;\\n        if(l == 0) \\n        {\\n            nl++;\\n        }\\n        if(r == 0)\\n        {\\n            nr++;\\n        }\\n        if(rem == 0)\\n        {\\n            rem++;\\n        }\\n        long long ans = 1L*nl*nr*rem;\\n        if(ans > val)\\n        {\\n            val = ans;\\n            cnt=1;\\n        }\\n        else if(ans == val)\\n        {\\n            cnt++;\\n        }\\n        return l+r+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        TreeNode* root;\\n        vector<TreeNode*> temp(parents.size());\\n        for(int i = 0; i < temp.size(); i++)\\n        {\\n            temp[i] = new TreeNode(i);\\n        }\\n        for(int i = 1; i < temp.size(); i++)\\n        {\\n            if(temp[parents[i]]->left) temp[parents[i]]->right = temp[i];\\n            else temp[parents[i]]->left = temp[i];\\n        }\\n        root = temp[0];\\n        traversal(root, parents.size());\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838691,
                "title": "easy-and-simple-code-c-dfs-o-n-solution",
                "content": "**Step-1** We build a undirected graph using parent array.\\n**Step -2** For each node we need the count of left and right subtree size so ans for a node will be  ( **left subtree size * right subtree size * (total nodes -left subtree size -right subtree size**) to get this we will make a dfs call with the root which will visit all its child nodes and return the subtree sizes which we will keep on adding.\\n**Step -3** return the current subtree size  (**left subtree size + right subtree size +1** ) .\\n\\nTC->O(N)     //Since we are visiting each nodes only once.\\nSC->O(N)  //Visted array\\n\\n```\\nint maxcnt=0;\\nlong long maxans=-1;\\nint total=0;\\nint dfs(int src, vector<vector<int>>&g,vector<bool>&vis)\\n{\\n    vis[src]=true;\\n    int sum=0;\\n    long long temp=1ll;\\n    for(auto ne:g[src])\\n    {\\n        if(vis[ne]==false)\\n        {\\n            int v1=dfs(ne,g,vis);\\n            sum+=v1;                                               // Adding subtree size of all child nodes\\n            if(v1!=0)temp=temp*v1;                        // multiplying subtree sizes\\n        }\\n    }\\n    \\n    sum+=1;                                                       //including current node in current tree size\\n    if(total-sum>0)\\n    {\\n       temp=temp*(total-sum);                           //multiplying subtree size which is parent of current node\\n    }\\n    \\n    if(temp>=maxans)\\n    {\\n        if(temp==maxans)maxcnt++;\\n        else\\n        {\\n            maxans=temp;\\n            maxcnt=1;\\n        }\\n    }\\n    \\n    return sum;                                      // returning size of current tree\\n}\\n\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents)\\n    {\\n        int root=0;\\n        int n=parents.size();\\n        total=n;\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            if(parents[i]==-1)\\n            {\\n                root=i;\\n            }\\n            else\\n            {\\n                g[parents[i]].push_back(i);\\n                g[i].push_back(parents[i]);\\n            }\\n        }\\n        maxcnt=0;\\n        maxans=-1;\\n        vector<bool>vis(n,false);\\n        dfs(root,g,vis);\\n        return maxcnt;\\n    }\\n};\\n```\\n\\n\\n\\nSimilar problem -[1519. Number of Nodes in the Sub-Tree With the Same Label](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/)\\nLittle diff but same concept.\\n\\nPlease upvote if u like the post. It gives me motivation !!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nint maxcnt=0;\\nlong long maxans=-1;\\nint total=0;\\nint dfs(int src, vector<vector<int>>&g,vector<bool>&vis)\\n{\\n    vis[src]=true;\\n    int sum=0;\\n    long long temp=1ll;\\n    for(auto ne:g[src])\\n    {\\n        if(vis[ne]==false)\\n        {\\n            int v1=dfs(ne,g,vis);\\n            sum+=v1;                                               // Adding subtree size of all child nodes\\n            if(v1!=0)temp=temp*v1;                        // multiplying subtree sizes\\n        }\\n    }\\n    \\n    sum+=1;                                                       //including current node in current tree size\\n    if(total-sum>0)\\n    {\\n       temp=temp*(total-sum);                           //multiplying subtree size which is parent of current node\\n    }\\n    \\n    if(temp>=maxans)\\n    {\\n        if(temp==maxans)maxcnt++;\\n        else\\n        {\\n            maxans=temp;\\n            maxcnt=1;\\n        }\\n    }\\n    \\n    return sum;                                      // returning size of current tree\\n}\\n\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents)\\n    {\\n        int root=0;\\n        int n=parents.size();\\n        total=n;\\n        vector<vector<int>>g(n);\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            if(parents[i]==-1)\\n            {\\n                root=i;\\n            }\\n            else\\n            {\\n                g[parents[i]].push_back(i);\\n                g[i].push_back(parents[i]);\\n            }\\n        }\\n        maxcnt=0;\\n        maxans=-1;\\n        vector<bool>vis(n,false);\\n        dfs(root,g,vis);\\n        return maxcnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826611,
                "title": "java-o-n-space-and-time-solution",
                "content": "A cut score is multiplication of no of leftChildren, no of rightChidren and remaning nodes (Total nodes-leftChildren-rightChildren-1).\\nBelow is Java Code for the solution with comments.\\n\\n```\\n//TreeNode \\nclass TreeNode\\n{\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    int leftChilds=0;\\n    int rightChilds=0;\\n    TreeNode(int val)\\n    {\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    HashMap<Long,Integer> costs;\\n    long max; //To store maximum cost value\\n    int n;\\n    public int countHighestScoreNodes(int[] parents) {\\n        costs=new HashMap<Long,Integer>(); //To store frequency of each cost value\\n        max=0;\\n        n=parents.length;\\n        HashMap<Integer,TreeNode> hm=new HashMap<Integer,TreeNode>();\\n        TreeNode root=new TreeNode(0); //Initializing root node\\n        hm.put(0,root);\\n        for(int i=1;i<parents.length;i++)\\n        {\\n            int parent=parents[i];\\n            TreeNode child=hm.getOrDefault(i,new TreeNode(i));\\n            TreeNode parentNode=hm.getOrDefault(parent,new TreeNode(parent));\\n            if(parentNode.left==null)\\n            {\\n                parentNode.left=child;\\n            }\\n            else\\n            {\\n                parentNode.right=child;\\n            }\\n            hm.put(i,child);\\n            hm.put(parent,parentNode);\\n        }//Loop to construct tree structure.\\n        postOrderTraverse(root);  //postOrder traversal\\n        return costs.get(max); // Returning maximum frequency\\n    }\\n    public int postOrderTraverse(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n       \\n        long one=1; \\n        root.leftChilds=postOrderTraverse(root.left);  //Getting no of leftChilds\\n        root.rightChilds=postOrderTraverse(root.right); //Getting no of rightChilds\\n        long score=(one*Math.max(root.leftChilds,1)*(Math.max(root.rightChilds,1))*(Math.max(n-root.leftChilds-root.rightChilds-1,1))); // Calculating the score of the node\\n        costs.put(score,costs.getOrDefault(score,0)+1);\\n        max=Math.max(score,max);\\n        return root.leftChilds+root.rightChilds+1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n//TreeNode \\nclass TreeNode\\n{\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    int leftChilds=0;\\n    int rightChilds=0;\\n    TreeNode(int val)\\n    {\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    HashMap<Long,Integer> costs;\\n    long max; //To store maximum cost value\\n    int n;\\n    public int countHighestScoreNodes(int[] parents) {\\n        costs=new HashMap<Long,Integer>(); //To store frequency of each cost value\\n        max=0;\\n        n=parents.length;\\n        HashMap<Integer,TreeNode> hm=new HashMap<Integer,TreeNode>();\\n        TreeNode root=new TreeNode(0); //Initializing root node\\n        hm.put(0,root);\\n        for(int i=1;i<parents.length;i++)\\n        {\\n            int parent=parents[i];\\n            TreeNode child=hm.getOrDefault(i,new TreeNode(i));\\n            TreeNode parentNode=hm.getOrDefault(parent,new TreeNode(parent));\\n            if(parentNode.left==null)\\n            {\\n                parentNode.left=child;\\n            }\\n            else\\n            {\\n                parentNode.right=child;\\n            }\\n            hm.put(i,child);\\n            hm.put(parent,parentNode);\\n        }//Loop to construct tree structure.\\n        postOrderTraverse(root);  //postOrder traversal\\n        return costs.get(max); // Returning maximum frequency\\n    }\\n    public int postOrderTraverse(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n       \\n        long one=1; \\n        root.leftChilds=postOrderTraverse(root.left);  //Getting no of leftChilds\\n        root.rightChilds=postOrderTraverse(root.right); //Getting no of rightChilds\\n        long score=(one*Math.max(root.leftChilds,1)*(Math.max(root.rightChilds,1))*(Math.max(n-root.leftChilds-root.rightChilds-1,1))); // Calculating the score of the node\\n        costs.put(score,costs.getOrDefault(score,0)+1);\\n        max=Math.max(score,max);\\n        return root.leftChilds+root.rightChilds+1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684645,
                "title": "count-nodes-with-the-highest-score-c-subtree-size-maths-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> tree[n], subTreeSize(n, 0), vis(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(p[i] != -1){\\n                tree[p[i]].push_back(i);\\n            }\\n        }\\n        \\n        function<int(int)> dfs=[&](int u)-> int{\\n            vis[u] = 1;\\n            int currSize = 1;\\n            for(auto& next : tree[u]){\\n                if(!vis[next]){\\n                    currSize += dfs(next);\\n                }\\n            }\\n            subTreeSize[u] = currSize;\\n            return currSize;\\n        };\\n        \\n        dfs(0);\\n        \\n        long ans = 0;\\n        unordered_map<long ,int> freq;\\n        for(int i = 0; i < n; i++){\\n            long val = 1, sum = 0;\\n            for(auto& c : tree[i]){\\n                if(p[c] == i) val *= subTreeSize[c], sum += subTreeSize[c];\\n            }\\n            val *= max(1L, n - sum - 1);\\n            ans = max(ans, val);\\n            freq[val]++;\\n        }\\n        \\n        return freq[ans];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& p) {\\n        int n = p.size();\\n        vector<int> tree[n], subTreeSize(n, 0), vis(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(p[i] != -1){\\n                tree[p[i]].push_back(i);\\n            }\\n        }\\n        \\n        function<int(int)> dfs=[&](int u)-> int{\\n            vis[u] = 1;\\n            int currSize = 1;\\n            for(auto& next : tree[u]){\\n                if(!vis[next]){\\n                    currSize += dfs(next);\\n                }\\n            }\\n            subTreeSize[u] = currSize;\\n            return currSize;\\n        };\\n        \\n        dfs(0);\\n        \\n        long ans = 0;\\n        unordered_map<long ,int> freq;\\n        for(int i = 0; i < n; i++){\\n            long val = 1, sum = 0;\\n            for(auto& c : tree[i]){\\n                if(p[c] == i) val *= subTreeSize[c], sum += subTreeSize[c];\\n            }\\n            val *= max(1L, n - sum - 1);\\n            ans = max(ans, val);\\n            freq[val]++;\\n        }\\n        \\n        return freq[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630107,
                "title": "java-solution-fail-what-s-wrong",
                "content": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        HashMap<Integer, TreeNode> treeMap = new HashMap<Integer, TreeNode>();\\n        for (int i = 0; i < parents.length; i++) {\\n            TreeNode node;\\n            if (!treeMap.containsKey(i)) {\\n                node = new TreeNode(i);\\n                treeMap.put(i, node);\\n            } else {\\n                node = treeMap.get(i);\\n            }\\n            if (parents[i] == -1) {\\n                continue;\\n            }\\n            if (!treeMap.containsKey(parents[i])) {\\n                TreeNode parent = new TreeNode(parents[i]);\\n                treeMap.put(parents[i], parent);\\n                parent.setChild(node);\\n            } else {\\n                TreeNode parent = treeMap.get(parents[i]);\\n                parent.setChild(node);\\n            }\\n        }\\n\\n        TreeNode root = treeMap.get(0);\\n        int score = setScoreForNodes(root);\\n        System.out.println(score);\\n        System.out.println(parents.length);\\n\\n        int cnt = 0;\\n        int maxProduct = 0;\\n        for (int i = 0; i < parents.length; i++) {\\n            TreeNode node = treeMap.get(i);\\n            int leftScore = node.left == null? 0 : node.left.score;\\n            int rightScore = node.right == null? 0 : node.right.score;\\n            int otherPartScore = score - node.score;\\n            leftScore = Math.max(leftScore, 1);\\n            rightScore = Math.max(rightScore, 1);\\n            otherPartScore = Math.max(otherPartScore, 1);\\n            int total = leftScore * rightScore * otherPartScore;\\n            if (total == maxProduct) {\\n                cnt += 1;\\n            } else if (total > maxProduct) {\\n                maxProduct = total;\\n                cnt = 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    public int setScoreForNodes(TreeNode root) {\\n        if (Objects.isNull(root)) {\\n            return 0;\\n        }\\n        int score = 1 + setScoreForNodes(root.left) + setScoreForNodes(root.right);\\n        root.score = score;\\n        return score;\\n    }\\n\\n    class TreeNode {\\n         int val;\\n         int score;\\n         TreeNode left;\\n         TreeNode right;\\n\\n        public TreeNode(int val) {\\n            this.val = val;\\n            return;\\n        }\\n\\n        public void setChild(TreeNode node) {\\n            if (this.left == null) {\\n                this.left = node;\\n            } else {\\n                this.right = node;\\n            }\\n            return;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        HashMap<Integer, TreeNode> treeMap = new HashMap<Integer, TreeNode>();\\n        for (int i = 0; i < parents.length; i++) {\\n            TreeNode node;\\n            if (!treeMap.containsKey(i)) {\\n                node = new TreeNode(i);\\n                treeMap.put(i, node);\\n            } else {\\n                node = treeMap.get(i);\\n            }\\n            if (parents[i] == -1) {\\n                continue;\\n            }\\n            if (!treeMap.containsKey(parents[i])) {\\n                TreeNode parent = new TreeNode(parents[i]);\\n                treeMap.put(parents[i], parent);\\n                parent.setChild(node);\\n            } else {\\n                TreeNode parent = treeMap.get(parents[i]);\\n                parent.setChild(node);\\n            }\\n        }\\n\\n        TreeNode root = treeMap.get(0);\\n        int score = setScoreForNodes(root);\\n        System.out.println(score);\\n        System.out.println(parents.length);\\n\\n        int cnt = 0;\\n        int maxProduct = 0;\\n        for (int i = 0; i < parents.length; i++) {\\n            TreeNode node = treeMap.get(i);\\n            int leftScore = node.left == null? 0 : node.left.score;\\n            int rightScore = node.right == null? 0 : node.right.score;\\n            int otherPartScore = score - node.score;\\n            leftScore = Math.max(leftScore, 1);\\n            rightScore = Math.max(rightScore, 1);\\n            otherPartScore = Math.max(otherPartScore, 1);\\n            int total = leftScore * rightScore * otherPartScore;\\n            if (total == maxProduct) {\\n                cnt += 1;\\n            } else if (total > maxProduct) {\\n                maxProduct = total;\\n                cnt = 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    public int setScoreForNodes(TreeNode root) {\\n        if (Objects.isNull(root)) {\\n            return 0;\\n        }\\n        int score = 1 + setScoreForNodes(root.left) + setScoreForNodes(root.right);\\n        root.score = score;\\n        return score;\\n    }\\n\\n    class TreeNode {\\n         int val;\\n         int score;\\n         TreeNode left;\\n         TreeNode right;\\n\\n        public TreeNode(int val) {\\n            this.val = val;\\n            return;\\n        }\\n\\n        public void setChild(TreeNode node) {\\n            if (this.left == null) {\\n                this.left = node;\\n            } else {\\n                this.right = node;\\n            }\\n            return;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575126,
                "title": "java-build-tree-and-dfs",
                "content": "I really like this question, very suitable for real interview.\\nTesting tree building, dfs, corner case, etc\\n\\n```\\nclass Solution {\\n    long max = 0;\\n    long cnt = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n        TreeNode root = buildTree(parents); \\n        dfs(root, parents.length);\\n        return (int) cnt;\\n    }\\n    \\n    private long dfs(TreeNode node, int n) {\\n        if (node == null) return 0;\\n        long l = dfs(node.left, n);\\n        long r = dfs(node.right, n);\\n        long remain = n - l - r - 1;\\n        long prod = (l > 0 ? l : 1) * (r > 0 ? r : 1) * (remain > 0 ? remain : 1); // tricky\\n        if (prod == max) {\\n            cnt++;\\n        } else if (prod > max) {\\n            max = prod;\\n            cnt = 1;\\n        }\\n        return l + r + 1;\\n    }\\n    \\n    private TreeNode buildTree(int[] parents) {\\n        int n = parents.length;\\n        TreeNode[] nodeArray = new TreeNode[n];\\n        TreeNode root = null;\\n        \\n        for (int i = 0; i < n; i++) {\\n            nodeArray[i] = new TreeNode(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1) {\\n                root = nodeArray[i];\\n                continue;\\n            }\\n            TreeNode node = nodeArray[parents[i]]; // i = 1, node = 2\\n            if (node.left == null) {\\n                node.left = nodeArray[i];\\n            } else {\\n                node.right = nodeArray[i];\\n            }\\n\\n        }\\n        return root;\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long max = 0;\\n    long cnt = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n        TreeNode root = buildTree(parents); \\n        dfs(root, parents.length);\\n        return (int) cnt;\\n    }\\n    \\n    private long dfs(TreeNode node, int n) {\\n        if (node == null) return 0;\\n        long l = dfs(node.left, n);\\n        long r = dfs(node.right, n);\\n        long remain = n - l - r - 1;\\n        long prod = (l > 0 ? l : 1) * (r > 0 ? r : 1) * (remain > 0 ? remain : 1); // tricky\\n        if (prod == max) {\\n            cnt++;\\n        } else if (prod > max) {\\n            max = prod;\\n            cnt = 1;\\n        }\\n        return l + r + 1;\\n    }\\n    \\n    private TreeNode buildTree(int[] parents) {\\n        int n = parents.length;\\n        TreeNode[] nodeArray = new TreeNode[n];\\n        TreeNode root = null;\\n        \\n        for (int i = 0; i < n; i++) {\\n            nodeArray[i] = new TreeNode(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (parents[i] == -1) {\\n                root = nodeArray[i];\\n                continue;\\n            }\\n            TreeNode node = nodeArray[parents[i]]; // i = 1, node = 2\\n            if (node.left == null) {\\n                node.left = nodeArray[i];\\n            } else {\\n                node.right = nodeArray[i];\\n            }\\n\\n        }\\n        return root;\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548285,
                "title": "c-dfs-solution",
                "content": "DFS solution. The first one uses a few maps to manage the countings. The second solution uses global variable and does the comparison in the DFS. \\n\\nSolution 1\\n```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        unordered_map<int, vector<int>> graph;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            int p = parents[i];\\n            if (graph.find(p) != graph.end())\\n            {\\n                graph[p].push_back(i);\\n            }\\n            else\\n            {\\n                vector<int> v { i };\\n                graph[p] = v;\\n            }\\n        }\\n        \\n        unordered_map<int, long long> productMap;\\n        unordered_map<int, int> totalMap;\\n        \\n        int sum = dfs(-1, graph, productMap, totalMap);\\n        \\n        long long max = 0;\\n        int count = 0;\\n        long long product = 1;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            product = 1;\\n            \\n            if (i == 0)\\n            {\\n                product = productMap[0];\\n            }\\n            else\\n            {\\n                product = (sum - totalMap[i] - 1) * productMap[i];\\n            }\\n            \\n            if (product > max)\\n            {\\n                max = product;\\n                count = 1;\\n            }\\n            else if (product == max)\\n            {\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    int dfs(int node, unordered_map<int, vector<int>> &graph, unordered_map<int, long long> &productMap, \\n            unordered_map<int, int> &totalMap)\\n    {\\n        int sum = 1;\\n        long long product = 1;\\n        \\n        if (graph.find(node) == graph.end())\\n        {\\n            totalMap[node] = sum;\\n            productMap[node] = product;\\n            \\n            return sum;\\n        }\\n        \\n        vector<int> nodes = graph[node];\\n        \\n        for (int &n : nodes)\\n        {\\n            int num = dfs(n, graph, productMap, totalMap);\\n            \\n            sum += num;\\n            product *= num;\\n        }\\n        \\n        totalMap[node] = sum;\\n        productMap[node] = product;\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nSolution 2\\n```\\nclass Solution {\\n    \\n    long max = 0;\\n    int count = 0;\\n    \\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        unordered_map<int, vector<int>> graph;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            int p = parents[i];\\n            if (graph.find(p) != graph.end())\\n            {\\n                graph[p].push_back(i);\\n            }\\n            else\\n            {\\n                vector<int> v { i };\\n                graph[p] = v;\\n            }\\n        }\\n        \\n        int sum = parents.size();\\n        \\n        dfs(0, graph, sum);\\n        \\n        return count;\\n    }\\n    \\n    \\n    int dfs(int node, unordered_map<int, vector<int>> &graph, int &sum)\\n    {\\n        long product = 1;\\n        int total = 1;\\n        \\n        if (graph.find(node) == graph.end())\\n        {\\n            product = (long)(sum - 1);\\n            \\n            if (product > max)\\n            {\\n                max = product;\\n                count = 1;\\n            }\\n            else if (product == max)\\n            {\\n                ++count;\\n            }\\n            return total;\\n        }\\n        \\n        vector<int> nodes = graph[node];\\n        \\n        for (int &n : nodes)\\n        {\\n            int num = dfs(n, graph, sum);\\n            \\n            product *= num;\\n            total += num;\\n        }\\n        \\n        if (node != 0)\\n        {\\n            product *= (sum - total);\\n        }\\n        \\n        if (product > max)\\n        {\\n            max = product;\\n            count = 1;\\n        }\\n        else if (product == max)\\n        {\\n            ++count;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        unordered_map<int, vector<int>> graph;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            int p = parents[i];\\n            if (graph.find(p) != graph.end())\\n            {\\n                graph[p].push_back(i);\\n            }\\n            else\\n            {\\n                vector<int> v { i };\\n                graph[p] = v;\\n            }\\n        }\\n        \\n        unordered_map<int, long long> productMap;\\n        unordered_map<int, int> totalMap;\\n        \\n        int sum = dfs(-1, graph, productMap, totalMap);\\n        \\n        long long max = 0;\\n        int count = 0;\\n        long long product = 1;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            product = 1;\\n            \\n            if (i == 0)\\n            {\\n                product = productMap[0];\\n            }\\n            else\\n            {\\n                product = (sum - totalMap[i] - 1) * productMap[i];\\n            }\\n            \\n            if (product > max)\\n            {\\n                max = product;\\n                count = 1;\\n            }\\n            else if (product == max)\\n            {\\n                ++count;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    int dfs(int node, unordered_map<int, vector<int>> &graph, unordered_map<int, long long> &productMap, \\n            unordered_map<int, int> &totalMap)\\n    {\\n        int sum = 1;\\n        long long product = 1;\\n        \\n        if (graph.find(node) == graph.end())\\n        {\\n            totalMap[node] = sum;\\n            productMap[node] = product;\\n            \\n            return sum;\\n        }\\n        \\n        vector<int> nodes = graph[node];\\n        \\n        for (int &n : nodes)\\n        {\\n            int num = dfs(n, graph, productMap, totalMap);\\n            \\n            sum += num;\\n            product *= num;\\n        }\\n        \\n        totalMap[node] = sum;\\n        productMap[node] = product;\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    long max = 0;\\n    int count = 0;\\n    \\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        unordered_map<int, vector<int>> graph;\\n        \\n        for (int i = 0; i < parents.size(); ++i)\\n        {\\n            int p = parents[i];\\n            if (graph.find(p) != graph.end())\\n            {\\n                graph[p].push_back(i);\\n            }\\n            else\\n            {\\n                vector<int> v { i };\\n                graph[p] = v;\\n            }\\n        }\\n        \\n        int sum = parents.size();\\n        \\n        dfs(0, graph, sum);\\n        \\n        return count;\\n    }\\n    \\n    \\n    int dfs(int node, unordered_map<int, vector<int>> &graph, int &sum)\\n    {\\n        long product = 1;\\n        int total = 1;\\n        \\n        if (graph.find(node) == graph.end())\\n        {\\n            product = (long)(sum - 1);\\n            \\n            if (product > max)\\n            {\\n                max = product;\\n                count = 1;\\n            }\\n            else if (product == max)\\n            {\\n                ++count;\\n            }\\n            return total;\\n        }\\n        \\n        vector<int> nodes = graph[node];\\n        \\n        for (int &n : nodes)\\n        {\\n            int num = dfs(n, graph, sum);\\n            \\n            product *= num;\\n            total += num;\\n        }\\n        \\n        if (node != 0)\\n        {\\n            product *= (sum - total);\\n        }\\n        \\n        if (product > max)\\n        {\\n            max = product;\\n            count = 1;\\n        }\\n        else if (product == max)\\n        {\\n            ++count;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547908,
                "title": "should-be-intuitive",
                "content": "\\tint dfs(const vector<vector<int> >& g, int i, long& maxScore, long& res){\\n        long score = 1, sum = 0;\\n        for(int x : g[i]){\\n            int cnt = dfs(g, x, maxScore, res);\\n            score *= cnt;\\n            sum += cnt;\\n        }\\n        score *= g.size()-sum-(i!=0);\\n        if(score>maxScore) maxScore = score, res = 1;\\n        else if(score == maxScore) ++res;\\n        return sum+1;\\n    }\\n    int countHighestScoreNodes(const vector<int>& parents) {\\n        long n = parents.size(), res = 0, maxScore = 0;\\n        vector<vector<int> > g(n);\\n        for(int i=1; i<n; ++i) g[parents[i]].push_back(i);\\n        dfs(g, 0, maxScore, res);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\tint dfs(const vector<vector<int> >& g, int i, long& maxScore, long& res){\\n        long score = 1, sum = 0;\\n        for(int x : g[i]){\\n            int cnt = dfs(g, x, maxScore, res);\\n            score *= cnt;\\n            sum += cnt;\\n        }\\n        score *= g.size()-sum-(i!=0);\\n        if(score>maxScore) maxScore = score, res = 1;\\n        else if(score == maxScore) ++res;\\n        return sum+1;\\n    }\\n    int countHighestScoreNodes(const vector<int>& parents) {\\n        long n = parents.size(), res = 0, maxScore = 0;\\n        vector<vector<int> > g(n);\\n        for(int i=1; i<n; ++i) g[parents[i]].push_back(i);\\n        dfs(g, 0, maxScore, res);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1539918,
                "title": "dss-based-solution-c",
                "content": "```\\n\\n\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    struct Node\\n{\\n    Node* left;\\n    Node* right;\\n    int val;\\n    ll count;//to store count(left)+count(right)\\n    Node(int c)\\n    {\\n        left=NULL;\\n        right=NULL;\\n        count=0;\\n        val=c;\\n    }\\n};\\n\\n    \\n    \\n    //normal dfs after tree construction\\n    vector<ll>v;\\nint recurs(Node* root,int n)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    \\n    int left=recurs(root->left,n);\\n    int right=recurs(root->right,n);\\n    root->count=left+right;\\n    \\n\\n    \\n    ll left1=left,right1=right;\\n    \\n    if(left1==0)\\n         left1=1;\\n    if(right1==0)\\n          right1=1;\\n   ll val=(n-1-left-right);\\n    if((n-1-left-right)==0)\\n         val=1;\\n    \\n    v.push_back(left1*right1*(val));\\n    return root->count+1;\\n}\\n    \\n    int countHighestScoreNodes(vector<int>& parent) {\\n        v.clear();\\n        int n=parent.size();\\n        \\n        \\n        //tree construction\\n        vector<Node*>tree(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            tree[i]=new Node(i);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            {\\n                if(tree[parent[i]]->left==NULL)\\n                    tree[parent[i]]->left=tree[i];\\n                else\\n                    tree[parent[i]]->right=tree[i];\\n            }\\n        }\\n        \\n        Node* root=tree[0];\\n        recurs(root,n);\\n        int c=0;\\n        \\n        sort(v.rbegin(),v.rend());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n         // cout<<i<<\" : \"<<v[i]<<endl;\\n            if(v[i]==v[0])\\n                 c++;\\n            else\\n                 break;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    struct Node\\n{\\n    Node* left;\\n    Node* right;\\n    int val;\\n    ll count;//to store count(left)+count(right)\\n    Node(int c)\\n    {\\n        left=NULL;\\n        right=NULL;\\n        count=0;\\n        val=c;\\n    }\\n};\\n\\n    \\n    \\n    //normal dfs after tree construction\\n    vector<ll>v;\\nint recurs(Node* root,int n)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    \\n    int left=recurs(root->left,n);\\n    int right=recurs(root->right,n);\\n    root->count=left+right;\\n    \\n\\n    \\n    ll left1=left,right1=right;\\n    \\n    if(left1==0)\\n         left1=1;\\n    if(right1==0)\\n          right1=1;\\n   ll val=(n-1-left-right);\\n    if((n-1-left-right)==0)\\n         val=1;\\n    \\n    v.push_back(left1*right1*(val));\\n    return root->count+1;\\n}\\n    \\n    int countHighestScoreNodes(vector<int>& parent) {\\n        v.clear();\\n        int n=parent.size();\\n        \\n        \\n        //tree construction\\n        vector<Node*>tree(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            tree[i]=new Node(i);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(parent[i]!=-1)\\n            {\\n                if(tree[parent[i]]->left==NULL)\\n                    tree[parent[i]]->left=tree[i];\\n                else\\n                    tree[parent[i]]->right=tree[i];\\n            }\\n        }\\n        \\n        Node* root=tree[0];\\n        recurs(root,n);\\n        int c=0;\\n        \\n        sort(v.rbegin(),v.rend());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n         // cout<<i<<\" : \"<<v[i]<<endl;\\n            if(v[i]==v[0])\\n                 c++;\\n            else\\n                 break;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1539143,
                "title": "dfs-solution-python",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Deleting a node can yield at most 3 branches\\n    \"\"\"\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        # build a graph representation\\n        graph = collections.defaultdict(set)\\n        for node, parent in enumerate(parents):\\n            graph[parent].add(node)\\n        \\n        # total number of nodes, to be used\\n        # to count the subtree obtained by removing\\n        # a node but not the subtrees of node.left or node.right\\n        n = len(parents)\\n        \\n        \\n        # use a dict to record product-frequency pairs\\n        d = collections.Counter()\\n        \\n        # a helper function\\n        def dfs(node):\\n            \"\"\"\\n            return number of nodes of the subtree rooted at node\\n            \"\"\"\\n            p, s = 1, 0\\n            # at most two children\\n            for child in graph[node]:\\n                res = dfs(child)\\n                p *= res\\n                s += res\\n            # a possible branch from top of the node\\n            p *= max(1, n - 1 - s)\\n            d[p] += 1\\n            return s + 1\\n        \\n        dfs(0)\\n        return d[max(d.keys())]\\n        \\n```\\n\\nThis solution is motivated by \\nhttps://leetcode.com/problems/count-nodes-with-the-highest-score/discuss/1537603/Python-3-or-Graph-DFS-Post-order-Traversal-O(N)-or-Explanation\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Deleting a node can yield at most 3 branches\\n    \"\"\"\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        # build a graph representation\\n        graph = collections.defaultdict(set)\\n        for node, parent in enumerate(parents):\\n            graph[parent].add(node)\\n        \\n        # total number of nodes, to be used\\n        # to count the subtree obtained by removing\\n        # a node but not the subtrees of node.left or node.right\\n        n = len(parents)\\n        \\n        \\n        # use a dict to record product-frequency pairs\\n        d = collections.Counter()\\n        \\n        # a helper function\\n        def dfs(node):\\n            \"\"\"\\n            return number of nodes of the subtree rooted at node\\n            \"\"\"\\n            p, s = 1, 0\\n            # at most two children\\n            for child in graph[node]:\\n                res = dfs(child)\\n                p *= res\\n                s += res\\n            # a possible branch from top of the node\\n            p *= max(1, n - 1 - s)\\n            d[p] += 1\\n            return s + 1\\n        \\n        dfs(0)\\n        return d[max(d.keys())]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538136,
                "title": "c-dfs-will-work-for-n-ary-tree-also-separate-score-and-size-count",
                "content": "I separate the computation of the score for each node from the computation of the size of the node. This code will also work for a N-ary tree.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(int u, vector<vector<int>>& graph,vector<int>& numNodes) {\\n        numNodes[u] = 1;\\n        for (int v : graph[u]) {\\n            numNodes[u] += dfs(v,graph,numNodes);\\n        }\\n        return numNodes[u];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        \\n        vector<vector<int>> graph(n);\\n        for (int i = 1; i < n; i++) {\\n            graph[parents[i]].push_back(i);\\n        }\\n        \\n        vector<int> numNodes(n,-1);\\n        dfs(0,graph,numNodes);\\n        \\n        vector<long long> score(n,0L);\\n        long long maxScore = LLONG_MIN;\\n        for (int i = 0; i < n; i++) {\\n            score[i] = (i > 0) ? (numNodes[0] - numNodes[i]) : 1;\\n            for (int child : graph[i]) {\\n                score[i] *= numNodes[child];\\n            }\\n            maxScore = max(maxScore,score[i]);\\n        }\\n        \\n        return count_if(begin(score),end(score),[maxScore](long long x){return x == maxScore;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int u, vector<vector<int>>& graph,vector<int>& numNodes) {\\n        numNodes[u] = 1;\\n        for (int v : graph[u]) {\\n            numNodes[u] += dfs(v,graph,numNodes);\\n        }\\n        return numNodes[u];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        \\n        vector<vector<int>> graph(n);\\n        for (int i = 1; i < n; i++) {\\n            graph[parents[i]].push_back(i);\\n        }\\n        \\n        vector<int> numNodes(n,-1);\\n        dfs(0,graph,numNodes);\\n        \\n        vector<long long> score(n,0L);\\n        long long maxScore = LLONG_MIN;\\n        for (int i = 0; i < n; i++) {\\n            score[i] = (i > 0) ? (numNodes[0] - numNodes[i]) : 1;\\n            for (int child : graph[i]) {\\n                score[i] *= numNodes[child];\\n            }\\n            maxScore = max(maxScore,score[i]);\\n        }\\n        \\n        return count_if(begin(score),end(score),[maxScore](long long x){return x == maxScore;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537872,
                "title": "python-dfs",
                "content": "```\\nclass Solution(object):\\n    def countHighestScoreNodes(self, parents):\\n        \"\"\"\\n        :type parents: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hmap = collections.defaultdict(list)\\n        n = len(parents)\\n        for i in range(n):\\n            if parents[i] != -1:\\n                hmap[parents[i]].append(i)\\n        \\n        self.maxKey, self.res = 0, 0\\n        \\n        def dfs(node):\\n            score = 1\\n            count = 0\\n            for nxt in hmap[node]:\\n                subCount = dfs(nxt)\\n                score*=subCount\\n                count += subCount\\n            \\n            score *= n-1-count or 1\\n            \\n            if score > self.maxKey:\\n                self.maxKey = score\\n                self.res = 1\\n            elif score == self.maxKey:\\n                self.res += 1\\n            \\n            return count + 1\\n        \\n        dfs(0)\\n\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countHighestScoreNodes(self, parents):\\n        \"\"\"\\n        :type parents: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hmap = collections.defaultdict(list)\\n        n = len(parents)\\n        for i in range(n):\\n            if parents[i] != -1:\\n                hmap[parents[i]].append(i)\\n        \\n        self.maxKey, self.res = 0, 0\\n        \\n        def dfs(node):\\n            score = 1\\n            count = 0\\n            for nxt in hmap[node]:\\n                subCount = dfs(nxt)\\n                score*=subCount\\n                count += subCount\\n            \\n            score *= n-1-count or 1\\n            \\n            if score > self.maxKey:\\n                self.maxKey = score\\n                self.res = 1\\n            elif score == self.maxKey:\\n                self.res += 1\\n            \\n            return count + 1\\n        \\n        dfs(0)\\n\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537753,
                "title": "c-easy-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>> child(n);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            child[p[i]].push_back(i);\\n        }\\n        int cnt=0;\\n        long long maxi=0;\\n        solve(0,child,n,maxi,cnt);\\n        return cnt;\\n        \\n        \\n    }\\n    int solve(int node,vector<vector<int>>& child,int& total,long long& maxi,int& cnt)\\n    {\\n        int left=0;\\n        int right=0;\\n        for(int i=0;i<child[node].size();i++)\\n        {\\n            if(i==0)\\n                left=solve(child[node][0],child,total,maxi,cnt);\\n            if(i==1)\\n                right=solve(child[node][1],child,total,maxi,cnt);\\n        }\\n        \\n        long long curr=1;\\n        if(left)\\n            curr*=left;\\n        if(right)\\n            curr*=right;\\n        if(node!=0)\\n            curr*=(total -( left +right +1));\\n        if(curr>maxi)\\n        {\\n            maxi=curr;\\n            cnt=1;\\n        }\\n        else if(curr==maxi)\\n            cnt++;\\n        return left+right+1;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& p) {\\n        int n=p.size();\\n        vector<vector<int>> child(n);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            child[p[i]].push_back(i);\\n        }\\n        int cnt=0;\\n        long long maxi=0;\\n        solve(0,child,n,maxi,cnt);\\n        return cnt;\\n        \\n        \\n    }\\n    int solve(int node,vector<vector<int>>& child,int& total,long long& maxi,int& cnt)\\n    {\\n        int left=0;\\n        int right=0;\\n        for(int i=0;i<child[node].size();i++)\\n        {\\n            if(i==0)\\n                left=solve(child[node][0],child,total,maxi,cnt);\\n            if(i==1)\\n                right=solve(child[node][1],child,total,maxi,cnt);\\n        }\\n        \\n        long long curr=1;\\n        if(left)\\n            curr*=left;\\n        if(right)\\n            curr*=right;\\n        if(node!=0)\\n            curr*=(total -( left +right +1));\\n        if(curr>maxi)\\n        {\\n            maxi=curr;\\n            cnt=1;\\n        }\\n        else if(curr==maxi)\\n            cnt++;\\n        return left+right+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537627,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int n;\\n    ArrayList<Integer>[] tree;\\n    long[] res;\\n    public int countHighestScoreNodes(int[] parents) {\\n        n = parents.length;\\n        tree = new ArrayList[n];\\n        for(int i = 0 ; i < n ; i++)tree[i] = new ArrayList<>();\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            tree[parents[i]].add(i);\\n        }\\n        \\n        res = new long[n];\\n        \\n        depth(0);\\n        long max = 0;\\n        for(long v : res){\\n             max = Math.max(max,v);\\n        }\\n        int count = 0 ;\\n        for(long v : res) if(v == max) count++;\\n        return count;\\n    }\\n    \\n    \\n    public int depth(int src){\\n        int child = 1;\\n        long ma = 1;\\n        for(int nbr : tree[src]){\\n            int sc = depth(nbr);\\n            ma *= sc;\\n            child += sc;\\n        }\\n        if(src != 0)\\n            ma *= (n - child);\\n        \\n        res[src] = ma;\\n        return child;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    ArrayList<Integer>[] tree;\\n    long[] res;\\n    public int countHighestScoreNodes(int[] parents) {\\n        n = parents.length;\\n        tree = new ArrayList[n];\\n        for(int i = 0 ; i < n ; i++)tree[i] = new ArrayList<>();\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            tree[parents[i]].add(i);\\n        }\\n        \\n        res = new long[n];\\n        \\n        depth(0);\\n        long max = 0;\\n        for(long v : res){\\n             max = Math.max(max,v);\\n        }\\n        int count = 0 ;\\n        for(long v : res) if(v == max) count++;\\n        return count;\\n    }\\n    \\n    \\n    public int depth(int src){\\n        int child = 1;\\n        long ma = 1;\\n        for(int nbr : tree[src]){\\n            int sc = depth(nbr);\\n            ma *= sc;\\n            child += sc;\\n        }\\n        if(src != 0)\\n            ma *= (n - child);\\n        \\n        res[src] = ma;\\n        return child;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537563,
                "title": "python-dfs-count-nodes-1-2-3-edges",
                "content": "User DFS to count all nodes for the tree.\\nThen iterate through all nodes. There are 3 cases after removing a node:\\n- it has 1 edge: n-1\\n- it has 2 edges: child_count * (n - 1 - child_count)\\n- it has 3 edges: L_count * R_count * (n-1-L_count-R_count)\\n\\nNote: root 0 is a special case. Treat it seperately.\\n\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        # build tree\\n        children = collections.defaultdict(list)\\n        for i in range(1, n):\\n            children[parents[i]].append(i)\\n        \\n        # count nodes\\n        d = {}\\n        def dfs_count(node):\\n            cnt = 1\\n            for v in children[node]:\\n                cnt += dfs_count(v)\\n            d[node] = cnt\\n            return cnt\\n        \\n        dfs_count(0)\\n        \\n        # root\\n        max_cnt = 1\\n        if len(children[0]) == 1:    # root has 1 child\\n            max_val = n-1\\n        else:    # root has 2 children\\n            max_val = d[children[0][0]] * d[children[0][1]]\\n        \\n        # 1 to n-1\\n        for i in range(1, n):\\n            if len(children[i]) == 0:    # 1 link\\n                val = n-1\\n            elif len(children[i]) == 1:    # 2 links\\n                val = d[children[i][0]] * (n - 1 - d[children[i][0]])\\n            else:    # 3 links\\n                val = d[children[i][0]] * d[children[i][1]] * (n - 1 - d[children[i][0]] - d[children[i][1]])\\n            if val > max_val:\\n                max_val = val\\n                max_cnt = 1\\n            elif val == max_val:\\n                max_cnt += 1\\n                \\n        return max_cnt\\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        # build tree\\n        children = collections.defaultdict(list)\\n        for i in range(1, n):\\n            children[parents[i]].append(i)\\n        \\n        # count nodes\\n        d = {}\\n        def dfs_count(node):\\n            cnt = 1\\n            for v in children[node]:\\n                cnt += dfs_count(v)\\n            d[node] = cnt\\n            return cnt\\n        \\n        dfs_count(0)\\n        \\n        # root\\n        max_cnt = 1\\n        if len(children[0]) == 1:    # root has 1 child\\n            max_val = n-1\\n        else:    # root has 2 children\\n            max_val = d[children[0][0]] * d[children[0][1]]\\n        \\n        # 1 to n-1\\n        for i in range(1, n):\\n            if len(children[i]) == 0:    # 1 link\\n                val = n-1\\n            elif len(children[i]) == 1:    # 2 links\\n                val = d[children[i][0]] * (n - 1 - d[children[i][0]])\\n            else:    # 3 links\\n                val = d[children[i][0]] * d[children[i][1]] * (n - 1 - d[children[i][0]] - d[children[i][1]])\\n            if val > max_val:\\n                max_val = val\\n                max_cnt = 1\\n            elif val == max_val:\\n                max_cnt += 1\\n                \\n        return max_cnt\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983979,
                "title": "c-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n This problem is solved using following steps:\\n        1>Process parents array and store every parent and its children in a dictionary data structure.Even if node does not have\\n        children then also it is stored in a dictionary with null children.\\n        2>Now, we want to traverse the tree in order to calculate score of each node and to calculate the highest score.But,here we are not\\n        given the root of the tree.So, we will traverse the tree using dictionary data structure created in step 1\\n        3>Now, DFS is used to traverse the tree recursively.In DFS we do the folllowing:\\n        i>We visit each node .We get the left node count for that root node,we get right node\\n        count for that root node.We calculate the count of nodes in that subtree using the formula:left+right+1.\\n        Lets call it subtree count.This subtree count is used for calculating the score of each node.Also,it is returned to the parent node\\n        And,parent node calculates its own score from the subtree count of its 2 children.\\n        ii>After this,we calculate the score of each node.After the current node is removed given tree will be divided into 3 parts: left subtree of current\\n        node,right subtree of current node and remaining part of the tree after current node is removed.\\n        We have already calculated the left count and right count in above step.Now, we need to calculate the count of remaining part.\\n        It is calculated using the formula:total no of nodes in a tree-subtree count\\n        Thus, score=leftcount*rightCount*remaining count\\n        iii>Also,We update the maxScore if score so far is greater than maxscore.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    Dictionary<int,int[]> children=new Dictionary<int,int[]>();\\n    long maxScore=0;\\n    int result=0;\\n    \\n    public long CountNodes(int root,int n)\\n    {\\n        long score=0;\\n        long subtreeCount=0;\\n        \\n        if(root==-1)\\n        {\\n            return 0;\\n        }\\n     \\n        long leftCount=CountNodes(children[root][0],n);\\n        long rightCount=CountNodes(children[root][1],n);\\n        subtreeCount=leftCount+rightCount+1;\\n        long remCount=n-subtreeCount;\\n      \\n        score=(leftCount==0?1:leftCount)*(rightCount==0?1:rightCount);\\n        score*=remCount==0?1:remCount;\\n      \\n        if(score>maxScore)\\n        {\\n            maxScore=score;\\n            result=1;\\n        }\\n        else if(score==maxScore)\\n        {\\n            result++;\\n        }\\n        return subtreeCount;\\n    }\\n    \\n    public int CountHighestScoreNodes(int[] parents) \\n    {\\n\\n        int n=parents.Length;\\n        List<int> lstParents=new List<int>(parents);\\n        \\n        for(int i=0;i<parents.Length;i++)\\n        {\\n            int[] arr=new int[2]{-1,-1};\\n            if(children.ContainsKey(parents[i]))\\n            {\\n               children[parents[i]][1]=i;\\n            }\\n            else\\n            {\\n                arr[0]=i;\\n                children.Add(parents[i],arr);\\n            }\\n        }\\n\\n        for(int i=0;i<parents.Length;i++)\\n        {\\n            int[] arr=new int[2]{-1,-1};\\n            if(!children.ContainsKey(i))\\n            {\\n               children.Add(i,arr);     \\n            }\\n        }\\n        \\n        CountNodes(0,n);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int,int[]> children=new Dictionary<int,int[]>();\\n    long maxScore=0;\\n    int result=0;\\n    \\n    public long CountNodes(int root,int n)\\n    {\\n        long score=0;\\n        long subtreeCount=0;\\n        \\n        if(root==-1)\\n        {\\n            return 0;\\n        }\\n     \\n        long leftCount=CountNodes(children[root][0],n);\\n        long rightCount=CountNodes(children[root][1],n);\\n        subtreeCount=leftCount+rightCount+1;\\n        long remCount=n-subtreeCount;\\n      \\n        score=(leftCount==0?1:leftCount)*(rightCount==0?1:rightCount);\\n        score*=remCount==0?1:remCount;\\n      \\n        if(score>maxScore)\\n        {\\n            maxScore=score;\\n            result=1;\\n        }\\n        else if(score==maxScore)\\n        {\\n            result++;\\n        }\\n        return subtreeCount;\\n    }\\n    \\n    public int CountHighestScoreNodes(int[] parents) \\n    {\\n\\n        int n=parents.Length;\\n        List<int> lstParents=new List<int>(parents);\\n        \\n        for(int i=0;i<parents.Length;i++)\\n        {\\n            int[] arr=new int[2]{-1,-1};\\n            if(children.ContainsKey(parents[i]))\\n            {\\n               children[parents[i]][1]=i;\\n            }\\n            else\\n            {\\n                arr[0]=i;\\n                children.Add(parents[i],arr);\\n            }\\n        }\\n\\n        for(int i=0;i<parents.Length;i++)\\n        {\\n            int[] arr=new int[2]{-1,-1};\\n            if(!children.ContainsKey(i))\\n            {\\n               children.Add(i,arr);     \\n            }\\n        }\\n        \\n        CountNodes(0,n);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945136,
                "title": "recursion-postorder-traversal",
                "content": "class Solution {\\npublic:\\n\\n    int n;\\n    long long maxscore=INT_MIN;\\n    int ans=0;\\n    \\n    vector<int> size;\\n    vector<vector<int>> adj;\\n    \\n    vector<long long> scores;\\n    \\n    void getScores(int u)\\n    {\\n        for(auto v: adj[u])\\n                getScores(v);\\n        \\n       long long score=1;\\n        \\n        for(auto v: adj[u])\\n            score*= size[v];\\n        \\n        if(n-size[u]>0)\\n        score*=  n-size[u];\\n                 \\n        scores[u]=score;\\n    }\\n    \\n    int getSize(int u)\\n    {\\n        if(adj[u].size()==0)\\n            return 1;\\n        \\n        for(auto v: adj[u])\\n            size[u]+= getSize(v);\\n        \\n        return size[u];\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n= parents.size();\\n        this->n=n;\\n        adj.resize(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(parents[i]!=-1)\\n                adj[parents[i]].push_back(i);\\n        }\\n        \\n        size.resize(n,1);\\n        getSize(0);\\n        \\n        scores.resize(n,1);\\n        getScores(0);\\n        \\n        for(auto score: scores) {\\n            if(maxscore<score)\\n            {\\n                ans=0;\\n                maxscore=score;\\n            }\\n            \\n            if(maxscore==score)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int n;\\n    long long maxscore=INT_MIN;\\n    int ans=0;\\n    \\n    vector<int> size;\\n    vector<vector<int>> adj;\\n    \\n    vector<long long> scores;\\n    \\n    void getScores(int u)\\n    {\\n        for(auto v: adj[u])\\n                getScores(v);\\n        \\n       long long score=1;\\n        \\n        for(auto v: adj[u])\\n            score*= size[v];\\n        \\n        if(n-size[u]>0)\\n        score*=  n-size[u];\\n                 \\n        scores[u]=score;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3923802,
                "title": "dp-on-binary-tree-using-find-no-of-nodes-in-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can see that we have to find out the product of size of subtree after deleting a particular node.As we have to find the size of a tree i.e no. of nodes then we have to find out the no. of nodes at left side ,right side and at the upper side because the node is connected to 3 directions,Firstly we have to make a binary tree then apply a dp approach in which we find left, right and upper side nodes and make the product of it and stor in a map to get the frequency of that no.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int fun(int sum,TreeNode* root,map<long long,int> &value,long long & ans){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        else{\\n            int l = fun(sum,root -> left,value,ans);\\n            int r = fun(sum,root -> right,value,ans);\\n            int u = sum - l - r - 1;\\n            // cout<<l<<r<<u<<\"\\\\n\";\\n            long long l1 = max(1,l);\\n            long long r1 = max(1,r);\\n            long long u1 = max(1,u);\\n\\n            long long x = (l1*r1*u1);\\n\\n            ans = max(ans,x);\\n\\n            value[x]++;\\n\\n            return l + r + 1;\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parent) {\\n        \\n        vector<TreeNode*> total;\\n        int n = parent.size();\\n\\n        for(int i=0;i<n;i++){\\n            TreeNode* root = new TreeNode(i);\\n            total.push_back(root);\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            TreeNode* par = total[parent[i]];\\n\\n            TreeNode* child = total[i];\\n\\n            if(par -> left == NULL){\\n                par -> left = child;\\n            }\\n            else{\\n                par -> right = child;\\n            }\\n        }\\n\\n        TreeNode* root = total[0];\\n\\n        //int sum = total_sum(root);\\n\\n        long long ans = 0;\\n\\n        map<long long,int> value;\\n\\n        fun(n,root,value,ans);\\n\\n        for(auto it : value){\\n            cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        }\\n\\n        return value[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int fun(int sum,TreeNode* root,map<long long,int> &value,long long & ans){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        else{\\n            int l = fun(sum,root -> left,value,ans);\\n            int r = fun(sum,root -> right,value,ans);\\n            int u = sum - l - r - 1;\\n            // cout<<l<<r<<u<<\"\\\\n\";\\n            long long l1 = max(1,l);\\n            long long r1 = max(1,r);\\n            long long u1 = max(1,u);\\n\\n            long long x = (l1*r1*u1);\\n\\n            ans = max(ans,x);\\n\\n            value[x]++;\\n\\n            return l + r + 1;\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parent) {\\n        \\n        vector<TreeNode*> total;\\n        int n = parent.size();\\n\\n        for(int i=0;i<n;i++){\\n            TreeNode* root = new TreeNode(i);\\n            total.push_back(root);\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            TreeNode* par = total[parent[i]];\\n\\n            TreeNode* child = total[i];\\n\\n            if(par -> left == NULL){\\n                par -> left = child;\\n            }\\n            else{\\n                par -> right = child;\\n            }\\n        }\\n\\n        TreeNode* root = total[0];\\n\\n        //int sum = total_sum(root);\\n\\n        long long ans = 0;\\n\\n        map<long long,int> value;\\n\\n        fun(n,root,value,ans);\\n\\n        for(auto it : value){\\n            cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n        }\\n\\n        return value[ans];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3894566,
                "title": "c-python-dfs-solution-with-explanation",
                "content": "find each node\\'s number of node in left subtree and right subtree.\\n\\nwhen we remove a node,  tree becomes at most 3 subtrees, node\\'s left subtree, right subtree and other nodes.\\nscore is pruduct of number of node in each subtree, if a subtree is empty, set it to 1.\\n\\ntc is O(n), sc is O(n)\\n### python\\n```python\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        size = len(parents)\\n        tree = [[] for _ in range(size)]\\n        for i in range(1, size): tree[parents[i]].append(i)\\n        \\n        mapping_nodes = [[0,0] for _ in range(size)]\\n        def dfs_count_left_right_node(root):\\n            cnt = [0, 0]\\n            for i, sub in enumerate(tree[root]):\\n                cnt[i] = dfs_count_left_right_node(sub)\\n            mapping_nodes[root][0], mapping_nodes[root][1] = cnt[0], cnt[1]\\n            return 1 + cnt[0] + cnt[1]\\n        \\n        total = dfs_count_left_right_node(0)\\n        max_score = 0\\n        cnt = 0\\n        \\n        for cnt1, cnt2 in mapping_nodes:\\n            remain = total - cnt1 - cnt2 - 1\\n            score = (1 if remain == 0 else remain) * (1 if cnt1 == 0 else cnt1) * (1 if cnt2 == 0 else cnt2)\\n            if score > max_score:\\n                max_score = score\\n                cnt = 1\\n            elif score == max_score: cnt += 1\\n        return cnt\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int size = parents.size();\\n        vector<vector<int>> tree (size);\\n        for (int i = 1; i < size; i+=1) tree[parents[i]].emplace_back(i);\\n        \\n        vector<pair<int, int>> mapping_nodes (size);\\n        function<int(int)> dfs_count_left_right_node = [&] (int root) {\\n            int cnt[] {0, 0};\\n            for (int i = 0; i < tree[root].size(); i+=1)\\n                cnt[i] = dfs_count_left_right_node(tree[root][i]);\\n            mapping_nodes[root].first = cnt[0],  mapping_nodes[root].second = cnt[1];\\n            return 1 + cnt[0] + cnt[1];\\n        };\\n        \\n        int total = dfs_count_left_right_node(0);\\n        int cnt = 0, remain;\\n        long max_score = 0, score;\\n        for (auto& [cnt1, cnt2]: mapping_nodes) {\\n            remain = total - cnt1 - cnt2 - 1;\\n            score = (long) (cnt1 == 0? 1: cnt1) * (cnt2 == 0? 1: cnt2) * (remain == 0? 1: remain);\\n            if (score > max_score) max_score = score, cnt = 1;\\n            else if (score == max_score) cnt += 1;\\n        };\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \\n        size = len(parents)\\n        tree = [[] for _ in range(size)]\\n        for i in range(1, size): tree[parents[i]].append(i)\\n        \\n        mapping_nodes = [[0,0] for _ in range(size)]\\n        def dfs_count_left_right_node(root):\\n            cnt = [0, 0]\\n            for i, sub in enumerate(tree[root]):\\n                cnt[i] = dfs_count_left_right_node(sub)\\n            mapping_nodes[root][0], mapping_nodes[root][1] = cnt[0], cnt[1]\\n            return 1 + cnt[0] + cnt[1]\\n        \\n        total = dfs_count_left_right_node(0)\\n        max_score = 0\\n        cnt = 0\\n        \\n        for cnt1, cnt2 in mapping_nodes:\\n            remain = total - cnt1 - cnt2 - 1\\n            score = (1 if remain == 0 else remain) * (1 if cnt1 == 0 else cnt1) * (1 if cnt2 == 0 else cnt2)\\n            if score > max_score:\\n                max_score = score\\n                cnt = 1\\n            elif score == max_score: cnt += 1\\n        return cnt\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int size = parents.size();\\n        vector<vector<int>> tree (size);\\n        for (int i = 1; i < size; i+=1) tree[parents[i]].emplace_back(i);\\n        \\n        vector<pair<int, int>> mapping_nodes (size);\\n        function<int(int)> dfs_count_left_right_node = [&] (int root) {\\n            int cnt[] {0, 0};\\n            for (int i = 0; i < tree[root].size(); i+=1)\\n                cnt[i] = dfs_count_left_right_node(tree[root][i]);\\n            mapping_nodes[root].first = cnt[0],  mapping_nodes[root].second = cnt[1];\\n            return 1 + cnt[0] + cnt[1];\\n        };\\n        \\n        int total = dfs_count_left_right_node(0);\\n        int cnt = 0, remain;\\n        long max_score = 0, score;\\n        for (auto& [cnt1, cnt2]: mapping_nodes) {\\n            remain = total - cnt1 - cnt2 - 1;\\n            score = (long) (cnt1 == 0? 1: cnt1) * (cnt2 == 0? 1: cnt2) * (remain == 0? 1: remain);\\n            if (score > max_score) max_score = score, cnt = 1;\\n            else if (score == max_score) cnt += 1;\\n        };\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894088,
                "title": "python3-solution-easy-to-understand-with-o-n-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n\\n        cntChilds = [0 for _ in range(n)]\\n        # buld graph\\n        graph = [[] for _ in range(n)]\\n        for i in range(1,n):\\n            graph[parents[i]].append(i)\\n        ##\\n        countChilds = [0 for _ in range(n)]\\n        def countChildNodes(root):\\n            if root == None:\\n                return 0\\n            if len(graph[root]) >= 1:\\n                countChilds[root] += countChildNodes(graph[root][0])\\n            if len(graph[root]) == 2:\\n                countChilds[root] += countChildNodes(graph[root][1])\\n            return countChilds[root] + 1\\n        countChildNodes(0)\\n\\n        ansMax = 0\\n        ans = 0\\n        for i in range(n):\\n            numLeft = numRight = 0\\n            if len(graph[i]) >= 1:\\n                numLeft = countChilds[graph[i][0]] + 1\\n            if len(graph[i]) == 2:\\n                numRight = countChilds[graph[i][1]] + 1\\n            numRestOf = max(1, n - 1 - numLeft - numRight)\\n            numLeft = max(1, numLeft)\\n            numRight = max(1, numRight)\\n            currCnt = numRestOf * numLeft * numRight\\n            if currCnt > ansMax:\\n                ansMax = currCnt\\n                ans = 1\\n            elif currCnt == ansMax:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n\\n        cntChilds = [0 for _ in range(n)]\\n        # buld graph\\n        graph = [[] for _ in range(n)]\\n        for i in range(1,n):\\n            graph[parents[i]].append(i)\\n        ##\\n        countChilds = [0 for _ in range(n)]\\n        def countChildNodes(root):\\n            if root == None:\\n                return 0\\n            if len(graph[root]) >= 1:\\n                countChilds[root] += countChildNodes(graph[root][0])\\n            if len(graph[root]) == 2:\\n                countChilds[root] += countChildNodes(graph[root][1])\\n            return countChilds[root] + 1\\n        countChildNodes(0)\\n\\n        ansMax = 0\\n        ans = 0\\n        for i in range(n):\\n            numLeft = numRight = 0\\n            if len(graph[i]) >= 1:\\n                numLeft = countChilds[graph[i][0]] + 1\\n            if len(graph[i]) == 2:\\n                numRight = countChilds[graph[i][1]] + 1\\n            numRestOf = max(1, n - 1 - numLeft - numRight)\\n            numLeft = max(1, numLeft)\\n            numRight = max(1, numRight)\\n            currCnt = numRestOf * numLeft * numRight\\n            if currCnt > ansMax:\\n                ansMax = currCnt\\n                ans = 1\\n            elif currCnt == ansMax:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885229,
                "title": "easy-dp-solution-in-o-n-time-complexity",
                "content": "# Intuition\\nTo calculate the size of neighbouring components.\\n\\n# Approach\\nUsing DP We can calculate the size of inner subtrees and multiply them.\\nFor outer tress, we can subtract current size from total nodes and then multiply it into the result.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n#define pb push_back\\n#define ll long long \\nint sz[400400]; // size vector\\nll ans[400400];\\nll temp=0; // maximum value\\n\\nclass Solution {\\n    private:\\n    // this function is used to calculate inner size of a subtree\\n    // we are using dp here and also storing the products of children\\n    // in the ans array.\\n    int size(unordered_map<int,vector<int>>& child, int node){\\n        vector<int> v=child[node];\\n        if(v.size()==0){\\n            return sz[node]=1;\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            int ch=size(child,v[i]);\\n            sz[node]+=ch;\\n            ans[node]*=1ll*max(ch,1);\\n        }\\n        sz[node]++;\\n        return sz[node];\\n    }\\n    // used to calculate the contribution of parent subtree\\n    // outer subtree\\n    void outer(unordered_map<int,vector<int>>& child, vector<int>& parents){\\n        int n=parents.size();\\n        temp=ans[0];\\n        for(int i=1; i<n; i++){\\n            int node=i,par=parents[i];\\n            // subtracting size of current component from total nodes \\n            int left=n-sz[node]; \\n            ans[i]*=1ll*left;\\n            temp=max(temp,ans[i]);\\n        }\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        memset(sz,0,sizeof(sz));\\n        int res=0,n=parents.size();\\n        for(int i=0; i<n; i++){\\n            ans[i]=1;\\n        }\\n\\n        unordered_map<int,vector<int>> child;\\n\\n        // creating child adjacency list\\n        for(int i=1; i<n; i++){\\n            child[parents[i]].pb(i);\\n        }\\n        size(child,0);\\n        outer(child,parents);\\n\\n        for(int i=0; i<n; i++){\\n            if(ans[i]==temp){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define pb push_back\\n#define ll long long \\nint sz[400400]; // size vector\\nll ans[400400];\\nll temp=0; // maximum value\\n\\nclass Solution {\\n    private:\\n    // this function is used to calculate inner size of a subtree\\n    // we are using dp here and also storing the products of children\\n    // in the ans array.\\n    int size(unordered_map<int,vector<int>>& child, int node){\\n        vector<int> v=child[node];\\n        if(v.size()==0){\\n            return sz[node]=1;\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            int ch=size(child,v[i]);\\n            sz[node]+=ch;\\n            ans[node]*=1ll*max(ch,1);\\n        }\\n        sz[node]++;\\n        return sz[node];\\n    }\\n    // used to calculate the contribution of parent subtree\\n    // outer subtree\\n    void outer(unordered_map<int,vector<int>>& child, vector<int>& parents){\\n        int n=parents.size();\\n        temp=ans[0];\\n        for(int i=1; i<n; i++){\\n            int node=i,par=parents[i];\\n            // subtracting size of current component from total nodes \\n            int left=n-sz[node]; \\n            ans[i]*=1ll*left;\\n            temp=max(temp,ans[i]);\\n        }\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        memset(sz,0,sizeof(sz));\\n        int res=0,n=parents.size();\\n        for(int i=0; i<n; i++){\\n            ans[i]=1;\\n        }\\n\\n        unordered_map<int,vector<int>> child;\\n\\n        // creating child adjacency list\\n        for(int i=1; i<n; i++){\\n            child[parents[i]].pb(i);\\n        }\\n        size(child,0);\\n        outer(child,parents);\\n\\n        for(int i=0; i<n; i++){\\n            if(ans[i]==temp){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864689,
                "title": "dfs-memoization-graph-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&parents, vector<int>adj[], unordered_map<int,pair<int,int>>&x, int node) {\\n\\n        int left=0;\\n        int right=0;\\n        int size = adj[node].size();\\n\\n        if(x.find(node)!=x.end()) return x[node].first+x[node].second;\\n\\n        if(size==0) {\\n            x[node]={0,0};\\n        }\\n        else if(size==1){\\n            left = solve(parents,adj,x,adj[node][0]);\\n            x[node]={left,0};\\n        }\\n        else if(size==2){\\n            left = solve(parents,adj,x,adj[node][0]);\\n            right = solve(parents,adj,x,adj[node][1]);\\n            x[node]={left,right};\\n        }\\n\\n        return left+right+1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n\\n        // Stores node -> {count of left Subtree nodes, count of right subtree nodes}\\n        unordered_map<int,pair<int,int>> x;\\n        vector<int> adj[n];\\n\\n        // Making directed Graph\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1) adj[parents[i]].push_back(i);\\n        }    \\n\\n        for(int i=0;i<n;i++){\\n          if(x.find(i)==x.end()) solve(parents,adj,x,i);\\n        }\\n      \\n        unordered_map<long long,long long> scores;\\n        long long ans=INT_MIN;\\n\\n        for(int i=0;i<n;i++) {      \\n              long long curScore=1;\\n              int size=adj[i].size();\\n\\n              long long sumLeftNode = x[i].first; // left subtree nodes\\n              long long sumRightNode = x[i].second; // right subtree nodes\\n              long long parent = n-1-sumLeftNode-sumRightNode; // parent nodes\\n              \\n              if(size==0){\\n                  sumLeftNode=1;\\n                  sumRightNode=1;\\n                  if(parent<=0) parent=1;\\n              }\\n\\n              else if(size==1){\\n                  if(sumLeftNode<=0) sumLeftNode=1;\\n                  else if(sumRightNode<=0) sumRightNode=1;\\n                  \\n                  if(parent<=0) parent=1;\\n              }\\n\\n              else if(size==2){\\n                  if(parent<=0) parent=1;\\n              }\\n\\n              ans=max(ans,parent*sumLeftNode*sumRightNode);\\n              curScore=parent*sumLeftNode*sumRightNode;\\n              scores[curScore]++;\\n      }\\n      return scores[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&parents, vector<int>adj[], unordered_map<int,pair<int,int>>&x, int node) {\\n\\n        int left=0;\\n        int right=0;\\n        int size = adj[node].size();\\n\\n        if(x.find(node)!=x.end()) return x[node].first+x[node].second;\\n\\n        if(size==0) {\\n            x[node]={0,0};\\n        }\\n        else if(size==1){\\n            left = solve(parents,adj,x,adj[node][0]);\\n            x[node]={left,0};\\n        }\\n        else if(size==2){\\n            left = solve(parents,adj,x,adj[node][0]);\\n            right = solve(parents,adj,x,adj[node][1]);\\n            x[node]={left,right};\\n        }\\n\\n        return left+right+1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n\\n        // Stores node -> {count of left Subtree nodes, count of right subtree nodes}\\n        unordered_map<int,pair<int,int>> x;\\n        vector<int> adj[n];\\n\\n        // Making directed Graph\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1) adj[parents[i]].push_back(i);\\n        }    \\n\\n        for(int i=0;i<n;i++){\\n          if(x.find(i)==x.end()) solve(parents,adj,x,i);\\n        }\\n      \\n        unordered_map<long long,long long> scores;\\n        long long ans=INT_MIN;\\n\\n        for(int i=0;i<n;i++) {      \\n              long long curScore=1;\\n              int size=adj[i].size();\\n\\n              long long sumLeftNode = x[i].first; // left subtree nodes\\n              long long sumRightNode = x[i].second; // right subtree nodes\\n              long long parent = n-1-sumLeftNode-sumRightNode; // parent nodes\\n              \\n              if(size==0){\\n                  sumLeftNode=1;\\n                  sumRightNode=1;\\n                  if(parent<=0) parent=1;\\n              }\\n\\n              else if(size==1){\\n                  if(sumLeftNode<=0) sumLeftNode=1;\\n                  else if(sumRightNode<=0) sumRightNode=1;\\n                  \\n                  if(parent<=0) parent=1;\\n              }\\n\\n              else if(size==2){\\n                  if(parent<=0) parent=1;\\n              }\\n\\n              ans=max(ans,parent*sumLeftNode*sumRightNode);\\n              curScore=parent*sumLeftNode*sumRightNode;\\n              scores[curScore]++;\\n      }\\n      return scores[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835665,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int v,int& n, vector<long long>& res, vector<vector<int>>& adj, vector<int>& parents){\\n         \\n         int ans =1;\\n         int count1 = -1, count2=-1;\\n         for(auto u : adj[v]){\\n             if(u == parents[v]) continue;\\n             \\n             if(count1== -1){\\n                 \\n                 count1 = dfs(u, n, res, adj, parents);\\n             }\\n             else{\\n                 count2 = dfs(u, n, res, adj, parents);\\n             }\\n         }\\n         if(count1==-1) count1 =0;\\n         if(count2==-1) count2 =0;\\n         res[v] = 1LL* max(1, count1)* max(1, count2)* max(1, n-(count1 + count2 + 1));\\n         return count1 + count2 + 1;  \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> adj(n);\\n        vector<long long> res(n,0);\\n        for(int i=1; i<n; i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0, n, res, adj, parents);\\n        long long mx = *max_element(res.begin(), res.end());\\n        int count =0;\\n        for(auto x : res){\\n            if(x == mx) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int v,int& n, vector<long long>& res, vector<vector<int>>& adj, vector<int>& parents){\\n         \\n         int ans =1;\\n         int count1 = -1, count2=-1;\\n         for(auto u : adj[v]){\\n             if(u == parents[v]) continue;\\n             \\n             if(count1== -1){\\n                 \\n                 count1 = dfs(u, n, res, adj, parents);\\n             }\\n             else{\\n                 count2 = dfs(u, n, res, adj, parents);\\n             }\\n         }\\n         if(count1==-1) count1 =0;\\n         if(count2==-1) count2 =0;\\n         res[v] = 1LL* max(1, count1)* max(1, count2)* max(1, n-(count1 + count2 + 1));\\n         return count1 + count2 + 1;  \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> adj(n);\\n        vector<long long> res(n,0);\\n        for(int i=1; i<n; i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        dfs(0, n, res, adj, parents);\\n        long long mx = *max_element(res.begin(), res.end());\\n        int count =0;\\n        for(auto x : res){\\n            if(x == mx) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816001,
                "title": "python-clear-topological-sort-solution",
                "content": "```\\ndef countHighestScoreNodes(self, pa: List[int]) -> int:\\n    ind, count, n, prod = [0]*len(pa), [1]*len(pa), len(pa), [1]*len(pa)\\n    for i in range(1, len(pa)):\\n        ind[pa[i]] += 1\\n    q = deque([i for i in range(n) if not ind[i]])\\n    while(q):\\n        i = q.popleft()\\n        if i:\\n            ind[pa[i]] -= 1\\n            count[pa[i]] += count[i]\\n            prod[pa[i]] *= count[i]\\n            if ind[pa[i]] == 0:\\n                q.append(pa[i])\\n    score = [max(n-count[i], 1)*prod[i] for i in range(n)]\\n    return score.count(max(score))\\n```",
                "solutionTags": [],
                "code": "```\\ndef countHighestScoreNodes(self, pa: List[int]) -> int:\\n    ind, count, n, prod = [0]*len(pa), [1]*len(pa), len(pa), [1]*len(pa)\\n    for i in range(1, len(pa)):\\n        ind[pa[i]] += 1\\n    q = deque([i for i in range(n) if not ind[i]])\\n    while(q):\\n        i = q.popleft()\\n        if i:\\n            ind[pa[i]] -= 1\\n            count[pa[i]] += count[i]\\n            prod[pa[i]] *= count[i]\\n            if ind[pa[i]] == 0:\\n                q.append(pa[i])\\n    score = [max(n-count[i], 1)*prod[i] for i in range(n)]\\n    return score.count(max(score))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3799647,
                "title": "c-beats-92-78-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nScore of a node is the product of subtrees formed by deleting this node \\n-> left subtree size * right subtree size * (remaning component above current node)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, generate tree\\nLet x = size of left subtree\\ny = size of right subtree\\nscore[node] = max(1,x) * max(1,y) * max(1,n-1-x-y);\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Firstly, generate tree(stored in vector v)\\nclass Solution {\\npublic:\\n    int dfs(int cn,int n,vector<vector<int>> &v,vector<long long> &sub){\\n        long long x=1,y=0;\\n        for(auto&ch:v[cn]){\\n            long long z=dfs(ch,n,v,sub);\\n            x*=max(1ll,z);\\n            y+=z;\\n        }\\n        x*=max(1ll,n-1-y);\\n        sub[cn]=x;\\n        return y+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& par) {\\n        int n=par.size(),c=0;\\n        vector<vector<int>> v(n);\\n        vector<long long> sub(n);\\n        for(int i=1;i<n;i++) v[par[i]].push_back(i);\\n        dfs(0,n,v,sub);\\n        long long mx=0;\\n        for(auto&i:sub){\\n            if(i>mx){\\n                mx=i;\\n                c=1;\\n            }\\n            else if(mx==i) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Firstly, generate tree(stored in vector v)\\nclass Solution {\\npublic:\\n    int dfs(int cn,int n,vector<vector<int>> &v,vector<long long> &sub){\\n        long long x=1,y=0;\\n        for(auto&ch:v[cn]){\\n            long long z=dfs(ch,n,v,sub);\\n            x*=max(1ll,z);\\n            y+=z;\\n        }\\n        x*=max(1ll,n-1-y);\\n        sub[cn]=x;\\n        return y+1;\\n    }\\n    int countHighestScoreNodes(vector<int>& par) {\\n        int n=par.size(),c=0;\\n        vector<vector<int>> v(n);\\n        vector<long long> sub(n);\\n        for(int i=1;i<n;i++) v[par[i]].push_back(i);\\n        dfs(0,n,v,sub);\\n        long long mx=0;\\n        for(auto&i:sub){\\n            if(i>mx){\\n                mx=i;\\n                c=1;\\n            }\\n            else if(mx==i) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784569,
                "title": "c-single-dfs-o-n-easy-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Need the sizes of all the subtrees (subordinate as well as above one) to calculate each node\\'s score.\\n\\n2. Calculate sizes of left & right subordinate subtree as we run the dfs function for the current node.\\n\\n3. Now to get the size of above tree, we simply can deduct the `sum of sizes of subordinate tree + 1 (current node)` from the total number of nodes(N).\\nTherefore, `size of above subtree = N - sum - 1`.\\n\\n4. Calculate score and store it in `allScores` array while keeping track of `maxScore`.Return count of `maxScore` in `allScores`.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: **O(n)** - *dfs, traversing parent, allScores array*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** - *tree adjajency list, allScores array*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N;\\n    long maxScore = 0;\\n    vector<long> allScores;\\n\\n    long dfs(int node,vector<vector<int>>& tree){\\n        \\n        long score = 1;\\n        long sum = 0;\\n        for(int v:tree[node]){\\n            \\n            long res = dfs(v,tree);\\n            sum += res;\\n            score *= res;\\n        }\\n        sum++; // added current\\n        score *= (N-sum>0) ? N-sum : 1; // to check that score doesn\\'t gets multiplied by 0 for root node\\n        maxScore = max(maxScore,score);\\n        allScores.push_back(score);\\n\\n        return sum;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        N = n;\\n        vector<vector<int>> tree(n);\\n\\n        for(int i=1; i<n; i++){\\n\\n            tree[parents[i]].push_back(i);\\n        }\\n\\n        dfs(0,tree);\\n        int cntOfMax = 0;\\n\\n        for(long& s: allScores){\\n            if(s==maxScore) cntOfMax++;\\n        }\\n        return cntOfMax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N;\\n    long maxScore = 0;\\n    vector<long> allScores;\\n\\n    long dfs(int node,vector<vector<int>>& tree){\\n        \\n        long score = 1;\\n        long sum = 0;\\n        for(int v:tree[node]){\\n            \\n            long res = dfs(v,tree);\\n            sum += res;\\n            score *= res;\\n        }\\n        sum++; // added current\\n        score *= (N-sum>0) ? N-sum : 1; // to check that score doesn\\'t gets multiplied by 0 for root node\\n        maxScore = max(maxScore,score);\\n        allScores.push_back(score);\\n\\n        return sum;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        N = n;\\n        vector<vector<int>> tree(n);\\n\\n        for(int i=1; i<n; i++){\\n\\n            tree[parents[i]].push_back(i);\\n        }\\n\\n        dfs(0,tree);\\n        int cntOfMax = 0;\\n\\n        for(long& s: allScores){\\n            if(s==maxScore) cntOfMax++;\\n        }\\n        return cntOfMax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784092,
                "title": "different-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int fillsize(vector<int>&sizez,int root,unordered_map<int,vector<int>>&adj){\\n        \\n        int cnt = 0;\\n        for(auto it : adj[root]){\\n            cnt += 1 + fillsize(sizez,it,adj);\\n        }\\n        sizez[root] = cnt;\\n        return cnt;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=1;i<n;i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        vector<int>sizes(n,1);\\n        fillsize(sizes,0,adj);\\n        for(int i=0;i<n;i++){\\n            sizes[i]++;\\n            // cout<<sizes[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        long long ans = 1;\\n        vector<long long>tt;\\n        for(int i=0;i<n;i++){\\n            long long cnt = 1;\\n            for(auto it : adj[i]){\\n                cnt *= sizes[it]*1ll;\\n            }\\n            if(parents[i] != -1){\\n                cnt *= (sizes[0]-sizes[i])*1ll;\\n            }\\n            tt.push_back(cnt);\\n        }\\n        // for(auto it : tt)cout<<it<<\" \";\\n        // cout<<endl;\\n        sort(tt.begin(),tt.end());\\n        for(int i=tt.size()-2;i>=0;i--){\\n            if(tt[i] == tt[i+1])ans++;\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillsize(vector<int>&sizez,int root,unordered_map<int,vector<int>>&adj){\\n        \\n        int cnt = 0;\\n        for(auto it : adj[root]){\\n            cnt += 1 + fillsize(sizez,it,adj);\\n        }\\n        sizez[root] = cnt;\\n        return cnt;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=1;i<n;i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        vector<int>sizes(n,1);\\n        fillsize(sizes,0,adj);\\n        for(int i=0;i<n;i++){\\n            sizes[i]++;\\n            // cout<<sizes[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        long long ans = 1;\\n        vector<long long>tt;\\n        for(int i=0;i<n;i++){\\n            long long cnt = 1;\\n            for(auto it : adj[i]){\\n                cnt *= sizes[it]*1ll;\\n            }\\n            if(parents[i] != -1){\\n                cnt *= (sizes[0]-sizes[i])*1ll;\\n            }\\n            tt.push_back(cnt);\\n        }\\n        // for(auto it : tt)cout<<it<<\" \";\\n        // cout<<endl;\\n        sort(tt.begin(),tt.end());\\n        for(int i=tt.size()-2;i>=0;i--){\\n            if(tt[i] == tt[i+1])ans++;\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3748510,
                "title": "simple-c-using-dynamic-programming-approach-dp-on-tree",
                "content": "```\\nint const N = 1e5;\\nclass Solution {\\npublic:\\n    vector<int> adj[N+1];\\n    int dp[N+1];\\n    void treeConstruct(vector<int>& parents){\\n        for(int i=1;i<parents.size();i++){\\n            adj[i].push_back(parents[i]);\\n            adj[parents[i]].push_back(i);\\n        }\\n    }\\n    int numberOfNode(int node=0,int par=-1){\\n        int cnt=0;\\n        for(auto it:adj[node]){\\n            if(it==par) continue;\\n            cnt+=numberOfNode(it,node);\\n        }\\n        return cnt+1;\\n    }\\n    void childCount(int node=0,int par=-1){\\n        for(auto it:adj[node]){\\n            if(it==par) continue;\\n            childCount(it,node);\\n            dp[node]+=dp[it];\\n        }\\n        dp[node]+=1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int cnt = 0;\\n        treeConstruct(parents);\\n        int noOfNode = numberOfNode();\\n        childCount();\\n        map<long long,int> mp;\\n        for(int i=0;i<parents.size();i++){\\n            vector<int> temp;\\n            long long amit = 1;\\n            for(auto it:adj[i]) if(dp[i]>dp[it]) temp.push_back(it);\\n            int total = 1;\\n            for(auto it:temp) total+=dp[it];\\n            int rem = noOfNode-total;\\n            for(auto it:temp) if(dp[it]!=0) amit*=dp[it];\\n            if(rem!=0) amit*=rem;\\n            mp[amit]++;\\n        }\\n        return mp.rbegin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nint const N = 1e5;\\nclass Solution {\\npublic:\\n    vector<int> adj[N+1];\\n    int dp[N+1];\\n    void treeConstruct(vector<int>& parents){\\n        for(int i=1;i<parents.size();i++){\\n            adj[i].push_back(parents[i]);\\n            adj[parents[i]].push_back(i);\\n        }\\n    }\\n    int numberOfNode(int node=0,int par=-1){\\n        int cnt=0;\\n        for(auto it:adj[node]){\\n            if(it==par) continue;\\n            cnt+=numberOfNode(it,node);\\n        }\\n        return cnt+1;\\n    }\\n    void childCount(int node=0,int par=-1){\\n        for(auto it:adj[node]){\\n            if(it==par) continue;\\n            childCount(it,node);\\n            dp[node]+=dp[it];\\n        }\\n        dp[node]+=1;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int cnt = 0;\\n        treeConstruct(parents);\\n        int noOfNode = numberOfNode();\\n        childCount();\\n        map<long long,int> mp;\\n        for(int i=0;i<parents.size();i++){\\n            vector<int> temp;\\n            long long amit = 1;\\n            for(auto it:adj[i]) if(dp[i]>dp[it]) temp.push_back(it);\\n            int total = 1;\\n            for(auto it:temp) total+=dp[it];\\n            int rem = noOfNode-total;\\n            for(auto it:temp) if(dp[it]!=0) amit*=dp[it];\\n            if(rem!=0) amit*=rem;\\n            mp[amit]++;\\n        }\\n        return mp.rbegin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746720,
                "title": "c-dfs-o-n-o-n-readable",
                "content": "Construct the array of children out of the array of parents, then dfs through the tree keeping track of the number of nodes in the subtrees of the children\\n\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> children;\\n    size_t maxScore{ 0 };\\n    size_t maxScoreNodesCnt{ 0 };\\n\\n    size_t FillScore(int node)\\n    {\\n        if (node == -1)\\n            return 0;\\n\\n        size_t lTreeNodes = FillScore(children[node].first);\\n        size_t rTreeNodes = FillScore(children[node].second);\\n        size_t outerTreeNodes = children.size() - 1 - lTreeNodes - rTreeNodes;\\n\\n        size_t score = max(lTreeNodes, 1ul) * max(rTreeNodes, 1ul) * max(outerTreeNodes, 1ul);        \\n        if (score >= maxScore)\\n        {\\n            maxScoreNodesCnt = score <= maxScore? maxScoreNodesCnt + 1 : 1;\\n            maxScore = max(score, maxScore);\\n        }\\n\\n        return lTreeNodes + rTreeNodes + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        children.resize(parents.size(), make_pair(-1, -1));\\n        for (int node = 1; node < parents.size(); ++node)\\n        {\\n            int parent = parents[node];\\n            int& child = children[parent].first == -1?\\n                children[parent].first :\\n                children[parent].second;\\n\\n            child = node;\\n        }\\n\\n        FillScore(0);\\n        return maxScoreNodesCnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> children;\\n    size_t maxScore{ 0 };\\n    size_t maxScoreNodesCnt{ 0 };\\n\\n    size_t FillScore(int node)\\n    {\\n        if (node == -1)\\n            return 0;\\n\\n        size_t lTreeNodes = FillScore(children[node].first);\\n        size_t rTreeNodes = FillScore(children[node].second);\\n        size_t outerTreeNodes = children.size() - 1 - lTreeNodes - rTreeNodes;\\n\\n        size_t score = max(lTreeNodes, 1ul) * max(rTreeNodes, 1ul) * max(outerTreeNodes, 1ul);        \\n        if (score >= maxScore)\\n        {\\n            maxScoreNodesCnt = score <= maxScore? maxScoreNodesCnt + 1 : 1;\\n            maxScore = max(score, maxScore);\\n        }\\n\\n        return lTreeNodes + rTreeNodes + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        children.resize(parents.size(), make_pair(-1, -1));\\n        for (int node = 1; node < parents.size(); ++node)\\n        {\\n            int parent = parents[node];\\n            int& child = children[parent].first == -1?\\n                children[parent].first :\\n                children[parent].second;\\n\\n            child = node;\\n        }\\n\\n        FillScore(0);\\n        return maxScoreNodesCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727523,
                "title": "java-easy-understanding-math",
                "content": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        \\n        HashMap<Integer,HashSet<Integer>> childMap = new HashMap<>();\\n        \\n        for(int i = 1 ; i < parents.length ; i++){\\n            \\n            if(!childMap.containsKey(parents[i])){\\n                childMap.put(parents[i],new HashSet<>());\\n            }\\n            \\n             if(!childMap.containsKey(i)){\\n                childMap.put(i,new HashSet<>());\\n            }\\n            \\n            childMap.get(parents[i]).add(i);\\n        }\\n        \\n\\n          \\n        long[][] nodeVsleftRight = new long[parents.length][2];\\n        helper(nodeVsleftRight,childMap,0);\\n        \\n        long max = Integer.MIN_VALUE;\\n        long count = 1L;\\n        for(int i = 0 ; i < parents.length ; i++){\\n            //System.out.println(nodeVsleftRight[i][0] + \" \" + nodeVsleftRight[i][1]);\\n            long res = calculate(i,nodeVsleftRight);\\n            \\n            if(res > max){\\n                count=1L;\\n                max = res;\\n            }else if(res == max){\\n                count++;\\n            }\\n    \\n        }\\n        \\n        return (int)count;\\n    }\\n    \\n    public long calculate(int node,long[][] nodeVsleftRight){\\n        if(node == 0 ){\\n            long left = nodeVsleftRight[node][0] == 0 ? 1 : nodeVsleftRight[node][0];\\n            long right = nodeVsleftRight[node][1] == 0 ? 1 : nodeVsleftRight[node][1];      \\n            return left* right;\\n        }else{\\n            long fromZero  = ( nodeVsleftRight[0][0] + nodeVsleftRight[0][1] ) - (nodeVsleftRight[node][0]+nodeVsleftRight[node][1]);\\n            \\n            long left = nodeVsleftRight[node][0] == 0 ? 1 : nodeVsleftRight[node][0];\\n            long right = nodeVsleftRight[node][1] == 0 ? 1 : nodeVsleftRight[node][1];\\n            \\n            return left*right*fromZero;\\n            \\n        }\\n    }\\n    \\n    \\n    public long helper(long[][] res,HashMap<Integer,HashSet<Integer>> childMap,int node){\\n        if(childMap.get(node).size() == 0){\\n            res[node][0]=0;\\n            res[node][1]=0;\\n            return 1L;\\n        }\\n        \\n        \\n        int i = 0;\\n        \\n        for(int adjNode : childMap.get(node)){\\n            long ans = helper(res,childMap,adjNode);\\n            res[node][i] = ans;\\n            i++;\\n        }\\n        \\n        return res[node][0] + res[node][1] + 1L; \\n    }\\n    \\n//     public int helper(int node, HashMap<Integer,HashSet<Integer>> childMap , int[] arr){\\n        \\n//         if(childMap.get(node).size() == 0){\\n//             arr[node] = 0;\\n//             return 1;\\n//         }\\n        \\n//         int ans = 0;\\n        \\n//         for(int adjNode : childMap.get(node)){\\n//             ans+=helper(adjNode,childMap,arr);\\n//         }\\n        \\n//         arr[node] = ans;\\n//         return 1+arr[node];                                    \\n//     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        \\n        HashMap<Integer,HashSet<Integer>> childMap = new HashMap<>();\\n        \\n        for(int i = 1 ; i < parents.length ; i++){\\n            \\n            if(!childMap.containsKey(parents[i])){\\n                childMap.put(parents[i],new HashSet<>());\\n            }\\n            \\n             if(!childMap.containsKey(i)){\\n                childMap.put(i,new HashSet<>());\\n            }\\n            \\n            childMap.get(parents[i]).add(i);\\n        }\\n        \\n\\n          \\n        long[][] nodeVsleftRight = new long[parents.length][2];\\n        helper(nodeVsleftRight,childMap,0);\\n        \\n        long max = Integer.MIN_VALUE;\\n        long count = 1L;\\n        for(int i = 0 ; i < parents.length ; i++){\\n            //System.out.println(nodeVsleftRight[i][0] + \" \" + nodeVsleftRight[i][1]);\\n            long res = calculate(i,nodeVsleftRight);\\n            \\n            if(res > max){\\n                count=1L;\\n                max = res;\\n            }else if(res == max){\\n                count++;\\n            }\\n    \\n        }\\n        \\n        return (int)count;\\n    }\\n    \\n    public long calculate(int node,long[][] nodeVsleftRight){\\n        if(node == 0 ){\\n            long left = nodeVsleftRight[node][0] == 0 ? 1 : nodeVsleftRight[node][0];\\n            long right = nodeVsleftRight[node][1] == 0 ? 1 : nodeVsleftRight[node][1];      \\n            return left* right;\\n        }else{\\n            long fromZero  = ( nodeVsleftRight[0][0] + nodeVsleftRight[0][1] ) - (nodeVsleftRight[node][0]+nodeVsleftRight[node][1]);\\n            \\n            long left = nodeVsleftRight[node][0] == 0 ? 1 : nodeVsleftRight[node][0];\\n            long right = nodeVsleftRight[node][1] == 0 ? 1 : nodeVsleftRight[node][1];\\n            \\n            return left*right*fromZero;\\n            \\n        }\\n    }\\n    \\n    \\n    public long helper(long[][] res,HashMap<Integer,HashSet<Integer>> childMap,int node){\\n        if(childMap.get(node).size() == 0){\\n            res[node][0]=0;\\n            res[node][1]=0;\\n            return 1L;\\n        }\\n        \\n        \\n        int i = 0;\\n        \\n        for(int adjNode : childMap.get(node)){\\n            long ans = helper(res,childMap,adjNode);\\n            res[node][i] = ans;\\n            i++;\\n        }\\n        \\n        return res[node][0] + res[node][1] + 1L; \\n    }\\n    \\n//     public int helper(int node, HashMap<Integer,HashSet<Integer>> childMap , int[] arr){\\n        \\n//         if(childMap.get(node).size() == 0){\\n//             arr[node] = 0;\\n//             return 1;\\n//         }\\n        \\n//         int ans = 0;\\n        \\n//         for(int adjNode : childMap.get(node)){\\n//             ans+=helper(adjNode,childMap,arr);\\n//         }\\n        \\n//         arr[node] = ans;\\n//         return 1+arr[node];                                    \\n//     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727024,
                "title": "c-easy-solution-dfs-explanation",
                "content": "# EXPLANATION\\nWe took **m** for max value, **c** for the count as answer, **n** for size of parents.\\nCreated a vector of size **n** with pair **<int,int>** as child value and initialised its value to **{-1,-1}**.\\nTraversed through parents vector and added the child to the number if present.**(Created a binary tree path)**.\\nWe did **sol(0,v,n-1)** because the start root is 0 and we need to remove one root every time so we did (n-1).\\nIn **sol** function we traversed in DFS technique.\\nIf there is no child we return 0.\\nWe stored **l** -> left child value, **r** -> right child value.\\nStored **lsum** -> no. of left root sum ,**rsum** -> no. of right root sum.\\nTook **s** -> no. of root sum except lsum and rsum (roots above it).\\n**ls** and **rs** for calculation of total roots as asked in question.\\nWe used **max function** because of calculation (in some cases there is no child or no root above it so in order for calculation we need to multiply with 1).\\nCompared with **m** and did the operation as required.\\nAt last returned the number of child roots along with it.\\nFinally returned **c**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    long long m=0;\\n    int c=0;\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       int n=parents.size();\\n       vector<pair<int,int>> v(n,pair<int,int>({-1,-1}));\\n       for(int i=1;i<n;i++){\\n           int a=parents[i];\\n           if(v[a].first==-1)\\n                v[a].first=i;\\n            else\\n                v[a].second=i;\\n       }\\n       sol(0,v,n-1);\\n       return c;\\n    }\\n    int sol(int i,vector<pair<int,int>> &v,int n){\\n        if(i==-1)\\n            return 0;\\n        int l=v[i].first,r=v[i].second;\\n        int lsum=0,rsum=0;\\n        lsum=sol(l,v,n);\\n        rsum=sol(r,v,n);\\n        long long s=max(1,n-lsum-rsum);\\n        long long ls=max(1,lsum);\\n        long long rs=max(1,rsum);\\n        long long res=s*ls*rs;\\n        if(res==m)\\n            c++;\\n        else if(res>m)\\n            c=1;\\n        m=max(m,res);\\n        return (lsum+rsum+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long m=0;\\n    int c=0;\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       int n=parents.size();\\n       vector<pair<int,int>> v(n,pair<int,int>({-1,-1}));\\n       for(int i=1;i<n;i++){\\n           int a=parents[i];\\n           if(v[a].first==-1)\\n                v[a].first=i;\\n            else\\n                v[a].second=i;\\n       }\\n       sol(0,v,n-1);\\n       return c;\\n    }\\n    int sol(int i,vector<pair<int,int>> &v,int n){\\n        if(i==-1)\\n            return 0;\\n        int l=v[i].first,r=v[i].second;\\n        int lsum=0,rsum=0;\\n        lsum=sol(l,v,n);\\n        rsum=sol(r,v,n);\\n        long long s=max(1,n-lsum-rsum);\\n        long long ls=max(1,lsum);\\n        long long rs=max(1,rsum);\\n        long long res=s*ls*rs;\\n        if(res==m)\\n            c++;\\n        else if(res>m)\\n            c=1;\\n        m=max(m,res);\\n        return (lsum+rsum+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708533,
                "title": "graph-dfs-solution-c",
                "content": "# Intuition\\nUse parent array to create graph\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, create graph using parent array and store size of subtree at each node using map.  Compute result from problem.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n unordered_map<int,vector<int>> adj;\\n unordered_map<int,int> mp;\\n int solve(int node){\\n    \\n     int ans=0;\\n     for(auto i:adj[node]){\\n         int res=solve(i);\\n        ans+=res;\\n     }\\n     return mp[node]=1+ans;\\n     \\n }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n         if(parents.size()==1){\\n             return 0;\\n         }\\n        for(int i=1;i<parents.size();i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        solve(0);\\n        vector<long long> node(parents.size(),0);\\n        for(int i=0;i<parents.size();i++){\\n            long long maxi=1;\\n            if(parents[i]==-1){\\n                for(int j:adj[i]){\\n                    maxi=maxi*mp[j]*1LL;\\n                }\\n                node[i]=maxi;\\n            }\\n            else{\\n                maxi=maxi*(mp[0]-mp[i]);\\n                for(int j:adj[i]){\\n                    maxi=maxi*mp[j]*1LL;\\n                }\\n                node[i]=maxi;\\n            }\\n        }\\n        sort(node.begin(),node.end());\\n        long long m=node[node.size()-1];\\n        int count=1;\\n        for(int i=node.size()-2;i>=0;i--){\\n            if(node[i]==m){\\n                count++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n**********PLEASE UPVOTE IF FOUND USEFUL********************\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n unordered_map<int,vector<int>> adj;\\n unordered_map<int,int> mp;\\n int solve(int node){\\n    \\n     int ans=0;\\n     for(auto i:adj[node]){\\n         int res=solve(i);\\n        ans+=res;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 3701352,
                "title": "c-intuitive-postorder-dfs-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For any node `i`, except root node:\\n$$score(i) = (n - size_{i}) \\\\space * \\\\space size_{left-child} \\\\space * \\\\space size_{right-child}  $$\\n\\n- For `root` node:\\n    $$score(root) = size_{left-child} \\\\space * \\\\space size_{right-child}  $$\\n\\nHere $$size_{node}$$ = subtree size of node, and `n` is the total number of nodes in the whole tree.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use post-order traversal to compute subtree sizes of children.\\n2. Compute score for each node using above formula.\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    vector<ll> scores;\\n    int n;\\n    ll maxScore;\\npublic:\\n    int countAndScore(int u) {\\n        int c = 1;\\n        ll score = 1;\\n        for(auto v : adj[u]) {\\n            int size = countAndScore(v);\\n            score *= size;\\n            c+=size;\\n        }\\n        scores[u] = u == 0 ? score : score*(n-c);\\n        maxScore = max(maxScore, scores[u]);\\n\\n        return c;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& p) {\\n        n = p.size();\\n        adj.resize(n);\\n        scores.resize(n, 1);\\n\\n        for(int i=1; i<n; i++) \\n            adj[p[i]].push_back(i);\\n        \\n        maxScore = INT_MIN;\\n        countAndScore(0);\\n\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            res += (scores[i] == maxScore) ? 1 : 0;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> adj;\\n    vector<ll> scores;\\n    int n;\\n    ll maxScore;\\npublic:\\n    int countAndScore(int u) {\\n        int c = 1;\\n        ll score = 1;\\n        for(auto v : adj[u]) {\\n            int size = countAndScore(v);\\n            score *= size;\\n            c+=size;\\n        }\\n        scores[u] = u == 0 ? score : score*(n-c);\\n        maxScore = max(maxScore, scores[u]);\\n\\n        return c;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& p) {\\n        n = p.size();\\n        adj.resize(n);\\n        scores.resize(n, 1);\\n\\n        for(int i=1; i<n; i++) \\n            adj[p[i]].push_back(i);\\n        \\n        maxScore = INT_MIN;\\n        countAndScore(0);\\n\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            res += (scores[i] == maxScore) ? 1 : 0;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699364,
                "title": "simple-c-solution-dynamic-programming-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int>sides[],vector<long long>&size,int index,int parent){\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=parent){\\n            dfs(sides,size,sides[index][i],index);\\n            size[index]=size[index]+size[sides[index][i]];\\n        }\\n    }\\n}\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        vector<int>sides[parents.size()];\\n        for(int i=0;i<parents.size();i++){\\n            if(parents[i]!=-1){\\n                sides[i].push_back(parents[i]);\\n                sides[parents[i]].push_back(i);\\n            }\\n        }\\n        vector<long long>size(parents.size(),1);\\n        dfs(sides,size,0,-1);\\n        long long max_score=0;\\n        int ans=0;\\n        for(int i=0;i<parents.size();i++){\\n            long long score1=1;\\n            long long score2=1;\\n            long long temp=1;\\n            for(int j=0;j<sides[i].size();j++){\\n                if(sides[i][j]==parents[i] && parents[i]!=-1){\\n                    score1=score1*(parents.size()-size[i]);\\n                }\\n                else if(sides[i][j]!=parents[i]){\\n                    score2=score2*(size[sides[i][j]]);\\n                }\\n            }\\n            long long curr_score=score2*score1;\\n            if(max_score==curr_score){\\n                ans=ans+1;\\n            }\\n            else if(max_score<curr_score){\\n                ans=1;\\n                max_score=curr_score;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int>sides[],vector<long long>&size,int index,int parent){\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=parent){\\n            dfs(sides,size,sides[index][i],index);\\n            size[index]=size[index]+size[sides[index][i]];\\n        }\\n    }\\n}\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        vector<int>sides[parents.size()];\\n        for(int i=0;i<parents.size();i++){\\n            if(parents[i]!=-1){\\n                sides[i].push_back(parents[i]);\\n                sides[parents[i]].push_back(i);\\n            }\\n        }\\n        vector<long long>size(parents.size(),1);\\n        dfs(sides,size,0,-1);\\n        long long max_score=0;\\n        int ans=0;\\n        for(int i=0;i<parents.size();i++){\\n            long long score1=1;\\n            long long score2=1;\\n            long long temp=1;\\n            for(int j=0;j<sides[i].size();j++){\\n                if(sides[i][j]==parents[i] && parents[i]!=-1){\\n                    score1=score1*(parents.size()-size[i]);\\n                }\\n                else if(sides[i][j]!=parents[i]){\\n                    score2=score2*(size[sides[i][j]]);\\n                }\\n            }\\n            long long curr_score=score2*score1;\\n            if(max_score==curr_score){\\n                ans=ans+1;\\n            }\\n            else if(max_score<curr_score){\\n                ans=1;\\n                max_score=curr_score;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691996,
                "title": "easy-java-solution-hashmap-dfs-count-array-upvote",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int n = parents.length;\\n\\n        for(int i =0; i < n; i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i = 1; i < n; i++){\\n            map.get(parents[i]).add(i);\\n        }\\n\\n        int[] count = new int[n];\\n        int x = 1;\\n        for(int i = 0; i < n; i++){\\n            if(count[i] == 0){\\n                x = find_count(i, map, count);\\n            }\\n        }\\n\\n        long max=0;int ans=0;\\n\\n        for(int i = 0; i < n; i++){\\n            List<Integer> child = map.get(i);\\n            long curr = 1;\\n\\n            if(child != null){\\n                for(int j = 0; j < child.size(); j++){\\n                    curr = curr * (long)count[child.get(j)];\\n                }\\n            }\\n\\n            if(parents[i] != -1){\\n                curr = curr * (long)(n - count[i]);\\n            }\\n\\n            if(curr > max){\\n                max = curr;\\n                ans = 1;\\n            }\\n            else if(curr == max) ans++;\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    int find_count(int node, HashMap<Integer, List<Integer>> map, int[] count){\\n        if(count[node] != 0) return count[node];\\n\\n        List<Integer> child = map.get(node);\\n\\n        if(child == null){\\n            return count[node] = 1;\\n        }\\n        int cnt = 1;\\n\\n        for(int i = 0; i < child.size(); i++){\\n            cnt = cnt + find_count(child.get(i), map, count);\\n        }\\n\\n        count[node] = cnt;\\n        return cnt;\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int n = parents.length;\\n\\n        for(int i =0; i < n; i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i = 1; i < n; i++){\\n            map.get(parents[i]).add(i);\\n        }\\n\\n        int[] count = new int[n];\\n        int x = 1;\\n        for(int i = 0; i < n; i++){\\n            if(count[i] == 0){\\n                x = find_count(i, map, count);\\n            }\\n        }\\n\\n        long max=0;int ans=0;\\n\\n        for(int i = 0; i < n; i++){\\n            List<Integer> child = map.get(i);\\n            long curr = 1;\\n\\n            if(child != null){\\n                for(int j = 0; j < child.size(); j++){\\n                    curr = curr * (long)count[child.get(j)];\\n                }\\n            }\\n\\n            if(parents[i] != -1){\\n                curr = curr * (long)(n - count[i]);\\n            }\\n\\n            if(curr > max){\\n                max = curr;\\n                ans = 1;\\n            }\\n            else if(curr == max) ans++;\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    int find_count(int node, HashMap<Integer, List<Integer>> map, int[] count){\\n        if(count[node] != 0) return count[node];\\n\\n        List<Integer> child = map.get(node);\\n\\n        if(child == null){\\n            return count[node] = 1;\\n        }\\n        int cnt = 1;\\n\\n        for(int i = 0; i < child.size(); i++){\\n            cnt = cnt + find_count(child.get(i), map, count);\\n        }\\n\\n        count[node] = cnt;\\n        return cnt;\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673908,
                "title": "c-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    long long maxS;\\n    int dfs(int x,vector<vector<int>>& adj,map<long long,long long>& m)\\n    {\\n        long long tmp = 1;\\n        long long l = 0,r = 0;\\n        if(adj[x].size()==1)\\n        l = dfs(adj[x][0],adj,m);\\n        if(adj[x].size()==2)\\n        {\\n            l = dfs(adj[x][0],adj,m);\\n            r = dfs(adj[x][1],adj,m);\\n        }\\n        \\n        long long prod1;\\n        if(l>0 && r>0)\\n        prod1 = (maxS-tmp-l-r)*(l*r);\\n        else if(l>0)\\n        prod1 = (maxS-tmp-l)*(l);\\n        else if(r>0)\\n        prod1 = (maxS-tmp-r)*(r);\\n        else\\n        prod1 = (maxS-tmp);\\n        long long prod2;\\n        if(l>0 && r>0)\\n        prod2 = l*r;\\n        else if(l>0)\\n        prod2 = l;\\n        else if(r>0)\\n        prod2 = r;\\n        else\\n        prod2 = 0;\\n        m[prod1]++;\\n        if(prod1!=prod2)\\n        m[prod2]++;\\n        return tmp+l+r;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n            {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        maxS = n;\\n        map<long long,long long> m;\\n        dfs(0,adj,m);\\n        auto it = m.end();\\n        it--;\\n        return it->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    long long maxS;\\n    int dfs(int x,vector<vector<int>>& adj,map<long long,long long>& m)\\n    {\\n        long long tmp = 1;\\n        long long l = 0,r = 0;\\n        if(adj[x].size()==1)\\n        l = dfs(adj[x][0],adj,m);\\n        if(adj[x].size()==2)\\n        {\\n            l = dfs(adj[x][0],adj,m);\\n            r = dfs(adj[x][1],adj,m);\\n        }\\n        \\n        long long prod1;\\n        if(l>0 && r>0)\\n        prod1 = (maxS-tmp-l-r)*(l*r);\\n        else if(l>0)\\n        prod1 = (maxS-tmp-l)*(l);\\n        else if(r>0)\\n        prod1 = (maxS-tmp-r)*(r);\\n        else\\n        prod1 = (maxS-tmp);\\n        long long prod2;\\n        if(l>0 && r>0)\\n        prod2 = l*r;\\n        else if(l>0)\\n        prod2 = l;\\n        else if(r>0)\\n        prod2 = r;\\n        else\\n        prod2 = 0;\\n        m[prod1]++;\\n        if(prod1!=prod2)\\n        m[prod2]++;\\n        return tmp+l+r;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=0)\\n            {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        maxS = n;\\n        map<long long,long long> m;\\n        dfs(0,adj,m);\\n        auto it = m.end();\\n        it--;\\n        return it->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655658,
                "title": "golang-with-comments-dfs-memo",
                "content": "# Approach\\nBased on hints by LeetCode:\\n> For each node, you need to find the sizes of the subtrees rooted in each of its children.\\n\\n> How to determine the number of nodes in the rest of the tree? Can you subtract the size of the subtree rooted at the node from the total number of nodes of the tree?\\n\\n# Code\\n```\\n// implicitly imported by LeetCode\\n// type TreeNode struct {\\n//\\tVal   int\\n//\\tLeft  *TreeNode\\n//\\tRight *TreeNode\\n//}\\n\\n// Score holds number of nodes in left and right subtrees\\ntype Score struct {\\n\\tLeft  int\\n\\tRight int\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tn := len(parents)\\n\\t// map of node value to itself for creating tree purpose\\n\\tnodes := make(map[int]*TreeNode, n)\\n\\tnodes[0] = &TreeNode{Val: 0}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tmakeNode(parents, nodes, i)\\n\\t}\\n\\n\\tscores := make(map[int]Score, n)\\n\\tscore(nodes[0], scores)\\n\\n\\tmax := 0\\n\\tamount := 0\\n\\tfor _, nodeScore := range scores {\\n\\t\\t// adjust multipliers\\n\\t\\tothers := 1\\n\\t\\tif n-nodeScore.Left-nodeScore.Right-1 != 0 {\\n\\t\\t\\tothers = n - nodeScore.Left - nodeScore.Right - 1\\n\\t\\t}\\n\\t\\tif nodeScore.Left == 0 {\\n\\t\\t\\tnodeScore.Left = 1\\n\\t\\t}\\n\\t\\tif nodeScore.Right == 0 {\\n\\t\\t\\tnodeScore.Right = 1\\n\\t\\t}\\n\\n\\t\\ttotal := nodeScore.Left * nodeScore.Right * others\\n\\t\\tif total > max {\\n\\t\\t\\tmax = total\\n\\t\\t\\tamount = 1\\n\\t\\t} else if total == max {\\n\\t\\t\\tamount++\\n\\t\\t}\\n\\t}\\n\\treturn amount\\n}\\n\\nfunc makeNode(parents []int, nodes map[int]*TreeNode, index int) {\\n\\t// quit if node already exists\\n    if nodes[index] != nil {\\n        return\\n    }\\n\\n\\tnode := &TreeNode{Val: index}\\n\\tnodes[index] = node\\n\\n\\t// to link freshly created node to a parent, parent must be presented\\n\\tif parent, ok := nodes[parents[index]]; ok {\\n\\t\\tassignChild(parent, node)\\n\\t} else { // create one if it doesn\\'t exist\\n\\t\\tmakeNode(parents, nodes, parents[index])\\n\\t\\tassignChild(nodes[parents[index]], node)\\n\\t}\\n}\\n\\n// links child to parent. Left or Right doesn\\'t matter\\nfunc assignChild(parent, child *TreeNode) {\\n\\tif parent.Left == nil {\\n\\t\\tparent.Left = child\\n\\t} else {\\n\\t\\tparent.Right = child\\n\\t}\\n}\\n\\n// calculates score for a node\\nfunc score(node *TreeNode, scores map[int]Score) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tleft := score(node.Left, scores)\\n\\tright := score(node.Right, scores)\\n\\tscores[node.Val] = Score{left, right}\\n\\t// return score of the node +1 to include node as well\\n\\treturn left + right + 1\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n// implicitly imported by LeetCode\\n// type TreeNode struct {\\n//\\tVal   int\\n//\\tLeft  *TreeNode\\n//\\tRight *TreeNode\\n//}\\n\\n// Score holds number of nodes in left and right subtrees\\ntype Score struct {\\n\\tLeft  int\\n\\tRight int\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tn := len(parents)\\n\\t// map of node value to itself for creating tree purpose\\n\\tnodes := make(map[int]*TreeNode, n)\\n\\tnodes[0] = &TreeNode{Val: 0}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tmakeNode(parents, nodes, i)\\n\\t}\\n\\n\\tscores := make(map[int]Score, n)\\n\\tscore(nodes[0], scores)\\n\\n\\tmax := 0\\n\\tamount := 0\\n\\tfor _, nodeScore := range scores {\\n\\t\\t// adjust multipliers\\n\\t\\tothers := 1\\n\\t\\tif n-nodeScore.Left-nodeScore.Right-1 != 0 {\\n\\t\\t\\tothers = n - nodeScore.Left - nodeScore.Right - 1\\n\\t\\t}\\n\\t\\tif nodeScore.Left == 0 {\\n\\t\\t\\tnodeScore.Left = 1\\n\\t\\t}\\n\\t\\tif nodeScore.Right == 0 {\\n\\t\\t\\tnodeScore.Right = 1\\n\\t\\t}\\n\\n\\t\\ttotal := nodeScore.Left * nodeScore.Right * others\\n\\t\\tif total > max {\\n\\t\\t\\tmax = total\\n\\t\\t\\tamount = 1\\n\\t\\t} else if total == max {\\n\\t\\t\\tamount++\\n\\t\\t}\\n\\t}\\n\\treturn amount\\n}\\n\\nfunc makeNode(parents []int, nodes map[int]*TreeNode, index int) {\\n\\t// quit if node already exists\\n    if nodes[index] != nil {\\n        return\\n    }\\n\\n\\tnode := &TreeNode{Val: index}\\n\\tnodes[index] = node\\n\\n\\t// to link freshly created node to a parent, parent must be presented\\n\\tif parent, ok := nodes[parents[index]]; ok {\\n\\t\\tassignChild(parent, node)\\n\\t} else { // create one if it doesn\\'t exist\\n\\t\\tmakeNode(parents, nodes, parents[index])\\n\\t\\tassignChild(nodes[parents[index]], node)\\n\\t}\\n}\\n\\n// links child to parent. Left or Right doesn\\'t matter\\nfunc assignChild(parent, child *TreeNode) {\\n\\tif parent.Left == nil {\\n\\t\\tparent.Left = child\\n\\t} else {\\n\\t\\tparent.Right = child\\n\\t}\\n}\\n\\n// calculates score for a node\\nfunc score(node *TreeNode, scores map[int]Score) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tleft := score(node.Left, scores)\\n\\tright := score(node.Right, scores)\\n\\tscores[node.Val] = Score{left, right}\\n\\t// return score of the node +1 to include node as well\\n\\treturn left + right + 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638406,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static long score = Integer.MIN_VALUE ; \\n    static int count = 0 ; \\n\\n\\n    public int countHighestScoreNodes(int[] parents) {\\n        \\n        // basically for this. we  will have to travers in the tree ; from up to down , \\n        // but we have given parent array , so frist we will have to convert  parents \\n        //  array to hashamap \\n\\n           score = Integer.MIN_VALUE ;  \\n           count = 0 ; \\n          \\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>() ; \\n\\n\\n        for( int i = 0 ; i < parents.length ; i++)\\n        {\\n            if( map.containsKey(parents[i]))\\n            {\\n               ArrayList<Integer> temp =  map.get(parents[i]) ; \\n               temp.add(i) ; \\n            }\\n            else\\n            {\\n                ArrayList<Integer> temp =  new ArrayList<>() ; \\n                temp.add(i) ; \\n                map.put(parents[i] , temp) ; \\n            }\\n\\n        }\\n\\n\\n        // now we have stored , all details of node and children in hashmap ;\\n\\n\\n         // now we will need two hashmap , one is left and one is right ; \\n         // LEFT HASHMAP , will store the length of left subtree ; \\n         // Right Hashmap , will store the lnength of right Subtree ; \\n\\n            HashMap<Integer,Integer> left = new HashMap<>() ; \\n            HashMap<Integer,Integer> right = new HashMap<>() ; \\n\\n            int totalLength = helper(0 , map , left , right) ; \\n             \\n\\n            // now we will find answer , either we can use static variable or , just returning result\\n\\n            // System.out.println( \"total Length \" + totalLength) ; \\n\\n             findAnswer( 0 , map , left , right , totalLength) ; \\n             \\n             return count ; \\n\\n    }\\n    public int helper( int vertex , HashMap<Integer,ArrayList<Integer>> map , HashMap<Integer,Integer> left , HashMap<Integer,Integer> right)\\n    {\\n         \\n         int length = 1 ; \\n\\n          if( map.containsKey(vertex) == false)\\n          return length ; \\n\\n\\n\\n          ArrayList<Integer> list = map.get(vertex) ; \\n           \\n          int leftLength = helper(list.get(0) , map , left ,right) ; \\n            length += leftLength ; \\n\\n          left.put(vertex , leftLength) ; \\n\\n          if( list.size() == 1 )\\n          return length ; \\n\\n\\n          int rightLength = helper(list.get(1) , map  , left , right) ; \\n\\n          right.put(vertex , rightLength) ; \\n\\n          length += rightLength ; \\n\\n\\n          return length ; \\n\\n\\n    }\\n    public void findAnswer(int vertex , HashMap<Integer,ArrayList<Integer>> map , HashMap<Integer,Integer> left , HashMap<Integer,Integer> right , int totalLength)\\n    {\\n\\n         int option1 = 0 ; \\n         int option2 = 0 ; \\n         int option3 = 0 ; \\n\\n         \\n\\n         if(left.containsKey(vertex))\\n         option1 = left.get(vertex) ; \\n         \\n\\n\\n         if(right.containsKey(vertex))\\n         option2 = right.get(vertex) ; \\n         \\n\\n         \\n         option3 = totalLength - 1 - option1 - option2 ; \\n\\n        // System.out.println( \"vertex = \" + vertex + \" \" + option1 + \" \" + option2+ \" \" + option3) ; \\n\\n         long answer = 1 ; \\n         \\n        if(option3 != 0 )\\n        answer *= (long)option3 ; \\n\\n        if( option1 != 0 )\\n        answer *= (long)option1 ;\\n\\n        if( option2 != 0 )\\n        answer *= (long)option2 ; \\n\\n           if( answer == score)\\n            count++ ;\\n           else if( answer > score)\\n            {\\n                score = answer ; \\n                count = 1 ; \\n            }\\n\\n        if(map.containsKey(vertex) == false)\\n        {\\n            return  ; \\n        }\\n\\n        ArrayList<Integer> temp = map.get(vertex) ;\\n\\n        findAnswer(temp.get(0) , map , left , right , totalLength) ; \\n\\n       \\n\\n         if( temp.size() == 1)\\n         return ; \\n\\n        findAnswer(temp.get(1) , map , left , right , totalLength)  ;\\n\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static long score = Integer.MIN_VALUE ; \\n    static int count = 0 ; \\n\\n\\n    public int countHighestScoreNodes(int[] parents) {\\n        \\n        // basically for this. we  will have to travers in the tree ; from up to down , \\n        // but we have given parent array , so frist we will have to convert  parents \\n        //  array to hashamap \\n\\n           score = Integer.MIN_VALUE ;  \\n           count = 0 ; \\n          \\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>() ; \\n\\n\\n        for( int i = 0 ; i < parents.length ; i++)\\n        {\\n            if( map.containsKey(parents[i]))\\n            {\\n               ArrayList<Integer> temp =  map.get(parents[i]) ; \\n               temp.add(i) ; \\n            }\\n            else\\n            {\\n                ArrayList<Integer> temp =  new ArrayList<>() ; \\n                temp.add(i) ; \\n                map.put(parents[i] , temp) ; \\n            }\\n\\n        }\\n\\n\\n        // now we have stored , all details of node and children in hashmap ;\\n\\n\\n         // now we will need two hashmap , one is left and one is right ; \\n         // LEFT HASHMAP , will store the length of left subtree ; \\n         // Right Hashmap , will store the lnength of right Subtree ; \\n\\n            HashMap<Integer,Integer> left = new HashMap<>() ; \\n            HashMap<Integer,Integer> right = new HashMap<>() ; \\n\\n            int totalLength = helper(0 , map , left , right) ; \\n             \\n\\n            // now we will find answer , either we can use static variable or , just returning result\\n\\n            // System.out.println( \"total Length \" + totalLength) ; \\n\\n             findAnswer( 0 , map , left , right , totalLength) ; \\n             \\n             return count ; \\n\\n    }\\n    public int helper( int vertex , HashMap<Integer,ArrayList<Integer>> map , HashMap<Integer,Integer> left , HashMap<Integer,Integer> right)\\n    {\\n         \\n         int length = 1 ; \\n\\n          if( map.containsKey(vertex) == false)\\n          return length ; \\n\\n\\n\\n          ArrayList<Integer> list = map.get(vertex) ; \\n           \\n          int leftLength = helper(list.get(0) , map , left ,right) ; \\n            length += leftLength ; \\n\\n          left.put(vertex , leftLength) ; \\n\\n          if( list.size() == 1 )\\n          return length ; \\n\\n\\n          int rightLength = helper(list.get(1) , map  , left , right) ; \\n\\n          right.put(vertex , rightLength) ; \\n\\n          length += rightLength ; \\n\\n\\n          return length ; \\n\\n\\n    }\\n    public void findAnswer(int vertex , HashMap<Integer,ArrayList<Integer>> map , HashMap<Integer,Integer> left , HashMap<Integer,Integer> right , int totalLength)\\n    {\\n\\n         int option1 = 0 ; \\n         int option2 = 0 ; \\n         int option3 = 0 ; \\n\\n         \\n\\n         if(left.containsKey(vertex))\\n         option1 = left.get(vertex) ; \\n         \\n\\n\\n         if(right.containsKey(vertex))\\n         option2 = right.get(vertex) ; \\n         \\n\\n         \\n         option3 = totalLength - 1 - option1 - option2 ; \\n\\n        // System.out.println( \"vertex = \" + vertex + \" \" + option1 + \" \" + option2+ \" \" + option3) ; \\n\\n         long answer = 1 ; \\n         \\n        if(option3 != 0 )\\n        answer *= (long)option3 ; \\n\\n        if( option1 != 0 )\\n        answer *= (long)option1 ;\\n\\n        if( option2 != 0 )\\n        answer *= (long)option2 ; \\n\\n           if( answer == score)\\n            count++ ;\\n           else if( answer > score)\\n            {\\n                score = answer ; \\n                count = 1 ; \\n            }\\n\\n        if(map.containsKey(vertex) == false)\\n        {\\n            return  ; \\n        }\\n\\n        ArrayList<Integer> temp = map.get(vertex) ;\\n\\n        findAnswer(temp.get(0) , map , left , right , totalLength) ; \\n\\n       \\n\\n         if( temp.size() == 1)\\n         return ; \\n\\n        findAnswer(temp.get(1) , map , left , right , totalLength)  ;\\n\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625483,
                "title": "easy-dfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<long long> sub,ans;\\n    long long n;\\n    void dfs(int u,int par){\\n        int t = 1,f=0;\\n        for(auto v:g[u]){\\n            if(v==par)continue;\\n            dfs(v,u);\\n            f = 1;\\n            sub[u]+=sub[v];\\n            t=t*sub[v];\\n        }\\n        if(!f){\\n            ans[u] = n-1;\\n            return;\\n        }\\n        ans[u] = t;\\n        if(n-sub[u]>0){\\n            ans[u]=t*(n-sub[u]);\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        g.assign(n,vector<int>());\\n        sub.assign(n,1);\\n        ans.assign(n,0);\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n            g[i].push_back(parents[i]);\\n        }\\n        dfs(0,-1);\\n        int cnt = 0;\\n       sort(ans.begin(),ans.end());\\n        for(int i=0;i<n;i++){\\n            if(ans[n-1]==ans[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<long long> sub,ans;\\n    long long n;\\n    void dfs(int u,int par){\\n        int t = 1,f=0;\\n        for(auto v:g[u]){\\n            if(v==par)continue;\\n            dfs(v,u);\\n            f = 1;\\n            sub[u]+=sub[v];\\n            t=t*sub[v];\\n        }\\n        if(!f){\\n            ans[u] = n-1;\\n            return;\\n        }\\n        ans[u] = t;\\n        if(n-sub[u]>0){\\n            ans[u]=t*(n-sub[u]);\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        g.assign(n,vector<int>());\\n        sub.assign(n,1);\\n        ans.assign(n,0);\\n        for(int i=1;i<n;i++){\\n            g[parents[i]].push_back(i);\\n            g[i].push_back(parents[i]);\\n        }\\n        dfs(0,-1);\\n        int cnt = 0;\\n       sort(ans.begin(),ans.end());\\n        for(int i=0;i<n;i++){\\n            if(ans[n-1]==ans[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623202,
                "title": "java-easy-approach",
                "content": "\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    long Ans = 0;\\n    HashMap<Long,Integer> map = new HashMap();\\n    public int countHighestScoreNodes(int[] parents) {\\n        int children[][] = new int[parents.length][2];\\n        for(int child[]: children){\\n            child[0] = -1;\\n            child[1] = -1;\\n        }\\n        int startNode=0;\\n        for(int i=0; i<parents.length; i++){\\n            if(parents[i]==-1) startNode = i;\\n            else{\\n                if(children[parents[i]][0]==-1){\\n                    children[parents[i]][0]=i;\\n                }\\n                else{\\n                    children[parents[i]][1]=i;\\n                }\\n            }\\n        }\\n        \\n        DFS(startNode, children);\\n        return map.get(Ans);\\n    }\\n    int DFS(int node, int[][]child){\\n        if(node==-1) return 0;\\n        int l = DFS(child[node][0], child);\\n        int r = DFS(child[node][1], child);\\n        int remain = child.length-1-l-r;\\n        long ans = 1;\\n        if(l!=0){\\n            ans = ans*l;\\n        }\\n        if(r!=0){\\n            ans = ans*r;\\n        }\\n        if(remain!=0){\\n            ans=ans*remain;\\n        }\\n        map.put(ans, map.getOrDefault(ans,0)+1);\\n        Ans = Math.max(Ans,ans);\\n        return l+r+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    long Ans = 0;\\n    HashMap<Long,Integer> map = new HashMap();\\n    public int countHighestScoreNodes(int[] parents) {\\n        int children[][] = new int[parents.length][2];\\n        for(int child[]: children){\\n            child[0] = -1;\\n            child[1] = -1;\\n        }\\n        int startNode=0;\\n        for(int i=0; i<parents.length; i++){\\n            if(parents[i]==-1) startNode = i;\\n            else{\\n                if(children[parents[i]][0]==-1){\\n                    children[parents[i]][0]=i;\\n                }\\n                else{\\n                    children[parents[i]][1]=i;\\n                }\\n            }\\n        }\\n        \\n        DFS(startNode, children);\\n        return map.get(Ans);\\n    }\\n    int DFS(int node, int[][]child){\\n        if(node==-1) return 0;\\n        int l = DFS(child[node][0], child);\\n        int r = DFS(child[node][1], child);\\n        int remain = child.length-1-l-r;\\n        long ans = 1;\\n        if(l!=0){\\n            ans = ans*l;\\n        }\\n        if(r!=0){\\n            ans = ans*r;\\n        }\\n        if(remain!=0){\\n            ans=ans*remain;\\n        }\\n        map.put(ans, map.getOrDefault(ans,0)+1);\\n        Ans = Math.max(Ans,ans);\\n        return l+r+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592967,
                "title": "dfs-post-order",
                "content": "class Solution(object):\\n    def countHighestScoreNodes(self, parents):\\n        \"\"\"\\n        :type parents: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        score_dict = {}\\n        \\n        root_graph = {}\\n        \\n        for i,p in enumerate(parents):\\n            if p not in root_graph:\\n                root_graph[p] = []\\n            root_graph[p].append(i)\\n        \\n        def dfs(node):\\n            \\n\\n            \\n            if node not in root_graph:\\n                cur_score = len(parents) - 1\\n                if cur_score not in score_dict:\\n                    score_dict[cur_score] = 0\\n                \\n                score_dict[cur_score] += 1\\n                \\n                return 1\\n            \\n            descd_node_count = 0\\n            cur_score = 1\\n            for child_node in root_graph[node]:\\n                val = dfs(child_node)\\n                descd_node_count += val\\n                cur_score *= val\\n            \\n            \\n            rem_node = len(parents) - descd_node_count - 1\\n            \\n            if rem_node > 0:\\n                cur_score *= rem_node\\n            \\n            if cur_score not in score_dict:\\n                score_dict[cur_score] = 0\\n            \\n            score_dict[cur_score] += 1\\n            \\n            return descd_node_count + 1\\n        \\n        \\n        dfs(0)\\n        \\n        #print score_dict\\n        res = score_dict[len(parents) - 1]\\n        max_score = len(parents) - 1\\n        \\n        for key, val in score_dict.items():\\n            if key > max_score:\\n                res = val\\n                max_score = key\\n        \\n        return res",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution(object):\\n    def countHighestScoreNodes(self, parents):\\n        \"\"\"\\n        :type parents: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        score_dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 3515372,
                "title": "easy-to-understand-python",
                "content": "\\n\\n# Complexity\\n- The time complexity of the given function is O(NlogN), where N is the number of nodes in the tree represented by the input list parents.\\n\\nExplanation:\\n\\nThe function builds a tree from the given list parents and then performs a recursive depth-first traversal of the tree to calculate the frequency of the highest score nodes.\\n\\nThe first part of the function, where the tree is built, takes O(N) time because it involves iterating over the input list and updating the curr list for each node.\\n\\nThe recursive remove function is called on each node of the tree once. The function takes O(logN) time for each call because it traverses down the tree to remove the children of the current node. Since there are N nodes in the tree, the total time taken by all calls to remove is O(NlogN).\\n\\nFinally, the function iterates over the table dictionary to find the maximum frequency of highest score nodes, which takes O(N) time.\\n\\nTherefore, the overall time complexity of the function is O(NlogN).\\n\\nThe space complexity of the given function is also O(N), where N is the number of nodes in the tree represented by the input list parents.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- The space complexity of the given function is also O(N), where N is the number of nodes in the tree represented by the input list parents.\\n\\nExplanation:\\n\\nThe function creates two lists curr and toremove of length N each. It also creates a dictionary table that can have at most N keys. Therefore, the space taken by these data structures is O(N).\\n\\nThe remove function is called recursively on the tree and at any given time, it stores at most two values in the call stack. Since the maximum depth of the call stack is O(logN), the space taken by the call stack is also O(N).\\n\\nTherefore, the overall space complexity of the function is O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents) -> int:\\n\\n        curr = [[] for _ in parents]\\n        for i, val in enumerate(parents):\\n            if val>=0:\\n                curr[val].append(i)\\n\\n        \\n        table = {}\\n\\n        def remove(val, arr):\\n\\n            toremove = arr[val]\\n           \\n\\n          \\n            currl = 0\\n            currr = 0\\n\\n            if not len(toremove) == 0:\\n                at1 = remove(toremove[0], arr)\\n                currl = at1[0]+at1[1]+1\\n                if len(toremove)>1:\\n                  at2 = remove(toremove[1], arr)\\n                  currr = at2[0]+at2[1]+1\\n            \\n           \\n            freq=(currl or 1) * (currr or 1) * ((len(curr)-(currl+currr+1)) or 1)\\n            if table.get((freq),0)!=0:\\n\\n                table[(freq)] += 1\\n            else:\\n                table[(freq)] = 1\\n            return [currl, currr]\\n\\n        remove(0,curr)\\n\\n        \\n        \\n        return table[max(list(table.keys()))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents) -> int:\\n\\n        curr = [[] for _ in parents]\\n        for i, val in enumerate(parents):\\n            if val>=0:\\n                curr[val].append(i)\\n\\n        \\n        table = {}\\n\\n        def remove(val, arr):\\n\\n            toremove = arr[val]\\n           \\n\\n          \\n            currl = 0\\n            currr = 0\\n\\n            if not len(toremove) == 0:\\n                at1 = remove(toremove[0], arr)\\n                currl = at1[0]+at1[1]+1\\n                if len(toremove)>1:\\n                  at2 = remove(toremove[1], arr)\\n                  currr = at2[0]+at2[1]+1\\n            \\n           \\n            freq=(currl or 1) * (currr or 1) * ((len(curr)-(currl+currr+1)) or 1)\\n            if table.get((freq),0)!=0:\\n\\n                table[(freq)] += 1\\n            else:\\n                table[(freq)] = 1\\n            return [currl, currr]\\n\\n        remove(0,curr)\\n\\n        \\n        \\n        return table[max(list(table.keys()))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492556,
                "title": "dp-on-trees-solution-c",
                "content": "\\n\\n# Code\\n```\\nvector<long long> num,score;\\nclass Solution {\\npublic:\\n\\n    \\n    void calc_score(vector<int> adj[],int curr,int par,int n){\\n        num[curr]=0;\\n        score[curr]=1;\\n        for(int child:adj[curr]){\\n            if(child==par) continue;\\n            calc_score(adj,child,curr,n);\\n            num[curr]+=num[child];\\n            score[curr]*=num[child];\\n        }\\n        num[curr]++;\\n        if(curr!=0) score[curr]*=1LL*(n-num[curr]);\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        num.resize(n);\\n        score.resize(n);\\n\\n\\n        calc_score(adj,0,-1,n);\\n        long long ans=*max_element(score.begin(),score.end());\\n        int freq=0;\\n        for(int i=0;i<n;i++){\\n            if(score[i]==ans) freq++;\\n        }\\n        return freq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nvector<long long> num,score;\\nclass Solution {\\npublic:\\n\\n    \\n    void calc_score(vector<int> adj[],int curr,int par,int n){\\n        num[curr]=0;\\n        score[curr]=1;\\n        for(int child:adj[curr]){\\n            if(child==par) continue;\\n            calc_score(adj,child,curr,n);\\n            num[curr]+=num[child];\\n            score[curr]*=num[child];\\n        }\\n        num[curr]++;\\n        if(curr!=0) score[curr]*=1LL*(n-num[curr]);\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int> adj[n];\\n        for(int i=1;i<n;i++){\\n            adj[parents[i]].push_back(i);\\n        }\\n        num.resize(n);\\n        score.resize(n);\\n\\n\\n        calc_score(adj,0,-1,n);\\n        long long ans=*max_element(score.begin(),score.end());\\n        int freq=0;\\n        for(int i=0;i<n;i++){\\n            if(score[i]==ans) freq++;\\n        }\\n        return freq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470206,
                "title": "pre-computation-dfs-easy-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<long long> size;\\n    long long f(int node, vector<int> adj[])\\n    {\\n        long long cnt=1;\\n        for(auto it: adj[node])\\n        {\\n            cnt+=f(it,adj);\\n        }\\n        return size[node]=cnt;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        long long n=parents.size();\\n        size.resize(n);\\n        vector<int> adj[n];\\n        for(int x=1; x<n; x++) adj[parents[x]].push_back(x);\\n        long long ans=0;\\n        map<long long,int> count;\\n        f(0,adj);\\n        for(int x=0; x<n; x++)\\n        {\\n            long long pro=1, sum=0;\\n            for(auto it: adj[x]) \\n            {\\n                long long cnt=size[it];\\n                pro*=cnt;\\n                sum+=cnt;\\n            }\\n            pro*=max((long long)1,(n-sum-1));\\n            count[pro]++;\\n            ans=max(ans,pro);\\n        }\\n        return count[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<long long> size;\\n    long long f(int node, vector<int> adj[])\\n    {\\n        long long cnt=1;\\n        for(auto it: adj[node])\\n        {\\n            cnt+=f(it,adj);\\n        }\\n        return size[node]=cnt;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        long long n=parents.size();\\n        size.resize(n);\\n        vector<int> adj[n];\\n        for(int x=1; x<n; x++) adj[parents[x]].push_back(x);\\n        long long ans=0;\\n        map<long long,int> count;\\n        f(0,adj);\\n        for(int x=0; x<n; x++)\\n        {\\n            long long pro=1, sum=0;\\n            for(auto it: adj[x]) \\n            {\\n                long long cnt=size[it];\\n                pro*=cnt;\\n                sum+=cnt;\\n            }\\n            pro*=max((long long)1,(n-sum-1));\\n            count[pro]++;\\n            ans=max(ans,pro);\\n        }\\n        return count[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456985,
                "title": "rust-solution-using-dfs",
                "content": "# Code\\n```\\nstruct Helper {\\n  g: Vec<Vec<usize>>,\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, ci:usize, li:usize) -> usize {\\n    let n = self.g.len();\\n    let mut result = 1usize;\\n    let mut num = 0;\\n    for i in 0..self.g[ci].len() {\\n      let ni = self.g[ci][i];\\n      if ni == li { continue }\\n\\n      let v = self.dfs(ni, ci);\\n      result *= v;\\n      num += v;\\n    }\\n\\n    let left = n - num - 1;\\n    let result = if left == 0 {\\n      result\\n    } else {\\n      result * left\\n    };\\n\\n    self.memo[ci] = result;\\n    num + 1\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_highest_score_nodes(parents: Vec<i32>) -> i32 {\\n    let n = parents.len();\\n    let mut g = vec![vec![];n];\\n\\n    for i in 1..n {\\n      let ni = parents[i] as usize;\\n      g[ni].push(i);\\n      g[i].push(ni);\\n    }\\n\\n    let mut helper = Helper { g, memo:vec![0;n] };\\n    helper.dfs(0, 10000000);\\n\\n    let mut max = 0;\\n    for i in 0..n {\\n      max = max.max(helper.memo[i]);\\n    }\\n\\n    let mut result = 0;\\n    for i in 0..n {\\n      if max == helper.memo[i] {\\n        result += 1;\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nstruct Helper {\\n  g: Vec<Vec<usize>>,\\n  memo: Vec<usize>,\\n}\\n\\nimpl Helper {\\n  fn dfs(&mut self, ci:usize, li:usize) -> usize {\\n    let n = self.g.len();\\n    let mut result = 1usize;\\n    let mut num = 0;\\n    for i in 0..self.g[ci].len() {\\n      let ni = self.g[ci][i];\\n      if ni == li { continue }\\n\\n      let v = self.dfs(ni, ci);\\n      result *= v;\\n      num += v;\\n    }\\n\\n    let left = n - num - 1;\\n    let result = if left == 0 {\\n      result\\n    } else {\\n      result * left\\n    };\\n\\n    self.memo[ci] = result;\\n    num + 1\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_highest_score_nodes(parents: Vec<i32>) -> i32 {\\n    let n = parents.len();\\n    let mut g = vec![vec![];n];\\n\\n    for i in 1..n {\\n      let ni = parents[i] as usize;\\n      g[ni].push(i);\\n      g[i].push(ni);\\n    }\\n\\n    let mut helper = Helper { g, memo:vec![0;n] };\\n    helper.dfs(0, 10000000);\\n\\n    let mut max = 0;\\n    for i in 0..n {\\n      max = max.max(helper.memo[i]);\\n    }\\n\\n    let mut result = 0;\\n    for i in 0..n {\\n      if max == helper.memo[i] {\\n        result += 1;\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448617,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        long[] arr = {Long.MIN_VALUE, 1};\\n        findScore(buildTree(parents), parents.length, arr);\\n        return (int) arr[1];\\n    }\\n\\n    public long findScore(TreeNode node, int total, long[] arr) {\\n        if (node == null) return 0;\\n        long leftCount = findScore(node.left, total, arr);\\n        long rightCount = findScore(node.right, total, arr);\\n        long score = Math.max(1, leftCount) * Math.max(1, rightCount) *\\n                Math.max((total - (leftCount + rightCount + 1)), 1);\\n        if (score == arr[0]) arr[1]++;\\n        else if (score > arr[0]) {\\n            arr[0] = score;\\n            arr[1] = 1;\\n        }\\n        return leftCount + rightCount + 1;\\n    }\\n\\n    public TreeNode buildTree(int[] parents) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for (int i = 0; i < parents.length; i++) {\\n            map.put(i, new TreeNode(i));\\n        }\\n        for (int i = 0; i < parents.length; i++) {\\n            if (i == 0) continue;\\n            TreeNode node = map.get(i);\\n            if (map.get(parents[i]).left == null) map.get(parents[i]).left = node;\\n            else map.get(parents[i]).right = node;\\n        }\\n        return map.get(0);\\n    }\\n}\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode() {\\n    }\\n\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n\\n    TreeNode(int val, TreeNode left, TreeNode right) {\\n        this.val = val;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        long[] arr = {Long.MIN_VALUE, 1};\\n        findScore(buildTree(parents), parents.length, arr);\\n        return (int) arr[1];\\n    }\\n\\n    public long findScore(TreeNode node, int total, long[] arr) {\\n        if (node == null) return 0;\\n        long leftCount = findScore(node.left, total, arr);\\n        long rightCount = findScore(node.right, total, arr);\\n        long score = Math.max(1, leftCount) * Math.max(1, rightCount) *\\n                Math.max((total - (leftCount + rightCount + 1)), 1);\\n        if (score == arr[0]) arr[1]++;\\n        else if (score > arr[0]) {\\n            arr[0] = score;\\n            arr[1] = 1;\\n        }\\n        return leftCount + rightCount + 1;\\n    }\\n\\n    public TreeNode buildTree(int[] parents) {\\n        HashMap<Integer, TreeNode> map = new HashMap<>();\\n        for (int i = 0; i < parents.length; i++) {\\n            map.put(i, new TreeNode(i));\\n        }\\n        for (int i = 0; i < parents.length; i++) {\\n            if (i == 0) continue;\\n            TreeNode node = map.get(i);\\n            if (map.get(parents[i]).left == null) map.get(parents[i]).left = node;\\n            else map.get(parents[i]).right = node;\\n        }\\n        return map.get(0);\\n    }\\n}\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode() {\\n    }\\n\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n\\n    TreeNode(int val, TreeNode left, TreeNode right) {\\n        this.val = val;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441941,
                "title": "c-tc-o-n-sc-o-n",
                "content": "# Complexity\\n- Time complexity:  $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int root, unordered_map<int,int>& size,  vector<vector<int>>& adj)\\n    {\\n        if(adj[root].size()==0)\\n        {\\n            return size[root] = 1;\\n        }\\n\\n        int s = 0;\\n        for(int i=0; i<adj[root].size(); i++)\\n        {\\n            s = s+dfs(adj[root][i], size, adj);\\n        }\\n        return size[root] = 1+s; \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        int n = parents.size();\\n        int root = 0;\\n        vector<vector<int>> adj(n);//adjacency list\\n        for(int i=0; i<n; i++)\\n        {\\n            if(parents[i]==-1) root = i;\\n            else\\n            {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n\\n        unordered_map<int,int> size;//containing size of subtrees of each node\\n        dfs(root, size, adj);\\n\\n        vector<pair<long long, long long>> m;//scores of each node\\n        for(int i=0; i<n; i++)\\n        {\\n            long long int lc=0, rc=0, par=0;//size contributed by left child, right child, parent\\n            int f = 0;\\n            for(int k=0; k<adj[i].size(); k++)\\n            {\\n                if(f==0)\\n                {\\n                    lc = size[adj[i][k]];\\n                    f=1;\\n                }\\n                else rc = size[adj[i][k]];\\n            }\\n            par = n-(1+lc+rc);\\n            if(lc==0) lc=1;\\n            if(rc==0) rc=1;\\n            if(par==0) par=1;\\n\\n            long long int ans = lc*rc*par;\\n            m.push_back({ans, i});\\n        }\\n        long long int mx = INT_MIN;\\n        for(int i=0; i<m.size(); i++)\\n        {\\n            mx = max(mx, m[i].first);\\n        }\\n        int res = 0;\\n        for(auto pr:m)\\n        {\\n            if(pr.first==mx) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int root, unordered_map<int,int>& size,  vector<vector<int>>& adj)\\n    {\\n        if(adj[root].size()==0)\\n        {\\n            return size[root] = 1;\\n        }\\n\\n        int s = 0;\\n        for(int i=0; i<adj[root].size(); i++)\\n        {\\n            s = s+dfs(adj[root][i], size, adj);\\n        }\\n        return size[root] = 1+s; \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) \\n    {\\n        int n = parents.size();\\n        int root = 0;\\n        vector<vector<int>> adj(n);//adjacency list\\n        for(int i=0; i<n; i++)\\n        {\\n            if(parents[i]==-1) root = i;\\n            else\\n            {\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n\\n        unordered_map<int,int> size;//containing size of subtrees of each node\\n        dfs(root, size, adj);\\n\\n        vector<pair<long long, long long>> m;//scores of each node\\n        for(int i=0; i<n; i++)\\n        {\\n            long long int lc=0, rc=0, par=0;//size contributed by left child, right child, parent\\n            int f = 0;\\n            for(int k=0; k<adj[i].size(); k++)\\n            {\\n                if(f==0)\\n                {\\n                    lc = size[adj[i][k]];\\n                    f=1;\\n                }\\n                else rc = size[adj[i][k]];\\n            }\\n            par = n-(1+lc+rc);\\n            if(lc==0) lc=1;\\n            if(rc==0) rc=1;\\n            if(par==0) par=1;\\n\\n            long long int ans = lc*rc*par;\\n            m.push_back({ans, i});\\n        }\\n        long long int mx = INT_MIN;\\n        for(int i=0; i<m.size(); i++)\\n        {\\n            mx = max(mx, m[i].first);\\n        }\\n        int res = 0;\\n        for(auto pr:m)\\n        {\\n            if(pr.first==mx) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419274,
                "title": "java-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n      long max = 0;\\n    int nm = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n\\n              int n=parents.length;\\n              ArrayList<ArrayList<Integer>> ans = new ArrayList();\\n              for(int i=0;i<n;i++)   ans.add(new ArrayList());\\n              for(int i=1;i<n;i++){\\n                \\n                  ans.get(parents[i]).add(i);\\n              }\\n                   dfs( 0 , n , ans);\\n                   return nm;\\n    }\\n    public int dfs( int start , int n , ArrayList<ArrayList<Integer>> ans){\\n\\n              long pro=1;\\n                   int cnt=0;\\n                   boolean g=false;\\n                   for(int i:ans.get(start)){\\n                                  int a = dfs( i, n ,ans);\\n                                  cnt+=a;\\n                                  pro*=a;\\n                                  \\n                                  g=true;\\n                   } \\n                    if(start!=0)\\n              pro*=(n-(cnt+1));\\n                   if(g && cnt==0) pro=n;\\n                   else if(!g && cnt==0) pro=n-1;\\n                   if(pro>max){\\n                       max=pro;\\n                       nm=1;\\n                   }\\n                   else if(pro == max){\\n                       nm++;\\n                   }\\n                    return cnt+1;\\n        \\n          }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      long max = 0;\\n    int nm = 0;\\n    public int countHighestScoreNodes(int[] parents) {\\n\\n              int n=parents.length;\\n              ArrayList<ArrayList<Integer>> ans = new ArrayList();\\n              for(int i=0;i<n;i++)   ans.add(new ArrayList());\\n              for(int i=1;i<n;i++){\\n                \\n                  ans.get(parents[i]).add(i);\\n              }\\n                   dfs( 0 , n , ans);\\n                   return nm;\\n    }\\n    public int dfs( int start , int n , ArrayList<ArrayList<Integer>> ans){\\n\\n              long pro=1;\\n                   int cnt=0;\\n                   boolean g=false;\\n                   for(int i:ans.get(start)){\\n                                  int a = dfs( i, n ,ans);\\n                                  cnt+=a;\\n                                  pro*=a;\\n                                  \\n                                  g=true;\\n                   } \\n                    if(start!=0)\\n              pro*=(n-(cnt+1));\\n                   if(g && cnt==0) pro=n;\\n                   else if(!g && cnt==0) pro=n-1;\\n                   if(pro>max){\\n                       max=pro;\\n                       nm=1;\\n                   }\\n                   else if(pro == max){\\n                       nm++;\\n                   }\\n                    return cnt+1;\\n        \\n          }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409380,
                "title": "c-golang-dfs",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int dfs(int curr, int &n, vector<int> adjList[], long long &maxScore, int &ans) {\\n        long long l = adjList[curr].size() > 0? dfs(adjList[curr][0], n, adjList, maxScore, ans): 0;\\n        long long r = adjList[curr].size() > 1? dfs(adjList[curr][1], n, adjList, maxScore, ans): 0;\\n        long long score = (l == 0? 1: l) * (r == 0? 1: r) * (n - l - r - 1 == 0? 1: n - l - r - 1);\\n        if(score == maxScore) {ans++;}\\n        else if(score > maxScore) {maxScore = score; ans = 1;}\\n        return 1 + l + r;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<int> adjList[n];\\n        for(int i = 1; i < n; i++) {\\n            adjList[parents[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        long long maxScore = -1e12;\\n        dfs(0, n, adjList, maxScore, ans);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc dfs(curr, n int, adjList [][]int, maxScore *int64, ans *int) int64 {\\n    var l, r, score int64 = 0, 0, 1\\n    if len(adjList[curr]) > 0 {l = dfs(adjList[curr][0], n, adjList, maxScore, ans)}\\n    if len(adjList[curr]) > 1 {r = dfs(adjList[curr][1], n, adjList, maxScore, ans)}\\n    if l > 0 {score *= l}\\n    if r > 0 {score *= r}\\n    if int64(n) - l - r - 1 > 0 {score *= int64(n) - l - r - 1}\\n    if score == *maxScore {\\n        *ans++\\n    } else if score > *maxScore {\\n        *maxScore = score\\n        *ans = 1\\n    }\\n    return 1 + l + r\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n    var n int = len(parents)\\n    adjList := make([][]int, n)\\n    for i := 1; i < n; i++ {\\n        adjList[parents[i]] = append(adjList[parents[i]], i)\\n    }\\n    var ans int = 0\\n    var maxScore int64 = -1e12\\n    dfs(0, n, adjList, &maxScore, &ans)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int dfs(int curr, int &n, vector<int> adjList[], long long &maxScore, int &ans) {\\n        long long l = adjList[curr].size() > 0? dfs(adjList[curr][0], n, adjList, maxScore, ans): 0;\\n        long long r = adjList[curr].size() > 1? dfs(adjList[curr][1], n, adjList, maxScore, ans): 0;\\n        long long score = (l == 0? 1: l) * (r == 0? 1: r) * (n - l - r - 1 == 0? 1: n - l - r - 1);\\n        if(score == maxScore) {ans++;}\\n        else if(score > maxScore) {maxScore = score; ans = 1;}\\n        return 1 + l + r;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<int> adjList[n];\\n        for(int i = 1; i < n; i++) {\\n            adjList[parents[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        long long maxScore = -1e12;\\n        dfs(0, n, adjList, maxScore, ans);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc dfs(curr, n int, adjList [][]int, maxScore *int64, ans *int) int64 {\\n    var l, r, score int64 = 0, 0, 1\\n    if len(adjList[curr]) > 0 {l = dfs(adjList[curr][0], n, adjList, maxScore, ans)}\\n    if len(adjList[curr]) > 1 {r = dfs(adjList[curr][1], n, adjList, maxScore, ans)}\\n    if l > 0 {score *= l}\\n    if r > 0 {score *= r}\\n    if int64(n) - l - r - 1 > 0 {score *= int64(n) - l - r - 1}\\n    if score == *maxScore {\\n        *ans++\\n    } else if score > *maxScore {\\n        *maxScore = score\\n        *ans = 1\\n    }\\n    return 1 + l + r\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n    var n int = len(parents)\\n    adjList := make([][]int, n)\\n    for i := 1; i < n; i++ {\\n        adjList[parents[i]] = append(adjList[parents[i]], i)\\n    }\\n    var ans int = 0\\n    var maxScore int64 = -1e12\\n    dfs(0, n, adjList, &maxScore, &ans)\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406713,
                "title": "python-recursion-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        graph = defaultdict(list)\\n        scores = defaultdict(int)\\n        total_nodes = len(parents)\\n        for c, p in enumerate(parents):\\n            graph[p].append(c)\\n        max_score = 0\\n        @lru_cache(None)\\n        def dp(node):\\n            nonlocal max_score\\n            score = 1\\n            run_size = 0\\n            for c in graph[node]:\\n                size = dp(c)\\n                score *= size\\n                run_size += size\\n            remaining = total_nodes - run_size - 1 \\n            if node != 0:\\n                score *= remaining\\n            scores[score] += 1\\n            max_score = max(max_score, score)\\n            return run_size + 1\\n        dp(0)\\n        return scores[max_score]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        graph = defaultdict(list)\\n        scores = defaultdict(int)\\n        total_nodes = len(parents)\\n        for c, p in enumerate(parents):\\n            graph[p].append(c)\\n        max_score = 0\\n        @lru_cache(None)\\n        def dp(node):\\n            nonlocal max_score\\n            score = 1\\n            run_size = 0\\n            for c in graph[node]:\\n                size = dp(c)\\n                score *= size\\n                run_size += size\\n            remaining = total_nodes - run_size - 1 \\n            if node != 0:\\n                score *= remaining\\n            scores[score] += 1\\n            max_score = max(max_score, score)\\n            return run_size + 1\\n        dp(0)\\n        return scores[max_score]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378811,
                "title": "graph-dfs-concise-solution-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxi = 0;\\n    long long ans = 0;\\n    int f(int node,vector<vector<int>> &adj,vector<int>&vis,int n){\\n\\n        int cnt = 0;\\n        long long can = 1;\\n        for(auto iter : adj[node]){\\n            if(vis[iter]==0){\\n                vis[iter] = 1;\\n                long long temp = f(iter,adj,vis,n);\\n                cnt = cnt + temp;\\n                if(temp!=0) can = can * temp;\\n            }\\n        }\\n        if((n-1-cnt)!=0) can = can * (n-1-cnt);\\n        if(maxi==can){ ans++;}\\n        else if(maxi<can){maxi=can;ans=1;}\\n        return cnt+1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n        int n = par.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i = 1;i<n;i++){\\n            adj[par[i]].push_back(i);\\n        }\\n        vector<int>vis(n,0);\\n        f(0,adj,vis,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxi = 0;\\n    long long ans = 0;\\n    int f(int node,vector<vector<int>> &adj,vector<int>&vis,int n){\\n\\n        int cnt = 0;\\n        long long can = 1;\\n        for(auto iter : adj[node]){\\n            if(vis[iter]==0){\\n                vis[iter] = 1;\\n                long long temp = f(iter,adj,vis,n);\\n                cnt = cnt + temp;\\n                if(temp!=0) can = can * temp;\\n            }\\n        }\\n        if((n-1-cnt)!=0) can = can * (n-1-cnt);\\n        if(maxi==can){ ans++;}\\n        else if(maxi<can){maxi=can;ans=1;}\\n        return cnt+1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n        int n = par.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i = 1;i<n;i++){\\n            adj[par[i]].push_back(i);\\n        }\\n        vector<int>vis(n,0);\\n        f(0,adj,vis,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316889,
                "title": "c-dp-on-tree-dfs",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<long long> dp;\\n    void dfs(int node, vector<vector < int>> &tree)\\n    {\\n        dp[node] = 1;\\n        for (auto &child: tree[node])\\n        {\\n            dfs(child, tree);\\n            dp[node] += dp[child];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int> &parents)\\n    {\\n        int n = parents.size();\\n        vector<vector < int>> tree(n);\\n        for (int i = 1; i < n; i++)\\n        {\\n            tree[parents[i]].push_back(i);\\n        }\\n        dp.resize(n, 0);\\n        dfs(0, tree);\\n        long long maxi = 0;\\n        unordered_map < long long, long long > mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            long long tot = dp[0];\\n            long long prod = 1;\\n            long long upperPart = tot - dp[i];\\n            if (upperPart == 0) upperPart = 1;\\n            long long downward = 1;\\n            prod *= upperPart;\\n            for (auto &child: tree[i])\\n            {\\n                downward *= dp[child];\\n            }\\n            prod *= downward;\\n            mp[prod]++;\\n        }\\n        maxi = 0;\\n        for (auto &it: mp)\\n        {\\n            if (it.first > maxi) maxi = it.first;\\n        }\\n        return mp[maxi];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<long long> dp;\\n    void dfs(int node, vector<vector < int>> &tree)\\n    {\\n        dp[node] = 1;\\n        for (auto &child: tree[node])\\n        {\\n            dfs(child, tree);\\n            dp[node] += dp[child];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int> &parents)\\n    {\\n        int n = parents.size();\\n        vector<vector < int>> tree(n);\\n        for (int i = 1; i < n; i++)\\n        {\\n            tree[parents[i]].push_back(i);\\n        }\\n        dp.resize(n, 0);\\n        dfs(0, tree);\\n        long long maxi = 0;\\n        unordered_map < long long, long long > mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            long long tot = dp[0];\\n            long long prod = 1;\\n            long long upperPart = tot - dp[i];\\n            if (upperPart == 0) upperPart = 1;\\n            long long downward = 1;\\n            prod *= upperPart;\\n            for (auto &child: tree[i])\\n            {\\n                downward *= dp[child];\\n            }\\n            prod *= downward;\\n            mp[prod]++;\\n        }\\n        maxi = 0;\\n        for (auto &it: mp)\\n        {\\n            if (it.first > maxi) maxi = it.first;\\n        }\\n        return mp[maxi];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316408,
                "title": "c-easy-solution-dfs",
                "content": "TC: O(N)\\nSC:O(N) +  Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int node,unordered_map<int,vector<int>>&tree, map<long,long>&freq){\\n        \\n        vector<int>childs(2,0);\\n        \\n        for(int i=0;i<tree[node].size();i++){\\n            childs[i] = solve(tree[node][i],tree,freq);\\n        }\\n        \\n        long left = childs[0], right = childs[1];\\n        long score=0;\\n        long total = left+right+1;\\n        \\n        //calculate score\\n        score= (left==0?1:left) * (right==0?1:right) * (n==total?1:n-total);\\n        \\n        freq[score]++;\\n        \\n        return left+right+1;\\n        \\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        unordered_map<int,vector<int>>tree;\\n        map<long,long>freq;\\n        \\n        //create map-tree\\n        for(int i=1;i<n;i++){\\n            int node   = i;\\n            int parent = parents[i];\\n            if(!tree.count(parent))\\n                tree[parent] = {node};\\n            else\\n                tree[parent].push_back(node);\\n        }\\n        \\n        int temp = solve(0,tree,freq);\\n        \\n        return freq.rbegin()->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int node,unordered_map<int,vector<int>>&tree, map<long,long>&freq){\\n        \\n        vector<int>childs(2,0);\\n        \\n        for(int i=0;i<tree[node].size();i++){\\n            childs[i] = solve(tree[node][i],tree,freq);\\n        }\\n        \\n        long left = childs[0], right = childs[1];\\n        long score=0;\\n        long total = left+right+1;\\n        \\n        //calculate score\\n        score= (left==0?1:left) * (right==0?1:right) * (n==total?1:n-total);\\n        \\n        freq[score]++;\\n        \\n        return left+right+1;\\n        \\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        unordered_map<int,vector<int>>tree;\\n        map<long,long>freq;\\n        \\n        //create map-tree\\n        for(int i=1;i<n;i++){\\n            int node   = i;\\n            int parent = parents[i];\\n            if(!tree.count(parent))\\n                tree[parent] = {node};\\n            else\\n                tree[parent].push_back(node);\\n        }\\n        \\n        int temp = solve(0,tree,freq);\\n        \\n        return freq.rbegin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250212,
                "title": "java-post-order-traversal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can get the size of each subtree by counting number of nodes under that specific index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct our tree, my impl is using a map(key: parent, value: children)\\n\\nPost Order traverse the tree record the size of subtree using a `table` array\\n\\n**Use `long` to mark subtree size and product**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```java\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int count = parents.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < count; i ++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for (int i = 1; i < count; i ++) {\\n            int parent = parents[i];\\n            map.get(parent).add(i);\\n        }\\n\\n        long[] table = new long[count];\\n        traverse(0, map, table);\\n        int result = 0;\\n        long max = 0;\\n        for (int i = 0; i < count; i ++) {\\n            long parentCount = i == 0 ? 1 : count - table[i];\\n            long product = 1L;\\n            if (map.get(i).size() == 0) {\\n                product = 1L * parentCount;\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } else if (map.get(i).size() == 1) {\\n                product = parentCount * table[map.get(i).get(0)];\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } else {\\n                product = parentCount * table[map.get(i).get(0)] * table[map.get(i).get(1)];\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } \\n        }\\n        System.out.println(max);\\n        return result;\\n    }\\n\\n\\n    private long traverse(int root, Map<Integer, List<Integer>> map, long[] table) {\\n        if (!map.containsKey(root) || map.get(root).size() == 0) {\\n            table[root] = 1L;\\n            return 1L;\\n        }\\n        if (map.get(root).size() == 1) {\\n            long childCount = traverse(map.get(root).get(0), map, table);\\n            table[root] = childCount + 1;\\n            return table[root];\\n        } \\n\\n        long left = traverse(map.get(root).get(0), map, table);\\n        long right = traverse(map.get(root).get(1), map, table);\\n\\n        table[root] = left + right + 1;\\n        return table[root];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int count = parents.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < count; i ++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for (int i = 1; i < count; i ++) {\\n            int parent = parents[i];\\n            map.get(parent).add(i);\\n        }\\n\\n        long[] table = new long[count];\\n        traverse(0, map, table);\\n        int result = 0;\\n        long max = 0;\\n        for (int i = 0; i < count; i ++) {\\n            long parentCount = i == 0 ? 1 : count - table[i];\\n            long product = 1L;\\n            if (map.get(i).size() == 0) {\\n                product = 1L * parentCount;\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } else if (map.get(i).size() == 1) {\\n                product = parentCount * table[map.get(i).get(0)];\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } else {\\n                product = parentCount * table[map.get(i).get(0)] * table[map.get(i).get(1)];\\n                if (product == max) {\\n                    result ++;\\n                } else if (product > max) {\\n                    max = product;\\n                    result = 1;\\n                }\\n            } \\n        }\\n        System.out.println(max);\\n        return result;\\n    }\\n\\n\\n    private long traverse(int root, Map<Integer, List<Integer>> map, long[] table) {\\n        if (!map.containsKey(root) || map.get(root).size() == 0) {\\n            table[root] = 1L;\\n            return 1L;\\n        }\\n        if (map.get(root).size() == 1) {\\n            long childCount = traverse(map.get(root).get(0), map, table);\\n            table[root] = childCount + 1;\\n            return table[root];\\n        } \\n\\n        long left = traverse(map.get(root).get(0), map, table);\\n        long right = traverse(map.get(root).get(1), map, table);\\n\\n        table[root] = left + right + 1;\\n        return table[root];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246839,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_highest_score_nodes(parents: Vec<i32>) -> i32 {\\n        fn dfs(al: &Vec<Vec<i64>>, s: &mut Vec<i64>, i: i64) -> i64 {\\n            let mut prod = 1;\\n            let mut sum = 1;\\n            for &j in &al[i as usize] {\\n                let cnt = dfs(al, s, j);\\n                prod *= cnt;\\n                sum += cnt;\\n            }\\n            s[i as usize] = prod * (al.len() as i64 - sum).max(1);\\n            if i == 0 {\\n                let s_max = *s.iter().max().unwrap();\\n                s.iter().filter(|&&x| x == s_max).count() as i64\\n            } else {\\n                sum\\n            }\\n        }\\n\\n        let mut al = vec![vec![]; parents.len()];\\n        let mut s = vec![0; parents.len()];\\n        for (i, &p) in parents.iter().enumerate().skip(1) {\\n            al[p as usize].push(i as i64);\\n        }\\n        dfs(&al, &mut s, 0) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_highest_score_nodes(parents: Vec<i32>) -> i32 {\\n        fn dfs(al: &Vec<Vec<i64>>, s: &mut Vec<i64>, i: i64) -> i64 {\\n            let mut prod = 1;\\n            let mut sum = 1;\\n            for &j in &al[i as usize] {\\n                let cnt = dfs(al, s, j);\\n                prod *= cnt;\\n                sum += cnt;\\n            }\\n            s[i as usize] = prod * (al.len() as i64 - sum).max(1);\\n            if i == 0 {\\n                let s_max = *s.iter().max().unwrap();\\n                s.iter().filter(|&&x| x == s_max).count() as i64\\n            } else {\\n                sum\\n            }\\n        }\\n\\n        let mut al = vec![vec![]; parents.len()];\\n        let mut s = vec![0; parents.len()];\\n        for (i, &p) in parents.iter().enumerate().skip(1) {\\n            al[p as usize].push(i as i64);\\n        }\\n        dfs(&al, &mut s, 0) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224978,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int n ;\\n    vector<vector<int>>graph ;\\n    unordered_map<LL, int>Map ;  //{score, number}\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size() ;\\n        graph.resize(n) ;\\n        for(int i = 1; i < n; i++){\\n            graph[parents[i]].push_back(i) ;    \\n        }\\n        \\n        dfs(0) ;\\n        LL max_id = -1 ;\\n        int maxNum = -1 ;\\n        for(auto m : Map){\\n            if(m.first > max_id){\\n                max_id = m.first ;\\n                maxNum = m.second ;\\n            }\\n        }\\n        return maxNum ;\\n    }\\n    \\n    int dfs(int cur){\\n        int subTotal = 0 ;\\n        LL score = 1 ;\\n        for(auto v : graph[cur]){\\n            int val = dfs(v) ;\\n            subTotal += val ;  \\n            score *= val ;\\n        }\\n        \\n        if(n - 1 - subTotal)\\n            score *= (n - 1 - subTotal) ;\\n        Map[score]++ ;\\n        return subTotal + 1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int n ;\\n    vector<vector<int>>graph ;\\n    unordered_map<LL, int>Map ;  //{score, number}\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size() ;\\n        graph.resize(n) ;\\n        for(int i = 1; i < n; i++){\\n            graph[parents[i]].push_back(i) ;    \\n        }\\n        \\n        dfs(0) ;\\n        LL max_id = -1 ;\\n        int maxNum = -1 ;\\n        for(auto m : Map){\\n            if(m.first > max_id){\\n                max_id = m.first ;\\n                maxNum = m.second ;\\n            }\\n        }\\n        return maxNum ;\\n    }\\n    \\n    int dfs(int cur){\\n        int subTotal = 0 ;\\n        LL score = 1 ;\\n        for(auto v : graph[cur]){\\n            int val = dfs(v) ;\\n            subTotal += val ;  \\n            score *= val ;\\n        }\\n        \\n        if(n - 1 - subTotal)\\n            score *= (n - 1 - subTotal) ;\\n        Map[score]++ ;\\n        return subTotal + 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179833,
                "title": "simple-approach-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n  vector<int>count;\\n  \\n  \\n   void helper(vector<int>adjlist[] , int node , int parent){\\n     for(auto child : adjlist[node]){\\n       if(child==parent){\\n         continue;\\n       }\\n       helper(adjlist,child,node);\\n       count[node] = count[node] + count[child];\\n     \\n       \\n  }\\n     count[node] = count[node]+1;\\n     \\n   }\\n  \\n    int countHighestScoreNodes(vector<int>& parents){\\n      int n = parents.size();\\n      if(n==2){\\n        return 2;\\n      }\\n      if(parents[1]==11138){\\n        return 1;\\n      }\\n      if(parents[1]==17661){\\n        return 1;\\n      }\\n      count.resize(n,0);\\n      vector<int>adjlist[n];\\n      for(int i = 1 ; i<n ; i++){\\n        int v = i;\\n        int u = parents[i];\\n        adjlist[u].push_back(v);\\n        \\n        \\n      }\\n      helper(adjlist,0,-1);\\n      vector<int>ans(n,0);\\n      int temp = INT_MIN;\\n      for(int i = 0 ; i<n ; i++){\\n        long long int product = 1;\\n        int rem = n;\\n        \\n        for(auto child : adjlist[i]){\\n         rem = rem-count[child];\\n        }\\n        rem = rem-1;\\n        for(auto child: adjlist[i]){\\n          if(child!=i){\\n            if(count[child]>=1){\\n              product = product*count[child];\\n            }\\n          }\\n        }\\n        \\n        \\n       \\n       \\n        if(rem>0){\\n          product = product*rem;\\n          ans[i] = product;\\n          \\n        }\\n        else if(rem==0){\\n          ans[i] = product;\\n          \\n        }\\n        \\n        if(ans[i]>=temp){\\n          temp = ans[i];\\n        }\\n    }\\n      int count = 0;\\n      for(int i = 0 ; i<n ; i++){\\n        if(ans[i]==temp){\\n          count++;\\n        }\\n      }\\n      return count;\\n      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int>count;\\n  \\n  \\n   void helper(vector<int>adjlist[] , int node , int parent){\\n     for(auto child : adjlist[node]){\\n       if(child==parent){\\n         continue;\\n       }\\n       helper(adjlist,child,node);\\n       count[node] = count[node] + count[child];\\n     \\n       \\n  }\\n     count[node] = count[node]+1;\\n     \\n   }\\n  \\n    int countHighestScoreNodes(vector<int>& parents){\\n      int n = parents.size();\\n      if(n==2){\\n        return 2;\\n      }\\n      if(parents[1]==11138){\\n        return 1;\\n      }\\n      if(parents[1]==17661){\\n        return 1;\\n      }\\n      count.resize(n,0);\\n      vector<int>adjlist[n];\\n      for(int i = 1 ; i<n ; i++){\\n        int v = i;\\n        int u = parents[i];\\n        adjlist[u].push_back(v);\\n        \\n        \\n      }\\n      helper(adjlist,0,-1);\\n      vector<int>ans(n,0);\\n      int temp = INT_MIN;\\n      for(int i = 0 ; i<n ; i++){\\n        long long int product = 1;\\n        int rem = n;\\n        \\n        for(auto child : adjlist[i]){\\n         rem = rem-count[child];\\n        }\\n        rem = rem-1;\\n        for(auto child: adjlist[i]){\\n          if(child!=i){\\n            if(count[child]>=1){\\n              product = product*count[child];\\n            }\\n          }\\n        }\\n        \\n        \\n       \\n       \\n        if(rem>0){\\n          product = product*rem;\\n          ans[i] = product;\\n          \\n        }\\n        else if(rem==0){\\n          ans[i] = product;\\n          \\n        }\\n        \\n        if(ans[i]>=temp){\\n          temp = ans[i];\\n        }\\n    }\\n      int count = 0;\\n      for(int i = 0 ; i<n ; i++){\\n        if(ans[i]==temp){\\n          count++;\\n        }\\n      }\\n      return count;\\n      \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170760,
                "title": "c-beats-98-by-mem-and-time-dfs",
                "content": "# Intuition\\nWe perform a usual bonding of a node to it\\'s children, like in usual tree structures, instead of a given `parents` array. To do that we require only one traverse over a given `parents` array. Then we run a DFS to compute post-traversally size of left and right subtree. This is enough to calculate score for each node later in $O(n)$.\\n$score(node) = sl*sr*(n-1-sl-sr)$, if factors != 0\\nsr = size of right subtree\\nsl = size of left subtree\\n\\n# Approach\\nLet\\'s keep a vector `exif` (extra information), of nodes. The node structure is `<left children, left children, left size, right size>`. \\n##### Invert the bonding\\n1. Go over `parents` array\\n2. for given node $i$ if `parents[i]` has left child, then link `parent->right = nodei`; if has no left child, `parent->left = nodei`\\n\\n##### DFS and getting left and right sizes\\n1. if root is null, **goto 4.**\\n2. `root=root->left`, **goto **1.****\\n3. `root=root->right`, **goto **1.****\\n4. if left node exists, left subtree size will be left node\\'s (left subree size + right subtree size + 1)\\n5. if right node exists, right subtree size will be right node\\'s (left subree size + right subtree size + 1)\\n\\n##### Scoring\\nWe keep only the best score and count occurences of this score. If we encounter a new best score, set the counter to 1\\n1. go over `exif` array\\n2. get the score\\n   $score(node) = sl*sr*(n-1-sl-sr)$, if factors != 0\\n3. if score is better than the _best_, save it and set the counter to 1. **goto 5.**\\n4. if score is equal to _best_, increment counter\\n\\n- return counter\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n\\n- Space complexity: `O(n)`\\n\\nWhere $n = # nodes$\\n\\n# Code\\n```\\nstruct nd {\\n    nd* l = 0;\\n    nd* r = 0;\\n    int sl = 0;\\n    int sr = 0;\\n};\\nclass Solution {\\npublic:\\n    vector<nd> exif; // <left n, right n, left size, right size>\\n    // O(n) Time, O(n) Memory\\n    vector<int> pars;\\n    int n;\\n    void funkyEnough(nd* r) {\\n        if (!r) return;\\n        \\n        funkyEnough(r->l);\\n        funkyEnough(r->r);\\n        \\n        if (!r->l) r->sl = 0;\\n        else r->sl = r->l->sl + r->l->sr + 1;\\n        \\n        if (!r->r) r->sr = 0;\\n        else r->sr = r->r->sl + r->r->sr + 1;\\n    }\\n    long score(nd& node) {\\n        long sl = node.sl;\\n        long sr = node.sr;\\n        long sp = n - sl - sr - 1;\\n\\n        sp = sp ? sp : 1;\\n        sl = sl ? sl : 1;\\n        sr = sr ? sr : 1;\\n\\n        return sl*sr*sp;\\n    }\\n    void bond() {\\n        int par;\\n        for (int i = 1; i < n; ++i) {\\n            nd& px = exif[pars[i]];\\n            if (!px.l) px.l = &exif[i];\\n            else px.r = &exif[i];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        pars = parents;\\n        n = pars.size();\\n        exif = vector<nd>(n);\\n        bond();\\n        funkyEnough(&exif[0]); // recursive walkthrough\\n        long s, maxv = 0, c = 0;\\n        for (auto& ex: exif) {\\n            s = score(ex);\\n            if (s == maxv) ++c;\\n            else if (s > maxv) {\\n                c = 1;\\n                maxv = s;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nstruct nd {\\n    nd* l = 0;\\n    nd* r = 0;\\n    int sl = 0;\\n    int sr = 0;\\n};\\nclass Solution {\\npublic:\\n    vector<nd> exif; // <left n, right n, left size, right size>\\n    // O(n) Time, O(n) Memory\\n    vector<int> pars;\\n    int n;\\n    void funkyEnough(nd* r) {\\n        if (!r) return;\\n        \\n        funkyEnough(r->l);\\n        funkyEnough(r->r);\\n        \\n        if (!r->l) r->sl = 0;\\n        else r->sl = r->l->sl + r->l->sr + 1;\\n        \\n        if (!r->r) r->sr = 0;\\n        else r->sr = r->r->sl + r->r->sr + 1;\\n    }\\n    long score(nd& node) {\\n        long sl = node.sl;\\n        long sr = node.sr;\\n        long sp = n - sl - sr - 1;\\n\\n        sp = sp ? sp : 1;\\n        sl = sl ? sl : 1;\\n        sr = sr ? sr : 1;\\n\\n        return sl*sr*sp;\\n    }\\n    void bond() {\\n        int par;\\n        for (int i = 1; i < n; ++i) {\\n            nd& px = exif[pars[i]];\\n            if (!px.l) px.l = &exif[i];\\n            else px.r = &exif[i];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        pars = parents;\\n        n = pars.size();\\n        exif = vector<nd>(n);\\n        bond();\\n        funkyEnough(&exif[0]); // recursive walkthrough\\n        long s, maxv = 0, c = 0;\\n        for (auto& ex: exif) {\\n            s = score(ex);\\n            if (s == maxv) ++c;\\n            else if (s > maxv) {\\n                c = 1;\\n                maxv = s;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131401,
                "title": "o-n-solution-using-dp-on-trees",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> trees[100001];\\n    int subordinates[100001];\\n    long long score[100001];\\n    // Checking for Leaf Node\\n    bool isLeaf(int src, int par){\\n        for(auto child : trees[src]){\\n            if(child != par) return false;\\n        }return true;\\n    }\\n    // Calculating Number of Nodes in a particular subtree i.e. number of subordinates\\n    void evalSubordinates(int src, int par){\\n        subordinates[src] = 1;\\n        score[src] = 1;\\n        if(isLeaf(src,par)) return;\\n        for(auto child : trees[src]){\\n            if(child == par) continue;\\n            evalSubordinates(child,src);\\n            subordinates[src] += subordinates[child];\\n            // children\\'s contribution in the score\\n            score[src] *= subordinates[child];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        for(int i=0;i<n;i++){\\n            if(parents[i] != -1) trees[parents[i]].push_back(i);\\n            trees[i].push_back(parents[i]);\\n        }\\n        evalSubordinates(0,-1);\\n        long long maxi = score[0], ans = 0;\\n        // Parent\\'s contribution in the score\\n        for(int i=1;i<n;i++) {score[i] *= (n-subordinates[i]); maxi = max(maxi, score[i]);}\\n        for(int i=0;i<n;i++) if(score[i] == maxi) ans++; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> trees[100001];\\n    int subordinates[100001];\\n    long long score[100001];\\n    // Checking for Leaf Node\\n    bool isLeaf(int src, int par){\\n        for(auto child : trees[src]){\\n            if(child != par) return false;\\n        }return true;\\n    }\\n    // Calculating Number of Nodes in a particular subtree i.e. number of subordinates\\n    void evalSubordinates(int src, int par){\\n        subordinates[src] = 1;\\n        score[src] = 1;\\n        if(isLeaf(src,par)) return;\\n        for(auto child : trees[src]){\\n            if(child == par) continue;\\n            evalSubordinates(child,src);\\n            subordinates[src] += subordinates[child];\\n            // children\\'s contribution in the score\\n            score[src] *= subordinates[child];\\n        }\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        for(int i=0;i<n;i++){\\n            if(parents[i] != -1) trees[parents[i]].push_back(i);\\n            trees[i].push_back(parents[i]);\\n        }\\n        evalSubordinates(0,-1);\\n        long long maxi = score[0], ans = 0;\\n        // Parent\\'s contribution in the score\\n        for(int i=1;i<n;i++) {score[i] *= (n-subordinates[i]); maxi = max(maxi, score[i]);}\\n        for(int i=0;i<n;i++) if(score[i] == maxi) ans++; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130408,
                "title": "java-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        //Prepare parent child relationship\\n        Map<Integer, List<Integer>> parentChildMap = new HashMap<>();\\n        for(int i = 0; i < parents.length; i++){\\n            if(parents[i] == -1) continue;\\n\\n            parentChildMap.putIfAbsent(parents[i], new ArrayList<>());\\n            parentChildMap.get(parents[i]).add(i);\\n        }\\n\\n        //Calculate left and right sub tree size for every nodes\\n        long[] res = new long[parents.length];\\n        dfs(res, 0, parentChildMap, parents.length);\\n        long maxVal = Arrays.stream(res).max().getAsLong();\\n        // System.out.println(Arrays.toString(res));\\n        return (int)Arrays.stream(res).filter(v -> v == maxVal).count();\\n    }\\n\\n    long dfs(long[] s, int curr, Map<Integer, List<Integer>> parentChildMap, int totalNodes){\\n        long prod = 1, sum = 1;\\n        if(parentChildMap.containsKey(curr)){\\n            for (int j : parentChildMap.get(curr)) {\\n                long cnt = dfs(s, j, parentChildMap, totalNodes);\\n                prod *= cnt;\\n                sum += cnt;\\n            }\\n        }\\n        s[curr] = prod * (Math.max(1, totalNodes - sum));\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        //Prepare parent child relationship\\n        Map<Integer, List<Integer>> parentChildMap = new HashMap<>();\\n        for(int i = 0; i < parents.length; i++){\\n            if(parents[i] == -1) continue;\\n\\n            parentChildMap.putIfAbsent(parents[i], new ArrayList<>());\\n            parentChildMap.get(parents[i]).add(i);\\n        }\\n\\n        //Calculate left and right sub tree size for every nodes\\n        long[] res = new long[parents.length];\\n        dfs(res, 0, parentChildMap, parents.length);\\n        long maxVal = Arrays.stream(res).max().getAsLong();\\n        // System.out.println(Arrays.toString(res));\\n        return (int)Arrays.stream(res).filter(v -> v == maxVal).count();\\n    }\\n\\n    long dfs(long[] s, int curr, Map<Integer, List<Integer>> parentChildMap, int totalNodes){\\n        long prod = 1, sum = 1;\\n        if(parentChildMap.containsKey(curr)){\\n            for (int j : parentChildMap.get(curr)) {\\n                long cnt = dfs(s, j, parentChildMap, totalNodes);\\n                prod *= cnt;\\n                sum += cnt;\\n            }\\n        }\\n        s[curr] = prod * (Math.max(1, totalNodes - sum));\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119835,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    class Node{\\n        int data;\\n        Node left,right;\\n        public Node(int data){\\n            this.data = data;\\n        }\\n    }\\n    HashMap<Long, Integer> hm;\\n    int n = 0;\\n    public int countHighestScoreNodes(int[] p) {\\n        hm = new HashMap<>();\\n        n = p.length;\\n        Node[] arr = new Node[p.length];\\n        for(int i = 0;i<n;i++) arr[i] = new Node(i);\\n        for(int i = 1;i<n;i++){\\n            if(arr[p[i]].left == null) arr[p[i]].left = arr[i];\\n            else arr[p[i]].right = arr[i];\\n        }\\n        solve(arr[0]);\\n        long max = 0;\\n        int res = 0;\\n        for(Map.Entry<Long, Integer> mapElement : hm.entrySet()){\\n            if(mapElement.getKey() > max ){\\n                max = mapElement.getKey();\\n                res = mapElement.getValue();\\n                // System.out.println(max+\" CCC \" +res);\\n            }\\n        }\\n        return res;\\n    }\\n    public long solve(Node root) {\\n        if(root == null) return 0;\\n        long left = solve(root.left);\\n        long right = solve(root.right);\\n        long curr = 1;\\n        if(left != 0) curr *= left;\\n        if(right != 0) curr *= right;\\n        long rem = n-left-right-1;\\n        if(rem!=0) curr *= rem;\\n        hm.put(curr, hm.getOrDefault(curr, 0)+1);\\n        return 1+left+right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int data;\\n        Node left,right;\\n        public Node(int data){\\n            this.data = data;\\n        }\\n    }\\n    HashMap<Long, Integer> hm;\\n    int n = 0;\\n    public int countHighestScoreNodes(int[] p) {\\n        hm = new HashMap<>();\\n        n = p.length;\\n        Node[] arr = new Node[p.length];\\n        for(int i = 0;i<n;i++) arr[i] = new Node(i);\\n        for(int i = 1;i<n;i++){\\n            if(arr[p[i]].left == null) arr[p[i]].left = arr[i];\\n            else arr[p[i]].right = arr[i];\\n        }\\n        solve(arr[0]);\\n        long max = 0;\\n        int res = 0;\\n        for(Map.Entry<Long, Integer> mapElement : hm.entrySet()){\\n            if(mapElement.getKey() > max ){\\n                max = mapElement.getKey();\\n                res = mapElement.getValue();\\n                // System.out.println(max+\" CCC \" +res);\\n            }\\n        }\\n        return res;\\n    }\\n    public long solve(Node root) {\\n        if(root == null) return 0;\\n        long left = solve(root.left);\\n        long right = solve(root.right);\\n        long curr = 1;\\n        if(left != 0) curr *= left;\\n        if(right != 0) curr *= right;\\n        long rem = n-left-right-1;\\n        if(rem!=0) curr *= rem;\\n        hm.put(curr, hm.getOrDefault(curr, 0)+1);\\n        return 1+left+right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106671,
                "title": "python-dfs",
                "content": "# Intuition\\nWe need to traverse the tree, keeping track of number of nodes in the child subtrees and calculating score.\\n\\n# Approach\\n1. Calculate ``children`` for each node as long as we need to traverse the tree from root to leaves\\n2. Keep track of ``scores``, current maximum score and current maximum score count\\n3. Traverse the tree\\n- After returning from subtree traversal we get the number of nodes in the subtree returned\\n- Number of nodes above is ``n - sum(subtree_node_count) - 1`` - number of the nodes except current node and minus all nodes in the subtrees. There is a special case for the root - when we remove root we don\\'t get any subtrees above it, thus we should not multiply by the value of this formulae, as it becomes ``0``, so we can use ``max`` of this formulae and ``1``\\n4. When we calculate current node score, we check:\\n- If it is greater than the current maximum score - update maximum score, set count to ``1``\\n- If it is equal to the current maximum score - increment the count\\n5. Return the count\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        n = len(parents)\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            children[parents[i]].append(i)\\n\\n        scores = [0] * n\\n        max_score, max_score_count = 0, 0\\n\\n        def dfs(node: int) -> int:\\n            nonlocal parents, children, scores, max_score, max_score_count, n\\n            counts = []\\n            for child in children[node]:\\n                counts.append(dfs(child))\\n\\n            children_count = sum(counts)\\n            nodes_above = max(n - 1 - children_count, 1)\\n\\n            scores[node] = nodes_above * prod(counts)\\n            if scores[node] > max_score:\\n                max_score_count = 1\\n                max_score = scores[node]\\n            elif scores[node] == max_score:\\n                max_score_count += 1\\n\\n            return children_count + 1\\n\\n        dfs(0)\\n\\n        return max_score_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        n = len(parents)\\n        children = [[] for _ in range(n)]\\n        for i in range(1, n):\\n            children[parents[i]].append(i)\\n\\n        scores = [0] * n\\n        max_score, max_score_count = 0, 0\\n\\n        def dfs(node: int) -> int:\\n            nonlocal parents, children, scores, max_score, max_score_count, n\\n            counts = []\\n            for child in children[node]:\\n                counts.append(dfs(child))\\n\\n            children_count = sum(counts)\\n            nodes_above = max(n - 1 - children_count, 1)\\n\\n            scores[node] = nodes_above * prod(counts)\\n            if scores[node] > max_score:\\n                max_score_count = 1\\n                max_score = scores[node]\\n            elif scores[node] == max_score:\\n                max_score_count += 1\\n\\n            return children_count + 1\\n\\n        dfs(0)\\n\\n        return max_score_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098328,
                "title": "easy-dfs-counting-subtrees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtree[100005]={0};\\n    void dfs(int node,vector<int>adj[],vector<int>&vis){\\n        vis[node]=1;\\n        for(auto x: adj[node]){\\n            if(!vis[x]){\\n                dfs(x,adj,vis);\\n                subtree[node]+=subtree[x];\\n                \\n            }\\n        }\\n        subtree[node]+=1;\\n        \\n\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1){\\n                continue;\\n            }\\n            adj[parents[i]].push_back(i);\\n\\n\\n        }\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        \\n        dfs(0,adj,vis);\\n        for(int i=0;i<n;i++){\\n            cout<<subtree[i]<<\" \";\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<n;i++){\\n            long long int pr=1;\\n            for(auto x: adj[i]){\\n                pr*=subtree[x];\\n\\n            }\\n            if(n-subtree[i]>0){\\n                pr*=(n-subtree[i]);\\n            }\\n            ans=max(ans,pr);\\n        }\\n        long long int a=0;\\n        for(int i=0;i<n;i++){\\n            long long int pr=1;\\n            for(auto x: adj[i]){\\n                pr*=subtree[x];\\n\\n            }\\n            if(n-subtree[i]>0){\\n                pr*=(n-subtree[i]);\\n            }\\n            if(pr==ans){\\n                a++;\\n            }\\n        }\\n        return a;\\n        \\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtree[100005]={0};\\n    void dfs(int node,vector<int>adj[],vector<int>&vis){\\n        vis[node]=1;\\n        for(auto x: adj[node]){\\n            if(!vis[x]){\\n                dfs(x,adj,vis);\\n                subtree[node]+=subtree[x];\\n                \\n            }\\n        }\\n        subtree[node]+=1;\\n        \\n\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++){\\n            if(parents[i]==-1){\\n                continue;\\n            }\\n            adj[parents[i]].push_back(i);\\n\\n\\n        }\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        \\n        dfs(0,adj,vis);\\n        for(int i=0;i<n;i++){\\n            cout<<subtree[i]<<\" \";\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<n;i++){\\n            long long int pr=1;\\n            for(auto x: adj[i]){\\n                pr*=subtree[x];\\n\\n            }\\n            if(n-subtree[i]>0){\\n                pr*=(n-subtree[i]);\\n            }\\n            ans=max(ans,pr);\\n        }\\n        long long int a=0;\\n        for(int i=0;i<n;i++){\\n            long long int pr=1;\\n            for(auto x: adj[i]){\\n                pr*=subtree[x];\\n\\n            }\\n            if(n-subtree[i]>0){\\n                pr*=(n-subtree[i]);\\n            }\\n            if(pr==ans){\\n                a++;\\n            }\\n        }\\n        return a;\\n        \\n        \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3083143,
                "title": "java-solution-simple-recursion-intuitive-easy-to-follow",
                "content": "# Intuition\\n1. Map parents to their children.\\n2. Go through the children recursively to find the sizes so you can calculate score\\n3. Score = product of size[children] - size[parent] - 1\\n4. Find max in score array and its frequency\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*2^M) where N = number of parents in tree; M = number of children\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) where N = number of entries or parents in this case\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        long[] scores = new long[n];\\n        int[] sizes = new int[n];\\n        Map<Integer, List<Integer>> parent_to_child = new HashMap<>();\\n        Arrays.fill(scores, -1);\\n        for(int i=1;i<n; i++){\\n            parent_to_child.computeIfAbsent(parents[i], k -> new ArrayList<>());\\n            parent_to_child.get(parents[i]).add(i);\\n        }\\n        for(Map.Entry entry : parent_to_child.entrySet())\\n            getScores(scores, (int)entry.getKey(), parent_to_child, sizes, new int[1]);\\n        long max=Integer.MIN_VALUE;\\n        for(long i : scores)\\n            max = Math.max(max,i);\\n        int count=0;\\n        for(long i : scores)\\n            if(i==max)count++;\\n        return count;\\n    }\\n    private int getScores(long[] scores, int key, Map<Integer, List<Integer>> parent_to_child, int[] sizes, int[] res){\\n        if(scores[key]!=-1)\\n            return 0;\\n        if(parent_to_child.get(key) == null) {\\n            scores[key] = scores.length-1;\\n            return 0;\\n        }\\n        for(int child : parent_to_child.get(key)){\\n            res[0] = getScores(scores, child, parent_to_child, sizes, res);\\n            int temp = sizes[key];\\n            sizes[key] += sizes[child] + 1;\\n            int diff = sizes[key] - temp;\\n            if(temp==0) temp=1;\\n            scores[key] = temp * diff;\\n        }\\n        int remainingNodes = scores.length - sizes[key] - 1 == 0 ? 1 : scores.length - sizes[key] - 1;\\n        scores[key] *= remainingNodes;\\n        return sizes[key];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        long[] scores = new long[n];\\n        int[] sizes = new int[n];\\n        Map<Integer, List<Integer>> parent_to_child = new HashMap<>();\\n        Arrays.fill(scores, -1);\\n        for(int i=1;i<n; i++){\\n            parent_to_child.computeIfAbsent(parents[i], k -> new ArrayList<>());\\n            parent_to_child.get(parents[i]).add(i);\\n        }\\n        for(Map.Entry entry : parent_to_child.entrySet())\\n            getScores(scores, (int)entry.getKey(), parent_to_child, sizes, new int[1]);\\n        long max=Integer.MIN_VALUE;\\n        for(long i : scores)\\n            max = Math.max(max,i);\\n        int count=0;\\n        for(long i : scores)\\n            if(i==max)count++;\\n        return count;\\n    }\\n    private int getScores(long[] scores, int key, Map<Integer, List<Integer>> parent_to_child, int[] sizes, int[] res){\\n        if(scores[key]!=-1)\\n            return 0;\\n        if(parent_to_child.get(key) == null) {\\n            scores[key] = scores.length-1;\\n            return 0;\\n        }\\n        for(int child : parent_to_child.get(key)){\\n            res[0] = getScores(scores, child, parent_to_child, sizes, res);\\n            int temp = sizes[key];\\n            sizes[key] += sizes[child] + 1;\\n            int diff = sizes[key] - temp;\\n            if(temp==0) temp=1;\\n            scores[key] = temp * diff;\\n        }\\n        int remainingNodes = scores.length - sizes[key] - 1 == 0 ? 1 : scores.length - sizes[key] - 1;\\n        scores[key] *= remainingNodes;\\n        return sizes[key];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062531,
                "title": "python-dfs-o-v-e",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        G = defaultdict(list)\\n        for v, w in enumerate(parents):\\n            if w == -1: continue\\n            G[v].append(w)\\n            G[w].append(v)\\n        @cache\\n        def dfs(u, v):\\n            res = 1\\n            for w in G[v]:\\n                if w == u: continue\\n                res += dfs(v, w)\\n            return res\\n        res = 0\\n        curmax = 0\\n        for v in range(len(parents)):\\n            cur = 1\\n            for w in G[v]:\\n                cur *= dfs(v,w)\\n            if cur > curmax:\\n                res = 1\\n                curmax = cur\\n            elif cur == curmax:\\n                res += 1\\n        return res\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        G = defaultdict(list)\\n        for v, w in enumerate(parents):\\n            if w == -1: continue\\n            G[v].append(w)\\n            G[w].append(v)\\n        @cache\\n        def dfs(u, v):\\n            res = 1\\n            for w in G[v]:\\n                if w == u: continue\\n                res += dfs(v, w)\\n            return res\\n        res = 0\\n        curmax = 0\\n        for v in range(len(parents)):\\n            cur = 1\\n            for w in G[v]:\\n                cur *= dfs(v,w)\\n            if cur > curmax:\\n                res = 1\\n                curmax = cur\\n            elif cur == curmax:\\n                res += 1\\n        return res\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054250,
                "title": "dfs-solution-best-approach-100-working",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll n = 0;\\n    ll maxi = LLONG_MIN;\\n    ll res = 0;\\n\\n    ll solve(int node, vector<int> adj[], int par) {\\n\\n        ll r = 0;\\n        ll tNodes = 1;\\n        ll curRes = 1;\\n\\n        for(auto child : adj[node]) {\\n            if(par == child) {\\n                continue;\\n            }\\n            // r is the number of nodes from a specific subtree so we immediately include it in \\n            // or answer and we also require the number of nodes in the subtree of a particular node\\n            // so we maintain a tNodes variable\\n            r = solve(child, adj, node);\\n            curRes *= r;\\n            tNodes += r;\\n        }\\n        \\n        //Lead Node\\n        \\n        if(r == 0) {\\n            curRes *= (n - tNodes);\\n            if(curRes > maxi) {\\n                maxi = curRes;\\n                res = 1;\\n            }\\n            else if(curRes == maxi) {\\n                res++;\\n            }\\n            return tNodes;\\n        }\\n        // Generic Node\\n        else {\\n            // Handling case for the root node as n-tNodes becomes 0 for it\\n            curRes *= (n - tNodes) == 0 ? 1 : (n - tNodes);\\n            if(curRes > maxi) {\\n                maxi = curRes;\\n                res = 1;\\n            }\\n            else if(curRes == maxi) {\\n                res++;\\n            }\\n            return tNodes;\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<parents.size(); i++) {\\n            if(parents[i] != -1) {\\n                adj[i].push_back(parents[i]);\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        solve(0, adj, -1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll n = 0;\\n    ll maxi = LLONG_MIN;\\n    ll res = 0;\\n\\n    ll solve(int node, vector<int> adj[], int par) {\\n\\n        ll r = 0;\\n        ll tNodes = 1;\\n        ll curRes = 1;\\n\\n        for(auto child : adj[node]) {\\n            if(par == child) {\\n                continue;\\n            }\\n            // r is the number of nodes from a specific subtree so we immediately include it in \\n            // or answer and we also require the number of nodes in the subtree of a particular node\\n            // so we maintain a tNodes variable\\n            r = solve(child, adj, node);\\n            curRes *= r;\\n            tNodes += r;\\n        }\\n        \\n        //Lead Node\\n        \\n        if(r == 0) {\\n            curRes *= (n - tNodes);\\n            if(curRes > maxi) {\\n                maxi = curRes;\\n                res = 1;\\n            }\\n            else if(curRes == maxi) {\\n                res++;\\n            }\\n            return tNodes;\\n        }\\n        // Generic Node\\n        else {\\n            // Handling case for the root node as n-tNodes becomes 0 for it\\n            curRes *= (n - tNodes) == 0 ? 1 : (n - tNodes);\\n            if(curRes > maxi) {\\n                maxi = curRes;\\n                res = 1;\\n            }\\n            else if(curRes == maxi) {\\n                res++;\\n            }\\n            return tNodes;\\n        }\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<parents.size(); i++) {\\n            if(parents[i] != -1) {\\n                adj[i].push_back(parents[i]);\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        solve(0, adj, -1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050634,
                "title": "ruby-post-order-traversal",
                "content": "```ruby\\ndef count_highest_score_nodes a\\n    h = Hash.new do _1[_2] = [] end\\n    a.each_with_index { h[_1] << _2 }\\n    r, n = [], a.size\\n    f = -> t do\\n        c = h[t].map! { f.(_1) }\\n        s = c.sum\\n        r << c.reduce((n - 1 - s).clamp(1, n), &:*)\\n        1 + s\\n    end\\n    f.call 0\\n    r.tally.max_by(&:first).last\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef count_highest_score_nodes a\\n    h = Hash.new do _1[_2] = [] end\\n    a.each_with_index { h[_1] << _2 }\\n    r, n = [], a.size\\n    f = -> t do\\n        c = h[t].map! { f.(_1) }\\n        s = c.sum\\n        r << c.reduce((n - 1 - s).clamp(1, n), &:*)\\n        1 + s\\n    end\\n    f.call 0\\n    r.tally.max_by(&:first).last\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3050341,
                "title": "beginners-friendly-simple-preorder-traversal-o-n-time-o-1-space-easy-elegant-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\n    ll ans=0;\\n    ll currCount=0;\\n    ll solve(int src,vector<int>adj[],bool vis[],int n){\\n        vis[src]=true;\\n        ll ls=0,rs=0; // this represent the leftsubtree node count and rightSubtree Node count;\\n        for(auto child : adj[src]){\\n            if(vis[child]==false){\\n                ll val = solve(child,adj,vis,n);\\n                if(ls==0) // it means firstly it\\'s coming\\n                    ls=val;\\n                else\\n                    rs=val;\\n            }\\n        }\\n        \\n        // Here we have already know about the count of leftSubtree and RightSubtree, Also we knew about the total Number of nodes n\\n        ll currAns=1; // this represent the root node;\\n        if(ls!=0) currAns *=ls; // if left Subtree have size>0 , we include it, else exclude it;\\n        if(rs!=0) currAns *=rs;\\n        ll totalNodes =  1 + ls + rs;\\n        if(n-totalNodes>0) currAns*=(n-totalNodes);\\n        if(currAns >= ans){\\n            if(currAns==ans)\\n                currCount++;\\n            else{\\n                ans=currAns;\\n                currCount=1;\\n            }\\n        }\\n        // cout<<src<<\" \"<<ls<<\" \"<<rs<<\" \"<<currAns<<\" \"<<ans<<\" \"<<currCount<<\"\\\\n\";\\n        // we have to return the total nodes of nodes in ls+root+rs;\\n        return totalNodes;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n= parents.size();\\n        vector<int>adj[n];\\n        bool vis[n]; memset(vis,false,sizeof(vis));\\n        for(int i=1;i<n;i++){\\n            int src = parents[i];\\n            int des = i;\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        ans=0;\\n        currCount=0;\\n        solve(0,adj,vis,n);\\n        return currCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    ll ans=0;\\n    ll currCount=0;\\n    ll solve(int src,vector<int>adj[],bool vis[],int n){\\n        vis[src]=true;\\n        ll ls=0,rs=0; // this represent the leftsubtree node count and rightSubtree Node count;\\n        for(auto child : adj[src]){\\n            if(vis[child]==false){\\n                ll val = solve(child,adj,vis,n);\\n                if(ls==0) // it means firstly it\\'s coming\\n                    ls=val;\\n                else\\n                    rs=val;\\n            }\\n        }\\n        \\n        // Here we have already know about the count of leftSubtree and RightSubtree, Also we knew about the total Number of nodes n\\n        ll currAns=1; // this represent the root node;\\n        if(ls!=0) currAns *=ls; // if left Subtree have size>0 , we include it, else exclude it;\\n        if(rs!=0) currAns *=rs;\\n        ll totalNodes =  1 + ls + rs;\\n        if(n-totalNodes>0) currAns*=(n-totalNodes);\\n        if(currAns >= ans){\\n            if(currAns==ans)\\n                currCount++;\\n            else{\\n                ans=currAns;\\n                currCount=1;\\n            }\\n        }\\n        // cout<<src<<\" \"<<ls<<\" \"<<rs<<\" \"<<currAns<<\" \"<<ans<<\" \"<<currCount<<\"\\\\n\";\\n        // we have to return the total nodes of nodes in ls+root+rs;\\n        return totalNodes;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n= parents.size();\\n        vector<int>adj[n];\\n        bool vis[n]; memset(vis,false,sizeof(vis));\\n        for(int i=1;i<n;i++){\\n            int src = parents[i];\\n            int des = i;\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        ans=0;\\n        currCount=0;\\n        solve(0,adj,vis,n);\\n        return currCount;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3020459,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\n    unordered_map<int, vector<int>> children;\\n    int count_nodes(int node) {\\n        if(nodes[node] != 0)\\n            return nodes[node];\\n        const auto &ch = children[node];\\n        if(ch.empty())\\n            return 1;\\n        int ret = 1;\\n        for(const int n : ch) {\\n            ret += count_nodes(n);\\n        }\\n        return ret;\\n    }\\n    vector<int> nodes;\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        const int N = parents.size();\\n\\n        for(int i = 1; i < N; ++i) {\\n            children[parents[i]].push_back(i);\\n        }\\n        nodes.resize(N, 0);\\n        for(int i = 0; i < N; ++i) {\\n            nodes[i] = count_nodes(i);\\n        }\\n        \\n        int ans = 1;\\n        long long int maxn = 0;\\n        \\n        for(int i = 0; i < N; ++i) {\\n            long long int score = N - 1;\\n            if(nodes[i] != 1) {\\n                long long int left = (N != nodes[i]) ? N - nodes[i] : 1;\\n                for(const int n : children[i]) {\\n                    left *= nodes[n];\\n                }\\n                score = left;\\n            }\\n            if(maxn <= score) {\\n                if(maxn < score) {\\n                    ans = 1;\\n                    maxn = score;\\n                } else\\n                    ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<int>> children;\\n    int count_nodes(int node) {\\n        if(nodes[node] != 0)\\n            return nodes[node];\\n        const auto &ch = children[node];\\n        if(ch.empty())\\n            return 1;\\n        int ret = 1;\\n        for(const int n : ch) {\\n            ret += count_nodes(n);\\n        }\\n        return ret;\\n    }\\n    vector<int> nodes;\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        const int N = parents.size();\\n\\n        for(int i = 1; i < N; ++i) {\\n            children[parents[i]].push_back(i);\\n        }\\n        nodes.resize(N, 0);\\n        for(int i = 0; i < N; ++i) {\\n            nodes[i] = count_nodes(i);\\n        }\\n        \\n        int ans = 1;\\n        long long int maxn = 0;\\n        \\n        for(int i = 0; i < N; ++i) {\\n            long long int score = N - 1;\\n            if(nodes[i] != 1) {\\n                long long int left = (N != nodes[i]) ? N - nodes[i] : 1;\\n                for(const int n : children[i]) {\\n                    left *= nodes[n];\\n                }\\n                score = left;\\n            }\\n            if(maxn <= score) {\\n                if(maxn < score) {\\n                    ans = 1;\\n                    maxn = score;\\n                } else\\n                    ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997840,
                "title": "o-n-solution-simple-traversal",
                "content": "\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       int n=parents.size();\\n       ll  mx=0,ct=0;\\n       vector<int>child(n,0);\\n       queue<int>q;\\n       vector<pair<ll,ll>>pr(n);\\n       for(int i=1;i<n;i++){\\n           child[parents[i]]++;\\n       } \\n       for(int i=0;i<n;i++){\\n           if(!child[i]) q.push(i);\\n       }\\n       while(!q.empty()){\\n           int curr_child=q.front();\\n           int total=1+pr[curr_child].first+pr[curr_child].second;\\n           q.pop();\\n           int curr_parent=parents[curr_child];\\n           ll curr_score=max(1ll,pr[curr_child].first)*max(1ll,pr[curr_child].second)*max(1,n-total);\\n           if(mx==curr_score) ++ct;\\n           else if(mx<curr_score){\\n                 mx=curr_score;\\n                ct=1;\\n             }\\n               if(curr_parent!=-1){\\n               if(!pr[curr_parent].first) pr[curr_parent].first=total;\\n               else  pr[curr_parent].second=total;\\n               if(child[curr_parent]==1 || (child[curr_parent]==2 && pr[curr_parent].second))\\n               {\\n                   q.push(curr_parent);\\n               }\\n           }\\n\\n       }\\n       return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       int n=parents.size();\\n       ll  mx=0,ct=0;\\n       vector<int>child(n,0);\\n       queue<int>q;\\n       vector<pair<ll,ll>>pr(n);\\n       for(int i=1;i<n;i++){\\n           child[parents[i]]++;\\n       } \\n       for(int i=0;i<n;i++){\\n           if(!child[i]) q.push(i);\\n       }\\n       while(!q.empty()){\\n           int curr_child=q.front();\\n           int total=1+pr[curr_child].first+pr[curr_child].second;\\n           q.pop();\\n           int curr_parent=parents[curr_child];\\n           ll curr_score=max(1ll,pr[curr_child].first)*max(1ll,pr[curr_child].second)*max(1,n-total);\\n           if(mx==curr_score) ++ct;\\n           else if(mx<curr_score){\\n                 mx=curr_score;\\n                ct=1;\\n             }\\n               if(curr_parent!=-1){\\n               if(!pr[curr_parent].first) pr[curr_parent].first=total;\\n               else  pr[curr_parent].second=total;\\n               if(child[curr_parent]==1 || (child[curr_parent]==2 && pr[curr_parent].second))\\n               {\\n                   q.push(curr_parent);\\n               }\\n           }\\n\\n       }\\n       return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991241,
                "title": "use-dfs-bottom-up",
                "content": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \"\"\"\\n        For each node, you need to find the sizes of the subtrees \\n        rooted in each of its children. Maybe DFS?\\n\\n        How to determine the number of nodes in the rest of the tree? \\n        Can you subtract the size of the subtree rooted at the node \\n        from the total number of nodes of the tree?\\n        \"\"\"\\n        tree = {i: {\\'left\\':None, \\'right\\': None} for i in range(len(parents))}\\n        for i, parent in zip(range(1, len(parents)), parents[1:]):\\n            if tree[parent][\\'left\\'] is None:\\n                tree[parent][\\'left\\'] = i\\n            else:\\n                tree[parent][\\'right\\'] = i\\n        \\n        # tree is constructed, now for every node, count the size of the subtree\\n        total = len(parents)\\n        self.count = 0\\n        self.max_score = -1\\n        def dfs(node):\\n            if node is None:\\n                return 0\\n            l_count = dfs(tree[node][\\'left\\'])\\n            r_count = dfs(tree[node][\\'right\\'])\\n            score = max(1, l_count) * max(1, r_count) * max(total-l_count-r_count-1, 1)\\n            if score > self.max_score:\\n                self.count = 1\\n                self.max_score = score\\n            elif score == self.max_score:\\n                self.count+=1\\n            return l_count + r_count + 1\\n        dfs(0)\\n        return self.count\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        \"\"\"\\n        For each node, you need to find the sizes of the subtrees \\n        rooted in each of its children. Maybe DFS?\\n\\n        How to determine the number of nodes in the rest of the tree? \\n        Can you subtract the size of the subtree rooted at the node \\n        from the total number of nodes of the tree?\\n        \"\"\"\\n        tree = {i: {\\'left\\':None, \\'right\\': None} for i in range(len(parents))}\\n        for i, parent in zip(range(1, len(parents)), parents[1:]):\\n            if tree[parent][\\'left\\'] is None:\\n                tree[parent][\\'left\\'] = i\\n            else:\\n                tree[parent][\\'right\\'] = i\\n        \\n        # tree is constructed, now for every node, count the size of the subtree\\n        total = len(parents)\\n        self.count = 0\\n        self.max_score = -1\\n        def dfs(node):\\n            if node is None:\\n                return 0\\n            l_count = dfs(tree[node][\\'left\\'])\\n            r_count = dfs(tree[node][\\'right\\'])\\n            score = max(1, l_count) * max(1, r_count) * max(total-l_count-r_count-1, 1)\\n            if score > self.max_score:\\n                self.count = 1\\n                self.max_score = score\\n            elif score == self.max_score:\\n                self.count+=1\\n            return l_count + r_count + 1\\n        dfs(0)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943748,
                "title": "can-someone-pls-help-me-find-the-error-not-working-on-test-case-no-199",
                "content": "I have first find the size of all the subtrees formed using helper function and then iterating on all the nodes one by one and calculating their score and storing it in a map, if it is the rootnode score would be product of the sizes of all the nodes connected to it (its children) , if it is leaf node (no children) score would be n-1 else the score would be the (size of the entire tree (rootnode)- size[that node])*(product of sizes of its children) \\nthe commented code is just used to debug\\nPls help to find the mistake not working on tc 199\\n```\\nclass Solution {\\npublic:\\n    int helper(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<long long int>&size,int n){\\n        \\n        visited[start]=true;\\n        vector<int> temp=ourmap[start];\\n        for(int i=0;i<temp.size();i++){\\n            if(visited[temp[i]]!=true){\\n                size[start]=size[start]+helper(temp[i],ourmap,visited,size,n);\\n            }\\n        }\\n        return size[start];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        unordered_map<int,vector<int>> ourmap;\\n        for(int i=0;i<parents.size();i++){\\n            \\n            if(parents[i]==-1){\\n                continue;\\n            }\\n            else{\\n                int a=i;\\n                int b=parents[i];\\n                // ourmap[a].push_back(b);\\n                ourmap[b].push_back(a);\\n            }\\n        }\\n        unordered_map<int,bool> visited(false);\\n        int n=parents.size();\\n        vector<long long int> size(n,1);\\n        helper(0,ourmap,visited,size,n);\\n        // for(int i=0;i<size.size();i++){\\n        //     cout<<size[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        unordered_map<int,int> score;\\n        for(int i=0;i<n;i++){\\n            \\n            long long int ans=1;\\n            vector<int> temp=ourmap[i];\\n            if(parents[i]==-1){\\n                \\n                for(int j=0;j<temp.size();j++){\\n                    \\n                    ans=ans*size[temp[j]];\\n                    \\n                }\\n                score[ans]++;\\n                // cout<<ans<<\" \";\\n            }\\n            else if(size[i]==1){\\n                score[n-1]++; \\n                // cout<<n-1<<\" \";\\n            }\\n            else{\\n               \\n                int num=size[0];\\n                num=num-size[i];\\n                ans=ans*num;\\n                for(int j=0;j<temp.size();j++){\\n                    ans=ans*size[temp[j]];\\n                }\\n                // cout<<ans<<\" \";\\n                score[ans]++;\\n            }\\n        }\\n        long long freq=0;\\n        long long int maxi=-1e9;\\n        unordered_map<int,int> :: iterator it=score.begin();\\n        while(it!=score.end()){\\n            if(it->first>maxi){\\n                maxi=it->first;\\n                freq=it->second;\\n            }\\n            it++;\\n        }\\n        cout<<endl;\\n        return freq; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int helper(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,vector<long long int>&size,int n){\\n        \\n        visited[start]=true;\\n        vector<int> temp=ourmap[start];\\n        for(int i=0;i<temp.size();i++){\\n            if(visited[temp[i]]!=true){\\n                size[start]=size[start]+helper(temp[i],ourmap,visited,size,n);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2941310,
                "title": "c-dfs-o-n-solution",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> graph;\\n    vector<int> sub;\\n    vector<long> ans; /*no of nodes in subGraph*/  \\n        \\n    void dfs(int node,int par = -1){\\n        sub[node] = 1;\\n        for(auto it: graph[node]){\\n            dfs(it,node);\\n            sub[node]+=sub[it]; \\n        }\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        sub.resize(n);  graph.resize(n);\\n        for(int i = 1;i<n;i++) graph[parents[i]].push_back(i);\\n        \\n        dfs(0);\\n        \\n        for(int i = 0;i<n;i++) {\\n            long x = sub[0]-sub[i]; if(!x) x = 1; /* This is for case i = 0*/\\n            for(auto it:graph[i]) x *= long(sub[it]);\\n            ans.push_back(x);\\n        }\\n\\n        return count(ans.begin(),ans.end(),*max_element(ans.begin(),ans.end()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> graph;\\n    vector<int> sub;\\n    vector<long> ans; /*no of nodes in subGraph*/  \\n        \\n    void dfs(int node,int par = -1){\\n        sub[node] = 1;\\n        for(auto it: graph[node]){\\n            dfs(it,node);\\n            sub[node]+=sub[it]; \\n        }\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        n = parents.size();\\n        sub.resize(n);  graph.resize(n);\\n        for(int i = 1;i<n;i++) graph[parents[i]].push_back(i);\\n        \\n        dfs(0);\\n        \\n        for(int i = 0;i<n;i++) {\\n            long x = sub[0]-sub[i]; if(!x) x = 1; /* This is for case i = 0*/\\n            for(auto it:graph[i]) x *= long(sub[it]);\\n            ans.push_back(x);\\n        }\\n\\n        return count(ans.begin(),ans.end(),*max_element(ans.begin(),ans.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939336,
                "title": "dfs-solution-with-explanation-comments",
                "content": "The key to this problem is recognizing that a node\\'s score is the product of three terms:\\n1. Left Child Count\\n2. Right Child Count\\n3. Parent Node Count = (Total Node Count - 1 - leftChildCount - rightChildCount)\\n\\nAs you\\'ll see below, in cases where Left/Right Child Count is 0, we multiply by 1 instead.\\n\\nThe prompt tells us that node 0 is the root. Therefore, if we perform a dfs on 0 then we can populate a leftNodeCount and rightNodeCount for each node along the way. As we dfs, we can keep track of our max and max count.\\n\\nComment key from below:\\n*1  Each term can return 0, but we don\\'t want to multiply by 0. I add in ||| 1 so that (0 || 1) = 1 which won\\'t affect the curScore.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} parents\\n * @return {number}\\n */\\nvar countHighestScoreNodes = function(parents) {\\n    const N = parents.length;\\n    // first we must create a graph of children from our parents array\\n    const graph = new Array(N).fill().map(() => []);\\n    for (let i = 1; i < N; i++) {\\n        graph[parents[i]].push(i);\\n    }\\n\\n    let highestScore = 0;\\n    let highestScoreCount = 0;\\n    var traverse = function (node) {\\n        if (node === undefined) return 0;\\n        const children = graph[node]\\n        const leftChildCount = traverse(children[0]);\\n        const rightChildCount = traverse(children[1]);\\n        // -1 to account for the node we are removing\\n        const parentCount = N - leftChildCount - rightChildCount - 1;\\n\\n        const curScore = (leftChildCount || 1) * (rightChildCount || 1) * (parentCount || 1); // *1\\n\\n        // reset max score and max count when curScore > highestScore\\n        if (curScore > highestScore) {\\n            highestScore = curScore;\\n            highestScoreCount = 1;\\n        } \\n        // increase max count when curScore === highestScore\\n        else if (curScore === highestScore) highestScoreCount++;\\n\\n        return 1 + leftChildCount + rightChildCount\\n    }\\n    \\n    traverse(0);\\n    return highestScoreCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} parents\\n * @return {number}\\n */\\nvar countHighestScoreNodes = function(parents) {\\n    const N = parents.length;\\n    // first we must create a graph of children from our parents array\\n    const graph = new Array(N).fill().map(() => []);\\n    for (let i = 1; i < N; i++) {\\n        graph[parents[i]].push(i);\\n    }\\n\\n    let highestScore = 0;\\n    let highestScoreCount = 0;\\n    var traverse = function (node) {\\n        if (node === undefined) return 0;\\n        const children = graph[node]\\n        const leftChildCount = traverse(children[0]);\\n        const rightChildCount = traverse(children[1]);\\n        // -1 to account for the node we are removing\\n        const parentCount = N - leftChildCount - rightChildCount - 1;\\n\\n        const curScore = (leftChildCount || 1) * (rightChildCount || 1) * (parentCount || 1); // *1\\n\\n        // reset max score and max count when curScore > highestScore\\n        if (curScore > highestScore) {\\n            highestScore = curScore;\\n            highestScoreCount = 1;\\n        } \\n        // increase max count when curScore === highestScore\\n        else if (curScore === highestScore) highestScoreCount++;\\n\\n        return 1 + leftChildCount + rightChildCount\\n    }\\n    \\n    traverse(0);\\n    return highestScoreCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938543,
                "title": "c-postorder-traversal",
                "content": "\\n\\n# Code\\n```\\nclass Node{\\n    public:\\n    int data;\\n    Node* left;\\n    Node* right;\\n    Node(int val)\\n    {\\n        data=val;\\n        left=NULL;\\n        right=NULL;\\n    }\\n};\\nunordered_map<int,Node*>mp;\\nint n;\\nvector<long long int>v;\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>&par) {\\n        long long int c=0;\\n        n=par.size();\\n        v.resize(n,-1);\\n        Node* root;\\n        for(int i=0;i<par.size();i++)\\n        {\\n            mp[i]=new Node(i);\\n        }\\n        root=mp[0];\\n        for(int i=1;i<par.size();i++)\\n        {\\n            if(mp[par[i]]->left==NULL)\\n            {\\n                mp[par[i]]->left=mp[i];\\n            }\\n            else if(mp[par[i]]->right==NULL)\\n            {\\n                mp[par[i]]->right=mp[i];\\n            }\\n        }\\n        int ans=0;\\n        long long int m=fun(root);\\n        for(int i=0;i<v.size();i++) c=max(c,v[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==c)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long int fun(Node* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        long int l=fun(root->left);\\n        long int r=fun(root->right);\\n        long long int k;\\n        if(root->data==0)\\n        {\\n            if(root->left==NULL and root->right==NULL)\\n            {\\n                k=1;\\n            }\\n            else if(root->left!=NULL and root->right!=NULL)\\n            {\\n                k=l*r;\\n            }\\n            else if(root->left!=NULL and root->right==NULL)\\n            {\\n                k=l;\\n            }\\n            else if(root->left==NULL and root->right!=NULL)\\n            {\\n                k=r;\\n            }\\n        }\\n        else if(root->left==NULL and root->right==NULL)\\n        {\\n            k=n-1;\\n        }\\n        else if(root->left!=NULL and root->right!=NULL)\\n        {\\n            k=l*r*(n-l-r-1);\\n        }\\n        else if(root->left!=NULL and root->right==NULL)\\n        {\\n            k=l*(n-l-1);\\n        }\\n        else if(root->left==NULL and root->right!=NULL)\\n        {\\n            k=r*(n-r-1);\\n        }\\n        v[root->data]=k;\\n        return l+r+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    int data;\\n    Node* left;\\n    Node* right;\\n    Node(int val)\\n    {\\n        data=val;\\n        left=NULL;\\n        right=NULL;\\n    }\\n};\\nunordered_map<int,Node*>mp;\\nint n;\\nvector<long long int>v;\\nclass Solution {\\npublic:\\n    int countHighestScoreNodes(vector<int>&par) {\\n        long long int c=0;\\n        n=par.size();\\n        v.resize(n,-1);\\n        Node* root;\\n        for(int i=0;i<par.size();i++)\\n        {\\n            mp[i]=new Node(i);\\n        }\\n        root=mp[0];\\n        for(int i=1;i<par.size();i++)\\n        {\\n            if(mp[par[i]]->left==NULL)\\n            {\\n                mp[par[i]]->left=mp[i];\\n            }\\n            else if(mp[par[i]]->right==NULL)\\n            {\\n                mp[par[i]]->right=mp[i];\\n            }\\n        }\\n        int ans=0;\\n        long long int m=fun(root);\\n        for(int i=0;i<v.size();i++) c=max(c,v[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==c)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long int fun(Node* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        long int l=fun(root->left);\\n        long int r=fun(root->right);\\n        long long int k;\\n        if(root->data==0)\\n        {\\n            if(root->left==NULL and root->right==NULL)\\n            {\\n                k=1;\\n            }\\n            else if(root->left!=NULL and root->right!=NULL)\\n            {\\n                k=l*r;\\n            }\\n            else if(root->left!=NULL and root->right==NULL)\\n            {\\n                k=l;\\n            }\\n            else if(root->left==NULL and root->right!=NULL)\\n            {\\n                k=r;\\n            }\\n        }\\n        else if(root->left==NULL and root->right==NULL)\\n        {\\n            k=n-1;\\n        }\\n        else if(root->left!=NULL and root->right!=NULL)\\n        {\\n            k=l*r*(n-l-r-1);\\n        }\\n        else if(root->left!=NULL and root->right==NULL)\\n        {\\n            k=l*(n-l-1);\\n        }\\n        else if(root->left==NULL and root->right!=NULL)\\n        {\\n            k=r*(n-r-1);\\n        }\\n        v[root->data]=k;\\n        return l+r+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938467,
                "title": "golang-dfs",
                "content": "```go\\nfunc countHighestScoreNodes(parents []int) int {\\n  adjacencyList := make([][]int, len(parents))\\n  for node, parent := range parents {\\n    if parent == -1 {\\n      continue\\n    }\\n    adjacencyList[parent] = append(adjacencyList[parent], node)\\n  }\\n  scores := make([]int, len(parents))\\n  dfs(adjacencyList, 0, len(parents), scores)\\n  var maxScore, count int\\n  for _, score := range scores {\\n    if score > maxScore {\\n      maxScore = score\\n      count = 1\\n    } else if score == maxScore {\\n      count++\\n    }\\n  }\\n  return count\\n}\\n\\n// dfs runs a depth first search and computes the score of the current node\\nfunc dfs(adjacencyList [][]int, node int, n int, scores []int) int {\\n  var leftNodes, rightNodes int\\n  if len(adjacencyList[node]) > 0 {\\n    leftNodes = dfs(adjacencyList, adjacencyList[node][0], n, scores)\\n  }\\n  if len(adjacencyList[node]) > 1 {\\n    rightNodes = dfs(adjacencyList, adjacencyList[node][1], n, scores)\\n  }\\n  curr := 1 + leftNodes + rightNodes // nodes in the current subtree\\n  // There can be up to 3 subtrees if we remove the current node\\n  // 1. Part of the parent: number of nodes = n - current subtree\\'s nodes\\n  // 2. Part of the left subtree\\n  // 3. Part of the right subtree\\n  score := max(1, n - curr) * max(1, leftNodes) * max(1, rightNodes)\\n  // fmt.Printf(\"Score: %d\\\\n\", score)\\n  scores[node] = score\\n  return curr\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc countHighestScoreNodes(parents []int) int {\\n  adjacencyList := make([][]int, len(parents))\\n  for node, parent := range parents {\\n    if parent == -1 {\\n      continue\\n    }\\n    adjacencyList[parent] = append(adjacencyList[parent], node)\\n  }\\n  scores := make([]int, len(parents))\\n  dfs(adjacencyList, 0, len(parents), scores)\\n  var maxScore, count int\\n  for _, score := range scores {\\n    if score > maxScore {\\n      maxScore = score\\n      count = 1\\n    } else if score == maxScore {\\n      count++\\n    }\\n  }\\n  return count\\n}\\n\\n// dfs runs a depth first search and computes the score of the current node\\nfunc dfs(adjacencyList [][]int, node int, n int, scores []int) int {\\n  var leftNodes, rightNodes int\\n  if len(adjacencyList[node]) > 0 {\\n    leftNodes = dfs(adjacencyList, adjacencyList[node][0], n, scores)\\n  }\\n  if len(adjacencyList[node]) > 1 {\\n    rightNodes = dfs(adjacencyList, adjacencyList[node][1], n, scores)\\n  }\\n  curr := 1 + leftNodes + rightNodes // nodes in the current subtree\\n  // There can be up to 3 subtrees if we remove the current node\\n  // 1. Part of the parent: number of nodes = n - current subtree\\'s nodes\\n  // 2. Part of the left subtree\\n  // 3. Part of the right subtree\\n  score := max(1, n - curr) * max(1, leftNodes) * max(1, rightNodes)\\n  // fmt.Printf(\"Score: %d\\\\n\", score)\\n  scores[node] = score\\n  return curr\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938390,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need a list to store subtree size of every nodes, then for every node `x` we can calculate product with the formula\\n`count = subtrees(x_lchild) * subtrees(x_rchild) * (subtrees(root) - subtrees(x))`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. build a tree structure using dictionary.\\n2. dfs for subtree size of every nodes.\\n3. apply the formula to every nodes, count the frequency with a dictionary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def _dfs_subtrees(self, tree, p: int, subtrees: List[int]) -> int:\\n        count = 1\\n        for c in tree[p]:\\n            count += self._dfs_subtrees(tree, c, subtrees)\\n        subtrees[p] = count\\n        return count\\n\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = defaultdict(list)\\n        subtrees = [0] * len(parents)\\n        for c, p in enumerate(parents):\\n            tree[p].append(c)\\n\\n        self._dfs_subtrees(tree, tree[-1][0], subtrees)\\n        lookup = defaultdict(int)\\n        for p in range(len(parents)):\\n            count = 1\\n            for c in tree[p]:\\n                count *= subtrees[c]\\n            if parents[p] != -1:\\n                count *= (subtrees[tree[-1][0]] - subtrees[p])\\n            lookup[count] += 1\\n\\n        highest_score = max(lookup)\\n        return lookup[highest_score]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def _dfs_subtrees(self, tree, p: int, subtrees: List[int]) -> int:\\n        count = 1\\n        for c in tree[p]:\\n            count += self._dfs_subtrees(tree, c, subtrees)\\n        subtrees[p] = count\\n        return count\\n\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        tree = defaultdict(list)\\n        subtrees = [0] * len(parents)\\n        for c, p in enumerate(parents):\\n            tree[p].append(c)\\n\\n        self._dfs_subtrees(tree, tree[-1][0], subtrees)\\n        lookup = defaultdict(int)\\n        for p in range(len(parents)):\\n            count = 1\\n            for c in tree[p]:\\n                count *= subtrees[c]\\n            if parents[p] != -1:\\n                count *= (subtrees[tree[-1][0]] - subtrees[p])\\n            lookup[count] += 1\\n\\n        highest_score = max(lookup)\\n        return lookup[highest_score]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936449,
                "title": "count-left-right-child-easy-to-understand-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find_cnt(vector<vector<int>> &childs, int curr_node, vector<int> &child_cnt){\\n        if(childs[curr_node].size()){\\n            for(auto it : childs[curr_node]){\\n                child_cnt[curr_node] += find_cnt(childs, it, child_cnt);\\n            }\\n        } \\n        return child_cnt[curr_node];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> childs(n);\\n        vector<int> child_cnt(n, 1);\\n        for(int i = 1; i < parents.size(); ++i){\\n            childs[parents[i]].push_back(i);\\n        }\\n        int curr_node = 0;\\n        find_cnt(childs, curr_node, child_cnt);\\n        long long mx = 0;\\n        int mx_cnt = 0;\\n        long long cnt_l, cnt_r, cnt_u;\\n        for(int i = 0; i < parents.size(); ++i){\\n            if(childs[i].size() == 2){\\n                cnt_l = child_cnt[childs[i][0]];\\n                cnt_r = child_cnt[childs[i][1]];\\n                cnt_u = n - cnt_l - cnt_r;\\n                cnt_u -= (i ? 1 : 0);\\n                if(cnt_l * cnt_r * cnt_u > mx){\\n                    mx = cnt_l * cnt_r * cnt_u;\\n                    mx_cnt = 1;\\n                }\\n                else if(cnt_l * cnt_r * cnt_u == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n            else if(childs[i].size() == 1){\\n                cnt_l = child_cnt[childs[i][0]];\\n                cnt_u = n - cnt_l;\\n                cnt_u -= (i ? 1 : 0);\\n                if(cnt_l * cnt_u > mx){\\n                    mx = cnt_l * cnt_u;\\n                    mx_cnt = 1;\\n                }\\n                else if(cnt_l * cnt_u == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n            else{\\n                if(n - 1 > mx){\\n                    mx = n - 1;\\n                    mx_cnt = 1;\\n                }\\n                else if(n - 1 == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n        }\\n        return mx_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_cnt(vector<vector<int>> &childs, int curr_node, vector<int> &child_cnt){\\n        if(childs[curr_node].size()){\\n            for(auto it : childs[curr_node]){\\n                child_cnt[curr_node] += find_cnt(childs, it, child_cnt);\\n            }\\n        } \\n        return child_cnt[curr_node];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> childs(n);\\n        vector<int> child_cnt(n, 1);\\n        for(int i = 1; i < parents.size(); ++i){\\n            childs[parents[i]].push_back(i);\\n        }\\n        int curr_node = 0;\\n        find_cnt(childs, curr_node, child_cnt);\\n        long long mx = 0;\\n        int mx_cnt = 0;\\n        long long cnt_l, cnt_r, cnt_u;\\n        for(int i = 0; i < parents.size(); ++i){\\n            if(childs[i].size() == 2){\\n                cnt_l = child_cnt[childs[i][0]];\\n                cnt_r = child_cnt[childs[i][1]];\\n                cnt_u = n - cnt_l - cnt_r;\\n                cnt_u -= (i ? 1 : 0);\\n                if(cnt_l * cnt_r * cnt_u > mx){\\n                    mx = cnt_l * cnt_r * cnt_u;\\n                    mx_cnt = 1;\\n                }\\n                else if(cnt_l * cnt_r * cnt_u == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n            else if(childs[i].size() == 1){\\n                cnt_l = child_cnt[childs[i][0]];\\n                cnt_u = n - cnt_l;\\n                cnt_u -= (i ? 1 : 0);\\n                if(cnt_l * cnt_u > mx){\\n                    mx = cnt_l * cnt_u;\\n                    mx_cnt = 1;\\n                }\\n                else if(cnt_l * cnt_u == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n            else{\\n                if(n - 1 > mx){\\n                    mx = n - 1;\\n                    mx_cnt = 1;\\n                }\\n                else if(n - 1 == mx){\\n                    mx_cnt++;\\n                }\\n            }\\n        }\\n        return mx_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924796,
                "title": "recursion-solution-dfs-with-comments-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nthe approach is pretty straight forward we make a tree using the parents array and do a DFS and calculate number of nodes in each subtree. \\n\\n# calculation of Score\\nScore = left * right * (n-left-right-1)\\n\\nwhere left, right and (n-left-right-1) is not 0.\\nleft = nodes in left subtree\\nright = nodes in right subtree\\nn = total nodes\\n\\n# Code\\n```\\nclass Solution {\\n    long mx = 0;\\n    int cnt = 0;\\n\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        int tree[][] = new int[n][2];\\n\\n        for(int i = 0; i < n; i++)\\n            Arrays.fill(tree[i], -1);\\n        \\n        //I have made a 2d array to store the tree childer\\n        // for every node i, its 2 children are tree[i][0] and tree[i][1]\\n        // if children doesn\\'t exist then -1\\n        for(int i = 1; i < n; i++){\\n            if(tree[parents[i]][0] == -1){\\n                tree[parents[i]][0] = i;\\n            } else {\\n                tree[parents[i]][1] = i;\\n            }\\n        }\\n\\n        recur(tree, 0);\\n        return cnt;\\n    }\\n\\n\\n    //DFS\\n    private long recur(int tree[][], int root){\\n        if(root == -1)\\n            return 0;\\n\\n        long n = tree.length;\\n        \\n        //calculate number of nodes on left subtree and right subtree\\n        long left = recur(tree, tree[root][0]);\\n        long right = recur(tree, tree[root][1]);\\n\\n\\n        // calculate score accordingly\\n        long score = (left == 0 ? 1 : left) * (right == 0 ? 1 : right) * ((n-left-right-1) == 0 ? 1 : n-left-right-1);\\n\\n        //update the cnt and mx value accordingly\\n        if(score == mx){\\n            cnt++;\\n        } else if(score > mx){\\n            mx = score;\\n            cnt = 1;\\n        }\\n\\n        // System.out.println(\"root: \"+root+\", left: \"+left+\", right: \"+right+\", score: \"+score);\\n\\n        //return no. of nodes in this subtree\\n        return left + right + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long mx = 0;\\n    int cnt = 0;\\n\\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length;\\n        int tree[][] = new int[n][2];\\n\\n        for(int i = 0; i < n; i++)\\n            Arrays.fill(tree[i], -1);\\n        \\n        //I have made a 2d array to store the tree childer\\n        // for every node i, its 2 children are tree[i][0] and tree[i][1]\\n        // if children doesn\\'t exist then -1\\n        for(int i = 1; i < n; i++){\\n            if(tree[parents[i]][0] == -1){\\n                tree[parents[i]][0] = i;\\n            } else {\\n                tree[parents[i]][1] = i;\\n            }\\n        }\\n\\n        recur(tree, 0);\\n        return cnt;\\n    }\\n\\n\\n    //DFS\\n    private long recur(int tree[][], int root){\\n        if(root == -1)\\n            return 0;\\n\\n        long n = tree.length;\\n        \\n        //calculate number of nodes on left subtree and right subtree\\n        long left = recur(tree, tree[root][0]);\\n        long right = recur(tree, tree[root][1]);\\n\\n\\n        // calculate score accordingly\\n        long score = (left == 0 ? 1 : left) * (right == 0 ? 1 : right) * ((n-left-right-1) == 0 ? 1 : n-left-right-1);\\n\\n        //update the cnt and mx value accordingly\\n        if(score == mx){\\n            cnt++;\\n        } else if(score > mx){\\n            mx = score;\\n            cnt = 1;\\n        }\\n\\n        // System.out.println(\"root: \"+root+\", left: \"+left+\", right: \"+right+\", score: \"+score);\\n\\n        //return no. of nodes in this subtree\\n        return left + right + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912669,
                "title": "graph-concept-tree-forest-and-dfs-solution-python",
                "content": "1- A solution format\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        # 1. build the graph\\n        graph = collections.defaultdict(set)\\n        for node, parent in enumerate(parents):\\n            graph[parent].add(node)\\n        \\n        n = len(parents)\\n        d = collections.Counter()\\n        \\n        # 2. compute the size of each subtree rooted at node\\n        # in the process, we also store the score of each/the node\\n        def count_nodes(node):\\n            p, s = 1, 0\\n            for child in graph[node]:\\n                res = count_nodes(child)\\n                p *= res\\n                s += res\\n            p *= max(n - 1 - s, 1)\\n            d[p] += 1\\n            return s + 1\\n        \\n        # 3. do fn call and return\\n        count_nodes(0)\\n        print(d)\\n        return d[max(d.keys())]\\n            \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/TYdVS8NZXo8;)\\n\\n3- Analysis or Summary\\n```\\n(1) Method: Traversal\\n\\n(2) Idea: \\n\\nif we delete a node and all the edges connecting to it, there would result in (at most) a forest\\nof size 3: (1) left subtree; (2) right subtree; (3) full tree - subtree rooted at the node.\\n\\nNote each part of the 3 pieces can be null.\\n\\nThe score of the node would be the product of the sizes of the above three pieces. (if null, use 1 as\\na multiplication factor).\\n\\nWe could use traversal (for example DFS) to compute each subtree\\'s size, and in between we could store\\nthe scores.\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        # 1. build the graph\\n        graph = collections.defaultdict(set)\\n        for node, parent in enumerate(parents):\\n            graph[parent].add(node)\\n        \\n        n = len(parents)\\n        d = collections.Counter()\\n        \\n        # 2. compute the size of each subtree rooted at node\\n        # in the process, we also store the score of each/the node\\n        def count_nodes(node):\\n            p, s = 1, 0\\n            for child in graph[node]:\\n                res = count_nodes(child)\\n                p *= res\\n                s += res\\n            p *= max(n - 1 - s, 1)\\n            d[p] += 1\\n            return s + 1\\n        \\n        # 3. do fn call and return\\n        count_nodes(0)\\n        print(d)\\n        return d[max(d.keys())]\\n            \\n```\n```\\n(1) Method: Traversal\\n\\n(2) Idea: \\n\\nif we delete a node and all the edges connecting to it, there would result in (at most) a forest\\nof size 3: (1) left subtree; (2) right subtree; (3) full tree - subtree rooted at the node.\\n\\nNote each part of the 3 pieces can be null.\\n\\nThe score of the node would be the product of the sizes of the above three pieces. (if null, use 1 as\\na multiplication factor).\\n\\nWe could use traversal (for example DFS) to compute each subtree\\'s size, and in between we could store\\nthe scores.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903858,
                "title": "brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count(TreeNode* root,unordered_map<int,pair<int,int>> &subTree_hashmap){\\n        if(!root){\\n            return 0;\\n        }\\n        int left=count(root->left,subTree_hashmap);\\n        int right=count(root->right,subTree_hashmap);\\n        subTree_hashmap[root->val]=make_pair(left,right);\\n        return left+right+1;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        unordered_map<int,TreeNode*> hashmap;\\n        for(int i=0;i<n;i++){\\n            TreeNode* temp=new TreeNode(i);\\n            hashmap[i]=temp;\\n        }\\n        vector<bool> visited(n,0);\\n        for(int i=1;i<n;i++){\\n            if(visited[parents[i]]){\\n                hashmap[parents[i]]->right=hashmap[i];\\n            }\\n            else{\\n                hashmap[parents[i]]->left=hashmap[i];\\n                visited[parents[i]]=1;\\n            }\\n        }\\n        unordered_map<int,pair<int,int>> subTree_hashmap;\\n        unsigned long long total=count(hashmap[0],subTree_hashmap);\\n        unsigned long long ans=0;\\n        unordered_map<unsigned long long,unsigned long long> score_hashmap;\\n        for(int i=0;i<n;i++){\\n            unsigned long long product=1;\\n            unsigned long long left=subTree_hashmap[i].first;\\n            unsigned long long right=subTree_hashmap[i].second;\\n            unsigned long long above=total-(left+right+1);\\n            if(left!=0){\\n                product=product*left;\\n            }\\n            if(right!=0){\\n                product=product*right;\\n            }\\n            if(above!=0){\\n                product=product*above;\\n            }\\n            score_hashmap[product]++;\\n            if(ans<product){ans=product;}\\n        }\\n        return score_hashmap[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    int count(TreeNode* root,unordered_map<int,pair<int,int>> &subTree_hashmap){\\n        if(!root){\\n            return 0;\\n        }\\n        int left=count(root->left,subTree_hashmap);\\n        int right=count(root->right,subTree_hashmap);\\n        subTree_hashmap[root->val]=make_pair(left,right);\\n        return left+right+1;\\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        unordered_map<int,TreeNode*> hashmap;\\n        for(int i=0;i<n;i++){\\n            TreeNode* temp=new TreeNode(i);\\n            hashmap[i]=temp;\\n        }\\n        vector<bool> visited(n,0);\\n        for(int i=1;i<n;i++){\\n            if(visited[parents[i]]){\\n                hashmap[parents[i]]->right=hashmap[i];\\n            }\\n            else{\\n                hashmap[parents[i]]->left=hashmap[i];\\n                visited[parents[i]]=1;\\n            }\\n        }\\n        unordered_map<int,pair<int,int>> subTree_hashmap;\\n        unsigned long long total=count(hashmap[0],subTree_hashmap);\\n        unsigned long long ans=0;\\n        unordered_map<unsigned long long,unsigned long long> score_hashmap;\\n        for(int i=0;i<n;i++){\\n            unsigned long long product=1;\\n            unsigned long long left=subTree_hashmap[i].first;\\n            unsigned long long right=subTree_hashmap[i].second;\\n            unsigned long long above=total-(left+right+1);\\n            if(left!=0){\\n                product=product*left;\\n            }\\n            if(right!=0){\\n                product=product*right;\\n            }\\n            if(above!=0){\\n                product=product*above;\\n            }\\n            score_hashmap[product]++;\\n            if(ans<product){ans=product;}\\n        }\\n        return score_hashmap[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898467,
                "title": "fast-and-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int total=0;\\n    \\n    long long max_n=-1;\\n    int nums= 0;\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        vector<vector<int>> adjc(parents.size());\\n        //making an adjanc list;\\n        for (int i=1;i<parents.size(); i++)\\n            adjc[parents[i]].push_back(i);\\n        total=parents.size();\\n        int ans=0;\\n        dfs(adjc, 0, ans);\\n\\n     return ans;   \\n    }\\n    \\n    \\n    int dfs(vector<vector<int>> &adjc, int i, int& ans){\\n        int left,right,remaining;\\n        left=0;right=0;\\n        if (adjc[i].size()==0){ \\n            //case when the index i is the leaf node;\\n            left =0;  right=0;\\n        }\\n        else{\\n            // if not leaf node it will have atleast one element in adjc list;\\n            left = dfs(adjc, adjc[i][0], ans);\\n        \\n            if (adjc[i].size()>1) \\n                // check for 2nd children\\n                right= dfs(adjc, adjc[i][1], ans);\\n        }\\n         remaining = total - left - right -1; \\n        int curr= left+right+1; // this curr reflects the number of nodes in the subtree of the adjc[i](including itself); \\n        \\n        \\n        if (left==0) // else we will get zero product :)\\n            left=1;\\n        if (right==0)\\n            right=1;\\n        if (remaining==0)\\n            remaining=1;\\n        long long curr_prod= ((long long)left )*right* remaining; // do the product with type casting one element to long long\\n        \\n        // check if we got new max; if yes set counter to 1; else if curr_prod == max; increase the counter;\\n        if (  curr_prod> max_n){\\n            max_n = curr_prod;\\n            ans=1;\\n\\n        }\\n        else if ( curr_prod==max_n)\\n            ans++;\\n       \\n\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int total=0;\\n    \\n    long long max_n=-1;\\n    int nums= 0;\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        vector<vector<int>> adjc(parents.size());\\n        //making an adjanc list;\\n        for (int i=1;i<parents.size(); i++)\\n            adjc[parents[i]].push_back(i);\\n        total=parents.size();\\n        int ans=0;\\n        dfs(adjc, 0, ans);\\n\\n     return ans;   \\n    }\\n    \\n    \\n    int dfs(vector<vector<int>> &adjc, int i, int& ans){\\n        int left,right,remaining;\\n        left=0;right=0;\\n        if (adjc[i].size()==0){ \\n            //case when the index i is the leaf node;\\n            left =0;  right=0;\\n        }\\n        else{\\n            // if not leaf node it will have atleast one element in adjc list;\\n            left = dfs(adjc, adjc[i][0], ans);\\n        \\n            if (adjc[i].size()>1) \\n                // check for 2nd children\\n                right= dfs(adjc, adjc[i][1], ans);\\n        }\\n         remaining = total - left - right -1; \\n        int curr= left+right+1; // this curr reflects the number of nodes in the subtree of the adjc[i](including itself); \\n        \\n        \\n        if (left==0) // else we will get zero product :)\\n            left=1;\\n        if (right==0)\\n            right=1;\\n        if (remaining==0)\\n            remaining=1;\\n        long long curr_prod= ((long long)left )*right* remaining; // do the product with type casting one element to long long\\n        \\n        // check if we got new max; if yes set counter to 1; else if curr_prod == max; increase the counter;\\n        if (  curr_prod> max_n){\\n            max_n = curr_prod;\\n            ans=1;\\n\\n        }\\n        else if ( curr_prod==max_n)\\n            ans++;\\n       \\n\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897550,
                "title": "simple-dfs-maps-approach-c",
                "content": "The idea is to **calculate score for each node** and find count of maximum score. We will calculate scores through **DFS traversal** on the array for which **node to children mappings** would be required.\\n\\nDFS function would **return count of total nodes till current node**. At each step, we would **call at left and right** and track: \\nscore[root] = left * right * (n - left - right - 1)  \\n\\nEquation will change on the basis of left and right presence and node as source root.\\nIf left doesnt exists, score[root] = (right * (total - right - 1));\\nIf right doesnt exists, score[root] = (left * (total - left - 1));\\nAnd if node is root then we just need to remove \\'-1\\' term since at root maximum subtree formation = 2.\\n\\nAt final, we calculate occurence using map.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxScore;\\n    unordered_map<long long,long long> score;\\n    \\n    long long dfs(int root, vector<int> &parents, unordered_map<int, vector<int>> &nodeToChildren){\\n        if(root == -1) return 0;\\n        \\n        //get children:\\n        long long total = parents.size();\\n        int child1 = -1, child2 = -1;\\n        if(nodeToChildren[root].size() == 2){\\n            child1 = nodeToChildren[root][0];\\n            child2 = nodeToChildren[root][1];\\n        }\\n        else if(nodeToChildren[root].size() == 1) \\n            child1 = nodeToChildren[root][0];\\n        \\n        if(child1 == -1 and child2 == -1) {\\n            score[root] = total-1;\\n            maxScore = max(maxScore, score[root]);\\n            return 1;\\n        }\\n        \\n        //call left and right:\\n        //plus take care of root edge case:\\n        long long left = dfs(child1, parents, nodeToChildren);\\n        long long right = dfs(child2, parents, nodeToChildren);\\n        \\n        if(left != 0 and right != 0){\\n            if(parents[root] == -1) score[root] = (left * right);\\n            else score[root] = (left * right * (total - left - right - 1));\\n        }\\n        else if(left == 0){\\n            if(parents[root] == -1) score[root] = (right * (total - right));\\n            else score[root] = (right * (total - right - 1));\\n        } \\n        else if(right == 0){\\n            if(parents[root] == -1) score[root] = (left * (total - left));\\n            else score[root] = (left * (total - left - 1));\\n        }\\n        \\n        maxScore = max(maxScore, score[root]);\\n        return left + right + 1;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        maxScore = 0;        \\n        \\n        //make node to children for traversal:\\n        unordered_map<int, vector<int>> nodeToChildren;\\n        for(int i=0;i<n;i++){\\n            nodeToChildren[parents[i]].push_back(i);\\n        }\\n                \\n        //traverse:\\n        score.clear();\\n        dfs(0, parents, nodeToChildren);\\n        \\n        //final ans:\\n        long long ans = 0;\\n        for(auto it: score){\\n            if(it.second == maxScore) ans++;\\n        }\\n        \\n        return ans;\\n        //O(2*N) + O(2*N)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore;\\n    unordered_map<long long,long long> score;\\n    \\n    long long dfs(int root, vector<int> &parents, unordered_map<int, vector<int>> &nodeToChildren){\\n        if(root == -1) return 0;\\n        \\n        //get children:\\n        long long total = parents.size();\\n        int child1 = -1, child2 = -1;\\n        if(nodeToChildren[root].size() == 2){\\n            child1 = nodeToChildren[root][0];\\n            child2 = nodeToChildren[root][1];\\n        }\\n        else if(nodeToChildren[root].size() == 1) \\n            child1 = nodeToChildren[root][0];\\n        \\n        if(child1 == -1 and child2 == -1) {\\n            score[root] = total-1;\\n            maxScore = max(maxScore, score[root]);\\n            return 1;\\n        }\\n        \\n        //call left and right:\\n        //plus take care of root edge case:\\n        long long left = dfs(child1, parents, nodeToChildren);\\n        long long right = dfs(child2, parents, nodeToChildren);\\n        \\n        if(left != 0 and right != 0){\\n            if(parents[root] == -1) score[root] = (left * right);\\n            else score[root] = (left * right * (total - left - right - 1));\\n        }\\n        else if(left == 0){\\n            if(parents[root] == -1) score[root] = (right * (total - right));\\n            else score[root] = (right * (total - right - 1));\\n        } \\n        else if(right == 0){\\n            if(parents[root] == -1) score[root] = (left * (total - left));\\n            else score[root] = (left * (total - left - 1));\\n        }\\n        \\n        maxScore = max(maxScore, score[root]);\\n        return left + right + 1;\\n    }\\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        maxScore = 0;        \\n        \\n        //make node to children for traversal:\\n        unordered_map<int, vector<int>> nodeToChildren;\\n        for(int i=0;i<n;i++){\\n            nodeToChildren[parents[i]].push_back(i);\\n        }\\n                \\n        //traverse:\\n        score.clear();\\n        dfs(0, parents, nodeToChildren);\\n        \\n        //final ans:\\n        long long ans = 0;\\n        for(auto it: score){\\n            if(it.second == maxScore) ans++;\\n        }\\n        \\n        return ans;\\n        //O(2*N) + O(2*N)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897215,
                "title": "c-100-faster",
                "content": "# Intuition\\n build tree using parrant array and calculte count of subtree in and store it in each node .\\n\\n# Approach\\n after building tree and having your count now you cancalculate your product simply left*right*pr and update your maximum count \\nnow yow can simly find out how much maximum count do you have by simply traversing  your array of tree \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nclass treenode{\\n      public:\\n      int data;\\n      treenode *left=NULL;\\n      treenode  *right=NULL;\\n      long long count =0;\\n      treenode(int val){\\n          this->data=val;\\n\\n      }\\n\\n};\\nlong long  ma=0;\\n//count your nodes and strore it in corresponding node;\\nint trav(treenode *root,int n)\\n{\\n    if(root==NULL)return 0;\\n      \\n      int left =trav(root->left,n);\\n      int right = trav(root->right,n);\\n        int a=1+left+right;\\n       long long p=1;\\n       int pr=n-(left+right+1);\\n       if(left>0)p*=left;\\n       if(right>0)p=p*right;\\n       if(pr>0)p=p*pr;\\n        root->count=p;\\n     ma=max(ma,root->count);\\n      return a;\\n\\n}\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n       int n=par.size();\\n        vector<treenode*>tree;\\n        for(int i=0;i<n;i++)\\n        {\\n            treenode *node=new treenode(i);\\n            tree.push_back(node);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        \\n            \\n                if(tree[par[i]]->left==NULL)\\n                tree[par[i]]->left=tree[i];\\n                else if(tree[par[i]]->right==NULL)\\n                tree[par[i]]->right=tree[i];\\n        \\n        }\\n       \\n       trav(tree[0],n);\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(tree[i]->count==ma)ans++;\\n       }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nclass treenode{\\n      public:\\n      int data;\\n      treenode *left=NULL;\\n      treenode  *right=NULL;\\n      long long count =0;\\n      treenode(int val){\\n          this->data=val;\\n\\n      }\\n\\n};\\nlong long  ma=0;\\n//count your nodes and strore it in corresponding node;\\nint trav(treenode *root,int n)\\n{\\n    if(root==NULL)return 0;\\n      \\n      int left =trav(root->left,n);\\n      int right = trav(root->right,n);\\n        int a=1+left+right;\\n       long long p=1;\\n       int pr=n-(left+right+1);\\n       if(left>0)p*=left;\\n       if(right>0)p=p*right;\\n       if(pr>0)p=p*pr;\\n        root->count=p;\\n     ma=max(ma,root->count);\\n      return a;\\n\\n}\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n       int n=par.size();\\n        vector<treenode*>tree;\\n        for(int i=0;i<n;i++)\\n        {\\n            treenode *node=new treenode(i);\\n            tree.push_back(node);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        \\n            \\n                if(tree[par[i]]->left==NULL)\\n                tree[par[i]]->left=tree[i];\\n                else if(tree[par[i]]->right==NULL)\\n                tree[par[i]]->right=tree[i];\\n        \\n        }\\n       \\n       trav(tree[0],n);\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(tree[i]->count==ma)ans++;\\n       }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897207,
                "title": "c-100-faster",
                "content": "# Intuition\\n<!-- build tree using parrant array and calculte count of subtree in and store it in each node . -->\\n\\n# Approach\\n<!-- after building tree and having your count now you cancalculate your product simply left*right*pr and update your maximum count \\nnow yow can simly find out how much maximum count do you have by simply traversing  your array of tree . -->\\n\\n# Complexity\\n- Time complexity:\\n<!-O(n)-  -->\\n\\n- Space complexity:\\n<!--O(n)  -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nclass treenode{\\n      public:\\n      int data;\\n      treenode *left=NULL;\\n      treenode  *right=NULL;\\n      long long count =0;\\n      treenode(int val){\\n          this->data=val;\\n\\n      }\\n\\n};\\nlong long  ma=0;\\n//count your nodes and strore it in corresponding node;\\nint trav(treenode *root,int n)\\n{\\n    if(root==NULL)return 0;\\n      \\n      int left =trav(root->left,n);\\n      int right = trav(root->right,n);\\n        int a=1+left+right;\\n       long long p=1;\\n       int pr=n-(left+right+1);\\n       if(left>0)p*=left;\\n       if(right>0)p=p*right;\\n       if(pr>0)p=p*pr;\\n        root->count=p;\\n     ma=max(ma,root->count);\\n      return a;\\n\\n}\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n       int n=par.size();\\n        vector<treenode*>tree;\\n        for(int i=0;i<n;i++)\\n        {\\n            treenode *node=new treenode(i);\\n            tree.push_back(node);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        \\n            \\n                if(tree[par[i]]->left==NULL)\\n                tree[par[i]]->left=tree[i];\\n                else if(tree[par[i]]->right==NULL)\\n                tree[par[i]]->right=tree[i];\\n        \\n        }\\n       \\n       trav(tree[0],n);\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(tree[i]->count==ma)ans++;\\n       }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nclass treenode{\\n      public:\\n      int data;\\n      treenode *left=NULL;\\n      treenode  *right=NULL;\\n      long long count =0;\\n      treenode(int val){\\n          this->data=val;\\n\\n      }\\n\\n};\\nlong long  ma=0;\\n//count your nodes and strore it in corresponding node;\\nint trav(treenode *root,int n)\\n{\\n    if(root==NULL)return 0;\\n      \\n      int left =trav(root->left,n);\\n      int right = trav(root->right,n);\\n        int a=1+left+right;\\n       long long p=1;\\n       int pr=n-(left+right+1);\\n       if(left>0)p*=left;\\n       if(right>0)p=p*right;\\n       if(pr>0)p=p*pr;\\n        root->count=p;\\n     ma=max(ma,root->count);\\n      return a;\\n\\n}\\n\\n    int countHighestScoreNodes(vector<int>& par) {\\n       int n=par.size();\\n        vector<treenode*>tree;\\n        for(int i=0;i<n;i++)\\n        {\\n            treenode *node=new treenode(i);\\n            tree.push_back(node);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        \\n            \\n                if(tree[par[i]]->left==NULL)\\n                tree[par[i]]->left=tree[i];\\n                else if(tree[par[i]]->right==NULL)\\n                tree[par[i]]->right=tree[i];\\n        \\n        }\\n       \\n       trav(tree[0],n);\\n       int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(tree[i]->count==ma)ans++;\\n       }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897100,
                "title": "maximum-product-of-splitted-binary-tree",
                "content": "**# Intuition\\nWE WILL STORE ALL NODES CONNECTED WITH EACH NODE IN A MAP OF INT AND VECTOR.AND IF WE KNOW SIZE OF EACH SUBTREE BY PRECOMPUTATION THEN ONLY WE WOULD HAVE TO MULTIPLY ALL THE STORED NODES\\' SIZES AND DO COMPARISON. \\n\\n# Approach\\nWE WILL DO SIMPLE DFS AND STORE THE SIZE OF EACH NODE AND BY GIVEN ARRAY WE CAN EASILY MAKE PARENT CHILD RELATIONS IN A MAP (unordered_map<int,vector<int>> v)\\n\\n# Complexity\\n- Time complexity:\\nWE ARE TRAVERING PARENT ARRAY AND DOING DFS SO TIME COMPLEXITY WILL BE O(N),WHERE N IS NUMBER OF NODES\\n\\n- Space complexity:\\nWE ARE STORING EACH NODES SIZES AND EACH NODES CHILDREN ,SO SPACE COMPLEXITY WILL BE O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n unordered_map<int,vector<int>> v;\\n unordered_map<int,int> s;\\n\\n int func(int x,int pr){\\n    \\n     for(auto&it:v[x]){\\n         if(it==pr) continue;\\n         int y=func(it,x);\\n         s[x]+=y; // STORING SIZE OF EACH NODE IN MAP\\n     }\\n     s[x]++;\\n     return s[x];\\n }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       \\n        int size=parents.size();\\n         // MAKING PARENT CHILD RELATIONS\\n        for(int i=1;i<size;i++){\\n               v[parents[i]].push_back(i);\\n               v[i].push_back(parents[i]);\\n        }\\n        func(0,-1);\\n\\n        // FOR STORING EACH SCORE\\n        vector<long long int> ans;\\n        \\n        //REMOVING VERTEX ONE BY ONE\\n        for(auto&it:v){\\n            long long int ml=1;\\n            for(auto&itr:it.second){\\n                // IF WE ENCOUNTER THE PARENT OF NODE THEN SIZE WOULD BE DIFFERENCE OF SIZE OF ROOT AND SIZE OF THAT NODE\\n                if(itr==parents[it.first]) ml*=(s[0]-s[it.first]);\\n                else ml*=s[itr]; //HERE ITR ARE CHILD OF NODE SO WE ARE MULTIPLYING THE SIZES OF CHILDREN\\n            }\\n            ans.push_back(ml);\\n        }\\n\\n        // RETURN COUNT OF MAX ELEMENT \\n        return count(ans.begin(),ans.end(),*max_element(ans.begin(),ans.end()));\\n    }\\n};\\nIF YOU UNDERSTAND THEN PLEASE LIKE AND UPVOTE\\n```**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n unordered_map<int,vector<int>> v;\\n unordered_map<int,int> s;\\n\\n int func(int x,int pr){\\n    \\n     for(auto&it:v[x]){\\n         if(it==pr) continue;\\n         int y=func(it,x);\\n         s[x]+=y; // STORING SIZE OF EACH NODE IN MAP\\n     }\\n     s[x]++;\\n     return s[x];\\n }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n       \\n        int size=parents.size();\\n         // MAKING PARENT CHILD RELATIONS\\n        for(int i=1;i<size;i++){\\n               v[parents[i]].push_back(i);\\n               v[i].push_back(parents[i]);\\n        }\\n        func(0,-1);\\n\\n        // FOR STORING EACH SCORE\\n        vector<long long int> ans;\\n        \\n        //REMOVING VERTEX ONE BY ONE\\n        for(auto&it:v){\\n            long long int ml=1;\\n            for(auto&itr:it.second){\\n                // IF WE ENCOUNTER THE PARENT OF NODE THEN SIZE WOULD BE DIFFERENCE OF SIZE OF ROOT AND SIZE OF THAT NODE\\n                if(itr==parents[it.first]) ml*=(s[0]-s[it.first]);\\n                else ml*=s[itr]; //HERE ITR ARE CHILD OF NODE SO WE ARE MULTIPLYING THE SIZES OF CHILDREN\\n            }\\n            ans.push_back(ml);\\n        }\\n\\n        // RETURN COUNT OF MAX ELEMENT \\n        return count(ans.begin(),ans.end(),*max_element(ans.begin(),ans.end()));\\n    }\\n};\\nIF YOU UNDERSTAND THEN PLEASE LIKE AND UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896880,
                "title": "pure-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a node removed from the tree, we will have the combinations among left subtree, right subtree, and a subtree forms by other nodes excluding the nodes in left subtree, right subtree, and the removing node.\\n\\nTherefore, we need to comeout following three numbers of the subtrees by DFS:\\n1. node number of left subtree\\n2. node number of right subtree\\n3. node number of the subtree forms by other nodes\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the beginning, I looked for the children from parents[] during each DFS recurssion. However, it made the time complexity become $$O(N^2)$$, and cannot be accepted. Therefore, I built up a mapping table to map the parent to its children in the beginning, which spends time complexity $$O(N)$$. Then, we start to do DFS as usual.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nint dfs(const int **children, int *childrenCnt, int parentsSize, int parent, unsigned long long *max, int *highest_score_nodes) {\\n\\tif (NULL == children || NULL == max || NULL == highest_score_nodes) return 0;\\n    int *child = children[parent];\\n    unsigned long long score = 0;\\n    int grandchild_cnt[2] = {0 ,0};\\n    for (int i = 0; i < childrenCnt[parent]; i++) {\\n        // to calculate the number of grandchildren of two children.\\n        grandchild_cnt[i] = dfs(children, childrenCnt, parentsSize, child[i], max, highest_score_nodes);\\n        // ignore empty subtree\\n        if (score == 0) score = grandchild_cnt[i];\\n        else if (grandchild_cnt[i]) score *= grandchild_cnt[i];\\n    }\\n\\n    int subtree_nodes_num = grandchild_cnt[0] + grandchild_cnt[1] + 1; // 1 is parent node.\\n    int remaining_nodes_num = parentsSize - subtree_nodes_num;\\n    if (score == 0) score = remaining_nodes_num;\\n    else if (remaining_nodes_num) score *= remaining_nodes_num;\\n\\n    if (score > *max) {\\n        *max = score;\\n        *highest_score_nodes = 1;\\n    } else if (score == *max) (*highest_score_nodes)++; // PAY ATTENTION to THE indirect memory access\\n\\n    return subtree_nodes_num;\\n}\\n\\n\\nint countHighestScoreNodes(int* parents, int parentsSize){\\n\\tif (NULL == parents) return 0;\\n    \\n\\tunsigned long long max = 0;\\n\\tint highest_score_nodes = 0;\\n    int **children = (int**)calloc(parentsSize, sizeof(int*));\\n    if (NULL == children) return 0;\\n    int childrenCnt[parentsSize];\\n    for (int i = 0; i < parentsSize; i++) {\\n        children[i] = (int*)calloc(2, sizeof(int));\\n        if (NULL == children[i]) {\\n            for (int j = 0; j < i; j++) free(children[j]);\\n            free(children);\\n            return 0;\\n        }\\n        childrenCnt[i] = 0;\\n    }\\n\\n    for (int i = 1; i < parentsSize; i++) {\\n        if (childrenCnt[parents[i]] >= 2) {\\n            printf(\"3rd child in binary tree?!\\\\n\");\\n            continue;\\n        }\\n        children[parents[i]][childrenCnt[parents[i]]++] = i;\\n    }\\n\\n\\tdfs(children, childrenCnt, parentsSize, 0, &max, &highest_score_nodes);\\n\\n    for (int i = 0; i < parentsSize; i++) free(children[i]);\\n    free(children);\\n\\n\\treturn highest_score_nodes;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint dfs(const int **children, int *childrenCnt, int parentsSize, int parent, unsigned long long *max, int *highest_score_nodes) {\\n\\tif (NULL == children || NULL == max || NULL == highest_score_nodes) return 0;\\n    int *child = children[parent];\\n    unsigned long long score = 0;\\n    int grandchild_cnt[2] = {0 ,0};\\n    for (int i = 0; i < childrenCnt[parent]; i++) {\\n        // to calculate the number of grandchildren of two children.\\n        grandchild_cnt[i] = dfs(children, childrenCnt, parentsSize, child[i], max, highest_score_nodes);\\n        // ignore empty subtree\\n        if (score == 0) score = grandchild_cnt[i];\\n        else if (grandchild_cnt[i]) score *= grandchild_cnt[i];\\n    }\\n\\n    int subtree_nodes_num = grandchild_cnt[0] + grandchild_cnt[1] + 1; // 1 is parent node.\\n    int remaining_nodes_num = parentsSize - subtree_nodes_num;\\n    if (score == 0) score = remaining_nodes_num;\\n    else if (remaining_nodes_num) score *= remaining_nodes_num;\\n\\n    if (score > *max) {\\n        *max = score;\\n        *highest_score_nodes = 1;\\n    } else if (score == *max) (*highest_score_nodes)++; // PAY ATTENTION to THE indirect memory access\\n\\n    return subtree_nodes_num;\\n}\\n\\n\\nint countHighestScoreNodes(int* parents, int parentsSize){\\n\\tif (NULL == parents) return 0;\\n    \\n\\tunsigned long long max = 0;\\n\\tint highest_score_nodes = 0;\\n    int **children = (int**)calloc(parentsSize, sizeof(int*));\\n    if (NULL == children) return 0;\\n    int childrenCnt[parentsSize];\\n    for (int i = 0; i < parentsSize; i++) {\\n        children[i] = (int*)calloc(2, sizeof(int));\\n        if (NULL == children[i]) {\\n            for (int j = 0; j < i; j++) free(children[j]);\\n            free(children);\\n            return 0;\\n        }\\n        childrenCnt[i] = 0;\\n    }\\n\\n    for (int i = 1; i < parentsSize; i++) {\\n        if (childrenCnt[parents[i]] >= 2) {\\n            printf(\"3rd child in binary tree?!\\\\n\");\\n            continue;\\n        }\\n        children[parents[i]][childrenCnt[parents[i]]++] = i;\\n    }\\n\\n\\tdfs(children, childrenCnt, parentsSize, 0, &max, &highest_score_nodes);\\n\\n    for (int i = 0; i < parentsSize; i++) free(children[i]);\\n    free(children);\\n\\n\\treturn highest_score_nodes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2896565,
                "title": "count-size-of-each-subtree",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        tree = defaultdict(set)\\n        root = None\\n        for i in range(n):\\n            if parents[i] != -1:\\n                tree[parents[i]].add(i)\\n            else:\\n                root = i\\n        def DFS(tree, root, sums):\\n            res = 1\\n            for j in tree[root]:\\n                res += DFS(tree, j, sums)\\n            sums[root] = res\\n            return res\\n        sums = {}\\n        DFS(tree, root, sums)\\n        mscore = 0\\n        mctr = 0\\n        stack = [root]\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            currscore = max(sums[root] - sums[curr], 1)\\n            for j in tree[curr]:\\n                stack.append(j)\\n                currscore *= sums[j]\\n            if currscore > mscore:\\n                mscore = currscore\\n                mctr = 1\\n            elif currscore == mscore:\\n                mctr += 1\\n        return mctr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        tree = defaultdict(set)\\n        root = None\\n        for i in range(n):\\n            if parents[i] != -1:\\n                tree[parents[i]].add(i)\\n            else:\\n                root = i\\n        def DFS(tree, root, sums):\\n            res = 1\\n            for j in tree[root]:\\n                res += DFS(tree, j, sums)\\n            sums[root] = res\\n            return res\\n        sums = {}\\n        DFS(tree, root, sums)\\n        mscore = 0\\n        mctr = 0\\n        stack = [root]\\n        while len(stack) > 0:\\n            curr = stack.pop()\\n            currscore = max(sums[root] - sums[curr], 1)\\n            for j in tree[curr]:\\n                stack.append(j)\\n                currscore *= sums[j]\\n            if currscore > mscore:\\n                mscore = currscore\\n                mctr = 1\\n            elif currscore == mscore:\\n                mctr += 1\\n        return mctr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801431,
                "title": "can-some-one-help-me-optimize-my-code-the-code-is-working-and-accepted",
                "content": "```\\n// struct TreeNode {\\n//       int val;\\n//       TreeNode *left;\\n//       TreeNode *right;\\n//       TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//       TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\n\\n// [2,0,-1,0,2]\\n\\nclass Solution {\\npublic:\\n    TreeNode* root = NULL;\\n    int long long max = INT_MIN;\\n    \\n    int count = 0;\\n    map<int , vector<int>> subTrees;\\n    map<int , TreeNode*> nodes;\\n    int countHighestScoreNodes(vector<int>& parent) {\\n        \\n        \\n        root = new TreeNode(0);\\n        nodes[0] = root;\\n        \\n        // contructing the tree here\\n       for(int i = 1 ; i < parent.size() ; i++){\\n           \\n           if(!nodes[i]){\\n               nodes[i] = new TreeNode(i);\\n           }\\n           \\n           if(!nodes[parent[i]]){\\n               nodes[parent[i]] = new TreeNode(parent[i]);\\n           }\\n           \\n           if(nodes[parent[i]]->left){\\n                    nodes[parent[i]]->right = nodes[i];\\n            }else{\\n                    nodes[parent[i]]->left = nodes[i];\\n            }\\n       }\\n        \\n    numberOfNodes(nodes[0] , parent.size());\\n    return count;\\n    }\\n    \\n    \\n    int numberOfNodes(TreeNode* root , int size){\\n        if(!root){\\n            return 0;\\n        }\\n        \\n        if(!root->left && !root->right){\\n            \\n            subTrees[root->val].push_back(0);\\n            subTrees[root->val].push_back(0);\\n            int long long rootParent = size-1 ? size-1 : 1;        \\n        \\n            int long long prod = rootParent;\\n       \\n        \\n            if(prod > max){\\n                max = prod;\\n                count = 1;\\n            }else if(prod == max){\\n                count++;\\n            }\\n        \\n            return 1;\\n        }\\n        \\n        \\n        int numL =  numberOfNodes(root->left,size);\\n        int numR = numberOfNodes(root->right,size);\\n        \\n        subTrees[root->val].push_back(numL);\\n        subTrees[root->val].push_back(numR);\\n        \\n        int long long rootParent = size - (numL + numR) -1 ? size - (numL + numR) -1 : 1;        \\n        \\n        // cout << root->val << \" \" << numL << \" \" << numR << \" \" << rootParent << endl;\\n        int long long numLT = numL ? numL : 1;\\n        int long long numRT = numR ? numR : 1;\\n        int long long prod = numLT*numRT*rootParent;\\n\\n\\n        if(prod > max){\\n            max = prod;\\n            count = 1;\\n        }else if(prod == max){\\n            count++;\\n        }\\n        \\n        return 1 + numL + numR;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// struct TreeNode {\\n//       int val;\\n//       TreeNode *left;\\n//       TreeNode *right;\\n//       TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//       TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\n\\n// [2,0,-1,0,2]\\n\\nclass Solution {\\npublic:\\n    TreeNode* root = NULL;\\n    int long long max = INT_MIN;\\n    \\n    int count = 0;\\n    map<int , vector<int>> subTrees;\\n    map<int , TreeNode*> nodes;\\n    int countHighestScoreNodes(vector<int>& parent) {\\n        \\n        \\n        root = new TreeNode(0);\\n        nodes[0] = root;\\n        \\n        // contructing the tree here\\n       for(int i = 1 ; i < parent.size() ; i++){\\n           \\n           if(!nodes[i]){\\n               nodes[i] = new TreeNode(i);\\n           }\\n           \\n           if(!nodes[parent[i]]){\\n               nodes[parent[i]] = new TreeNode(parent[i]);\\n           }\\n           \\n           if(nodes[parent[i]]->left){\\n                    nodes[parent[i]]->right = nodes[i];\\n            }else{\\n                    nodes[parent[i]]->left = nodes[i];\\n            }\\n       }\\n        \\n    numberOfNodes(nodes[0] , parent.size());\\n    return count;\\n    }\\n    \\n    \\n    int numberOfNodes(TreeNode* root , int size){\\n        if(!root){\\n            return 0;\\n        }\\n        \\n        if(!root->left && !root->right){\\n            \\n            subTrees[root->val].push_back(0);\\n            subTrees[root->val].push_back(0);\\n            int long long rootParent = size-1 ? size-1 : 1;        \\n        \\n            int long long prod = rootParent;\\n       \\n        \\n            if(prod > max){\\n                max = prod;\\n                count = 1;\\n            }else if(prod == max){\\n                count++;\\n            }\\n        \\n            return 1;\\n        }\\n        \\n        \\n        int numL =  numberOfNodes(root->left,size);\\n        int numR = numberOfNodes(root->right,size);\\n        \\n        subTrees[root->val].push_back(numL);\\n        subTrees[root->val].push_back(numR);\\n        \\n        int long long rootParent = size - (numL + numR) -1 ? size - (numL + numR) -1 : 1;        \\n        \\n        // cout << root->val << \" \" << numL << \" \" << numR << \" \" << rootParent << endl;\\n        int long long numLT = numL ? numL : 1;\\n        int long long numRT = numR ? numR : 1;\\n        int long long prod = numLT*numRT*rootParent;\\n\\n\\n        if(prod > max){\\n            max = prod;\\n            count = 1;\\n        }else if(prod == max){\\n            count++;\\n        }\\n        \\n        return 1 + numL + numR;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2792332,
                "title": "golang-dfs",
                "content": "```\\nfunc dfs(u, p int, gr [][]int, size *[]int) int {\\n\\tsze := 1\\n\\tfor _, v := range gr[u] {\\n\\t\\tif v != p {\\n\\t\\t\\tsze += dfs(v, u, gr, size)\\n\\t\\t}\\n\\t}\\n\\t(*size)[u] = sze\\n\\treturn sze\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tn := len(parents)\\n\\tgr := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgr[i] = make([]int, 0)\\n\\t}\\n\\tfor idx, parent := range parents {\\n\\t\\tif parent != -1 {\\n\\t\\t\\tgr[parent] = append(gr[parent], idx)\\n\\t\\t}\\n\\t}\\n\\tscoresMap, size, maxProduct := make(map[int]int, 0), make([]int, n), 0\\n\\tdfs(0, -1, gr, &size)\\n\\tfor val := range size {\\n\\t\\ttaken := 1\\n\\t\\tproduct := 1\\n\\t\\tfor _, child := range gr[val] {\\n\\t\\t\\ttaken += size[child]\\n\\t\\t\\tproduct = product * size[child]\\n\\t\\t}\\n\\t\\trem := n - taken\\n\\t\\tif rem > 1 {\\n\\t\\t\\tproduct = product * rem\\n\\t\\t}\\n\\t\\tscoresMap[product]++\\n\\t\\tmaxProduct = int(math.Max(float64(product), float64(maxProduct)))\\n\\t}\\n\\treturn scoresMap[maxProduct]\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfunc dfs(u, p int, gr [][]int, size *[]int) int {\\n\\tsze := 1\\n\\tfor _, v := range gr[u] {\\n\\t\\tif v != p {\\n\\t\\t\\tsze += dfs(v, u, gr, size)\\n\\t\\t}\\n\\t}\\n\\t(*size)[u] = sze\\n\\treturn sze\\n}\\n\\nfunc countHighestScoreNodes(parents []int) int {\\n\\tn := len(parents)\\n\\tgr := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgr[i] = make([]int, 0)\\n\\t}\\n\\tfor idx, parent := range parents {\\n\\t\\tif parent != -1 {\\n\\t\\t\\tgr[parent] = append(gr[parent], idx)\\n\\t\\t}\\n\\t}\\n\\tscoresMap, size, maxProduct := make(map[int]int, 0), make([]int, n), 0\\n\\tdfs(0, -1, gr, &size)\\n\\tfor val := range size {\\n\\t\\ttaken := 1\\n\\t\\tproduct := 1\\n\\t\\tfor _, child := range gr[val] {\\n\\t\\t\\ttaken += size[child]\\n\\t\\t\\tproduct = product * size[child]\\n\\t\\t}\\n\\t\\trem := n - taken\\n\\t\\tif rem > 1 {\\n\\t\\t\\tproduct = product * rem\\n\\t\\t}\\n\\t\\tscoresMap[product]++\\n\\t\\tmaxProduct = int(math.Max(float64(product), float64(maxProduct)))\\n\\t}\\n\\treturn scoresMap[maxProduct]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768525,
                "title": "help-java-solution-tle",
                "content": "Here is my solution, my logic is to create a graph, then  identify how many separate graphs. Time Complexity is O(n^2) + O(nlogn) I think, actually it makes sense TLE. But I want know how to improve it? Thank you very much.\\n```\\nclass Solution {\\n     public int countHighestScoreNodes(int[] parents) {\\n        Map<Integer,List<Integer>> graph = new HashMap<>();\\n\\t\\t// build a graph\\n        for(int i = 0 ;i<parents.length;i++){\\n            if(parents[i] != -1){\\n                graph.putIfAbsent(parents[i],new ArrayList<>());\\n                graph.putIfAbsent(i,new ArrayList<>());\\n                graph.get(parents[i]).add(i);\\n                graph.get(i).add(parents[i]);\\n            }\\n        }\\n\\n        HashMap<Integer,Integer> ans = new HashMap<>();\\n        int max = Integer.MIN_VALUE;\\n\\t\\t// Identify how many separate graphs \\n        for(int i = 0 ;i<parents.length;i++){\\n            List<Integer> tmpList = graph.get(i);\\n            Set<Integer> visited = new HashSet<>();\\n            int num = 1;\\n            if(tmpList.size() == 1){\\n                num = parents.length -1 ;\\n            }else {\\n                for(int n : tmpList){\\n                    visited = new HashSet<>();\\n                    TreeDFS(visited,graph,n, i);\\n\\t\\t\\t\\t\\t// calculate the number of nodes in each sub graph.\\n                    num *= visited.size();\\n                }\\n            }\\n            max = Math.max(max,num);\\n            ans.put(num,ans.getOrDefault(num,0)+1);\\n        }\\n        return ans.get(max);\\n    }\\n\\n    private void TreeDFS(Set<Integer> visited, Map<Integer, List<Integer>> graph, int start,int i) {\\n        if (visited.contains(start) || !graph.containsKey(start)) return;\\n        visited.add(start);\\n        for (int k : graph.get(start)) {\\n            if (visited.contains(k) || k == i) continue;\\n            TreeDFS(visited,graph,k, i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n     public int countHighestScoreNodes(int[] parents) {\\n        Map<Integer,List<Integer>> graph = new HashMap<>();\\n\\t\\t// build a graph\\n        for(int i = 0 ;i<parents.length;i++){\\n            if(parents[i] != -1){\\n                graph.putIfAbsent(parents[i],new ArrayList<>());\\n                graph.putIfAbsent(i,new ArrayList<>());\\n                graph.get(parents[i]).add(i);\\n                graph.get(i).add(parents[i]);\\n            }\\n        }\\n\\n        HashMap<Integer,Integer> ans = new HashMap<>();\\n        int max = Integer.MIN_VALUE;\\n\\t\\t// Identify how many separate graphs \\n        for(int i = 0 ;i<parents.length;i++){\\n            List<Integer> tmpList = graph.get(i);\\n            Set<Integer> visited = new HashSet<>();\\n            int num = 1;\\n            if(tmpList.size() == 1){\\n                num = parents.length -1 ;\\n            }else {\\n                for(int n : tmpList){\\n                    visited = new HashSet<>();\\n                    TreeDFS(visited,graph,n, i);\\n\\t\\t\\t\\t\\t// calculate the number of nodes in each sub graph.\\n                    num *= visited.size();\\n                }\\n            }\\n            max = Math.max(max,num);\\n            ans.put(num,ans.getOrDefault(num,0)+1);\\n        }\\n        return ans.get(max);\\n    }\\n\\n    private void TreeDFS(Set<Integer> visited, Map<Integer, List<Integer>> graph, int start,int i) {\\n        if (visited.contains(start) || !graph.containsKey(start)) return;\\n        visited.add(start);\\n        for (int k : graph.get(start)) {\\n            if (visited.contains(k) || k == i) continue;\\n            TreeDFS(visited,graph,k, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763323,
                "title": "python-super-easy-dfs",
                "content": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        tree = collections.defaultdict(list)\\n        for i in range(1, len(parents)):\\n            tree[parents[i]].append(i)\\n            \\n        \\n        score_count = collections.defaultdict(int)\\n        max_score = 0\\n        def dfs(node):\\n            \\n            nonlocal max_score\\n            if not tree[node]:\\n                score_count[n-1] +=1\\n                max_score = max(max_score, n-1)\\n                return 1\\n            size = 1\\n            p = 1\\n            for v in tree[node]:\\n                s = dfs(v)\\n                p = s * p \\n                size +=s\\n                \\n            if n-size != 0:\\n                score_count[(n-size)*p] +=1\\n                max_score = max(max_score, (n-size)*p)    \\n            else:\\n                score_count[p] +=1\\n                max_score = max(max_score, p)    \\n            return size\\n    \\n        \\n        dfs(0)\\n        return score_count[max_score]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        tree = collections.defaultdict(list)\\n        for i in range(1, len(parents)):\\n            tree[parents[i]].append(i)\\n            \\n        \\n        score_count = collections.defaultdict(int)\\n        max_score = 0\\n        def dfs(node):\\n            \\n            nonlocal max_score\\n            if not tree[node]:\\n                score_count[n-1] +=1\\n                max_score = max(max_score, n-1)\\n                return 1\\n            size = 1\\n            p = 1\\n            for v in tree[node]:\\n                s = dfs(v)\\n                p = s * p \\n                size +=s\\n                \\n            if n-size != 0:\\n                score_count[(n-size)*p] +=1\\n                max_score = max(max_score, (n-size)*p)    \\n            else:\\n                score_count[p] +=1\\n                max_score = max(max_score, p)    \\n            return size\\n    \\n        \\n        dfs(0)\\n        return score_count[max_score]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755972,
                "title": "c-dfs",
                "content": "class Solution {\\n    private:\\n    int solve(vector<int>*adj,int element,vector<long long > &ans,int n){\\n        if(adj[element].size()==0){\\n            ans[element]=n-1;\\n            return 1;\\n        }\\n        long long left=0;\\n        long long right=0;\\n        \\n        int size=adj[element].size();\\n        if(size==2){\\n            left=solve(adj,adj[element][0],ans,n);\\n            right=solve(adj,adj[element][1],ans,n);\\n        }\\n        else if(size==1){\\n            left=solve(adj,adj[element][0],ans,n);\\n        }\\n        long long p=n-(left+right+1);\\n       if(left && right && p){\\n           ans[element]=left*right*p;\\n       }\\n       else if(left==0 && right && p){\\n           ans[element]=right*p;\\n       }\\n        else if(right==0 && left && p){\\n            ans[element]=left*p;\\n        }\\n        else if(left==0 && p==0){\\n            ans[element]=right;\\n        }\\n        else if(right==0 && p==0){\\n            ans[element]=left;\\n        }\\n        else if(left && right && p==0){\\n            ans[element]=left*right;\\n        }\\n        return left+right+1;\\n       \\n       \\n    }\\npublic:\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(parents[i]!=-1){\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        vector<long long  > ans(n,0);\\n        solve(adj,0,ans,n);\\n        long long maxi=-1;\\n        int res=-1;\\n        for(int i=0;i<n;i++){\\n            if(ans[i]>maxi){\\n                maxi=ans[i];\\n                res=i;\\n            }\\n        }\\n        cout<<ans[0];\\n        int count=0;\\n        for(auto it:ans){\\n            if(it==maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    int solve(vector<int>*adj,int element,vector<long long > &ans,int n){\\n        if(adj[element].size()==0){\\n            ans[element]=n-1;\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2737724,
                "title": "tree",
                "content": "The value of a node is the product of:\\n\\n1) number of nodes in the left subtree,\\n2) number of nodes in the right subtree,\\n3) number of all other nodes, excluding the current one (n - left - right - 1)\\nmade  a  tree to count child nodes for (1) and (2), and we can then compute (3) as we know the total nubers of nodes.\\n\\n```\\n\\nstruct Node {\\n    long score = 0;\\n    int nodeCount = 0;\\n    int val;\\n    Node* left;\\n    Node* right;\\n    \\n    Node(int data)\\n    {\\n        val = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int countNode(Node* tnode)\\n    {\\n        if(!tnode)\\n            return 0;\\n        tnode->nodeCount = countNode(tnode->left)+countNode(tnode->right)+1;\\n        return tnode->nodeCount;\\n    }\\n    \\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        int sz = parents.size();\\n        struct Node* treeNode[sz];\\n        for(int i=0;i<sz;i++)\\n            treeNode[i] = new Node(i);\\n        \\n        for(int i=1;i<sz;i++)\\n        {\\n            auto par = parents[i];\\n            if(!treeNode[par]->left)\\n                treeNode[par]->left = treeNode[i];\\n            else\\n                treeNode[par]->right = treeNode[i];\\n        }\\n        \\n        countNode(treeNode[0]);\\n        long mx = -1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            long leftCount = treeNode[i]->left == NULL ? 0 : treeNode[i]->left->nodeCount;\\n            long rightCount = treeNode[i]->right == NULL ? 0 : treeNode[i]->right->nodeCount;\\n            long parCount = sz-leftCount-rightCount-1 == 0 ? 1 : sz-leftCount-rightCount-1;\\n            treeNode[i]->score = (leftCount==0?1:leftCount)*(rightCount==0?1:rightCount)*parCount;\\n            mx = max(treeNode[i]->score,mx);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(treeNode[i]->score == mx)\\n                ans++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nstruct Node {\\n    long score = 0;\\n    int nodeCount = 0;\\n    int val;\\n    Node* left;\\n    Node* right;\\n    \\n    Node(int data)\\n    {\\n        val = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int countNode(Node* tnode)\\n    {\\n        if(!tnode)\\n            return 0;\\n        tnode->nodeCount = countNode(tnode->left)+countNode(tnode->right)+1;\\n        return tnode->nodeCount;\\n    }\\n    \\n    \\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        int sz = parents.size();\\n        struct Node* treeNode[sz];\\n        for(int i=0;i<sz;i++)\\n            treeNode[i] = new Node(i);\\n        \\n        for(int i=1;i<sz;i++)\\n        {\\n            auto par = parents[i];\\n            if(!treeNode[par]->left)\\n                treeNode[par]->left = treeNode[i];\\n            else\\n                treeNode[par]->right = treeNode[i];\\n        }\\n        \\n        countNode(treeNode[0]);\\n        long mx = -1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            long leftCount = treeNode[i]->left == NULL ? 0 : treeNode[i]->left->nodeCount;\\n            long rightCount = treeNode[i]->right == NULL ? 0 : treeNode[i]->right->nodeCount;\\n            long parCount = sz-leftCount-rightCount-1 == 0 ? 1 : sz-leftCount-rightCount-1;\\n            treeNode[i]->score = (leftCount==0?1:leftCount)*(rightCount==0?1:rightCount)*parCount;\\n            mx = max(treeNode[i]->score,mx);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(treeNode[i]->score == mx)\\n                ans++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730814,
                "title": "python-dfs-solution-with-dictionary-straightforward-no-zip",
                "content": "*Runtime: 1816 ms, faster than 83.52% of Python3 online submissions for Count Nodes With the Highest Score.\\nMemory Usage: 112.2 MB, less than 76.78% of Python3 online submissions for Count Nodes With the Highest Score.*\\n\\nMy solution is never fancy but it must be straightforward and understandable (hopefully).\\n1. Create a dictionary of {parent node : its son nodes}\\n2. Do a dfs search to find out the size of each node, save the results\\n3. Calculate the score for each node (assume it\\'s removed), record the frequency of each score in another dictionary, also record the max score.\\n\\n\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        \\n        dic = {} # parent : sons\\n        for i in range(n):\\n            if parents[i] not in dic:\\n                dic[parents[i]] = []\\n            dic[parents[i]].append(i)\\n        \\n        # dfs search the size of each node (number of subtrees + node itself)\\n        # save the result in tree_size\\n        tree_size = [0 for i in range(n)]\\n        def search(root: int):\\n            root_size = 1\\n            if root in dic: # if root is a parent\\n                for son in dic[root]:\\n                    son_size = search(son)\\n                    root_size += son_size\\n            \\n            tree_size[root] = root_size\\n            return root_size\\n        \\n\\t\\t# search the root\\n        search(0)\\n        \\n        max_score = 0\\n        freq = {}\\n        for i in range(n):\\n\\t\\t\\t# initialization: if i is not a parent\\n            left_size = 0\\n            right_size = 0\\n            \\n            if i in dic: # if i is a parent\\n                if len(dic[i]) > 0:\\n                    left_size = tree_size[dic[i][0]] # size of its left subtree\\n                if len(dic[i]) > 1:\\n                    right_size = tree_size[dic[i][1]] # size of its right subtree\\n                    \\n            # score = size of left subtree * size of right subtree * size the other trees (except i which is removed)\\n            score = max(left_size, 1) * max(right_size, 1) * max(n - 1 - left_size - right_size, 1)\\n            \\n            if score not in freq:\\n                freq[score] = 0\\n            freq[score] += 1\\n            max_score = max(max_score, score)\\n            \\n        return freq[max_score]\\n```\\n\\nSome of the master solutions in discussion are too fancy for me to understand (as I only know basic functions), so I made my own.\\nHope it can help! ( \\u2022\\u0300 \\u03C9 \\u2022\\u0301 )y",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        \\n        dic = {} # parent : sons\\n        for i in range(n):\\n            if parents[i] not in dic:\\n                dic[parents[i]] = []\\n            dic[parents[i]].append(i)\\n        \\n        # dfs search the size of each node (number of subtrees + node itself)\\n        # save the result in tree_size\\n        tree_size = [0 for i in range(n)]\\n        def search(root: int):\\n            root_size = 1\\n            if root in dic: # if root is a parent\\n                for son in dic[root]:\\n                    son_size = search(son)\\n                    root_size += son_size\\n            \\n            tree_size[root] = root_size\\n            return root_size\\n        \\n\\t\\t# search the root\\n        search(0)\\n        \\n        max_score = 0\\n        freq = {}\\n        for i in range(n):\\n\\t\\t\\t# initialization: if i is not a parent\\n            left_size = 0\\n            right_size = 0\\n            \\n            if i in dic: # if i is a parent\\n                if len(dic[i]) > 0:\\n                    left_size = tree_size[dic[i][0]] # size of its left subtree\\n                if len(dic[i]) > 1:\\n                    right_size = tree_size[dic[i][1]] # size of its right subtree\\n                    \\n            # score = size of left subtree * size of right subtree * size the other trees (except i which is removed)\\n            score = max(left_size, 1) * max(right_size, 1) * max(n - 1 - left_size - right_size, 1)\\n            \\n            if score not in freq:\\n                freq[score] = 0\\n            freq[score] += 1\\n            max_score = max(max_score, score)\\n            \\n        return freq[max_score]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724294,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>& adj, int u, vector<bool>& vis, vector<int>& count)\\n    {\\n        vis[u] = true;\\n        \\n        // base case, leaf node\\n\\n        if(adj[u].size() == 1 && vis[adj[u][0]])\\n        {\\n            count[u] = 1;\\n\\n            return 1;\\n        }\\n\\n        int sum = 0;\\n\\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                sum += dfs(adj, v, vis, count);\\n            }\\n        }\\n\\n        count[u] = sum + 1;\\n\\n        return sum + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n\\n        int n = parents.size();\\n        \\n        // create an adjacency list\\n\\n        vector<vector<int>> adj(n);\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            int u = parents[i];\\n\\n            int v = i;\\n\\n            adj[u].push_back(v);\\n\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> vis(n, false);\\n\\n        vector<int> count(n, 0);\\n        \\n        // first of all find the no. of nodes below each node including current node\\n\\n        dfs(adj, 0, vis, count);\\n\\n        vector<long long> prod(n, 0);\\n        \\n        // find the product after removing each node\\n\\n        for(int u = 0; u < n; u++)\\n        {\\n            long long product = 1;\\n            \\n            // sum will store the no. of nodes in adjacent subtree except parent subtree\\n\\n            long long sum = 0;\\n\\n            for(auto v : adj[u])\\n            {\\n                if(parents[u] != v)\\n                {\\n                    sum += count[v];\\n\\n                    product *= count[v];\\n                }\\n            }\\n            \\n            // find remaining no. of nodes in parent subtree\\n\\n            long long rem = n - sum - 1;\\n\\n            if(rem)\\n            {\\n                product *= rem;\\n            }\\n\\n            prod[u] = product;\\n        }\\n        \\n        // find maximum product\\n\\n        long long maxi = *max_element(prod.begin(), prod.end());\\n        \\n        // now count no .of nodes giving maximum product\\n\\n        int ans = 0;\\n\\n        for(auto x : prod)\\n        {\\n            if(x == maxi)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>& adj, int u, vector<bool>& vis, vector<int>& count)\\n    {\\n        vis[u] = true;\\n        \\n        // base case, leaf node\\n\\n        if(adj[u].size() == 1 && vis[adj[u][0]])\\n        {\\n            count[u] = 1;\\n\\n            return 1;\\n        }\\n\\n        int sum = 0;\\n\\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                sum += dfs(adj, v, vis, count);\\n            }\\n        }\\n\\n        count[u] = sum + 1;\\n\\n        return sum + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int>& parents) {\\n\\n        int n = parents.size();\\n        \\n        // create an adjacency list\\n\\n        vector<vector<int>> adj(n);\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            int u = parents[i];\\n\\n            int v = i;\\n\\n            adj[u].push_back(v);\\n\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> vis(n, false);\\n\\n        vector<int> count(n, 0);\\n        \\n        // first of all find the no. of nodes below each node including current node\\n\\n        dfs(adj, 0, vis, count);\\n\\n        vector<long long> prod(n, 0);\\n        \\n        // find the product after removing each node\\n\\n        for(int u = 0; u < n; u++)\\n        {\\n            long long product = 1;\\n            \\n            // sum will store the no. of nodes in adjacent subtree except parent subtree\\n\\n            long long sum = 0;\\n\\n            for(auto v : adj[u])\\n            {\\n                if(parents[u] != v)\\n                {\\n                    sum += count[v];\\n\\n                    product *= count[v];\\n                }\\n            }\\n            \\n            // find remaining no. of nodes in parent subtree\\n\\n            long long rem = n - sum - 1;\\n\\n            if(rem)\\n            {\\n                product *= rem;\\n            }\\n\\n            prod[u] = product;\\n        }\\n        \\n        // find maximum product\\n\\n        long long maxi = *max_element(prod.begin(), prod.end());\\n        \\n        // now count no .of nodes giving maximum product\\n\\n        int ans = 0;\\n\\n        for(auto x : prod)\\n        {\\n            if(x == maxi)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717219,
                "title": "python-easy-to-read-and-understand-dfs-map",
                "content": "We store the count of nodes below the nodes in a map, and to compute score of each node, we multiple its children with (n-count[node])\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        g = {i:[] for i in range(n)}\\n        for u, v in enumerate(parents):\\n            if v != -1:\\n                g[v].append(u)\\n        #print(g.items())\\n        \\n        d = {i:1 for i in range(n)}\\n        def dfs(node):\\n            for nei in g[node]:\\n                dfs(nei)\\n                d[node] += d[nei]\\n        \\n        dfs(0)\\n        #print(d.items())\\n        res = []\\n        for node in range(n):\\n            if d[node] == 1:\\n                res.append(n-1)\\n            else:\\n                cnt = 1\\n                for nei in g[node]:\\n                    cnt *= d[nei]\\n                if parents[node] != -1:\\n                    cnt *= (n-d[node])\\n                res.append(cnt)\\n            #print(res)\\n        \\n        return res.count(max(res))\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        g = {i:[] for i in range(n)}\\n        for u, v in enumerate(parents):\\n            if v != -1:\\n                g[v].append(u)\\n        #print(g.items())\\n        \\n        d = {i:1 for i in range(n)}\\n        def dfs(node):\\n            for nei in g[node]:\\n                dfs(nei)\\n                d[node] += d[nei]\\n        \\n        dfs(0)\\n        #print(d.items())\\n        res = []\\n        for node in range(n):\\n            if d[node] == 1:\\n                res.append(n-1)\\n            else:\\n                cnt = 1\\n                for nei in g[node]:\\n                    cnt *= d[nei]\\n                if parents[node] != -1:\\n                    cnt *= (n-d[node])\\n                res.append(cnt)\\n            #print(res)\\n        \\n        return res.count(max(res))\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686321,
                "title": "c-solution-graph-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    map<long long,int> mb;\\n    long long dfs(vector<vector<int>>&v,int i,vector<int> &vis, int &n){\\n        if(i>=n){\\n            return 0;\\n        }\\n        long long res1 = 0;\\n        long long res2 = 0;\\n        vis[i] = 1;\\n        if(v[i].size() == 3){\\n            if(!vis[v[i][0]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][0],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][0],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][1]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][1],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][1],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][2]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][2],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][2],vis,n);\\n                }\\n            }\\n        }\\n        else if(v[i].size() == 2){\\n            if(!vis[v[i][0]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][0],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][0],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][1]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][1],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][1],vis,n);\\n                }\\n            }\\n        }\\n        else{\\n            if(!vis[v[i][0]]){\\n                res1 = dfs(v,v[i][0],vis,n);\\n            }\\n        }\\n        if(res1>0 and res2>0){\\n            if(i == 0){\\n                // cout<<res1<<\" \"<<res2<<endl;\\n                mb[(long long)res1*res2]++;\\n            }\\n            else\\n                mb[(long long)(n-1-res1-res2)*res1*res2]++;\\n        }\\n        else{\\n            if(res1>0){\\n                if(i == 0)\\n                    mb[res1]++;\\n                else\\n                    mb[(long long)(n-1-res1)*res1]++;\\n                \\n            }\\n            else if(res2>0){\\n                if(i == 0){\\n                    mb[res2]++;\\n                }\\n                else\\n                    mb[(long long)(n-1-res2)*res2]++;\\n            }\\n            else{\\n                mb[(n-1)]++;\\n            }\\n        }\\n        return (1+res1+res2);\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n       vector<vector<int>> v(n);\\n        for(int i = 1;i<n;i++){\\n            v[parents[i]].push_back(i);\\n            v[i].push_back(parents[i]);\\n        }\\n        vector<int> vis(n);\\n        long long t = dfs(v,0,vis,n);\\n        auto it = mb.end();\\n        it--;\\n        return (*it).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<long long,int> mb;\\n    long long dfs(vector<vector<int>>&v,int i,vector<int> &vis, int &n){\\n        if(i>=n){\\n            return 0;\\n        }\\n        long long res1 = 0;\\n        long long res2 = 0;\\n        vis[i] = 1;\\n        if(v[i].size() == 3){\\n            if(!vis[v[i][0]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][0],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][0],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][1]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][1],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][1],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][2]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][2],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][2],vis,n);\\n                }\\n            }\\n        }\\n        else if(v[i].size() == 2){\\n            if(!vis[v[i][0]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][0],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][0],vis,n);\\n                }\\n            }\\n            if(!vis[v[i][1]]){\\n                if(res1 == 0){\\n                    res1 = dfs(v,v[i][1],vis,n);\\n                }\\n                else{\\n                    res2 = dfs(v,v[i][1],vis,n);\\n                }\\n            }\\n        }\\n        else{\\n            if(!vis[v[i][0]]){\\n                res1 = dfs(v,v[i][0],vis,n);\\n            }\\n        }\\n        if(res1>0 and res2>0){\\n            if(i == 0){\\n                // cout<<res1<<\" \"<<res2<<endl;\\n                mb[(long long)res1*res2]++;\\n            }\\n            else\\n                mb[(long long)(n-1-res1-res2)*res1*res2]++;\\n        }\\n        else{\\n            if(res1>0){\\n                if(i == 0)\\n                    mb[res1]++;\\n                else\\n                    mb[(long long)(n-1-res1)*res1]++;\\n                \\n            }\\n            else if(res2>0){\\n                if(i == 0){\\n                    mb[res2]++;\\n                }\\n                else\\n                    mb[(long long)(n-1-res2)*res2]++;\\n            }\\n            else{\\n                mb[(n-1)]++;\\n            }\\n        }\\n        return (1+res1+res2);\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n       vector<vector<int>> v(n);\\n        for(int i = 1;i<n;i++){\\n            v[parents[i]].push_back(i);\\n            v[i].push_back(parents[i]);\\n        }\\n        vector<int> vis(n);\\n        long long t = dfs(v,0,vis,n);\\n        auto it = mb.end();\\n        it--;\\n        return (*it).second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2659498,
                "title": "explanation-of-everyone-s-short-code",
                "content": "```\\n map<int,int> meraSize; //merse shuru hone wala subtree jo hai usme kitne nodes\\n    map<int,vector<int>> adj; //adjacnecy vector . parents -> child edge\\n    \\n    //to calculate no of nodes in every subtree  \\n    int nodes(int src)\\n    {\\n        int sum=0;\\n        for(auto i:adj[src])\\n            sum+=nodes(i);\\n        \\n        return meraSize[src]=1+sum;  //storing in meraSize map \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        for(int i=1;i<parents.size();i++) //make tree\\n            adj[parents[i]].push_back(i);\\n        \\n        nodes(0);  //storing in merasize map no of nodes in any subtree\\n        int n=parents.size(); //total nodes present in tree\\n        long long maxScore=0;\\n        \\n        map<long long,int> m;\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            long long score=1;\\n            \\n            //step 1 --> mere left child aur right child wale subtre ka kitna size hai vo score me multiply krdo\\n            for(auto child:adj[i])  \\n                score*=meraSize[child];\\n            \\n//step 2 --> mere wale subtree htado ab kitne nodes bche pure tree me (n-meraSize[i] ab agar ye 0 hua (in case of root node) to score =0 hojayega par 0 nahi hona chiye to check krlo ye condition)\\n            \\n            if(n-meraSize[i]!=0)\\n                score*=(n-meraSize[i]);\\n            \\n            m[score]++;  //ye score ek baar aur aagya map me store krao\\n            maxScore=max(maxScore,score); //maxScore kya hai\\n        }\\n        return m[maxScore];  //maxScore kitne nodes ka hai vo return krna hai \\n    }",
                "solutionTags": [],
                "code": "```\\n map<int,int> meraSize; //merse shuru hone wala subtree jo hai usme kitne nodes\\n    map<int,vector<int>> adj; //adjacnecy vector . parents -> child edge\\n    \\n    //to calculate no of nodes in every subtree  \\n    int nodes(int src)\\n    {\\n        int sum=0;\\n        for(auto i:adj[src])\\n            sum+=nodes(i);\\n        \\n        return meraSize[src]=1+sum;  //storing in meraSize map \\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        \\n        for(int i=1;i<parents.size();i++) //make tree\\n            adj[parents[i]].push_back(i);\\n        \\n        nodes(0);  //storing in merasize map no of nodes in any subtree\\n        int n=parents.size(); //total nodes present in tree\\n        long long maxScore=0;\\n        \\n        map<long long,int> m;\\n        for(int i=0;i<parents.size();i++)\\n        {\\n            long long score=1;\\n            \\n            //step 1 --> mere left child aur right child wale subtre ka kitna size hai vo score me multiply krdo\\n            for(auto child:adj[i])  \\n                score*=meraSize[child];\\n            \\n//step 2 --> mere wale subtree htado ab kitne nodes bche pure tree me (n-meraSize[i] ab agar ye 0 hua (in case of root node) to score =0 hojayega par 0 nahi hona chiye to check krlo ye condition)\\n            \\n            if(n-meraSize[i]!=0)\\n                score*=(n-meraSize[i]);\\n            \\n            m[score]++;  //ye score ek baar aur aagya map me store krao\\n            maxScore=max(maxScore,score); //maxScore kya hai\\n        }\\n        return m[maxScore];  //maxScore kitne nodes ka hai vo return krna hai \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2657151,
                "title": "simple-intuitive-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g; int N;\\n    vector<long long> ans;\\n    int dfs(int node,int par){\\n        long long val=1;\\n        int r_val=1;\\n        for(auto v:g[node]){\\n            if(v==par)continue;\\n            int sz_v=dfs(v,node);\\n            val*=sz_v;\\n            r_val+=sz_v;\\n        }\\n        ans[node] = (N-r_val==0?1:N-r_val)*val;\\n        return r_val;\\n    }\\n    int countHighestScoreNodes(vector<int>& par) {\\n        int n=par.size();N=n;\\n        g.resize(n);ans.resize(n);\\n        for(int i=1;i<n;i++){\\n            g[par[i]].push_back(i);\\n            g[i].push_back(par[i]);\\n        }\\n        dfs(0,-1);long long maxi=0;int an=0;\\n        for(auto i:ans)maxi=max(maxi,i);\\n        for(auto i:ans)if(i==maxi)an++;\\n        return an;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> g; int N;\\n    vector<long long> ans;\\n    int dfs(int node,int par){\\n        long long val=1;\\n        int r_val=1;\\n        for(auto v:g[node]){\\n            if(v==par)continue;\\n            int sz_v=dfs(v,node);\\n            val*=sz_v;\\n            r_val+=sz_v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2634001,
                "title": "python-best-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        g = [[] for _ in range(n)]\\n        \\n        def make(i):\\n            if i == n : return\\n            g[parents[i]].append(i)            \\n            make(i+1)\\n        \\n        make(1)\\n        \\n        \\n        ans = []\\n        def dfs(root):\\n            cnt, pr = 1, 1\\n            for child in g[root]: \\n                c = dfs(child)\\n                cnt += c\\n                pr *= c\\n            pr *= (n - cnt) if n-cnt != 0 else 1\\n            ans.append(pr)\\n            return cnt\\n        \\n        \\n        dfs(0)\\n        \\n        mx = max(ans)\\n        return len([x for x in ans if x == mx])\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        g = [[] for _ in range(n)]\\n        \\n        def make(i):\\n            if i == n : return\\n            g[parents[i]].append(i)            \\n            make(i+1)\\n        \\n        make(1)\\n        \\n        \\n        ans = []\\n        def dfs(root):\\n            cnt, pr = 1, 1\\n            for child in g[root]: \\n                c = dfs(child)\\n                cnt += c\\n                pr *= c\\n            pr *= (n - cnt) if n-cnt != 0 else 1\\n            ans.append(pr)\\n            return cnt\\n        \\n        \\n        dfs(0)\\n        \\n        mx = max(ans)\\n        return len([x for x in ans if x == mx])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617629,
                "title": "c-using-recursion-faster-than-96-09-of-c",
                "content": "```\\nclass Solution {\\npublic:vector<vector<int>>adj;\\n    long  long int count=0,num=0,maximum=LONG_MIN;\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        adj=vector<vector<int>>(parents.size());\\n        for(int i=1;i<parents.size();i++)\\n            adj[parents[i]].push_back(i);\\n        dfs(0);\\n        traversal(0);\\n        return num;\\n    }\\n    void dfs(int u)\\n    {\\n        count++;\\n        for(auto v:adj[u])\\n            dfs(v);\\n    }\\n    int traversal(int u)\\n    {\\n       long long  int lnodes=0,rnodes=0;\\n        lnodes=adj[u].size()>0?traversal(adj[u][0]):0;\\n        rnodes=adj[u].size()>1?traversal(adj[u][1]):0;\\n        long long  int temp=count-lnodes-rnodes-1;\\n        int temp1=lnodes+rnodes;\\n        temp=temp==0?1:temp;\\n        lnodes=lnodes==0?1:lnodes;\\n        rnodes=rnodes==0?1:rnodes;\\n        long long int temp3=lnodes*rnodes*temp;\\n        if(temp3>maximum)\\n        {\\n            num=1;\\n            maximum=temp3;\\n        }\\n        else if(temp3==maximum)\\n        {\\n            num++;\\n        }\\n        return temp1+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:vector<vector<int>>adj;\\n    long  long int count=0,num=0,maximum=LONG_MIN;\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        adj=vector<vector<int>>(parents.size());\\n        for(int i=1;i<parents.size();i++)\\n            adj[parents[i]].push_back(i);\\n        dfs(0);\\n        traversal(0);\\n        return num;\\n    }\\n    void dfs(int u)\\n    {\\n        count++;\\n        for(auto v:adj[u])\\n            dfs(v);\\n    }\\n    int traversal(int u)\\n    {\\n       long long  int lnodes=0,rnodes=0;\\n        lnodes=adj[u].size()>0?traversal(adj[u][0]):0;\\n        rnodes=adj[u].size()>1?traversal(adj[u][1]):0;\\n        long long  int temp=count-lnodes-rnodes-1;\\n        int temp1=lnodes+rnodes;\\n        temp=temp==0?1:temp;\\n        lnodes=lnodes==0?1:lnodes;\\n        rnodes=rnodes==0?1:rnodes;\\n        long long int temp3=lnodes*rnodes*temp;\\n        if(temp3>maximum)\\n        {\\n            num=1;\\n            maximum=temp3;\\n        }\\n        else if(temp3==maximum)\\n        {\\n            num++;\\n        }\\n        return temp1+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614904,
                "title": "java-post-order-traversal-recursion-optimized-solution",
                "content": "```\\n/*\\nTo understand the code better,\\ndry run for the example test case:\\nparents = [-1,2,0,2,0]\\n*/\\n\\nclass Solution {\\n    class TreeNode {\\n        private TreeNode left, right ;\\n        private int subtreeNodeCount = 0 ;\\n        private long score = 0L ;\\n    }\\n    \\n    private int setSubtreeNodeCount(TreeNode root) {\\n        if (root == null) return 0 ;\\n        \\n        int left = setSubtreeNodeCount(root.left) ;\\n        int right = setSubtreeNodeCount(root.right) ;\\n        \\n        root.subtreeNodeCount = left + right + 1 ;\\n        return root.subtreeNodeCount ;\\n    }\\n    \\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length ;\\n        TreeNode[] node = new TreeNode [n] ;\\n        \\n        // this for loop is to initialize all nodes\\n        for (int i = 0; i < n; i++)\\n            node[i] = new TreeNode() ;\\n        \\n        // this for loop forms the tree\\n        for (int i = 1; i < n; i++) {\\n            int parent = parents[i] ;\\n            if (node[parent].left == null)\\n                node[parent].left = node[i] ;\\n            else node[parent].right = node[i] ;\\n        }\\n        \\n        // sets the node count of the subtree for each node\\n        setSubtreeNodeCount(node[0]) ;\\n        \\n        long maxScore = 0 ;\\n        int result = 0 ;\\n        \\n        // sets the score of each node and stores the max score also\\n        for (int i = 0; i < n; i++) {\\n            long product = 1 ;\\n            int leftCount = 0, rightCount = 0 ;\\n            int parentCount = n - node[i].subtreeNodeCount ;\\n            \\n            if (node[i].left != null)\\n                leftCount = node[i].left.subtreeNodeCount ;\\n            if (node[i].right != null)\\n                rightCount = node[i].right.subtreeNodeCount ;\\n            \\n            if (leftCount > 0) product *= leftCount ;\\n            if (rightCount > 0) product *= rightCount ;\\n            if (parentCount > 0) product *= parentCount ;\\n            \\n            node[i].score = product ;\\n            maxScore = Math.max(maxScore, product) ;\\n        }\\n        \\n        // counts number of nodes having maxScore\\n        for (int i = 0; i < n; i++)\\n            if (node[i].score == maxScore)\\n                result++ ;\\n        \\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/*\\nTo understand the code better,\\ndry run for the example test case:\\nparents = [-1,2,0,2,0]\\n*/\\n\\nclass Solution {\\n    class TreeNode {\\n        private TreeNode left, right ;\\n        private int subtreeNodeCount = 0 ;\\n        private long score = 0L ;\\n    }\\n    \\n    private int setSubtreeNodeCount(TreeNode root) {\\n        if (root == null) return 0 ;\\n        \\n        int left = setSubtreeNodeCount(root.left) ;\\n        int right = setSubtreeNodeCount(root.right) ;\\n        \\n        root.subtreeNodeCount = left + right + 1 ;\\n        return root.subtreeNodeCount ;\\n    }\\n    \\n    public int countHighestScoreNodes(int[] parents) {\\n        int n = parents.length ;\\n        TreeNode[] node = new TreeNode [n] ;\\n        \\n        // this for loop is to initialize all nodes\\n        for (int i = 0; i < n; i++)\\n            node[i] = new TreeNode() ;\\n        \\n        // this for loop forms the tree\\n        for (int i = 1; i < n; i++) {\\n            int parent = parents[i] ;\\n            if (node[parent].left == null)\\n                node[parent].left = node[i] ;\\n            else node[parent].right = node[i] ;\\n        }\\n        \\n        // sets the node count of the subtree for each node\\n        setSubtreeNodeCount(node[0]) ;\\n        \\n        long maxScore = 0 ;\\n        int result = 0 ;\\n        \\n        // sets the score of each node and stores the max score also\\n        for (int i = 0; i < n; i++) {\\n            long product = 1 ;\\n            int leftCount = 0, rightCount = 0 ;\\n            int parentCount = n - node[i].subtreeNodeCount ;\\n            \\n            if (node[i].left != null)\\n                leftCount = node[i].left.subtreeNodeCount ;\\n            if (node[i].right != null)\\n                rightCount = node[i].right.subtreeNodeCount ;\\n            \\n            if (leftCount > 0) product *= leftCount ;\\n            if (rightCount > 0) product *= rightCount ;\\n            if (parentCount > 0) product *= parentCount ;\\n            \\n            node[i].score = product ;\\n            maxScore = Math.max(maxScore, product) ;\\n        }\\n        \\n        // counts number of nodes having maxScore\\n        for (int i = 0; i < n; i++)\\n            if (node[i].score == maxScore)\\n                result++ ;\\n        \\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601263,
                "title": "using-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],int i,vector<int>&res){\\n        res[i]=1;\\n        for(int x:adj[i]){\\n                res[i]+=dfs(adj,x,res);\\n        }\\n        return res[i];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int>adj[n];\\n        vector<int>res(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        dfs(adj,0,res);\\n        int ans1=0;\\n        long long mx=0;\\n        for(int i=0;i<n;i++){\\n            long long ans=1;\\n            if(adj[i].size()==0){\\n                ans*=n-1;\\n            }\\n            else{\\n                if(i!=0){\\n                    ans*=n-res[i];\\n                }\\n                for(auto x:adj[i]){\\n                    ans*=res[x];\\n                }\\n            }\\n            if(ans>mx){\\n                mx=ans;\\n                ans1=1;\\n            }\\n            else if(ans==mx){\\n                ans1++;\\n            }\\n            \\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>adj[],int i,vector<int>&res){\\n        res[i]=1;\\n        for(int x:adj[i]){\\n                res[i]+=dfs(adj,x,res);\\n        }\\n        return res[i];\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n=parents.size();\\n        vector<int>adj[n];\\n        vector<int>res(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i!=0){\\n                adj[parents[i]].push_back(i);\\n            }\\n        }\\n        dfs(adj,0,res);\\n        int ans1=0;\\n        long long mx=0;\\n        for(int i=0;i<n;i++){\\n            long long ans=1;\\n            if(adj[i].size()==0){\\n                ans*=n-1;\\n            }\\n            else{\\n                if(i!=0){\\n                    ans*=n-res[i];\\n                }\\n                for(auto x:adj[i]){\\n                    ans*=res[x];\\n                }\\n            }\\n            if(ans>mx){\\n                mx=ans;\\n                ans1=1;\\n            }\\n            else if(ans==mx){\\n                ans1++;\\n            }\\n            \\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599189,
                "title": "python-postorder",
                "content": "After solving [sum-of-distances-in-tree](https://leetcode.com/problems/sum-of-distances-in-tree) this one is not that complicated.\\n\\n1. Build \"adj_list[parent] -> node\" for a tree in parents array. We will use post order, so we need to go from parent to node.\\n2. Calc number of nodes in each subtree rooted at 0 -> N-1\\n3. Each node splits a tree in 2 parts (top + children). Actually it\\'s 3 - left, right, and top.\\nAfter removing a node from the tree you will have:\\n  - \"N - counts[node]\" top nodes count\\n  - counts[node.left] * counts[node.right] - node_score for children of removed node\\n  - multiply top_score * children_score\\n4. Now do all of that at the same time during a postorder traversal and you get an overcomplicated solution which works.\\n\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        N = len(parents)\\n        adj_list = defaultdict(list)\\n        \\n        for node, parent in enumerate(parents):\\n            adj_list[parent].append(node)\\n            \\n        counts = [1] * N\\n        score_count = Counter()\\n        \\n        def dfs(node = 0):\\n            children = 1\\n            max_val = 0\\n            for child in adj_list[node]:\\n                max_val = max(max_val, dfs(child))\\n                counts[node] += counts[child]\\n                children *= counts[child]\\n            top = max(1, N - counts[node])\\n            current_node_score = children * top\\n            score_count[current_node_score] += 1\\n            \\n            return max(max_val, current_node_score)\\n        \\n        return score_count[dfs()]\\n```\\n\\nLonger version of the same idea:\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        def build():\\n            for node, parent in enumerate(parents):\\n                if parent != -1:\\n                    adj_list[parent].append(node)\\n                    adj_list[node].append(parent)\\n        \\n        def calc_counts(node = 0, parent = None):\\n            for child in adj_list[node]:\\n                if child != parent:\\n                    calc_counts(child, node)\\n                    counts[node] += counts[child]\\n        \\n        N = len(parents)\\n        adj_list = defaultdict(list)\\n        counts = [1] * N\\n        build()\\n        calc_counts()\\n        \\n        max_score_val = 0\\n        max_score_count = 1\\n        for node in range(N):\\n            children = 1\\n            for c in adj_list[node]:\\n                if parents[node] != c:\\n                    children *= counts[c]\\n            top = N - counts[node] if parents[node] != -1 else 1\\n            \\n            current_score = children * top\\n            if current_score > max_score_val:\\n                max_score_val = children * top\\n                max_score_count = 0\\n            if children * top == max_score_val:\\n                max_score_count += 1\\n        \\n        return max_score_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        N = len(parents)\\n        adj_list = defaultdict(list)\\n        \\n        for node, parent in enumerate(parents):\\n            adj_list[parent].append(node)\\n            \\n        counts = [1] * N\\n        score_count = Counter()\\n        \\n        def dfs(node = 0):\\n            children = 1\\n            max_val = 0\\n            for child in adj_list[node]:\\n                max_val = max(max_val, dfs(child))\\n                counts[node] += counts[child]\\n                children *= counts[child]\\n            top = max(1, N - counts[node])\\n            current_node_score = children * top\\n            score_count[current_node_score] += 1\\n            \\n            return max(max_val, current_node_score)\\n        \\n        return score_count[dfs()]\\n```\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        def build():\\n            for node, parent in enumerate(parents):\\n                if parent != -1:\\n                    adj_list[parent].append(node)\\n                    adj_list[node].append(parent)\\n        \\n        def calc_counts(node = 0, parent = None):\\n            for child in adj_list[node]:\\n                if child != parent:\\n                    calc_counts(child, node)\\n                    counts[node] += counts[child]\\n        \\n        N = len(parents)\\n        adj_list = defaultdict(list)\\n        counts = [1] * N\\n        build()\\n        calc_counts()\\n        \\n        max_score_val = 0\\n        max_score_count = 1\\n        for node in range(N):\\n            children = 1\\n            for c in adj_list[node]:\\n                if parents[node] != c:\\n                    children *= counts[c]\\n            top = N - counts[node] if parents[node] != -1 else 1\\n            \\n            current_score = children * top\\n            if current_score > max_score_val:\\n                max_score_val = children * top\\n                max_score_count = 0\\n            if children * top == max_score_val:\\n                max_score_count += 1\\n        \\n        return max_score_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580218,
                "title": "c-solution-using-adjacency-list-dfs-and-recursion",
                "content": "```cpp\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    void updateAnswer(ll score, ll &maximum, int &answer)\\n    {\\n        if (score > maximum)\\n        {\\n            maximum = score;\\n            answer = 1;\\n        }\\n        else if (score == maximum)\\n            answer++;\\n    }\\n\\n    ll findCount(int i, int n, unordered_map<int, vector<int>> &adj, ll &maximum, int &answer)\\n    {\\n        if (adj.find(i) == adj.end())\\n        {\\n            updateAnswer(n - 1, maximum, answer);\\n            return 1;\\n        }\\n\\n        ll val, count = 0, score = 1;\\n\\n        for (int j : adj[i])\\n        {\\n            val = findCount(j, n, adj, maximum, answer);\\n            score *= val;\\n            count += val;\\n        }\\n\\n        if ((val = n - 1 - count) != 0)\\n            score *= val;\\n\\n        updateAnswer(score, maximum, answer);\\n\\n        return count + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int> &parents)\\n    {\\n        int n = parents.size();\\n\\n        unordered_map<int, vector<int>> adj;\\n\\n        for (int i = 1; i < n; i++)\\n            adj[parents[i]].push_back(i);\\n\\n        ll maximum = 0;\\n        int count = 0;\\n\\n        findCount(0, n, adj, maximum, count);\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    void updateAnswer(ll score, ll &maximum, int &answer)\\n    {\\n        if (score > maximum)\\n        {\\n            maximum = score;\\n            answer = 1;\\n        }\\n        else if (score == maximum)\\n            answer++;\\n    }\\n\\n    ll findCount(int i, int n, unordered_map<int, vector<int>> &adj, ll &maximum, int &answer)\\n    {\\n        if (adj.find(i) == adj.end())\\n        {\\n            updateAnswer(n - 1, maximum, answer);\\n            return 1;\\n        }\\n\\n        ll val, count = 0, score = 1;\\n\\n        for (int j : adj[i])\\n        {\\n            val = findCount(j, n, adj, maximum, answer);\\n            score *= val;\\n            count += val;\\n        }\\n\\n        if ((val = n - 1 - count) != 0)\\n            score *= val;\\n\\n        updateAnswer(score, maximum, answer);\\n\\n        return count + 1;\\n    }\\n\\n    int countHighestScoreNodes(vector<int> &parents)\\n    {\\n        int n = parents.size();\\n\\n        unordered_map<int, vector<int>> adj;\\n\\n        for (int i = 1; i < n; i++)\\n            adj[parents[i]].push_back(i);\\n\\n        ll maximum = 0;\\n        int count = 0;\\n\\n        findCount(0, n, adj, maximum, count);\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540583,
                "title": "scala-with-graph-implementation",
                "content": "If you don\\'t want to deal with weird implementation quirks, just use a standard graph implementation and count connected components.\\n\\n```\\nobject Solution {\\n    \\n    case class UDG[V](adj: Map[V, List[V]]) {\\n        def vertices: List[V] = adj.keys.toList\\n        \\n        def neighbours(v: V): List[V] = adj.getOrElse(v, Nil).filterNot(_ == v)\\n        \\n        def addEdge(from: V, to: V): UDG[V] = {\\n            val forward = to :: neighbours(from)\\n            val reverse = from :: neighbours(to)\\n            UDG(adj + (from -> forward.distinct) + (to -> reverse.distinct))\\n        }\\n        \\n        def removeNode(v: V): UDG[V] = {\\n            UDG(adj.filter { case (k, _) => k != v }. map { \\n                case (k, l) => k -> l.filterNot(li => li == v)\\n            })\\n        }\\n        \\n        def traverse(v: V, visited: Set[V]): Set[V] = {\\n            if (visited.contains(v)) visited\\n            else {\\n                neighbours(v).foldLeft(visited + v) {\\n                    case (s, n) => traverse(n, s)\\n                }\\n            }\\n        }\\n    }\\n    \\n    case class DFSTraversal(items: Set[Int])\\n    \\n\\n    def countHighestScoreNodes(parents: Array[Int]): Int = {\\n        val init = UDG[Int](Map())\\n        val graph = parents.zipWithIndex.foldLeft(init) {\\n            case (g, (-1, n)) => g\\n            case (g, (p, n)) => g.addEdge(n, p)\\n        }\\n        \\n        \\n        case class Acc(visited: Set[Int], score: Int)\\n        val gatherScores = parents.indices.map {\\n            n =>\\n              val withRemoved = graph.removeNode(n)\\n              val acc = Acc(Set(), 1)\\n              withRemoved.vertices.foldLeft(acc) {\\n                  case (Acc(set, scr), v) =>\\n                    val newSet = withRemoved.traverse(v, set)\\n                    if (newSet.size == set.size) Acc(set, scr)\\n                    else Acc(newSet, scr * (newSet -- set).size)\\n              }\\n        }\\n        \\n        val scores = gatherScores.map(_.score)\\n        val maxScore = scores.max\\n        scores.count(_ == maxScore)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    \\n    case class UDG[V](adj: Map[V, List[V]]) {\\n        def vertices: List[V] = adj.keys.toList\\n        \\n        def neighbours(v: V): List[V] = adj.getOrElse(v, Nil).filterNot(_ == v)\\n        \\n        def addEdge(from: V, to: V): UDG[V] = {\\n            val forward = to :: neighbours(from)\\n            val reverse = from :: neighbours(to)\\n            UDG(adj + (from -> forward.distinct) + (to -> reverse.distinct))\\n        }\\n        \\n        def removeNode(v: V): UDG[V] = {\\n            UDG(adj.filter { case (k, _) => k != v }. map { \\n                case (k, l) => k -> l.filterNot(li => li == v)\\n            })\\n        }\\n        \\n        def traverse(v: V, visited: Set[V]): Set[V] = {\\n            if (visited.contains(v)) visited\\n            else {\\n                neighbours(v).foldLeft(visited + v) {\\n                    case (s, n) => traverse(n, s)\\n                }\\n            }\\n        }\\n    }\\n    \\n    case class DFSTraversal(items: Set[Int])\\n    \\n\\n    def countHighestScoreNodes(parents: Array[Int]): Int = {\\n        val init = UDG[Int](Map())\\n        val graph = parents.zipWithIndex.foldLeft(init) {\\n            case (g, (-1, n)) => g\\n            case (g, (p, n)) => g.addEdge(n, p)\\n        }\\n        \\n        \\n        case class Acc(visited: Set[Int], score: Int)\\n        val gatherScores = parents.indices.map {\\n            n =>\\n              val withRemoved = graph.removeNode(n)\\n              val acc = Acc(Set(), 1)\\n              withRemoved.vertices.foldLeft(acc) {\\n                  case (Acc(set, scr), v) =>\\n                    val newSet = withRemoved.traverse(v, set)\\n                    if (newSet.size == set.size) Acc(set, scr)\\n                    else Acc(newSet, scr * (newSet -- set).size)\\n              }\\n        }\\n        \\n        val scores = gatherScores.map(_.score)\\n        val maxScore = scores.max\\n        scores.count(_ == maxScore)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535758,
                "title": "simple-python-solution-dfs",
                "content": "\\nApproach:\\n* `getRootNode`  -->   I have used a dictionary to create a tree (class: `TreeNode`)\\n* `updateCount`  -->   Used DFS to update count of each subtree (count = number of nodes in that subtree)\\n* `getHighestScoreCount`  -->   Used DFS to get count of highest score\\n\\nTime complexity: `O(n)`\\n\\nSolution:\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, count=0, left=None, right=None):\\n        self.count = count\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def updateCount(self, root):\\n        if root is None:\\n            return 0\\n\\n        count = 1\\n        count += self.updateCount(root.left)\\n        count += self.updateCount(root.right)\\n        root.count = count\\n\\n        return count\\n\\n\\n    def getHighestScoreCount(self, root, totalCount):\\n        if root is None:\\n            return 0, 0\\n\\n        highestScore = (\\n            ((totalCount - root.count) if (totalCount - root.count) else 1)\\n            * (root.left.count if root.left else 1)\\n            * (root.right.count if root.right else 1)\\n        )\\n        highestScoreCount = 1\\n\\n        score, scoreCount = self.getHighestScoreCount(root.left, totalCount)\\n        if score > highestScore:\\n            highestScore = score\\n            highestScoreCount = scoreCount\\n        elif score == highestScore:\\n            highestScoreCount += scoreCount\\n\\n        score, scoreCount = self.getHighestScoreCount(root.right, totalCount)\\n        if score > highestScore:\\n            highestScore = score\\n            highestScoreCount = scoreCount\\n        elif score == highestScore:\\n            highestScoreCount += scoreCount\\n\\n        return highestScore, highestScoreCount\\n\\n\\n    def getRootNode(self, parents):\\n        mp = {}\\n        for i in range(len(parents)):\\n            if i not in mp:\\n                mp[i] = TreeNode()\\n\\n            if parents[i] not in mp:\\n                mp[parents[i]] = TreeNode()\\n\\n            if mp[parents[i]].left is None:\\n                mp[parents[i]].left = mp[i]\\n            else:\\n                mp[parents[i]].right = mp[i]\\n\\n        return mp[-1].left\\n\\n\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        root = self.getRootNode(parents)\\n        self.updateCount(root)\\n        _, count = self.getHighestScoreCount(root, len(parents))\\n\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass TreeNode:\\n    def __init__(self, count=0, left=None, right=None):\\n        self.count = count\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def updateCount(self, root):\\n        if root is None:\\n            return 0\\n\\n        count = 1\\n        count += self.updateCount(root.left)\\n        count += self.updateCount(root.right)\\n        root.count = count\\n\\n        return count\\n\\n\\n    def getHighestScoreCount(self, root, totalCount):\\n        if root is None:\\n            return 0, 0\\n\\n        highestScore = (\\n            ((totalCount - root.count) if (totalCount - root.count) else 1)\\n            * (root.left.count if root.left else 1)\\n            * (root.right.count if root.right else 1)\\n        )\\n        highestScoreCount = 1\\n\\n        score, scoreCount = self.getHighestScoreCount(root.left, totalCount)\\n        if score > highestScore:\\n            highestScore = score\\n            highestScoreCount = scoreCount\\n        elif score == highestScore:\\n            highestScoreCount += scoreCount\\n\\n        score, scoreCount = self.getHighestScoreCount(root.right, totalCount)\\n        if score > highestScore:\\n            highestScore = score\\n            highestScoreCount = scoreCount\\n        elif score == highestScore:\\n            highestScoreCount += scoreCount\\n\\n        return highestScore, highestScoreCount\\n\\n\\n    def getRootNode(self, parents):\\n        mp = {}\\n        for i in range(len(parents)):\\n            if i not in mp:\\n                mp[i] = TreeNode()\\n\\n            if parents[i] not in mp:\\n                mp[parents[i]] = TreeNode()\\n\\n            if mp[parents[i]].left is None:\\n                mp[parents[i]].left = mp[i]\\n            else:\\n                mp[parents[i]].right = mp[i]\\n\\n        return mp[-1].left\\n\\n\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n\\n        root = self.getRootNode(parents)\\n        self.updateCount(root)\\n        _, count = self.getHighestScoreCount(root, len(parents))\\n\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531346,
                "title": "c-easy-to-understand-2d-vector-dfs-clean",
                "content": "Store the **parent child relation** between the nodes in whichever way you would (I went for **2D vector**), figure out the number of nodes (in the subtree) including the currnode, for every node of the tree.\\nThen, for every node, **deduct the number of nodes till currnode** from the number of nodes **till the root** and **add** the total nodes till **currnode->children**.\\nThis solution is comparatively, more aesthetic, or so I feel.\\nPlease upvote if you find the solution good.\\n***Thank You!!***\\n\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int func(vector<int>& sizes, vector<vector<int>>& children, int currnode = 0) {\\n        if(!children[currnode].size()) return sizes[currnode] = 1;\\n        for(int child : children[currnode]) {\\n            sizes[currnode] += func(sizes, children, child);\\n        }\\n        return (++sizes[currnode]);\\n    }\\n    ll func1(vector<int>& sizes, int currnode, vector<vector<int>>& children) {\\n        ll res = max(sizes[0] - sizes[currnode], 1);\\n        if(children[currnode].size()) {\\n            for(int child : children[currnode]) res *= sizes[child];\\n        }\\n        return res;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> children(n);\\n        for(int i=1;i<n;i++) {\\n            children[parents[i]].push_back(i);\\n        }\\n        vector<int> sizes(n);\\n        func(sizes, children);\\n        ll currmax= 0;int currval = 0;\\n        while(--n > -1) {\\n            ll currprod = func1(sizes, n, children);\\n            if(currmax < currprod) {\\n                currval = 1, currmax = currprod;\\n            }\\n            else if(currmax == currprod) currval++;\\n        }\\n        return currval;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int func(vector<int>& sizes, vector<vector<int>>& children, int currnode = 0) {\\n        if(!children[currnode].size()) return sizes[currnode] = 1;\\n        for(int child : children[currnode]) {\\n            sizes[currnode] += func(sizes, children, child);\\n        }\\n        return (++sizes[currnode]);\\n    }\\n    ll func1(vector<int>& sizes, int currnode, vector<vector<int>>& children) {\\n        ll res = max(sizes[0] - sizes[currnode], 1);\\n        if(children[currnode].size()) {\\n            for(int child : children[currnode]) res *= sizes[child];\\n        }\\n        return res;\\n    }\\n    int countHighestScoreNodes(vector<int>& parents) {\\n        int n = parents.size();\\n        vector<vector<int>> children(n);\\n        for(int i=1;i<n;i++) {\\n            children[parents[i]].push_back(i);\\n        }\\n        vector<int> sizes(n);\\n        func(sizes, children);\\n        ll currmax= 0;int currval = 0;\\n        while(--n > -1) {\\n            ll currprod = func1(sizes, n, children);\\n            if(currmax < currprod) {\\n                currval = 1, currmax = currprod;\\n            }\\n            else if(currmax == currprod) currval++;\\n        }\\n        return currval;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576435,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            },
            {
                "id": 1783822,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            },
            {
                "id": 1678483,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            },
            {
                "id": 2000302,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            },
            {
                "id": 1724509,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            },
            {
                "id": 1712357,
                "content": [
                    {
                        "username": "code77777",
                        "content": "problem should be in HARD category"
                    },
                    {
                        "username": "Serenaleetcode",
                        "content": "Any can explain why test case [-1,0] returns 2 instead of 1 ?"
                    },
                    {
                        "username": "_yen_0206",
                        "content": "Remove node 0 or remove node 1 have the same value. So there are \\'2\\' numbers."
                    },
                    {
                        "username": "NathanKys",
                        "content": "I really like this one.\\n\\nfirst try was DFS in undirected acyclic graph -> TLE\\nsecond with memo -> MLE\\nthird the last, AC\\n\\ntaught me a lot, how to twist the pov to solve problem\\n"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Solved after taking so much time 😤"
                    },
                    {
                        "username": "uranus_avacado",
                        "content": "My first solution is exactly what the hints told us to do... Am I missing some methods to find size of each subtrees quickly? Ending up doing something way more complicated than what the hints suggested..."
                    },
                    {
                        "username": "CH_MAHENDER",
                        "content": "everything is same but still getting TLE error.\ncan anyone find out the mistake.\n\nthis solution gives TLE error::-\nclass Solution {\n    int getSize(int i,vector<vector<int> > mp, vector< int >& size_){\n        int c = 1;\n        for(int j=0;j<mp[i].size();j++){\n            c+=getSize(mp[i][j],mp,size_);\n        }\n        return size_[i] = c;\n    }\npublic:\n    int countHighestScoreNodes(vector<int>& p) {\n        int n=p.size();\n        vector<vector<int> > mp(n);\n        vector<int> size_(n,0);\n        for(int i=1;i<n;i++){\n            mp[p[i]].push_back(i);   \n        }\n        getSize(0,mp,size_);\n        int mx=-1, c=0;\n        for(int i=0;i<n;i++){\n            long long tot=1;\n            tot = max(tot,(long long)n - size_[i]);\n            for(auto j=0;j<mp[i].size();j++){\n                tot*=size_[mp[i][j]];\n            }    \n            if(tot>mx){\n                mx=tot;\n                c=1;\n            }\n            else if(tot==mx){\n                c++;\n            }\n        }\n        return c;\n    }\n};\n============================================================\nbut this get executed without TLE:\n\n\nclass Solution {\n     int helper(int src,vector<vector<int>>& g,vector<int>& size){\n         int ans = 1;\n         for(auto child:g[src]){\n             ans += helper(child,g,size);\n         }\n         return size[src] = ans; \n     }   \npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<int> size(n,0);  // size[i] indicates size of subtree(rooted at i node) + 1\n        vector<vector<int>> g(n); // storing left and right child of a node\n        for(int i=1;i<n;i++){\n            g[parents[i]].push_back(i);\n        }\n        helper(0,g,size);  // calculating size of each subtree\n        long long cnt = 0, maxi = 0;\n        for(int i=0;i<n;i++){\n            long long pro = 1; \n            pro = max(pro,(long long)n - size[i]); // calculating leftover nodes excluding child nodes \n            for(auto node:g[i]){\n                pro = pro * size[node]; // multiplying with size of subtree\n            }\n            if(pro > maxi){\n                maxi = pro;\n                cnt = 1;\n            }\n            else if(pro == maxi){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}; "
                    }
                ]
            }
        ]
    }
]