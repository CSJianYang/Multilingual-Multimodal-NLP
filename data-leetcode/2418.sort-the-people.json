[
    {
        "title": "Sort the People",
        "question_content": "You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\nFor each index i, names[i] and heights[i] denote the name and height of the ith person.\nReturn names sorted in descending order by the people's heights.\n&nbsp;\nExample 1:\n\nInput: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\nOutput: [\"Mary\",\"Emma\",\"John\"]\nExplanation: Mary is the tallest, followed by Emma and John.\n\nExample 2:\n\nInput: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\nOutput: [\"Bob\",\"Alice\",\"Bob\"]\nExplanation: The first Bob is the tallest, followed by Alice and the second Bob.\n\n&nbsp;\nConstraints:\n\n\tn == names.length == heights.length\n\t1 <= n <= 103\n\t1 <= names[i].length <= 20\n\t1 <= heights[i] <= 105\n\tnames[i] consists of lower and upper case English letters.\n\tAll the values of heights are distinct.",
        "solutions": [
            {
                "id": 2620605,
                "title": "c-4-solutions-pairs-comparator",
                "content": "**1. With Vector of Pairs**\\nJust sort the pair vector in which we will store the height in first part of pair.\\n\\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> A;\\n        int N = names.size();\\n        for(int i = 0; i < N; i++) {\\n            A.push_back({heights[i], names[i]});\\n        }\\n\\n        sort(A.rbegin(), A.rend());\\n\\n        vector<string> ans;\\n        for(int i = 0; i < N; i++) {\\n            ans.push_back(A[i].second);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**EDIT 1**\\n**Optimization** suggested by @dvisp - No need to create answer vector.\\n```cpp\\nfor(int i = 0; i < N; i++) {\\n\\tnames[i] = A[i].second;\\n}\\nreturn names;\\n```\\n\\n**2. Using Custom Comparator**\\nCreate separate vector and sort its index as per heights vector. Use those index to put names in answer. \\n\\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<int> idx(names.size());\\n        for (int i = 0; i < names.size(); ++i) {\\n            idx[i] = i;\\n        }\\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\\n            return heights[i] > heights[j];\\n        });\\n        vector<string> ans(names.size());\\n        for (int i = 0; i < names.size(); ++i) {\\n            ans[i] = names[idx[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**3. Priority Queue**  ( Solution by @secretsuccess291)\\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        priority_queue<pair<int, string>> pq;\\n        \\n        for(int i = 0; i < heights.size(); i++){\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        \\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n}\\n```\\n\\n**4. Map**\\nSolution suggested by @raunak_pandey\\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string>mp;\\n        vector<string>v;\\n        for(int i=0; i < size(names); i++)\\n            mp[heights[i]] = names[i];\\n        for (auto i = mp.rbegin(); i != mp.rend(); ++i) v.push_back(i->second);\\n        return v;\\n}\\n```\\n\\n**Related Problems**\\n[Sort Array By Parity](https://leetcode.com/problems/sort-array-by-parity/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> A;\\n        int N = names.size();\\n        for(int i = 0; i < N; i++) {\\n            A.push_back({heights[i], names[i]});\\n        }\\n\\n        sort(A.rbegin(), A.rend());\\n\\n        vector<string> ans;\\n        for(int i = 0; i < N; i++) {\\n            ans.push_back(A[i].second);\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\nfor(int i = 0; i < N; i++) {\\n\\tnames[i] = A[i].second;\\n}\\nreturn names;\\n```\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<int> idx(names.size());\\n        for (int i = 0; i < names.size(); ++i) {\\n            idx[i] = i;\\n        }\\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\\n            return heights[i] > heights[j];\\n        });\\n        vector<string> ans(names.size());\\n        for (int i = 0; i < names.size(); ++i) {\\n            ans[i] = names[idx[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        priority_queue<pair<int, string>> pq;\\n        \\n        for(int i = 0; i < heights.size(); i++){\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        \\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n}\\n```\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string>mp;\\n        vector<string>v;\\n        for(int i=0; i < size(names); i++)\\n            mp[heights[i]] = names[i];\\n        for (auto i = mp.rbegin(); i != mp.rend(); ++i) v.push_back(i->second);\\n        return v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620498,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620653,
                "title": "python3-sort-o-n-log-n-beginner-friendly",
                "content": "First, put the height and name into one array, then sort the array in decreasing order, finally only return the name in the array.\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        res = []\\n        for i in range(len(names)):\\n            res.append([heights[i],names[i]])\\n        res = sorted(res,reverse=True)\\n        return [name for height,name in res]\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        res = []\\n        for i in range(len(names)):\\n            res.append([heights[i],names[i]])\\n        res = sorted(res,reverse=True)\\n        return [name for height,name in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623032,
                "title": "c-6-different-approaches-pairs-hash-map-sort-permutation-map-bubble-and-selection-sort",
                "content": "I think my new favorite for this type of problem is approach 3, finding and applying a sort permutation. Please take the runtimes with a grain of salt. These are not microbenchmarks and the runtimes vary quite a bit on LC between submissions.\\n\\n### Approach 1: make_pairs, sort, unpack (52ms resp. 44ms)\\n\\nI am using ```std::transform``` instead of raw loops for making pairs and unpacking them again. To be fair the code using raw loops is even a bit shorter. :)\\n\\n```cpp\\n    static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n        // make pairs\\n        vector<pair<int, string>> tmp;\\n        tmp.reserve(size(names));\\n        transform(begin(names), end(names), begin(heights), back_inserter(tmp),\\n                 [](const string& name, int height) { return make_pair(height, name); });\\n        // sort\\n        sort(begin(tmp), end(tmp), greater<>());\\n        // unpack\\n        vector<string> ans;\\n        ans.reserve(size(tmp));\\n        transform(begin(tmp), end(tmp), back_inserter(ans), [](pair<int, string>& p) { return move(p.second); });\\n        return ans;\\n    }\\n```\\n\\nA variant of this idea is the use a ```pair<int, int>```, i.e. the height and the index of the name. This is faster than the above approach (44ms):\\n\\n```cpp\\n     static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n        // make pairs\\n        vector<pair<int, int>> tmp;\\n        tmp.reserve(size(names));\\n        for (int i = 0; i < size(names); ++i) tmp.emplace_back(heights[i], i);\\n        // sort\\n        sort(begin(tmp), end(tmp), greater<>());\\n        // unpack\\n        vector<string> ans;\\n        ans.reserve(size(tmp));\\n        transform(begin(tmp), end(tmp), back_inserter(ans), [&](pair<int, int>& p) { return move(names[p.second]); });\\n        return ans;\\n    }\\n```\\n\\n### Approach 2: hash map (57ms)\\n\\nThe names are not unique so we can not have a map from names to height and use that for sorting, but the heights are so we can index on that. **Unlike most other approaches in this post, this one only works because the values in heights are unique.**\\n\\n```cpp\\n    static vector<string> sortPeople(const vector<string>& names, vector<int>& heights) {\\n        unordered_map<int, string> hn;\\n        for (int i = 0; i < size(names); ++i) hn[heights[i]] = names[i];\\n        sort(begin(heights), end(heights), greater<>());\\n        vector<string> ans;\\n        ans.reserve(size(names));\\n        transform(begin(heights), end(heights), back_inserter(ans),\\n                 [&](int a) { return hn[a]; });\\n        return ans;\\n    }\\n```\\n\\n### Approch 3: find and apply sort permutation (fastest, 22ms)\\n\\nA different approach is the find and then apply a sort permutation. We use the ```heights``` vector to find the permutation and then apply it to the ```names``` vector. I think this approach is particular interesting of the object we want sort is expensive to move.\\n\\n```cpp\\n    static vector<string> sortPeople(vector<string>& names, const vector<int>& heights) {\\n        // find sort permutation\\n        vector<int> perm(size(names));\\n        iota(begin(perm), end(perm), 0);\\n        sort(begin(perm), end(perm), [&](int a, int b) {\\n            return heights[a] > heights[b];\\n        });\\n        // apply sort permutation\\n        vector<string> ans;\\n        ans.reserve(size(names));\\n        transform(begin(perm), end(perm), back_inserter(ans),\\n                 [&](int a) { return move(names[a]); });\\n        return ans;\\n    }\\n```\\n\\n### Approach 4: map (70ms)\\n\\nThis is inspired by a post from @harsh_negi_07 and one by @raunak__pandey. If we insert the elements into a ```std::map``` they are sorted right away, and we can do this because the heights are unique. Note that we use a different comperator for the map and with that the elements are in decending order. **Unlike most other approaches in this post, this one only works because the values in heights are unique.**\\n\\n```cpp\\n     static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n         map<int, string, greater<>> m;\\n         for (int i = 0; i < size(names); ++i) m[heights[i]] = names[i];\\n         vector<string> ans;\\n         ans.reserve(size(names));\\n         for (auto& [h, n] : m) ans.push_back(n);\\n         return ans;\\n    }\\n```\\n\\n### Approach 5: bubble sort (370ms)\\n\\n```\\n    static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        for (int n = size(names); n > 1; --n) {\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (heights[i] < heights[i + 1]) {\\n                    swap(heights[i], heights[i + 1]);\\n                    swap(names[i], names[i + 1]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n```\\n\\nEven a slightly more optimized bubble sort doesn\\'t really make a difference here:\\n\\n```cpp\\n    static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int n = size(names);\\n        bool swapped;\\n        do {\\n            swapped = false;\\n            for (int i = 1; i <= n - 1; ++i) {\\n                if (heights[i - 1] < heights[i]) {\\n                    swap(heights[i - 1], heights[i]);\\n                    swap(names[i - 1], names[i]);\\n                    swapped = true;\\n                }\\n            }\\n            --n;\\n        } while (swapped);\\n        return names;\\n    }\\n```\\n\\n### Approach 6: selection sort (48ms)\\n\\nThis is actually much better than I thought runtime wise and the implementation is pretty short too.\\n\\n```cpp\\n     static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n         for (int i = 0; i < size(heights); ++i) {\\n             const int mx = distance(begin(heights), max_element(next(begin(heights), i), end(heights)));\\n             swap(heights[i], heights[mx]);\\n             swap(names[i], names[mx]);\\n         }\\n         return names;\\n    }\\n```\\n\\n_As always: Feedback, comments, and questions are welcome, and please leave a like. :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```std::transform```\n```cpp\\n    static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n        // make pairs\\n        vector<pair<int, string>> tmp;\\n        tmp.reserve(size(names));\\n        transform(begin(names), end(names), begin(heights), back_inserter(tmp),\\n                 [](const string& name, int height) { return make_pair(height, name); });\\n        // sort\\n        sort(begin(tmp), end(tmp), greater<>());\\n        // unpack\\n        vector<string> ans;\\n        ans.reserve(size(tmp));\\n        transform(begin(tmp), end(tmp), back_inserter(ans), [](pair<int, string>& p) { return move(p.second); });\\n        return ans;\\n    }\\n```\n```pair<int, int>```\n```cpp\\n     static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n        // make pairs\\n        vector<pair<int, int>> tmp;\\n        tmp.reserve(size(names));\\n        for (int i = 0; i < size(names); ++i) tmp.emplace_back(heights[i], i);\\n        // sort\\n        sort(begin(tmp), end(tmp), greater<>());\\n        // unpack\\n        vector<string> ans;\\n        ans.reserve(size(tmp));\\n        transform(begin(tmp), end(tmp), back_inserter(ans), [&](pair<int, int>& p) { return move(names[p.second]); });\\n        return ans;\\n    }\\n```\n```cpp\\n    static vector<string> sortPeople(const vector<string>& names, vector<int>& heights) {\\n        unordered_map<int, string> hn;\\n        for (int i = 0; i < size(names); ++i) hn[heights[i]] = names[i];\\n        sort(begin(heights), end(heights), greater<>());\\n        vector<string> ans;\\n        ans.reserve(size(names));\\n        transform(begin(heights), end(heights), back_inserter(ans),\\n                 [&](int a) { return hn[a]; });\\n        return ans;\\n    }\\n```\n```heights```\n```names```\n```cpp\\n    static vector<string> sortPeople(vector<string>& names, const vector<int>& heights) {\\n        // find sort permutation\\n        vector<int> perm(size(names));\\n        iota(begin(perm), end(perm), 0);\\n        sort(begin(perm), end(perm), [&](int a, int b) {\\n            return heights[a] > heights[b];\\n        });\\n        // apply sort permutation\\n        vector<string> ans;\\n        ans.reserve(size(names));\\n        transform(begin(perm), end(perm), back_inserter(ans),\\n                 [&](int a) { return move(names[a]); });\\n        return ans;\\n    }\\n```\n```std::map```\n```cpp\\n     static vector<string> sortPeople(const vector<string>& names, const vector<int>& heights) {\\n         map<int, string, greater<>> m;\\n         for (int i = 0; i < size(names); ++i) m[heights[i]] = names[i];\\n         vector<string> ans;\\n         ans.reserve(size(names));\\n         for (auto& [h, n] : m) ans.push_back(n);\\n         return ans;\\n    }\\n```\n```\\n    static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        for (int n = size(names); n > 1; --n) {\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (heights[i] < heights[i + 1]) {\\n                    swap(heights[i], heights[i + 1]);\\n                    swap(names[i], names[i + 1]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n```\n```cpp\\n    static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int n = size(names);\\n        bool swapped;\\n        do {\\n            swapped = false;\\n            for (int i = 1; i <= n - 1; ++i) {\\n                if (heights[i - 1] < heights[i]) {\\n                    swap(heights[i - 1], heights[i]);\\n                    swap(names[i - 1], names[i]);\\n                    swapped = true;\\n                }\\n            }\\n            --n;\\n        } while (swapped);\\n        return names;\\n    }\\n```\n```cpp\\n     static vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n         for (int i = 0; i < size(heights); ++i) {\\n             const int mx = distance(begin(heights), max_element(next(begin(heights), i), end(heights)));\\n             swap(heights[i], heights[mx]);\\n             swap(names[i], names[mx]);\\n         }\\n         return names;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620751,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n\\t\\t// {height, name}\\n        vector<pair<int, string>> v;\\n\\t\\t// by putting height at first, we can skip writing a comparator as it\\'ll sort by first element of the pair\\n        for (int i = 0; i < names.size(); i++) v.push_back({heights[i], names[i]});\\n\\t\\t// sort in decreasing order\\n        sort(v.rbegin(), v.rend());\\n\\t\\t// build the final ans. x.second is the name.\\n        for (auto & x : v) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n\\t\\t// {height, name}\\n        vector<pair<int, string>> v;\\n\\t\\t// by putting height at first, we can skip writing a comparator as it\\'ll sort by first element of the pair\\n        for (int i = 0; i < names.size(); i++) v.push_back({heights[i], names[i]});\\n\\t\\t// sort in decreasing order\\n        sort(v.rbegin(), v.rend());\\n\\t\\t// build the final ans. x.second is the name.\\n        for (auto & x : v) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621386,
                "title": "java-simple-treemap",
                "content": "```\\nclass Solution {\\n  public String[] sortPeople(String[] names, int[] heights) {\\n      \\n    String[] result = new String[names.length];\\n      \\n    TreeMap < Integer, String > map = new TreeMap < > (Collections.reverseOrder());\\n\\n    for (int i = 0; i < names.length; i++) {\\n      map.put(heights[i], names[i]);           // Heights in descending order\\n    }\\n\\n    int i = 0;\\n    for (int h: map.keySet()) {\\n      result[i++] = map.get(h);               // Iterate TreeMap\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n  public String[] sortPeople(String[] names, int[] heights) {\\n      \\n    String[] result = new String[names.length];\\n      \\n    TreeMap < Integer, String > map = new TreeMap < > (Collections.reverseOrder());\\n\\n    for (int i = 0; i < names.length; i++) {\\n      map.put(heights[i], names[i]);           // Heights in descending order\\n    }\\n\\n    int i = 0;\\n    for (int h: map.keySet()) {\\n      result[i++] = map.get(h);               // Iterate TreeMap\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916689,
                "title": "python-98-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        height_dict = dict(zip(heights,names)) # // height_dict = {180: \\'Mary\\', 165: \\'John\\', 170: \\'Emma\\'}\\n        names.clear()\\n        for key in sorted(height_dict.keys(),reverse=True):\\n            names.append(height_dict[key])\\n        return names\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        height_dict = dict(zip(heights,names)) # // height_dict = {180: \\'Mary\\', 165: \\'John\\', 170: \\'Emma\\'}\\n        names.clear()\\n        for key in sorted(height_dict.keys(),reverse=True):\\n            names.append(height_dict[key])\\n        return names\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625120,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*logn)**\\n```java []\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int length = heights.length;\\n        Map<Integer, String> map = new HashMap();\\n        for(int i=0; i<length; i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[] res = new String[length];\\n        for(int i=length-1, j=0; i>=0; i--){\\n            res[j++] = map.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```javascript []\\nvar sortPeople = function(names, heights) {\\n    let length = heights.length;\\n    let map = new Map();\\n    for(let i=0; i<length; i++){\\n        map.set(heights[i], names[i]);\\n    }\\n    heights.sort((a,b) => b-a);\\n    let res = [];\\n    for(let height of heights){\\n        res.push(map.get(height));\\n    }\\n    return res;\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def sortPeople(self, names, heights):\\n        length = len(heights)\\n        mymap = {}\\n        for i in range(length):\\n            mymap[heights[i]] = names[i]\\n        heights.sort(reverse=True)\\n        res = []\\n        for height in heights:\\n            res.append(mymap[height])\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int length = heights.length;\\n        Map<Integer, String> map = new HashMap();\\n        for(int i=0; i<length; i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[] res = new String[length];\\n        for(int i=length-1, j=0; i>=0; i--){\\n            res[j++] = map.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```javascript []\\nvar sortPeople = function(names, heights) {\\n    let length = heights.length;\\n    let map = new Map();\\n    for(let i=0; i<length; i++){\\n        map.set(heights[i], names[i]);\\n    }\\n    heights.sort((a,b) => b-a);\\n    let res = [];\\n    for(let height of heights){\\n        res.push(map.get(height));\\n    }\\n    return res;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def sortPeople(self, names, heights):\\n        length = len(heights)\\n        mymap = {}\\n        for i in range(length):\\n            mymap[heights[i]] = names[i]\\n        heights.sort(reverse=True)\\n        res = []\\n        for height in heights:\\n            res.append(mymap[height])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627285,
                "title": "python3-2-lines-with-example-t-m-42ms-14-3mb",
                "content": "```\\nclass Solution:                   # Ex: names = [\"Larry\",\"Curly\",\"Moe\"]   heights = [130,125,155] \\n\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\n        _,names = zip(*sorted(zip(heights,names), reverse = True))   \\n                                  # zipped   --> [(130,\"Larry\"), (125,\"Curly\"), (155,\"Moe\")  ]\\n                                  # sorted   --> [(155,\"Moe\"  ), (130,\"Larry\"), (125,\"Curly\")]\\n                                  # unzipped --> _ = (155,130,125) , names = (\"Moe\",\"Larry\",\"Curly\")\\n        \\n\\t\\treturn  list(names)       # list(names) = [\"Moe\",\"Larry\",\"Curly\"]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:                   # Ex: names = [\"Larry\",\"Curly\",\"Moe\"]   heights = [130,125,155] \\n\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\n        _,names = zip(*sorted(zip(heights,names), reverse = True))   \\n                                  # zipped   --> [(130,\"Larry\"), (125,\"Curly\"), (155,\"Moe\")  ]\\n                                  # sorted   --> [(155,\"Moe\"  ), (130,\"Larry\"), (125,\"Curly\")]\\n                                  # unzipped --> _ = (155,130,125) , names = (\"Moe\",\"Larry\",\"Curly\")\\n        \\n\\t\\treturn  list(names)       # list(names) = [\"Moe\",\"Larry\",\"Curly\"]",
                "codeTag": "Java"
            },
            {
                "id": 3122301,
                "title": "python-easy-to-understand-for-beginners",
                "content": "\\n# Approach\\nusing zip easy..... \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        a=zip(heights,names)\\n        l=[]\\n        for i,j in sorted(a):\\n            l.append(j)\\n        return l[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        a=zip(heights,names)\\n        l=[]\\n        for i,j in sorted(a):\\n            l.append(j)\\n        return l[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674518,
                "title": "easy-c-solution-using-map-vector-and-sort-35-ms-faster-than-94-56-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> v;\\n        for(int i=0;i<heights.size();i++){\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.begin(),v.end(),greater<>());\\n        vector<string> ans;\\n        for(auto it : v)\\n            ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```\\nIn this problem you **don\\'t need to use compare** as we just have to **sort the element on the basis of one element only that is in this case is the height.**\\nI have inserted the **first element of the pair in vector as the height** becuase when we apply the sort inbuilt function then it will sort it on the basis of first element only.\\nUsed greater inside the sort function because we first want the person with larger height first (basically to sort in descending order)\\nIf you like the approach please Upvote it. and feel free to ask any queries regarding the logic.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> v;\\n        for(int i=0;i<heights.size();i++){\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.begin(),v.end(),greater<>());\\n        vector<string> ans;\\n        for(auto it : v)\\n            ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627803,
                "title": "python-elegant-short-one-line",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [name for _, name in sorted(zip(heights, names), reverse=True)]\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [name for _, name in sorted(zip(heights, names), reverse=True)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622312,
                "title": "swift-one-line-solution-o-nlogn",
                "content": "```\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] {\\n        zip(names, heights).sorted(by: { $0.1 > $1.1 }).map(\\\\.0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] {\\n        zip(names, heights).sorted(by: { $0.1 > $1.1 }).map(\\\\.0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620867,
                "title": "java-1-d-array-solution",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        \\n        String[] res = new String[names.length];\\n        int[] indexOfNames = new int[100001];\\n        \\n        for(int i = 0; i < heights.length; i++){\\n            indexOfNames[heights[i]] = i;\\n        }\\n            \\n        Arrays.sort(heights);\\n        \\n        for(int i = 0; i < heights.length; i++){\\n            res[heights.length - i - 1] = names[indexOfNames[heights[i]]];        \\n        }\\n        \\n        return res;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        \\n        String[] res = new String[names.length];\\n        int[] indexOfNames = new int[100001];\\n        \\n        for(int i = 0; i < heights.length; i++){\\n            indexOfNames[heights[i]] = i;\\n        }\\n            \\n        Arrays.sort(heights);\\n        \\n        for(int i = 0; i < heights.length; i++){\\n            res[heights.length - i - 1] = names[indexOfNames[heights[i]]];        \\n        }\\n        \\n        return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227917,
                "title": "best-java-code-easy-to-understand",
                "content": "# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\nA function sortPeople that takes in two arguments - an array of strings names and an array of integers heights. The function creates an empty TreeMap where the keys are integers and the values are strings.\\n\\nFirst loop iterates through the heights array and adds each integer element as a key to the TreeMap, with the corresponding string element in the names array as its value. TreeMap automatically sorts the keys in ascending order.\\n\\nA new string array sortName of the same length as the names array, and initializes an integer variable i to the index of the last element in sortName.\\n\\nSecond loop iterates through the keys in the TreeMap in ascending order. It assigns the corresponding value of each key to the current index of sortName, and then decrements i to move on to the next index in sortName. This effectively puts the values of names array in descending order based on the corresponding heights array values.\\n\\nFinally, the sorted sortName array is returned.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-------------------------------**VOTE UP**-----------------------------------\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        TreeMap<Integer,String> treeMap = new TreeMap<>();\\n\\n        for (int i=0; i<heights.length; i++){\\n            treeMap.put(heights[i],names[i]);\\n        }\\n\\n        String[] sortName= new String[names.length];\\n        int i=sortName.length-1;\\n\\n        for (int sort : treeMap.keySet()){\\n            sortName[i]=treeMap.get(sort);\\n            i--;\\n        }\\n        return sortName;\\n\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string> treeMap;\\n\\n        for (int i = 0; i < heights.size(); i++) {\\n            treeMap[heights[i]] = names[i];\\n        }\\n\\n        vector<string> sortedNames(names.size());\\n        int i =0;\\n\\n        for (auto it = treeMap.rbegin(); it != treeMap.rend(); it++) {\\n            sortedNames[i] = it->second;\\n            i++;\\n        }\\n        return sortedNames;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        a=zip(heights,names)\\n        l=[]\\n        for i,j in sorted(a):\\n            l.append(j)\\n        return l[::-1]\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```Java []\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        TreeMap<Integer,String> treeMap = new TreeMap<>();\\n\\n        for (int i=0; i<heights.length; i++){\\n            treeMap.put(heights[i],names[i]);\\n        }\\n\\n        String[] sortName= new String[names.length];\\n        int i=sortName.length-1;\\n\\n        for (int sort : treeMap.keySet()){\\n            sortName[i]=treeMap.get(sort);\\n            i--;\\n        }\\n        return sortName;\\n\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string> treeMap;\\n\\n        for (int i = 0; i < heights.size(); i++) {\\n            treeMap[heights[i]] = names[i];\\n        }\\n\\n        vector<string> sortedNames(names.size());\\n        int i =0;\\n\\n        for (auto it = treeMap.rbegin(); it != treeMap.rend(); it++) {\\n            sortedNames[i] = it->second;\\n            i++;\\n        }\\n        return sortedNames;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        a=zip(heights,names)\\n        l=[]\\n        for i,j in sorted(a):\\n            l.append(j)\\n        return l[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698889,
                "title": "javascript",
                "content": "```\\nvar sortPeople = function(names, heights) {\\n    let output = []\\n    \\n\\t// let\\'s concatenate the arrays to sort later\\n    for (let i in heights) {\\n        output.push({name: names[i], height: heights[i]})\\n    }\\n    \\n    return output\\n        .sort((a,b) => b.height - a.height) // sort\\n        .map(i => i.name) // cut needed\\n};\\n\\n```\\n\\nplease upvote, if you cool :)",
                "solutionTags": [],
                "code": "```\\nvar sortPeople = function(names, heights) {\\n    let output = []\\n    \\n\\t// let\\'s concatenate the arrays to sort later\\n    for (let i in heights) {\\n        output.push({name: names[i], height: heights[i]})\\n    }\\n    \\n    return output\\n        .sort((a,b) => b.height - a.height) // sort\\n        .map(i => i.name) // cut needed\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620813,
                "title": "maxheap-easy-for-begineer-solution",
                "content": "```\\n vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       priority_queue<pair<int,string>>maxh;\\n        vector<string>res;\\n        int n=heights.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            maxh.push({heights[i],names[i]});\\n        }\\n        while(maxh.size()>0)\\n        {\\n            res.push_back(maxh.top().second);\\n            maxh.pop();\\n        }\\n        return res;\\n    }\\n};\\n// if you understand please upvote\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       priority_queue<pair<int,string>>maxh;\\n        vector<string>res;\\n        int n=heights.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            maxh.push({heights[i],names[i]});\\n        }\\n        while(maxh.size()>0)\\n        {\\n            res.push_back(maxh.top().second);\\n            maxh.pop();\\n        }\\n        return res;\\n    }\\n};\\n// if you understand please upvote\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152874,
                "title": "array-sort",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) \\n    {\\n        Array.Sort(heights, names); \\n        var name = names.ToList<string>();\\n        name.Reverse();\\n        return name.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) \\n    {\\n        Array.Sort(heights, names); \\n        var name = names.ToList<string>();\\n        name.Reverse();\\n        return name.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653798,
                "title": "4liner-very-easy-javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function (names, heights) {\\n  //creating a array to store name , height as key value pair\\n  let d = [];\\n  for (let i = 0; i < names.length; i++) {\\n    d.push([names[i], heights[i]]);\\n  }\\n  //sorting heights based on decending order\\n  d.sort((a, b) => b[1] - a[1]);\\n\\n  d = d.map((x) => x[0]);\\n  return d;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function (names, heights) {\\n  //creating a array to store name , height as key value pair\\n  let d = [];\\n  for (let i = 0; i < names.length; i++) {\\n    d.push([names[i], heights[i]]);\\n  }\\n  //sorting heights based on decending order\\n  d.sort((a, b) => b[1] - a[1]);\\n\\n  d = d.map((x) => x[0]);\\n  return d;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621146,
                "title": "c-easy-solution",
                "content": "Simply store given two vectors into a new vector of type pair and reverse sort it \\nand store the names into the names vector.\\n\\n\\n```\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> A;\\n        int N = names.size();\\n        for(int i = 0; i < N; i++) {\\n            A.push_back({heights[i], names[i]});\\n        }\\n\\n        sort(A.rbegin(), A.rend());\\n\\n        for(int i = 0; i < N; i++) {\\n            names[i]=A[i].second;\\n        }\\n        return names;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> A;\\n        int N = names.size();\\n        for(int i = 0; i < N; i++) {\\n            A.push_back({heights[i], names[i]});\\n        }\\n\\n        sort(A.rbegin(), A.rend());\\n\\n        for(int i = 0; i < N; i++) {\\n            names[i]=A[i].second;\\n        }\\n        return names;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620491,
                "title": "c-pairing-sorting-simple-approach",
                "content": "**Please upvote if it helps :)**\\n```\\nclass Solution \\n{\\npublic:\\n    \\n    static bool comp(pair<int, string> &a, pair<int, string> &b) //this function sort in decreasing order\\n    {\\n        return a.first >= b.first;\\n    }\\n    \\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        vector<pair<int, string>> p;\\n        \\n        for(int i=0; i<names.size(); i++)\\n            p.push_back({heights[i], names[i]});\\n\\n        \\n        sort(p.begin(), p.end(), comp);\\n        \\n        vector<string> res;\\n        for(auto it:p)\\n            res.push_back(it.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    static bool comp(pair<int, string> &a, pair<int, string> &b) //this function sort in decreasing order\\n    {\\n        return a.first >= b.first;\\n    }\\n    \\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        vector<pair<int, string>> p;\\n        \\n        for(int i=0; i<names.size(); i++)\\n            p.push_back({heights[i], names[i]});\\n\\n        \\n        sort(p.begin(), p.end(), comp);\\n        \\n        vector<string> res;\\n        for(auto it:p)\\n            res.push_back(it.second);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774717,
                "title": "python-3-one-line-solutions-beats-96",
                "content": "```python3 []\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return[name for _, name in sorted(zip(heights, names), reverse = True)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return[name for _, name in sorted(zip(heights, names), reverse = True)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217001,
                "title": "java-easy-solution-o-n-time-complexity-using-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer,String> people = new TreeMap<>(Collections.reverseOrder());\\n        String[] str = new String[names.length];\\n        for(int i=0;i<names.length;i++)\\n            people.put(heights[i],names[i]);\\n        int i=0; \\n        for(Integer height:people.keySet())\\n            {\\n                str[i] = people.get(height);\\n                i++;\\n            }\\n\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer,String> people = new TreeMap<>(Collections.reverseOrder());\\n        String[] str = new String[names.length];\\n        for(int i=0;i<names.length;i++)\\n            people.put(heights[i],names[i]);\\n        int i=0; \\n        for(Integer height:people.keySet())\\n            {\\n                str[i] = people.get(height);\\n                i++;\\n            }\\n\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670358,
                "title": "python-one-liner-99-01-speed",
                "content": "Runtime: 111 ms, faster than 99.01% of Python3 online submissions for Sort the People.\\nMemory Usage: 14.4 MB, less than 89.45% of Python3 online submissions for Sort the People.\\n```\\nclass Solution:\\n    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:\\n        return [c for _, c in sorted(zip(h, n), reverse=True)]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "Runtime: 111 ms, faster than 99.01% of Python3 online submissions for Sort the People.\\nMemory Usage: 14.4 MB, less than 89.45% of Python3 online submissions for Sort the People.\\n```\\nclass Solution:\\n    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:\\n        return [c for _, c in sorted(zip(h, n), reverse=True)]",
                "codeTag": "Java"
            },
            {
                "id": 2648273,
                "title": "python-is-your-friend",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [b for a, b in sorted(zip(heights, names), reverse=True)]\\n```\\n**C++**\\nIf we want to avoid creating and sorting pairs, we can sort the index array.\\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n    vector<int> ids(names.size());\\n    vector<string> res;\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return heights[i] > heights[j]; });\\n    transform(begin(ids), end(ids), back_inserter(res), [&](int i) { return names[i]; });\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [b for a, b in sorted(zip(heights, names), reverse=True)]\\n```\n```cpp\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n    vector<int> ids(names.size());\\n    vector<string> res;\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return heights[i] > heights[j]; });\\n    transform(begin(ids), end(ids), back_inserter(res), [&](int i) { return names[i]; });\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620724,
                "title": "c-brute-force-solution-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int n = names.size();\\n        vector<pair<int, string>> p;\\n        for(int i=0; i<n; i++) {\\n            p.push_back({heights[i], names[i]});\\n        }\\n        \\n        // sort heights in descending order using c++ STL :)\\n        sort(p.rbegin(), p.rend());\\n        \\n        vector<string> ans;\\n        for(auto it : p) {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int n = names.size();\\n        vector<pair<int, string>> p;\\n        for(int i=0; i<n; i++) {\\n            p.push_back({heights[i], names[i]});\\n        }\\n        \\n        // sort heights in descending order using c++ STL :)\\n        sort(p.rbegin(), p.rend());\\n        \\n        vector<string> ans;\\n        for(auto it : p) {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620723,
                "title": "java-build-in-sort-easy-to-understand",
                "content": "\\nwe cannot sort input heights directly, because after sorted it we cannot know which height is belong to which person.\\n\\nSo before sort, we need to add some extra information (in this case is \"indices\") to heights.\\nJust image sorting \"heights\" and every \"height\" has a name tag on them, using the name tag we can know it\\'s who\\'s height.\\nThis is the  2D array comes from. \\n\\nThen we can use build-in sort to sort the 2d array. \\nAfter sorted, we can get name via indices.\\n\\n```\\n\\n\\t//Runtime: 9 ms, faster than 80.00% of Java online submissions for Sort the People.\\n    //Memory Usage: 42.9 MB, less than 100.00% of Java online submissions for Sort the People.\\n    //build-in sort\\n    //Time: O(NlgN + N); Space: O(N + lgN)\\n    //Time: O(NlgN); Space: O(N)\\n    public String[] sortPeople(String[] names, int[] heights) {\\n\\n        //Space: O(N)\\n\\t\\t//form a 2D array using people\\'s height and their position in original array.\\n        int[][] people = new int[names.length][2];\\n        for (int i = 0; i < names.length; i++)\\n            people[i]  = new int[] {heights[i], i};\\n\\n        //Time: O(NlgN); Space: O(lgN)\\n\\t\\t//sort in descending order by the people\\'s heights.\\n        Arrays.sort(people, (a, b) -> b[0] - a[0]);\\n\\n        String[] res = new String[names.length];\\n        //Time: O(N)\\n\\t\\t//Get result from sorted array. \\n        for (int i = 0; i < names.length; i++)\\n            res[i] = names[people[i][1]];\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\n\\t//Runtime: 9 ms, faster than 80.00% of Java online submissions for Sort the People.\\n    //Memory Usage: 42.9 MB, less than 100.00% of Java online submissions for Sort the People.\\n    //build-in sort\\n    //Time: O(NlgN + N); Space: O(N + lgN)\\n    //Time: O(NlgN); Space: O(N)\\n    public String[] sortPeople(String[] names, int[] heights) {\\n\\n        //Space: O(N)\\n\\t\\t//form a 2D array using people\\'s height and their position in original array.\\n        int[][] people = new int[names.length][2];\\n        for (int i = 0; i < names.length; i++)\\n            people[i]  = new int[] {heights[i], i};\\n\\n        //Time: O(NlgN); Space: O(lgN)\\n\\t\\t//sort in descending order by the people\\'s heights.\\n        Arrays.sort(people, (a, b) -> b[0] - a[0]);\\n\\n        String[] res = new String[names.length];\\n        //Time: O(N)\\n\\t\\t//Get result from sorted array. \\n        for (int i = 0; i < names.length; i++)\\n            res[i] = names[people[i][1]];\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620596,
                "title": "c-o-nlogn",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<string,int> &a, pair<string,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n        return a.second > b.second;\\n    }\\n    \\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string,int>> v;\\n        for(int i=0;i<names.size();i++) v.push_back({names[i],heights[i]});\\n        \\n        sort(v.begin(),v.end(),compare);\\n        \\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++) ans.push_back(v[i].first);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<string,int> &a, pair<string,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n        return a.second > b.second;\\n    }\\n    \\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string,int>> v;\\n        for(int i=0;i<names.size();i++) v.push_back({names[i],heights[i]});\\n        \\n        sort(v.begin(),v.end(),compare);\\n        \\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++) ans.push_back(v[i].first);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620567,
                "title": "c-using-bubble-sort-ezzzzzzzz",
                "content": "vector<string> sortPeople(vector<string>& names, vector<int>& v) {\\n        \\n        int n = v.size();\\n        \\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = 0; j < n - i - 1; j++)\\n                if (v[j] < v[j + 1]) {\\n                    swap(names[j],names[j+1]);\\n                    swap(v[j] , v[j+1]);\\n                    \\n                }\\n        return\\xA0names;\\n\\xA0\\xA0\\xA0\\xA0}\\n",
                "solutionTags": [],
                "code": "vector<string> sortPeople(vector<string>& names, vector<int>& v) {\\n        \\n        int n = v.size();\\n        \\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = 0; j < n - i - 1; j++)\\n                if (v[j] < v[j + 1]) {\\n                    swap(names[j],names[j+1]);\\n                    swap(v[j] , v[j+1]);\\n                    \\n                }\\n        return\\xA0names;\\n\\xA0\\xA0\\xA0\\xA0}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2620548,
                "title": "python-simple-python-solution-using-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 461 ms, faster than 41.67% of Python3 online submissions for Sort the People.\\n# Memory Usage: 14.5 MB, less than 33.33% of Python3 online submissions for Sort the People.\\n\\n\\tclass Solution:\\n\\t\\tdef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tsort_heights = sorted(heights, reverse = True)\\n\\n\\t\\t\\tfor height in sort_heights:\\n\\n\\t\\t\\t\\tindex = heights.index(height)\\n\\n\\t\\t\\t\\tresult.append(names[index])\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 461 ms, faster than 41.67% of Python3 online submissions for Sort the People.\\n# Memory Usage: 14.5 MB, less than 33.33% of Python3 online submissions for Sort the People.\\n\\n\\tclass Solution:\\n\\t\\tdef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tsort_heights = sorted(heights, reverse = True)\\n\\n\\t\\t\\tfor height in sort_heights:\\n\\n\\t\\t\\t\\tindex = heights.index(height)\\n\\n\\t\\t\\t\\tresult.append(names[index])\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2620482,
                "title": "2-approach-comparator-sort-map",
                "content": "**PAIR**\\n```\\nclass Solution {\\nprivate:\\n    static bool cmp(pair<string,int> p1, pair<string,int> p2){\\n        return p1.second>p2.second;             // Sorting according to integer\\n    }\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string,int>> v1;\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++)  \\n            v1.emplace_back(names[i],heights[i]);      // Store in form of pairs\\n        sort(v1.begin(),v1.end(),cmp);                              // sort using comparator function\\n        for(auto &it: v1)    \\n            ans.push_back(it.first);                  // Result\\n        return ans;\\n    }\\n};\\n```\\n\\n**MAP**\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m1;\\n        vector<string> ans; \\n        for(int i=0; i<names.size(); i++)                               \\n            m1[heights[i]] = names[i];      // map will sort according to heights\\n        for(auto it=m1.rbegin(); it!=m1.rend(); it++)                   \\n            ans.push_back(it->second);      // Reverse Traversal\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    static bool cmp(pair<string,int> p1, pair<string,int> p2){\\n        return p1.second>p2.second;             // Sorting according to integer\\n    }\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string,int>> v1;\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++)  \\n            v1.emplace_back(names[i],heights[i]);      // Store in form of pairs\\n        sort(v1.begin(),v1.end(),cmp);                              // sort using comparator function\\n        for(auto &it: v1)    \\n            ans.push_back(it.first);                  // Result\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m1;\\n        vector<string> ans; \\n        for(int i=0; i<names.size(); i++)                               \\n            m1[heights[i]] = names[i];      // map will sort according to heights\\n        for(auto it=m1.rbegin(); it!=m1.rend(); it++)                   \\n            ans.push_back(it->second);      // Reverse Traversal\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967081,
                "title": "java-code-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer,String>map=new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            map.put(heights[i],names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[]ans= new String[heights.length];\\n        int ind=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n            ans[ind]=map.get(heights[i]);\\n            ind++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer,String>map=new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            map.put(heights[i],names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[]ans= new String[heights.length];\\n        int ind=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n            ans[ind]=map.get(heights[i]);\\n            ind++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301168,
                "title": "c-code-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        priority_queue<pair<int, string> > pq;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        while(pq.size())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        priority_queue<pair<int, string> > pq;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        while(pq.size())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772577,
                "title": "js-one-line-solution",
                "content": "```\\nvar sortPeople = function(names, heights) {\\n    return new Array(names.length).fill(null).map((item, index) => ({name: names[index], height: heights[index]})).sort((a, b) => b.height - a.height).map(({name}) => name);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortPeople = function(names, heights) {\\n    return new Array(names.length).fill(null).map((item, index) => ({name: names[index], height: heights[index]})).sort((a, b) => b.height - a.height).map(({name}) => name);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656840,
                "title": "simple-python-solution-using-sorting",
                "content": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        comb = zip(names,heights)\\n        res = []\\n        comb = sorted(comb, key =lambda x: x[1],reverse=True)\\n        for i in comb:\\n            res.append(i[0])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        comb = zip(names,heights)\\n        res = []\\n        comb = sorted(comb, key =lambda x: x[1],reverse=True)\\n        for i in comb:\\n            res.append(i[0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624135,
                "title": "sort-the-people-using-priority-queue-in-simple-way",
                "content": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       priority_queue<pair<int,string>>q;\\n        int n=names.size();\\n        vector<string>ans;\\n        for(int i=0; i<n; i++){\\n            q.push({heights[i],names[i]});\\n            \\n        }\\n        while(q.size()>0){\\n            ans.push_back(q.top().second);\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       priority_queue<pair<int,string>>q;\\n        int n=names.size();\\n        vector<string>ans;\\n        for(int i=0; i<n; i++){\\n            q.push({heights[i],names[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2621152,
                "title": "python-solution-no-combination-easy-understanding",
                "content": "```\\nindices = []\\nsorted_heights = sorted(heights)[::-1]\\nfor i in sorted_heights:\\n\\tindices.append(heights.index(i))\\nresult = [names[i] for i in indices]\\nreturn result\\n```\\n\\nNext, you can find more compact form: \\n```\\nresult = []\\nfor i in sorted(heights)[::-1]:\\n\\tresult.append(names[heights.index(i)])\\nreturn result\\n```\\n\\nOr, here is the one-line solution: \\n```\\nreturn [names[heights.index(i)] for i in sorted(heights)[::-1]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nindices = []\\nsorted_heights = sorted(heights)[::-1]\\nfor i in sorted_heights:\\n\\tindices.append(heights.index(i))\\nresult = [names[i] for i in indices]\\nreturn result\\n```\n```\\nresult = []\\nfor i in sorted(heights)[::-1]:\\n\\tresult.append(names[heights.index(i)])\\nreturn result\\n```\n```\\nreturn [names[heights.index(i)] for i in sorted(heights)[::-1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620674,
                "title": "java-using-treemap",
                "content": "```\\n\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] h) {\\n        String ans[]=new String[names.length];\\n        TreeMap<Integer,String> map=new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<h.length;i++){\\n            map.put(h[i],names[i]);\\n        }\\n        int j=0;\\n        for(Map.Entry<Integer,String> e:map.entrySet()){\\n            ans[j]=e.getValue();\\n            j++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    public String[] sortPeople(String[] names, int[] h) {\\n        String ans[]=new String[names.length];\\n        TreeMap<Integer,String> map=new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<h.length;i++){\\n            map.put(h[i],names[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2620492,
                "title": "c-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        vector<pair<int,string>> vt;              // declare a pair of int,string\\n        \\n        int n = names.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vt.push_back({heights[i],names[i]});\\n        }\\n        \\n        sort(vt.begin(),vt.end());               // sort the nums in increasing order\\n        reverse(vt.begin(),vt.end());            // reverse it for getting decreasing order as we need\\n        \\n        vector<string> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(vt[i].second);         // just storing the answer as we have our pair in well order already\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        vector<pair<int,string>> vt;              // declare a pair of int,string\\n        \\n        int n = names.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vt.push_back({heights[i],names[i]});\\n        }\\n        \\n        sort(vt.begin(),vt.end());               // sort the nums in increasing order\\n        reverse(vt.begin(),vt.end());            // reverse it for getting decreasing order as we need\\n        \\n        vector<string> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(vt[i].second);         // just storing the answer as we have our pair in well order already\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691728,
                "title": "sort-the-people-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        \\n        for(int i=0; i<names.length; i++){\\n            for(int j=1+i; j<names.length; j++){\\n                if(heights[i] < heights[j]){\\n                    int temp = heights[i];\\n                    heights[i] = heights[j];\\n                    heights[j] = temp;\\n\\n                    String temp1 = names[i];\\n                        names[i] = names[j];\\n                        names[j] = temp1;\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        \\n        for(int i=0; i<names.length; i++){\\n            for(int j=1+i; j<names.length; j++){\\n                if(heights[i] < heights[j]){\\n                    int temp = heights[i];\\n                    heights[i] = heights[j];\\n                    heights[j] = temp;\\n\\n                    String temp1 = names[i];\\n                        names[i] = names[j];\\n                        names[j] = temp1;\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225228,
                "title": "javascript-hashmap-beat-91-in-time-85-in-space",
                "content": "# Code\\n```\\nvar sortPeople = function(names, heights) {\\n    let track = names.map((name, ind) => ({name:names[ind], age : heights[ind]}));\\n    \\n    track.sort((a,b) => b.age - a.age);\\n    \\n    return track.map(person => person.name)\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nvar sortPeople = function(names, heights) {\\n    let track = names.map((name, ind) => ({name:names[ind], age : heights[ind]}));\\n    \\n    track.sort((a,b) => b.age - a.age);\\n    \\n    return track.map(person => person.name)\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3185961,
                "title": "c-two-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- HashMap\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n- First, create a map named mpp where each key-value pair represents the height and the corresponding name of a person respectively. This is done by iterating through the input names and heights vectors and adding each height-name pair to the map.\\n\\n- Next, create an empty res vector and iterate through the mpp map in ascending order based on the keys (i.e. heights), and appends each name to the res vector.\\n\\n- Finally, the res vector is reversed to obtain the names sorted in descending order based on the heights and is returned as the result.\\n\\n# Complexity\\nTime complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The time complexity of this algorithm is O(n log n) due to the use of the map and the reverse function.\\n\\nSpace complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is also O(n) because the size of the mpp map and the res vector are both proportional to the input size n.\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        int n = heights.size();\\n        map <int, string> mpp;\\n\\n        for(int i = 0; i < names.size(); i++)\\n            mpp[heights[i]] = names[i];\\n\\n        vector <string> res;\\n        for(auto x: mpp)\\n            res.push_back(x.second);\\n\\n        reverse(res.begin(), res.end());\\n        return res;            \\n    }\\n};\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Priority Queue (Max Heap) + Pair\\n\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n- First create an empty priority queue pq of type pi (which is a pair of integer height and string name).\\n\\n- Then iterate through the input names and heights vectors and inserts each height-name pair as a new element into the pq priority queue. The pq is a max heap so the highest height person will be at the top of the heap.\\n\\n- Next create an empty res vector and continuously extracts the highest height person\\'s name from the top of the heap and pushes it into the res vector. This is done by repeatedly calling pq.top().second to get the name of the person at the top of the heap, appending that name to the res vector, and then removing the top element from the heap using pq.pop().\\n\\n- Finally, the res vector is returned as the result.\\n\\n# Complexity\\nTime complexity: O(n*logn)\\n- The time complexity of this algorithm is O(n log n) due to the use of the priority queue.\\n\\nSpace complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity is also O(n) because the size of the pq priority queue and the res vector are both proportional to the input size n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair <int, string> pi;\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        priority_queue <pi> pq;\\n\\n        for(int i = 0; i < names.size(); i++)\\n            pq.push({heights[i], names[i]});\\n\\n        vector <string> res;\\n        while(!pq.empty())\\n        {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }    \\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        int n = heights.size();\\n        map <int, string> mpp;\\n\\n        for(int i = 0; i < names.size(); i++)\\n            mpp[heights[i]] = names[i];\\n\\n        vector <string> res;\\n        for(auto x: mpp)\\n            res.push_back(x.second);\\n\\n        reverse(res.begin(), res.end());\\n        return res;            \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    typedef pair <int, string> pi;\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) \\n    {\\n        priority_queue <pi> pq;\\n\\n        for(int i = 0; i < names.size(); i++)\\n            pq.push({heights[i], names[i]});\\n\\n        vector <string> res;\\n        while(!pq.empty())\\n        {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }    \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900763,
                "title": "java-solution-using-hashmap",
                "content": "\\n# java Code using HashMap\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String[] res = new String[heights.length];\\n        int i=0;\\n        while(map.size() < heights.length){\\n            if(!map.containsKey(heights[i])){\\n                map.put(heights[i],names[i]);\\n            }\\n            i++;\\n        }\\n        Arrays.sort(heights);\\n        for(int j=heights.length-1;j>=0;j--){\\n           res[j] = map.get(heights[heights.length-j-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String[] res = new String[heights.length];\\n        int i=0;\\n        while(map.size() < heights.length){\\n            if(!map.containsKey(heights[i])){\\n                map.put(heights[i],names[i]);\\n            }\\n            i++;\\n        }\\n        Arrays.sort(heights);\\n        for(int j=heights.length-1;j>=0;j--){\\n           res[j] = map.get(heights[heights.length-j-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774379,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        l=[]\\n        for i in range(len(heights)):\\n            l.append([heights[i],names[i]])\\n        l.sort(reverse=True)\\n        k=[]\\n        for i in l:\\n            k.append(i[1])\\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        l=[]\\n        for i in range(len(heights)):\\n            l.append([heights[i],names[i]])\\n        l.sort(reverse=True)\\n        k=[]\\n        for i in l:\\n            k.append(i[1])\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739655,
                "title": "java-easy-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n       Map<Integer, String> map = new HashMap<>();\\n       for(int i = 0; i < names.length; i ++) {\\n           map.put(heights[i], names[i]);\\n       }\\n       Arrays.sort(heights);\\n\\n       String[] results = new String[heights.length];\\n       int index = 0;\\n       for(int i = names.length - 1; i >= 0; i --) {\\n           results[index] = map.get(heights[i]);\\n           index ++;\\n       } \\n       return results;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n       Map<Integer, String> map = new HashMap<>();\\n       for(int i = 0; i < names.length; i ++) {\\n           map.put(heights[i], names[i]);\\n       }\\n       Arrays.sort(heights);\\n\\n       String[] results = new String[heights.length];\\n       int index = 0;\\n       for(int i = names.length - 1; i >= 0; i --) {\\n           results[index] = map.get(heights[i]);\\n           index ++;\\n       } \\n       return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669392,
                "title": "python-c-java-beginner-level-simple-short-solution-easytounderstand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2418. Sort the People***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:\\n        ans=[]\\n        for i in range(len(h)):\\n            ans.append([h[i],n[i]])\\n        ans=sorted(ans,reverse=True)\\n        return[n for h,n in ans]\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] n, int[] h) {\\n        int l=h.length;\\n        Map<Integer,String> map=new HashMap();\\n        for(int i=0;i<l;i++)\\n            map.put(h[i],n[i]);\\n        Arrays.sort(h);\\n        String[] ans=new String[l];\\n        for(int i=l-1,j=0;i>=0;i--)\\n            ans[j++]=map.get(h[i]);\\n    return ans;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n     map<int,string> a;\\n        vector<string> ans; \\n        for(int i=0; i<n.size(); i++)\\n            a[h[i]] = n[i];      \\n        for(auto j=a.rbegin(); j!=a.rend(); j++)\\n            ans.push_back(j->second);            \\n        return ans;   \\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:\\n        ans=[]\\n        for i in range(len(h)):\\n            ans.append([h[i],n[i]])\\n        ans=sorted(ans,reverse=True)\\n        return[n for h,n in ans]\\n```\n```\\nclass Solution {\\n    public String[] sortPeople(String[] n, int[] h) {\\n        int l=h.length;\\n        Map<Integer,String> map=new HashMap();\\n        for(int i=0;i<l;i++)\\n            map.put(h[i],n[i]);\\n        Arrays.sort(h);\\n        String[] ans=new String[l];\\n        for(int i=l-1,j=0;i>=0;i--)\\n            ans[j++]=map.get(h[i]);\\n    return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n     map<int,string> a;\\n        vector<string> ans; \\n        for(int i=0; i<n.size(); i++)\\n            a[h[i]] = n[i];      \\n        for(auto j=a.rbegin(); j!=a.rend(); j++)\\n            ans.push_back(j->second);            \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639782,
                "title": "javascript-one-line",
                "content": "```\\nconst sortPeople = (names, heights) =>\\n  names\\n    .map((c, i) => [c, heights[i]])\\n    .sort((a, b) => b[1] - a[1])\\n    .map((c) => c[0]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortPeople = (names, heights) =>\\n  names\\n    .map((c, i) => [c, heights[i]])\\n    .sort((a, b) => b[1] - a[1])\\n    .map((c) => c[0]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631357,
                "title": "it-was-hard-for-me-but-remember-just-swap",
                "content": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        for i in range(len(heights)):\\n            tall_index = heights.index(max(heights[i:]))\\n            names[i], names[tall_index] = names[tall_index], names[i]\\n            heights[i], heights[tall_index] = heights[tall_index], heights[i]\\n        return names\\n        \\n```\\n\\nSWAP!\\n\\nThanks for reading :-)\\nIf you were helped this, Please thumbs up!\\nThat gives me courage. :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        for i in range(len(heights)):\\n            tall_index = heights.index(max(heights[i:]))\\n            names[i], names[tall_index] = names[tall_index], names[i]\\n            heights[i], heights[tall_index] = heights[tall_index], heights[i]\\n        return names\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623713,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar sortPeople = function (names, heights) {\\n    if (names.length === 1) return names\\n    let nameHeightMatrix = []\\n    let result = []\\n\\n    for (let i = 0; i < names.length; i++) {\\n        nameHeightMatrix.push([names[i], heights[i]])\\n    }\\n\\n    nameHeightMatrix.sort((a, b) => b[1] - a[1])\\n\\n    for (let [name, height] of nameHeightMatrix) {\\n        result.push(name)\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortPeople = function (names, heights) {\\n    if (names.length === 1) return names\\n    let nameHeightMatrix = []\\n    let result = []\\n\\n    for (let i = 0; i < names.length; i++) {\\n        nameHeightMatrix.push([names[i], heights[i]])\\n    }\\n\\n    nameHeightMatrix.sort((a, b) => b[1] - a[1])\\n\\n    for (let [name, height] of nameHeightMatrix) {\\n        result.push(name)\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620693,
                "title": "simple-c-pair-stl-solution-with-commented-code",
                "content": "We have to return names sorted in descending order by heights.\\n\\nObservation:\\nWe need to connect both names and heights in order to find decreasing order names, this can be done using pairs.\\n\\nIntuition:\\nSort the pair (heights,names) created as sorting done a/c. to first pair value that\\'s why taking heights as first pair value.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> sortednames;  //create vector of pair\\n        for(int i=0;i<names.size();i++){\\n            sortednames.push_back({heights[i],names[i]});   //storing values in pair\\n        }\\n        sort(sortednames.rbegin(),sortednames.rend());      //sorting\\n        vector<string> ans;\\n        for(int i=0;i<sortednames.size();i++)               //storing names a/c to desc. order height\\n            ans.push_back(sortednames[i].second);\\n        return ans;\\n    }\\n};\\n```\\n\\nTC: O(NlogN) for sorting\\nSC: O(N) for answer vector.\\nwhere N is size of num array.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> sortednames;  //create vector of pair\\n        for(int i=0;i<names.size();i++){\\n            sortednames.push_back({heights[i],names[i]});   //storing values in pair\\n        }\\n        sort(sortednames.rbegin(),sortednames.rend());      //sorting\\n        vector<string> ans;\\n        for(int i=0;i<sortednames.size();i++)               //storing names a/c to desc. order height\\n            ans.push_back(sortednames[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620691,
                "title": "just-a-hashmap-is-all-you-need-c",
                "content": "//map heights[i] to name[i] then sort heights in descending order and get corresponsing names.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        //map height[i] to names[i]\\n        unordered_map<int, string> mpp;\\n        for(int i=0; i<heights.size(); i++){\\n            mpp[heights[i]] = names[i];    \\n        }\\n        \\n        //sort the heights and store corresponding string\\n        vector<string> res;\\n        sort(heights.begin(), heights.end(), greater<int>());\\n        \\n        for(auto it: heights)\\n            res.push_back(mpp[it]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        //map height[i] to names[i]\\n        unordered_map<int, string> mpp;\\n        for(int i=0; i<heights.size(); i++){\\n            mpp[heights[i]] = names[i];    \\n        }\\n        \\n        //sort the heights and store corresponding string\\n        vector<string> res;\\n        sort(heights.begin(), heights.end(), greater<int>());\\n        \\n        for(auto it: heights)\\n            res.push_back(mpp[it]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839639,
                "title": "java-solution-using-hashmap-easy-and-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously we need to sort. But we need to sort the heights array, and get the corresponding names after the sort. Just blindly sorting the heights array, will cause us to lose the mapping of names to height.\\n\\nWe need to somehow sort the the heights array without losing this mapping. For this we use a simple HashMap that maps the person\\'s height to their name, thereby preserving that relationship safely. Now we can sort the input as we wish and the HashMap will keep track of the mapping.\\n\\nThe question has a constraint that the heights are all distinct values, allowing us to use the HashMap to store (height, name) pairs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we iterate through both arrays and add the (height, name) pairs into our HashMap. This makes sure that regardless of what future manipulations we do on the original array, the mapping of height and name remains safe in the HashMap.\\n\\nThen we sort the height array. Note that Arrays.sort() returns back the array in *ascending order*.\\n\\nThen we create a new string array that we will return back as the final answer. We fill this array by interating through the now sorted (in ascending order) heights array in reverse. This will yield the heights in descending order and the corresponding name is obtained from the HashMap. Be careful with the indices though - we are traversing in reverse for the heights array, but we want to insert into our result string array in the forward direction. Note carefully the indices that are used in code.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe slowest step in the algorithm is sorting the heights array, which is an O(nlogn) operation. \\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe HashMap will end up storing the (height, name) pairs for all the inputs. Thus the resulting space complexity is O(n).\\n\\n![image.png](https://assets.leetcode.com/users/images/c15a76cd-35f5-4c6e-a032-5a53737396cd_1690739088.1070201.png)\\n\\nClearly, this is a fast enough solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer, String> mymap = new HashMap<Integer, String>();\\n        for(int i = 0; i < heights.length; i++){\\n            mymap.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String res[] = new String[names.length];\\n        for(int i = heights.length-1; i >= 0; i--){\\n            res[heights.length-i-1] = mymap.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer, String> mymap = new HashMap<Integer, String>();\\n        for(int i = 0; i < heights.length; i++){\\n            mymap.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String res[] = new String[names.length];\\n        for(int i = heights.length-1; i >= 0; i--){\\n            res[heights.length-i-1] = mymap.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669991,
                "title": "c-priority-queue-heap-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First intuition was a map or sort, but a priority queue does the sorting by itself as we insert in pairs resembling a map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple priority queue based\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        priority_queue <pair<int, string>> pq;\\n        for(int i=0; i<names.size(); ++i){\\n            pq.push({heights[i], names[i]});\\n        }\\n        while(pq.size()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        priority_queue <pair<int, string>> pq;\\n        for(int i=0; i<names.size(); ++i){\\n            pq.push({heights[i], names[i]});\\n        }\\n        while(pq.size()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568492,
                "title": "c-o-n-sorting-pair",
                "content": "# Intuition\\nJust needed to know how the pair and vector together works.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake pair from both the given vector, then sort the pair vector on the basis of their second value. After this, retrive the first value from all the pair in the vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string, int>> helper;\\n        for(int i=0; i<names.size(); i++){\\n            helper.push_back({names[i], heights[i]});\\n        }\\n\\n        sort(helper.begin(), helper.end(), [](pair<string, int> &a, pair<string, int> &b){\\n            return a.second > b.second;\\n        });\\n\\n        vector<string> ans;\\n        for(int i=0; i<helper.size(); i++){\\n            ans.push_back(helper[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<string, int>> helper;\\n        for(int i=0; i<names.size(); i++){\\n            helper.push_back({names[i], heights[i]});\\n        }\\n\\n        sort(helper.begin(), helper.end(), [](pair<string, int> &a, pair<string, int> &b){\\n            return a.second > b.second;\\n        });\\n\\n        vector<string> ans;\\n        for(int i=0; i<helper.size(); i++){\\n            ans.push_back(helper[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496210,
                "title": "java-beginners-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add height as key as its distinct in hashmap\\n        then sort the height array as we will get the height in \\n        ascending order\\n        now put the name in string[] as the key is sorted now\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer, String> map= new HashMap<>();\\n        int k=0;\\n        for(int height: heights){\\n            map.put(height, names[k]);\\n            k++;\\n        }\\n        //sort key \\n        Arrays.sort(heights);\\n        String[] res=new String[names.length];\\n        int j=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n\\n            res[j]= map.get(heights[i]);\\n            j++;\\n        }\\nreturn res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap<Integer, String> map= new HashMap<>();\\n        int k=0;\\n        for(int height: heights){\\n            map.put(height, names[k]);\\n            k++;\\n        }\\n        //sort key \\n        Arrays.sort(heights);\\n        String[] res=new String[names.length];\\n        int j=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n\\n            res[j]= map.get(heights[i]);\\n            j++;\\n        }\\nreturn res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348887,
                "title": "simple-solution-but-time-complexity-is-too-high",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        for(int j = 0; j<names.length-1; j++){\\n                for(int i = 0; i<names.length-1-j; i++){\\n                    if(heights[i]<heights[i+1]){\\n                        String t = names[i+1];\\n                        names[i+1] = names[i];\\n                        names[i] = t;\\n                        int tt = heights[i+1];\\n                        heights[i+1] = heights[i];\\n                        heights[i] = tt;\\n                    }\\n                }\\n        }\\n         \\n         return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        for(int j = 0; j<names.length-1; j++){\\n                for(int i = 0; i<names.length-1-j; i++){\\n                    if(heights[i]<heights[i+1]){\\n                        String t = names[i+1];\\n                        names[i+1] = names[i];\\n                        names[i] = t;\\n                        int tt = heights[i+1];\\n                        heights[i+1] = heights[i];\\n                        heights[i] = tt;\\n                    }\\n                }\\n        }\\n         \\n         return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319351,
                "title": "c-solution-vector-of-pairs",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n    vector<pair<int, string>> v;\\n    int n=heights.size();\\n    for (int i = 0; i < n; i++)\\n        v.push_back({heights[i], names[i]});\\n    sort(v.begin(),v.end());\\n    vector<string> ans;\\n    for (int i = n-1; i >=0; i--)\\n        ans.push_back(v[i].second);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n    vector<pair<int, string>> v;\\n    int n=heights.size();\\n    for (int i = 0; i < n; i++)\\n        v.push_back({heights[i], names[i]});\\n    sort(v.begin(),v.end());\\n    vector<string> ans;\\n    for (int i = n-1; i >=0; i--)\\n        ans.push_back(v[i].second);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304336,
                "title": "using-extra-space",
                "content": "```\\nbool comp(pair<int,string> p1,pair<int,string> p2)\\n{\\n    return p1.first>p2.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& nm, vector<int>& h) {\\n        vector<string> res;\\n        vector<pair<int, string>> v;\\n        int n = nm.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({h[i],nm[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),comp);\\n        \\n        for(auto i: v)\\n        {\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool comp(pair<int,string> p1,pair<int,string> p2)\\n{\\n    return p1.first>p2.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& nm, vector<int>& h) {\\n        vector<string> res;\\n        vector<pair<int, string>> v;\\n        int n = nm.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({h[i],nm[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),comp);\\n        \\n        for(auto i: v)\\n        {\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165017,
                "title": "java-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String [] res = new String[names.length];\\n        Map<Integer, String> map = new HashMap();  \\n\\n        for (int i = 0; i < names.length; i++) map.put(heights[i], names[i]);\\n\\n        TreeMap<Integer,String> tm = new TreeMap<Integer,String>(map);\\n\\n        int index = res.length - 1;\\n        for (Map.Entry<Integer, String> entry : tm.entrySet()) {\\n            res[index] = entry.getValue();\\n            index--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String [] res = new String[names.length];\\n        Map<Integer, String> map = new HashMap();  \\n\\n        for (int i = 0; i < names.length; i++) map.put(heights[i], names[i]);\\n\\n        TreeMap<Integer,String> tm = new TreeMap<Integer,String>(map);\\n\\n        int index = res.length - 1;\\n        for (Map.Entry<Integer, String> entry : tm.entrySet()) {\\n            res[index] = entry.getValue();\\n            index--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128234,
                "title": "the-hashmap-way-in-java",
                "content": "class Solution {\\n\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n=names.length;\\n        HashMap<Integer,String> map=new HashMap<>();\\n          for(int i=0;i<n;i++){\\n              map.put(heights[i],names[i]);\\n          }\\n        //{180:\"Mary\",165:\"John\",170:\"Emma\"}\\n        //[180,170,165]\\n        Arrays.sort(heights);\\n        for(int i=n-1;i>=0;i--){\\n            names[n-i-1]=map.get(heights[i]);\\n        }\\n        return names;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n=names.length;\\n        HashMap<Integer,String> map=new HashMap<>();\\n          for(int i=0;i<n;i++){\\n              map.put(heights[i],names[i]);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3002837,
                "title": "javascript-solution-typescript",
                "content": "```\\nfunction sortPeople(names: string[], heights: number[]): string[] {\\n  const sortedHeights = Object.entries(heights).sort((a,b) => b[1] - a[1]);\\n  const arr = [];\\n  for(let i = 0; i < names.length; i++) {\\n    arr.push(names[sortedHeights[i][0]])\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction sortPeople(names: string[], heights: number[]): string[] {\\n  const sortedHeights = Object.entries(heights).sort((a,b) => b[1] - a[1]);\\n  const arr = [];\\n  for(let i = 0; i < names.length; i++) {\\n    arr.push(names[sortedHeights[i][0]])\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835936,
                "title": "python-sorted-reverse-true-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I shorted the height by that i will get the descending order of height. By using the index we can get the name of the person.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nShorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        hgts=sorted(heights,reverse=True)\\n        p=[]\\n        for i in hgts:\\n            p.append(names[heights.index(i)])\\n        return p\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        hgts=sorted(heights,reverse=True)\\n        p=[]\\n        for i in hgts:\\n            p.append(names[heights.index(i)])\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800186,
                "title": "two-easy-c-solutions-vector-of-pair-maps",
                "content": "Here is my C++ Solution Using Vector Of Pairs  : -\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> v;\\n        for (int i=0; i<names.size(); i++){\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<string> ans;\\n        for (int i=v.size()-1; i>=0; i--)ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is my C++ Solution using maps : -\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m;\\n        for (int i=0; i<names.size(); i++){\\n            m[heights[i]]= names[i];\\n        }\\n        vector<string> ans;\\n        for (auto it= m.rbegin(); it != m.rend(); it++)ans.push_back(it->second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> v;\\n        for (int i=0; i<names.size(); i++){\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<string> ans;\\n        for (int i=v.size()-1; i>=0; i--)ans.push_back(v[i].second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m;\\n        for (int i=0; i<names.size(); i++){\\n            m[heights[i]]= names[i];\\n        }\\n        vector<string> ans;\\n        for (auto it= m.rbegin(); it != m.rend(); it++)ans.push_back(it->second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799718,
                "title": "js-1-line",
                "content": "\\n```\\nconst sortPeople = (names, heights) => \\n  names.map((name, i) => [ heights[i], name ])\\n  .sort((a, b) => b[0] - a[0])\\n  .map(el => el[1])\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortPeople = (names, heights) => \\n  names.map((name, i) => [ heights[i], name ])\\n  .sort((a, b) => b[0] - a[0])\\n  .map(el => el[1])\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797377,
                "title": "c-o-nlogn-solution-usnig-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string> mp;\\n        for(int i=0;i<names.size();i++) {\\n            mp[heights[i]] = names[i];\\n        }\\n        int i = 0;\\n        for(auto it : mp) {\\n            names[i] = it.second;\\n            i++;\\n        }\\n        reverse(names.begin(), names.end());\\n        return names;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int, string> mp;\\n        for(int i=0;i<names.size();i++) {\\n            mp[heights[i]] = names[i];\\n        }\\n        int i = 0;\\n        for(auto it : mp) {\\n            names[i] = it.second;\\n            i++;\\n        }\\n        reverse(names.begin(), names.end());\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791505,
                "title": "java-easy-basic-solution-without-hash-map",
                "content": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String[] ans= new String[names.length];\\n        String str;\\n        int max=0,temp=0,temp1;\\n        for(int i=0;i<names.length;i++){\\n            max=0;\\n            for(int j=i;j<heights.length;j++){\\n                if(heights[j]>max){\\n                    max=heights[j];\\n                    temp=j; \\n                }\\n            }\\n            ans[i]=names[temp];\\n            //swapping the heights making it in descending order\\n            temp1=heights[i];\\n            heights[i]=heights[temp];\\n            heights[temp]=temp1;\\n            //swapping the names\\n            str=names[i];\\n            names[i]=names[temp];\\n            names[temp]=str;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String[] ans= new String[names.length];\\n        String str;\\n        int max=0,temp=0,temp1;\\n        for(int i=0;i<names.length;i++){\\n            max=0;\\n            for(int j=i;j<heights.length;j++){\\n                if(heights[j]>max){\\n                    max=heights[j];\\n                    temp=j; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2790293,
                "title": "java-o-n-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> heightMap = new TreeMap<>(Collections.reverseOrder());\\n        for(int i = 0; i < names.length; i++) {\\n            heightMap.put(heights[i], names[i]);\\n        }\\n        return heightMap.values().toArray(String[]::new);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> heightMap = new TreeMap<>(Collections.reverseOrder());\\n        for(int i = 0; i < names.length; i++) {\\n            heightMap.put(heights[i], names[i]);\\n        }\\n        return heightMap.values().toArray(String[]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762039,
                "title": "java-solution-with-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n\\n        int count = 0;\\n        for (Integer key : map.keySet()) {\\n            names[count++] = map.get(key);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n\\n        int count = 0;\\n        for (Integer key : map.keySet()) {\\n            names[count++] = map.get(key);\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759366,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m;\\n        for(int i=0;i<names.size();i++) m[heights[i]]=names[i];\\n        vector<string> ans;\\n        for (auto x:m) ans.push_back(x.second);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> m;\\n        for(int i=0;i<names.size();i++) m[heights[i]]=names[i];\\n        vector<string> ans;\\n        for (auto x:m) ans.push_back(x.second);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757641,
                "title": "c-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        //while map key is unique and heights values are distinct, so we should make map of (int,string) rather than (string,int)\\n        map<int,string> m;\\n        //store every person to his height\\n        for(int i = 0 ; i<heights.size() ; i++){\\n            m[heights[i]] = names[i];\\n        }\\n        //make a vector to store persons after sorting according to heights\\n        vector<string> ans;\\n        for(auto i : m)\\n            ans.push_back(i.second);\\n        //reverse vector because map sorting elements by key in ascending order\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        //while map key is unique and heights values are distinct, so we should make map of (int,string) rather than (string,int)\\n        map<int,string> m;\\n        //store every person to his height\\n        for(int i = 0 ; i<heights.size() ; i++){\\n            m[heights[i]] = names[i];\\n        }\\n        //make a vector to store persons after sorting according to heights\\n        vector<string> ans;\\n        for(auto i : m)\\n            ans.push_back(i.second);\\n        //reverse vector because map sorting elements by key in ascending order\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677351,
                "title": "python-easy-solution",
                "content": "```\\n\\t\\tarr=[]\\n        dict_={}\\n        for i in range(len(names)):\\n            if names[i] not in dict_:\\n                dict_[heights[i]]=names[i]\\n            else:\\n                dict_[heights[i]]=names[i]\\n        for i in sorted(dict_.keys()):\\n            arr.append(dict_[i])\\n        return arr[::-1]\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\t\\tarr=[]\\n        dict_={}\\n        for i in range(len(names)):\\n            if names[i] not in dict_:\\n                dict_[heights[i]]=names[i]\\n            else:\\n                dict_[heights[i]]=names[i]\\n        for i in sorted(dict_.keys()):\\n            arr.append(dict_[i])\\n        return arr[::-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676601,
                "title": "using-hashmaps-easy-to-understand-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap <Integer,String> map=new HashMap<>();\\n        for(int i=0; i<names.length ;i++){\\n             map.put(heights[i],names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[] ans=new String[heights.length];\\n        int j=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n            ans[j]=map.get(heights[i]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        HashMap <Integer,String> map=new HashMap<>();\\n        for(int i=0; i<names.length ;i++){\\n             map.put(heights[i],names[i]);\\n        }\\n        Arrays.sort(heights);\\n        String[] ans=new String[heights.length];\\n        int j=0;\\n        for(int i=heights.length-1;i>=0;i--){\\n            ans[j]=map.get(heights[i]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674147,
                "title": "easy-to-understand-for-beginners-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy To Understand  For Beginners Code IN C++\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n        for(int i=0;i<names.size()-1;i++)\\n        {\\n            for(int j=i+1;j<names.size();j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    swap(names[i],names[j]);\\n                    swap(heights[i],heights[j]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n        for(int i=0;i<names.size()-1;i++)\\n        {\\n            for(int j=i+1;j<names.size();j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    swap(names[i],names[j]);\\n                    swap(heights[i],heights[j]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673076,
                "title": "python-easiest-solution-beginner-friendly-with-clear-explanation",
                "content": "**Explaination:**\\n* Step-1: Create a temporary list and store sorted heights in descending order.\\n* Step-2: Create another list for answer\\n* Step-4: Loop through sorted temporary list and append names in answer from names list according to index of maximum heights  from heights list.\\n* Step-5: Return Ans or update names list/array\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        tempLi = sorted(heights, reverse = True)\\n        ans = []\\n        for i in tempLi:\\n            ans.append(names[heights.index(i)])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        tempLi = sorted(heights, reverse = True)\\n        ans = []\\n        for i in tempLi:\\n            ans.append(names[heights.index(i)])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662070,
                "title": "java-solution-simultaneous-sorting",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n = heights.length;  \\n        String temp; \\n        int t;\\n        for(int i=0; i < n; i++){  \\n            for(int j=1; j < (n-i); j++){  \\n                if(heights[j-1] < heights[j]){\\n                    t = heights[j-1];  \\n                    heights[j-1] = heights[j];  \\n                    heights[j] = t;\\n                    \\n                    temp = names[j-1];  \\n                    names[j-1] = names[j];  \\n                    names[j] = temp;  \\n                }  \\n            }\\n         }\\n        \\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n = heights.length;  \\n        String temp; \\n        int t;\\n        for(int i=0; i < n; i++){  \\n            for(int j=1; j < (n-i); j++){  \\n                if(heights[j-1] < heights[j]){\\n                    t = heights[j-1];  \\n                    heights[j-1] = heights[j];  \\n                    heights[j] = t;\\n                    \\n                    temp = names[j-1];  \\n                    names[j-1] = names[j];  \\n                    names[j] = temp;  \\n                }  \\n            }\\n         }\\n        \\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653394,
                "title": "javascript-easy-solution-2-lines",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function(names, heights) {\\n    const people = names.map((name, index) => ({name, height: heights[index]}));\\n    \\n    return people.sort((a, b) => b.height - a.height).map(({name}) => name);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function(names, heights) {\\n    const people = names.map((name, index) => ({name, height: heights[index]}));\\n    \\n    return people.sort((a, b) => b.height - a.height).map(({name}) => name);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643982,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:        \\n        return [name for name,height in sorted(zip(names, heights), key=lambda x: x[1], reverse=True)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:        \\n        return [name for name,height in sorted(zip(names, heights), key=lambda x: x[1], reverse=True)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641948,
                "title": "java-2-approaches-priorityqueue-hashmap",
                "content": "# Approach 1-->\\n```\\nclass pair{\\n    String name;\\n    int height;\\n    pair(String name, int height){\\n        this.name = name;\\n        this.height = height;\\n    }\\n}\\n\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            return b.height - a.height;\\n        });\\n        String res[] = new String[names.length];\\n        int ind = 0;\\n        for(int i = 0;i<names.length;i++){\\n            pair p = new pair(names[i], heights[i]);\\n            pq.offer(p);\\n        }\\n        while(!pq.isEmpty()){\\n            res[ind++] = pq.poll().name;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# Approach 2 -->\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String res[] = new String[names.length];\\n        int ind = names.length;\\n        Map<Integer, String> map = new TreeMap<>();\\n        for(int i = 0;i<names.length;i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        for(String p : map.values()){\\n            res[--ind] = p;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    String name;\\n    int height;\\n    pair(String name, int height){\\n        this.name = name;\\n        this.height = height;\\n    }\\n}\\n\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            return b.height - a.height;\\n        });\\n        String res[] = new String[names.length];\\n        int ind = 0;\\n        for(int i = 0;i<names.length;i++){\\n            pair p = new pair(names[i], heights[i]);\\n            pq.offer(p);\\n        }\\n        while(!pq.isEmpty()){\\n            res[ind++] = pq.poll().name;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String res[] = new String[names.length];\\n        int ind = names.length;\\n        Map<Integer, String> map = new TreeMap<>();\\n        for(int i = 0;i<names.length;i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        for(String p : map.values()){\\n            res[--ind] = p;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641734,
                "title": "sort-c-solution",
                "content": "```\\nint cmp(const void *a, const  void *b){ return (*(int*)b - *(int*)a); }\\nchar ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const  void *b){ return (*(int*)b - *(int*)a); }\\nchar ** sortPeople(char ** names, int namesSize, int* heights, int heightsSize, int* returnSize){\\n    char** ans = (char**)calloc(namesSize, sizeof(char*));\\n    for(int i = 0; i < heightsSize; i++)\\n        heights[i] = (heights[i] << 10) + i;\\n    qsort(heights, heightsSize, sizeof(int), cmp);\\n    for(int i = 0; i < heightsSize; i++)\\n        ans[i] = names[heights[i] & 0x3FF];\\n    *returnSize = heightsSize;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639879,
                "title": "c-easy-solution-hashmap-solution",
                "content": "Time Complexity -> O(n logn)\\n\\tSpace Complexity -> O(n)\\n\\t\\n\\tvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        \\n        unordered_map<int,string> mpp;\\n        \\n        for(int i=0;i<names.size();i++){\\n            mpp[heights[i]]=names[i];\\n        }\\n        \\n        sort(heights.rbegin(),heights.rend());\\n        \\n        for(int i=0;i<heights.size();i++){\\n            ans.push_back(mpp[heights[i]]);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "Time Complexity -> O(n logn)\\n\\tSpace Complexity -> O(n)\\n\\t\\n\\tvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        \\n        unordered_map<int,string> mpp;\\n        \\n        for(int i=0;i<names.size();i++){\\n            mpp[heights[i]]=names[i];\\n        }\\n        \\n        sort(heights.rbegin(),heights.rend());\\n        \\n        for(int i=0;i<heights.size();i++){\\n            ans.push_back(mpp[heights[i]]);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2638062,
                "title": "python3-easy-solution-with-explanation",
                "content": "Code:\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        hash = dict(zip(heights,names))\\n        res = []\\n        heights.sort(reverse=True)\\n        for h in heights:\\n            res.append(hash[h])\\n        return res\\n```\\n\\nTo create a dictionary from two sequences (lists), use the dict() and zip() methods. dict(zip(keys, values)) \\n\\nThe zip(fields, values) method returns an iterator that generates two-items tuples. If you call dict() on that iterator, you can create the dictionary you need.\\n\\nThe elements of the first list become the dictionary\\u2019s keys, and the elements second list represent the values in the dictionary.\\n\\nOne important thing to note that **dictionary = {zip(keys, values)} will not work**. You have to declare as dict(zip()) explicitly. If you make it work, you have to use proper dictionary comprehension.\\n\\neg. > hash = {180: \\'Mary\\', 165: \\'John\\', 170: \\'Emma\\'}\\n\\n> We have created a list res to store the result\\n> Now we want the res to be the list of names sorted in descending order acc to the heights.\\n> Thus, sort the heights first in descending order. (reverse = True) sorts in descending order\\n> Now iterate the for loop for heights and append the hash[h] ie the names in accordance to the height in the res. (heights is already sorted so names will be printed in sorted array in descending order)\\n> And at last return the res.\\n\\nThank you!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        hash = dict(zip(heights,names))\\n        res = []\\n        heights.sort(reverse=True)\\n        for h in heights:\\n            res.append(hash[h])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635644,
                "title": "javascript-commented-and-easy-understanding",
                "content": "I\\'ll be happy if you can upvote <3\\n\\n```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function(names, heights) {\\n    \\n    // We create an array that will return the result and a map that will hold as a key the height and as value the associated name.\\n    const map = new Map();\\n    const arr = [];\\n    \\n    // We can loop either the heights array or the names, since they have the same length.\\n    for(let i = 0; i < heights.length; i++) {\\n        \\n        // As we mentioned before, we set the heights[i] as the key and the names[i] as the value, so we can sort the heights later on.\\n        map.set(heights[i], names[i]);\\n    }\\n    \\n    // We sort the map according to the heights in desc order.\\n    const sortedMap = [...map].sort((a, b) => b[0] - a[0]);\\n    \\n    // We loop over the sorted map and push the values to the array. The values are the names of the people, sorted by their heights.\\n    for(let [key, value] of sortedMap) {\\n        arr.push(value);\\n    }\\n    \\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\nvar sortPeople = function(names, heights) {\\n    \\n    // We create an array that will return the result and a map that will hold as a key the height and as value the associated name.\\n    const map = new Map();\\n    const arr = [];\\n    \\n    // We can loop either the heights array or the names, since they have the same length.\\n    for(let i = 0; i < heights.length; i++) {\\n        \\n        // As we mentioned before, we set the heights[i] as the key and the names[i] as the value, so we can sort the heights later on.\\n        map.set(heights[i], names[i]);\\n    }\\n    \\n    // We sort the map according to the heights in desc order.\\n    const sortedMap = [...map].sort((a, b) => b[0] - a[0]);\\n    \\n    // We loop over the sorted map and push the values to the array. The values are the names of the people, sorted by their heights.\\n    for(let [key, value] of sortedMap) {\\n        arr.push(value);\\n    }\\n    \\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634485,
                "title": "c-using-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> merged;\\n        int n = names.size();\\n        for (int i = 0; i < n; i++) {\\n            merged.push_back({heights[i], names[i]});\\n        }\\n        sort(merged.rbegin(), merged.rend());\\n        names.clear();\\n        for (auto i : merged) {\\n            names.push_back(i.second);\\n        }\\n        return names;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int, string>> merged;\\n        int n = names.size();\\n        for (int i = 0; i < n; i++) {\\n            merged.push_back({heights[i], names[i]});\\n        }\\n        sort(merged.rbegin(), merged.rend());\\n        names.clear();\\n        for (auto i : merged) {\\n            names.push_back(i.second);\\n        }\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630023,
                "title": "javascript-o-n-logn-solution",
                "content": "Time Complexity : O(n*logn)\\n\\n```\\nvar sortPeople = function(names, heights) {\\n  const people = [];\\n  \\n  for(let [index, name] of names.entries()) {\\n    people.push([name, heights[index]]);\\n  }\\n  return people.sort((a, b) => b[1] - a[1]).map(([name]) => name);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar sortPeople = function(names, heights) {\\n  const people = [];\\n  \\n  for(let [index, name] of names.entries()) {\\n    people.push([name, heights[index]]);\\n  }\\n  return people.sort((a, b) => b[1] - a[1]).map(([name]) => name);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626127,
                "title": "golang-solution-49ms-100",
                "content": "Runtime: 49 ms, faster than 100.00% of Go online submissions for Sort the People.\\nMemory Usage: 7.4 MB, less than 100.00% of Go online submissions for Sort the People.\\n\\n```\\nfunc sortPeople(names []string, heights []int) []string {\\n    type people struct {\\n        name string\\n        height int\\n    }\\n    tmp := make([]people, 0, len(names))\\n    for i := 0; i < len(names); i++ {\\n        t := people{\\n            name: names[i],\\n            height: heights[i],\\n        }\\n        tmp = append(tmp, t)\\n    }\\n    sort.Slice(tmp, func(i, j int) bool { return tmp[i].height > tmp[j].height })\\n    ans := make([]string, 0, len(names))\\n    for _, t := range tmp {\\n        ans = append(ans, t.name)\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sortPeople(names []string, heights []int) []string {\\n    type people struct {\\n        name string\\n        height int\\n    }\\n    tmp := make([]people, 0, len(names))\\n    for i := 0; i < len(names); i++ {\\n        t := people{\\n            name: names[i],\\n            height: heights[i],\\n        }\\n        tmp = append(tmp, t)\\n    }\\n    sort.Slice(tmp, func(i, j int) bool { return tmp[i].height > tmp[j].height })\\n    ans := make([]string, 0, len(names))\\n    for _, t := range tmp {\\n        ans = append(ans, t.name)\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623719,
                "title": "using-hashmap-simple-and-easy-approch-use-height-ans-key-and-names-as-value",
                "content": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        map<int,string>m;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            m[h[i]]=n[i];\\n        }\\n        vector<string>ans;\\n        sort(h.begin(),h.end(),greater<int>());\\n        for(int i=0;i<n.size();i++)\\n        {\\n            ans.push_back(m[h[i]]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        map<int,string>m;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            m[h[i]]=n[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2623701,
                "title": "c-solution-using-hashing",
                "content": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n,vector<int>& h) \\n    {\\n        map<int,string>m;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            m[h[i]]=n[i];\\n        }\\n        sort(h.begin(),h.end(),greater<int>());\\n        vector<string>ans;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            string r=m[h[i]];\\n            ans.push_back(r);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n,vector<int>& h) \\n    {\\n        map<int,string>m;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            m[h[i]]=n[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2623238,
                "title": "sort-the-people",
                "content": "Please Upvote :)\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d=[ i for i in range(len(names))]\\n        for i in range(len(names)):\\n            d[i]=[names[i],heights[i]]\\n        d.sort(key=lambda x:x[1])\\n        ans=[]\\n        for i in range(len(names)-1,-1,-1):\\n            ans.append(d[i][0])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d=[ i for i in range(len(names))]\\n        for i in range(len(names)):\\n            d[i]=[names[i],heights[i]]\\n        d.sort(key=lambda x:x[1])\\n        ans=[]\\n        for i in range(len(names)-1,-1,-1):\\n            ans.append(d[i][0])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623227,
                "title": "easy-c-solution-with-dictionary-o-nlogn",
                "content": "\\t\\tpublic string[] SortPeople(string[] names, int[] heights) {\\n\\t\\t\\t\\tstring[] namesSorted = new string[names.Length];\\n\\n\\t\\t\\t\\tDictionary<int, string> heightNames = new Dictionary<int, string>();\\n\\t\\t\\t\\tfor (int i = 0; i < heights.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\theightNames.Add(heights[i], names[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tArray.Sort(heights);\\n\\t\\t\\t\\tint ind = 0;\\n\\t\\t\\t\\tfor (int i = heights.Length-1; i >=0 ; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnamesSorted[ind] = heightNames[heights[i]];\\n\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn namesSorted;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "C#",
                    "Sorting"
                ],
                "code": "\\t\\tpublic string[] SortPeople(string[] names, int[] heights) {\\n\\t\\t\\t\\tstring[] namesSorted = new string[names.Length];\\n\\n\\t\\t\\t\\tDictionary<int, string> heightNames = new Dictionary<int, string>();\\n\\t\\t\\t\\tfor (int i = 0; i < heights.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\theightNames.Add(heights[i], names[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tArray.Sort(heights);\\n\\t\\t\\t\\tint ind = 0;\\n\\t\\t\\t\\tfor (int i = heights.Length-1; i >=0 ; i--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnamesSorted[ind] = heightNames[heights[i]];\\n\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn namesSorted;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2623168,
                "title": "pair-class-in-java-o-n-in-cpp-one-line-in-py-py3-7-ways-meme",
                "content": "**UPVOTE PLEASE**\\n```\\njava:\\n\\nclass Solution {\\n    public String[] sortPeople(String[] n, int[] h) {\\n        List<pair> A=new ArrayList<pair>();\\n        for(int i=0;i<n.length;i++){\\n            A.add(new pair(h[i],n[i]));\\n        }\\n        Collections.sort(A,(a,b)->b.first-a.first);\\n        for(int i=0;i<n.length;i++){\\n            n[i]=A.get(i).second;\\n        }return n;\\n    }\\n    \\n}\\nclass pair{\\n        int first;\\n        String second;\\n        pair(int first,String second){\\n            this.first=first;\\n            this.second=second;\\n        }\\n    }\\n\\nmethod 2 using hashmap:\\n\\npublic String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n\\nmethod 3 using 2d array\\n\\npublic String[] sortPeople(String[] names, int[] heights) {\\n\\n        //Space: O(N)\\n        int[][] people = new int[names.length][2];\\n        for (int i = 0; i < names.length; i++)\\n            people[i]  = new int[] {heights[i], i};\\n\\n        //Time: O(NlgN); Space: O(lgN)\\n        Arrays.sort(people, (a, b) -> b[0] - a[0]);\\n\\n        String[] res = new String[names.length];\\n        //Time: O(N)\\n        for (int i = 0; i < names.length; i++)\\n            res[i] = names[people[i][1]];\\n\\n        return res;\\n    }\\n\\npy3:\\n\\ndef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [name for h,name in sorted(zip(heights,names),reverse=True)];\\n\\npy:\\ndef sortPeople(self, names, heights):\\n        \"\"\"\\n        :type names: List[str]\\n        :type heights: List[int]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [x for y,x in sorted(zip(heights,names),reverse=True) ]\\n        \\n\\nc++;\\nPriority Queue :\\n\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        priority_queue<pair<int, string>> pq;\\n        \\n        for(int i = 0; i < heights.size(); i++){\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        \\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n}\\nmethod 2:\\nvector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        vector<pair<int,string>> A;\\n        for(int i=0;i<n.size();i++){\\n            A.push_back({h[i],n[i]});\\n        }\\n        sort(A.rbegin(),A.rend());\\n        for(int i=0;i<n.size();i++){\\n            n[i]=A[i].second;\\n        }return n;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/69b26402-4881-4c8d-92d6-be31158a8423_1664115890.5671241.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\njava:\\n\\nclass Solution {\\n    public String[] sortPeople(String[] n, int[] h) {\\n        List<pair> A=new ArrayList<pair>();\\n        for(int i=0;i<n.length;i++){\\n            A.add(new pair(h[i],n[i]));\\n        }\\n        Collections.sort(A,(a,b)->b.first-a.first);\\n        for(int i=0;i<n.length;i++){\\n            n[i]=A.get(i).second;\\n        }return n;\\n    }\\n    \\n}\\nclass pair{\\n        int first;\\n        String second;\\n        pair(int first,String second){\\n            this.first=first;\\n            this.second=second;\\n        }\\n    }\\n\\nmethod 2 using hashmap:\\n\\npublic String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n\\nmethod 3 using 2d array\\n\\npublic String[] sortPeople(String[] names, int[] heights) {\\n\\n        //Space: O(N)\\n        int[][] people = new int[names.length][2];\\n        for (int i = 0; i < names.length; i++)\\n            people[i]  = new int[] {heights[i], i};\\n\\n        //Time: O(NlgN); Space: O(lgN)\\n        Arrays.sort(people, (a, b) -> b[0] - a[0]);\\n\\n        String[] res = new String[names.length];\\n        //Time: O(N)\\n        for (int i = 0; i < names.length; i++)\\n            res[i] = names[people[i][1]];\\n\\n        return res;\\n    }\\n\\npy3:\\n\\ndef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        return [name for h,name in sorted(zip(heights,names),reverse=True)];\\n\\npy:\\ndef sortPeople(self, names, heights):\\n        \"\"\"\\n        :type names: List[str]\\n        :type heights: List[int]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [x for y,x in sorted(zip(heights,names),reverse=True) ]\\n        \\n\\nc++;\\nPriority Queue :\\n\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        priority_queue<pair<int, string>> pq;\\n        \\n        for(int i = 0; i < heights.size(); i++){\\n            pq.push({heights[i], names[i]});\\n        }\\n        \\n        vector<string> ans;\\n        \\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n}\\nmethod 2:\\nvector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        vector<pair<int,string>> A;\\n        for(int i=0;i<n.size();i++){\\n            A.push_back({h[i],n[i]});\\n        }\\n        sort(A.rbegin(),A.rend());\\n        for(int i=0;i<n.size();i++){\\n            n[i]=A[i].second;\\n        }return n;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623084,
                "title": "java-easy-solution-sorting",
                "content": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int l=heights.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<l-i-1;j++)\\n            {\\n                if(heights[j]<heights[j+1])\\n                {\\n                    int temp=heights[j];\\n                    heights[j]=heights[j+1];\\n                    heights[j+1]=temp;\\n                    String cemp=names[j];\\n                    names[j]=names[j+1];\\n                    names[j+1]=cemp;\\n                }\\n            }\\n        }        \\n        return names;\\n  }\\n}",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int l=heights.length;\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=0;j<l-i-1;j++)\\n            {\\n                if(heights[j]<heights[j+1])\\n                {\\n                    int temp=heights[j];\\n                    heights[j]=heights[j+1];\\n                    heights[j+1]=temp;\\n                    String cemp=names[j];\\n                    names[j]=names[j+1];\\n                    names[j+1]=cemp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2621807,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn sort_people(names: Vec<String>, heights: Vec<i32>) -> Vec<String> {\\n        let mut v = names\\n            .into_iter()\\n            .zip(heights.into_iter())\\n            .collect::<Vec<_>>();\\n        v.sort_unstable_by_key(|(_, height)| -height);\\n        v.into_iter().map(|(x, _)| x).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sort_people(names: Vec<String>, heights: Vec<i32>) -> Vec<String> {\\n        let mut v = names\\n            .into_iter()\\n            .zip(heights.into_iter())\\n            .collect::<Vec<_>>();\\n        v.sort_unstable_by_key(|(_, height)| -height);\\n        v.into_iter().map(|(x, _)| x).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621567,
                "title": "python3-n-log-n-one-liner-beginner-friendly",
                "content": "* Idea is to pack height and name together\\n* Then sort\\n* return name by unpacking\\n \\n```\\n \\nreturn (name for height,name in sorted(((i,j) for i,j in zip(heights,names)),reverse=True))\\n \\n```\\n \\n*Well explained*\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        \\n\\n        #beginner friendly!\\n\\n        \\n        #creating tuple (packing) of height & names.\\n        #Tips: We have to sort according to  height so put hieght first then name\\n        \\n        HeightNameTup = []\\n        for height,name in zip(heights,names):\\n            HeightNameTup.append((height,name))\\n        # print(HeightNameTup)\\n        \\n        #just sort\\n        HeightNameTup.sort()\\n        \\n        #unpacking return list of name only\\n        ls=[]\\n        for height, name in HeightNameTup:\\n            ls.append(name)\\n        \\n        #return list\\n        return ls[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\n \\nreturn (name for height,name in sorted(((i,j) for i,j in zip(heights,names)),reverse=True))\\n \\n```\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        \\n\\n        #beginner friendly!\\n\\n        \\n        #creating tuple (packing) of height & names.\\n        #Tips: We have to sort according to  height so put hieght first then name\\n        \\n        HeightNameTup = []\\n        for height,name in zip(heights,names):\\n            HeightNameTup.append((height,name))\\n        # print(HeightNameTup)\\n        \\n        #just sort\\n        HeightNameTup.sort()\\n        \\n        #unpacking return list of name only\\n        ls=[]\\n        for height, name in HeightNameTup:\\n            ls.append(name)\\n        \\n        #return list\\n        return ls[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621366,
                "title": "java-solution-simple-approach-weekly-contest-312",
                "content": "\\tclass Solution {\\n\\t\\tpublic String[] sortPeople(String[] names, int[] heights) {\\n\\t\\t\\tHashMap<Integer,String> map= new HashMap<Integer,String>();\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tmap.put(heights[i],names[i]);\\n\\t\\t\\t}\\n\\t\\t\\tArrays.sort(heights);\\n\\t\\t\\tint k=n-1;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t   names[k--]= map.get(heights[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn names;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic String[] sortPeople(String[] names, int[] heights) {\\n\\t\\t\\tHashMap<Integer,String> map= new HashMap<Integer,String>();\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tmap.put(heights[i],names[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2621359,
                "title": "java-simplest-shortest-solution-treemap-no-sorting",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\nWe use a treemap instead of a hashmap which automatically sorts the keys and we put ```Collections.reverseOrder()``` comparator for a non-increasing (descending) sort.\\n\\nWe iterate over both the arrays together and put the corresponding values as ```<k, v>``` pairs in the map.\\n\\nThen we simply return the set of values from the map as an an array of string. \\n\\nOur work was done right at the beginning when we created the treemap.\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        \\n        return map.values().toArray(new String[0]);\\n    }\\n}\\n\\n// TC: O(n + logn), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```Collections.reverseOrder()```\n```<k, v>```\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        \\n        return map.values().toArray(new String[0]);\\n    }\\n}\\n\\n// TC: O(n + logn), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620783,
                "title": "java-treemap-solution-easy",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n=names.length;\\n        Map<Integer,String> mp=new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.put(heights[i],names[i]);\\n            }\\n        String []result= new String[n];\\n        int  x=0;\\n        for(Map.Entry<Integer,String> entry: mp.entrySet())\\n        {\\n            result[x++]=entry.getValue();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n=names.length;\\n        Map<Integer,String> mp=new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.put(heights[i],names[i]);\\n            }\\n        String []result= new String[n];\\n        int  x=0;\\n        for(Map.Entry<Integer,String> entry: mp.entrySet())\\n        {\\n            result[x++]=entry.getValue();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620748,
                "title": "c-intuitive-map-solution-very-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        vector<string> ans;\\n\\t\\t//map will store all heights to names pairs in decreasing order of their height automatically\\n        map<int, string, greater<int>> mp;\\n        for(int i=0;i<names.size();i++)   \\n            mp[heights[i]]=names[i];\\n\\t\\t\\n\\t\\t//just print all the names stored in the map\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        vector<string> ans;\\n\\t\\t//map will store all heights to names pairs in decreasing order of their height automatically\\n        map<int, string, greater<int>> mp;\\n        for(int i=0;i<names.size();i++)   \\n            mp[heights[i]]=names[i];\\n\\t\\t\\n\\t\\t//just print all the names stored in the map\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620735,
                "title": "same-as-two-sum-easy-cpp-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n            int n=nums.size();\\n            for(int i=0;i<n;i++){\\n               v.push_back({nums[i],i});\\n            }\\n          sort(v.begin(),v.end());\\n        vector<string>s;\\n        for(int i=n-1;i>=0;i--)\\n        { \\n             int k=v[i].second;\\n          \\n             s.push_back(names[k]);\\n           \\n        }\\n       \\n        return s;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n            int n=nums.size();\\n            for(int i=0;i<n;i++){\\n               v.push_back({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2620630,
                "title": "c-solution-easy-understanding-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        for(int i=0;i<heights.size();i++){\\n            for(int j=0;j<heights.size();j++){\\n                if(heights[i]>heights[j]){\\n                    swap(heights[i],heights[j]);\\n                    swap(names[i],names[j]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n};\\n```\\nplz upvote if found useful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        for(int i=0;i<heights.size();i++){\\n            for(int j=0;j<heights.size();j++){\\n                if(heights[i]>heights[j]){\\n                    swap(heights[i],heights[j]);\\n                    swap(names[i],names[j]);\\n                }\\n            }\\n        }\\n        return names;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620620,
                "title": "javascript-direct-way-100ms",
                "content": "Main idea: merge name and heights together and sort by height\\n```\\nconst sortPeople = (a, b) => {\\n    let n = a.length, d = [];\\n    for (let i = 0; i < n; i++) d.push([a[i], b[i]]);\\n    d.sort((x, y) => y[1] - x[1]);\\n    return d.map(x => x[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortPeople = (a, b) => {\\n    let n = a.length, d = [];\\n    for (let i = 0; i < n; i++) d.push([a[i], b[i]]);\\n    d.sort((x, y) => y[1] - x[1]);\\n    return d.map(x => x[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620603,
                "title": "javascript-array-methods-sorting-easy-to-understand",
                "content": "```\\nvar sortPeople = function(names, heights) {\\n    let finalArray = []\\n    for(let i=0;i<names.length;i++){\\n        finalArray.push([names[i],heights[i]])\\n    }\\n    return finalArray.sort((a,b)=>b[1]-a[1]).map((a)=>a[0]);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar sortPeople = function(names, heights) {\\n    let finalArray = []\\n    for(let i=0;i<names.length;i++){\\n        finalArray.push([names[i],heights[i]])\\n    }\\n    return finalArray.sort((a,b)=>b[1]-a[1]).map((a)=>a[0]);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620599,
                "title": "using-vector-pairs-in-c",
                "content": "bool sortcuties(pair<string,int> p1,pair<string,int> p2){\\nreturn (p1.second> p2.second);\\n}\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        int size_name = names.size();\\n    int size_height = heights.size();\\n        \\n        \\n        vector<pair<string,int>> v;\\n        for(int i=0;i<size_name;i++)\\n            v.push_back(make_pair(names[i],heights[i]));\\n            sort(v.rbegin(),v.rend(),sortcuties);\\n            for(auto i : v)\\n                ans.push_back(i.first);\\n            reverse(ans.begin(),ans.end());\\n        return ans;\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<string> ans;\\n        int size_name = names.size();\\n    int size_height = heights.size();\\n        \\n        \\n        vector<pair<string,int>> v;\\n        for(int i=0;i<size_name;i++)\\n            v.push_back(make_pair(names[i],heights[i]));\\n            sort(v.rbegin(),v.rend(),sortcuties);\\n            for(auto i : v)\\n                ans.push_back(i.first);\\n            reverse(ans.begin(),ans.end());\\n        return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2620573,
                "title": "100-fastest-c-easy-and-simple-solution-map",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>maping;\\n        for(int i=0;i<names.size();i++){\\n            maping[heights[i]]=names[i];\\n        }\\n        vector<string>ans;\\n        for (auto i = maping.rbegin(); i != maping.rend(); ++i) {\\n            ans.push_back(i->second);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>maping;\\n        for(int i=0;i<names.size();i++){\\n            maping[heights[i]]=names[i];\\n        }\\n        vector<string>ans;\\n        for (auto i = maping.rbegin(); i != maping.rend(); ++i) {\\n            ans.push_back(i->second);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620544,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        map<int,string>mp;\\n        for(int i=0;i<h.size();i++){\\n            mp[h[i]]=n[i];\\n        }\\n        vector<string>ans;\\n        for(auto a:mp)ans.push_back(a.second);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& n, vector<int>& h) {\\n        map<int,string>mp;\\n        for(int i=0;i<h.size();i++){\\n            mp[h[i]]=n[i];\\n        }\\n        vector<string>ans;\\n        for(auto a:mp)ans.push_back(a.second);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620477,
                "title": "super-easy-c-solution-using-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        map<int,string>hash;\\n        \\n        vector<string>ans;\\n        \\n        // map the height of the individuals to their names\\n        \\n        for(int i=0;i<names.size();i++)\\n            hash[heights[i]]=names[i];\\n        \\n        //sort the heights\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        \\n        //push the names into a vector according to the sorted heights \\n        \\n        for(int i=0;i<names.size();i++)\\n            ans.push_back(hash[heights[i]]);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        map<int,string>hash;\\n        \\n        vector<string>ans;\\n        \\n        // map the height of the individuals to their names\\n        \\n        for(int i=0;i<names.size();i++)\\n            hash[heights[i]]=names[i];\\n        \\n        //sort the heights\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        \\n        //push the names into a vector according to the sorted heights \\n        \\n        for(int i=0;i<names.size();i++)\\n            ans.push_back(hash[heights[i]]);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888220,
                "title": "c-beats-100-use-priorityqueue-no-one-else-is-doing-it",
                "content": "# Intuition\\nUse a priority queue of string names with the int heights as the sorting\\n\\n# Approach\\nUse int.MaxValue - heights[i] in order to have the largest height people output first\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) {\\n        var pq = new PriorityQueue<string,int>();\\n        for (int i = 0; i < names.Length; i++){\\n            pq.Enqueue(names[i], int.MaxValue - heights[i]);\\n        }\\n        var ans = new string[names.Length];\\n        for (int i = 0; i < names.Length; i++){\\n            ans[i] = pq.Dequeue();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) {\\n        var pq = new PriorityQueue<string,int>();\\n        for (int i = 0; i < names.Length; i++){\\n            pq.Enqueue(names[i], int.MaxValue - heights[i]);\\n        }\\n        var ans = new string[names.Length];\\n        for (int i = 0; i < names.Length; i++){\\n            ans[i] = pq.Dequeue();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754563,
                "title": "python-solution-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        s_heights = sorted(heights , reverse=True)\\n        n_list = []\\n        largest = 0\\n        for i in range(len(s_heights)):\\n            largest = heights.index(s_heights[i])\\n            n_list.append(names[largest])\\n\\n        return n_list\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        s_heights = sorted(heights , reverse=True)\\n        n_list = []\\n        largest = 0\\n        for i in range(len(s_heights)):\\n            largest = heights.index(s_heights[i])\\n            n_list.append(names[largest])\\n\\n        return n_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651101,
                "title": "c-1-liner-linq",
                "content": "# Complexity\\n- Time complexity: $$O(n \\\\times log(n))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n        return names.Zip(heights).OrderByDescending(x => x.Second).Select(x => x.First).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n        return names.Zip(heights).OrderByDescending(x => x.Second).Select(x => x.First).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578680,
                "title": "java-easy-approach-using-treemap-t-n-o-n-s-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer,String>map = new TreeMap<>();\\n        for(int i=0; i<names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        String res[] = new String[names.length];\\n        int count = 0;\\n        Arrays.sort(heights);\\n        for(int i=heights.length-1;i>=0; i--) {\\n            res[count++] = map.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer,String>map = new TreeMap<>();\\n        for(int i=0; i<names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        String res[] = new String[names.length];\\n        int count = 0;\\n        Arrays.sort(heights);\\n        for(int i=heights.length-1;i>=0; i--) {\\n            res[count++] = map.get(heights[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497060,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String result[] = new String[names.length];\\n        for(int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        int index = 0;\\n        for(int i = names.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String result[] = new String[names.length];\\n        for(int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        Arrays.sort(heights);\\n        int index = 0;\\n        for(int i = names.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482793,
                "title": "c-basic-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> vec;\\n        for(int i=0;i<names.size();i++){\\n            vec.push_back({heights[i],names[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        reverse(vec.begin(),vec.end());\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++){\\n            ans.push_back(vec[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> vec;\\n        for(int i=0;i<names.size();i++){\\n            vec.push_back({heights[i],names[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        reverse(vec.begin(),vec.end());\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++){\\n            ans.push_back(vec[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436942,
                "title": "approach-using-map",
                "content": "\\n# Approach\\nwe use a map to form a key-value pair of names and heigth\\nafter it sort the map in decending order using a vector of pair \\nafter this we push the names in ans vector\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>mp;\\n        vector<string>ans;\\n        vector<pair<int,string> > A;\\n\\n        for(int i=0;i<names.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n        for(auto &it:mp){\\n            A.push_back(it);\\n        }\\n        sort(A.rbegin(),A.rend());\\n        for(auto it:A){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>mp;\\n        vector<string>ans;\\n        vector<pair<int,string> > A;\\n\\n        for(int i=0;i<names.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n        for(auto &it:mp){\\n            A.push_back(it);\\n        }\\n        sort(A.rbegin(),A.rend());\\n        for(auto it:A){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352010,
                "title": "clear-and-easy-c-solution-beats-90-of-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>>vp;\\n        for(int i=0;i<heights.size();i++){\\n            vp.push_back({heights[i],names[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        vector<string>ans;\\n        for(auto gf: vp){\\n            ans.push_back(gf.second);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>>vp;\\n        for(int i=0;i<heights.size();i++){\\n            vp.push_back({heights[i],names[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        vector<string>ans;\\n        for(auto gf: vp){\\n            ans.push_back(gf.second);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328147,
                "title": "one-line-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] {\\n        Array(zip(names, heights)).sorted(by: { $0.1 > $1.1 }).map { $0.0 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] {\\n        Array(zip(names, heights)).sorted(by: { $0.1 > $1.1 }).map { $0.0 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324300,
                "title": "simple-solution-using-c-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> vec;\\n        int n = names.size();\\n        for (int i = 0; i < n; i++) {\\n            vec.push_back({heights[i], names[i]});\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        vector<string> res;\\n        for (auto p : vec) {\\n            res.push_back(p.second);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<pair<int,string>> vec;\\n        int n = names.size();\\n        for (int i = 0; i < n; i++) {\\n            vec.push_back({heights[i], names[i]});\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        vector<string> res;\\n        for (auto p : vec) {\\n            res.push_back(p.second);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305019,
                "title": "easyy",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        res = []\\n        for i in range(len(names)):\\n            res.append([heights[i],names[i]])\\n        res = sorted(res,reverse=True)\\n        return [name for height,name in res]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        res = []\\n        for i in range(len(names)):\\n            res.append([heights[i],names[i]])\\n        res = sorted(res,reverse=True)\\n        return [name for height,name in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267557,
                "title": "dart-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<String> sortPeople(List<String> names, List<int> heights) {\\n        Map<int, String> hasmap = {};\\n\\n        for (int i = 0; i < names.length; i++) {\\n            hasmap.addAll({heights[i]: names[i]});\\n        }\\n        \\n        hasmap = Map.fromEntries(hasmap.entries.toList()..sort((a, b) => b.key.compareTo(a.key),));\\n        \\n        print(hasmap);\\n\\n        return hasmap.values.toList();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<String> sortPeople(List<String> names, List<int> heights) {\\n        Map<int, String> hasmap = {};\\n\\n        for (int i = 0; i < names.length; i++) {\\n            hasmap.addAll({heights[i]: names[i]});\\n        }\\n        \\n        hasmap = Map.fromEntries(hasmap.entries.toList()..sort((a, b) => b.key.compareTo(a.key),));\\n        \\n        print(hasmap);\\n\\n        return hasmap.values.toList();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261489,
                "title": "c-simple-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        priority_queue<pair<int, string>> pq;\\n        for(int i=0; i<names.size(); i++)\\n            pq.push(make_pair(heights[i], names[i]));\\n\\n        vector<string> ans;\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        priority_queue<pair<int, string>> pq;\\n        for(int i=0; i<names.size(); i++)\\n            pq.push(make_pair(heights[i], names[i]));\\n\\n        vector<string> ans;\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248624,
                "title": "sort-the-people-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<int> arr;\\n        vector<string> str;\\n        int i, j;\\n        arr = heights;\\n        sort(arr.begin(), arr.end());\\n\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            for(j=0 ; j<heights.size() ; j++)\\n            {\\n                if(arr[i]==heights[j])\\n                {\\n                    str.push_back(names[j]);\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        vector<int> arr;\\n        vector<string> str;\\n        int i, j;\\n        arr = heights;\\n        sort(arr.begin(), arr.end());\\n\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            for(j=0 ; j<heights.size() ; j++)\\n            {\\n                if(arr[i]==heights[j])\\n                {\\n                    str.push_back(names[j]);\\n                }\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151870,
                "title": "easy-simple-c-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore each heights with the corresponding name in map.\\nthan sort the heights in the decressing order.\\nNow access all the name according to the sorted heights & push in ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> mp;\\n        for(int i=0;i<heights.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        vector<string> ans;\\n        for(int i=0;i<heights.size();i++){\\n           ans.push_back(mp[heights[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string> mp;\\n        for(int i=0;i<heights.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        vector<string> ans;\\n        for(int i=0;i<heights.size();i++){\\n           ans.push_back(mp[heights[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150770,
                "title": "c-easy-solution-100-testcases-passed",
                "content": "# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int maxIndex(vector<int> arr){\\n        // get the maximum value from the arr \\n        int maxi = *max_element(arr.begin(), arr.end());\\n\\n        //get the iterator of that maximum number\\n        vector<int>::iterator itr = find(arr.begin(), arr.end(), maxi);\\n        \\n        // returning the index of the maximum number\\n        return distance(arr.begin(), itr);\\n    }\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int i = 0;\\n        vector<string> ans;\\n\\n        // Loop will iterate untill the heights vector become empty; \\n        while(heights.size()){\\n            // get the maximum person height index\\n            i = maxIndex(heights);\\n\\n            //push the name of that person in ans vector\\n            ans.push_back(names[i]);\\n\\n            //remove the height ans name after pushing it into the ans vector\\n            heights.erase(heights.begin()+i);\\n            names.erase(names.begin()+i);\\n        }\\n\\n        //returing ans vector\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxIndex(vector<int> arr){\\n        // get the maximum value from the arr \\n        int maxi = *max_element(arr.begin(), arr.end());\\n\\n        //get the iterator of that maximum number\\n        vector<int>::iterator itr = find(arr.begin(), arr.end(), maxi);\\n        \\n        // returning the index of the maximum number\\n        return distance(arr.begin(), itr);\\n    }\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int i = 0;\\n        vector<string> ans;\\n\\n        // Loop will iterate untill the heights vector become empty; \\n        while(heights.size()){\\n            // get the maximum person height index\\n            i = maxIndex(heights);\\n\\n            //push the name of that person in ans vector\\n            ans.push_back(names[i]);\\n\\n            //remove the height ans name after pushing it into the ans vector\\n            heights.erase(heights.begin()+i);\\n            names.erase(names.begin()+i);\\n        }\\n\\n        //returing ans vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055243,
                "title": "simple-c-solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string,greater<int>> mp;\\n        for(int i=0;i<names.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n\\n        vector<string> ans;\\n        for(auto name: mp){\\n            ans.push_back(name.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string,greater<int>> mp;\\n        for(int i=0;i<names.size();i++){\\n            mp[heights[i]]=names[i];\\n        }\\n\\n        vector<string> ans;\\n        for(auto name: mp){\\n            ans.push_back(name.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038616,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n = names.length ;\\n        String[] ans = new String[n];\\n        int[] sorted = new int[n];\\n        int index = 0 ;\\n        for(int num : heights)\\n        {\\n            sorted[index] = num ;\\n            index++ ;  \\n        }\\n        index = 0 ;\\n        for(int i = 0 ; i < n - 1 ; i++ )\\n        {\\n            for(int j = i+1 ; j < n ; j ++)\\n            {\\n                if(sorted[i] < sorted[j] )\\n                {\\n                    int temp = sorted[i] ;\\n                    sorted[i] = sorted[j] ;\\n                    sorted[j] = temp ;\\n                }\\n            }   \\n        }\\n        int k ;\\n        for(int val : sorted )\\n        {\\n            for( k = 0 ; k < n ; k++)\\n            {\\n                if(val == heights[k])\\n                    break ;\\n            }\\n            ans[index] = names[k] ;\\n            index++ ;\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        int n = names.length ;\\n        String[] ans = new String[n];\\n        int[] sorted = new int[n];\\n        int index = 0 ;\\n        for(int num : heights)\\n        {\\n            sorted[index] = num ;\\n            index++ ;  \\n        }\\n        index = 0 ;\\n        for(int i = 0 ; i < n - 1 ; i++ )\\n        {\\n            for(int j = i+1 ; j < n ; j ++)\\n            {\\n                if(sorted[i] < sorted[j] )\\n                {\\n                    int temp = sorted[i] ;\\n                    sorted[i] = sorted[j] ;\\n                    sorted[j] = temp ;\\n                }\\n            }   \\n        }\\n        int k ;\\n        for(int val : sorted )\\n        {\\n            for( k = 0 ; k < n ; k++)\\n            {\\n                if(val == heights[k])\\n                    break ;\\n            }\\n            ans[index] = names[k] ;\\n            index++ ;\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845131,
                "title": "2418-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& name, vector<int>& height) {\\n        vector<string> v(100001,\"\");\\n        for(int i=0;i<name.size();i++)\\n        {\\n            v[height[i]]=name[i];\\n        }\\n        reverse(v.begin(),v.end());\\n        v.erase(remove(v.begin(),v.end(),\"\"), v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& name, vector<int>& height) {\\n        vector<string> v(100001,\"\");\\n        for(int i=0;i<name.size();i++)\\n        {\\n            v[height[i]]=name[i];\\n        }\\n        reverse(v.begin(),v.end());\\n        v.erase(remove(v.begin(),v.end(),\"\"), v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824807,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& h) {\\n       int n=names.size();\\n      vector<pair<int,string>>p;\\n        for(int i=0;i<n;i++){\\n           p.push_back({h[i],names[i]});\\n        }\\n        sort(p.begin(),p.end(), greater<pair<int,string>>());\\n    vector<string>res;\\n     for(int i=0;i<n;i++){\\n         res.push_back(p[i].second);\\n     }\\n     return res;\\n        }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& h) {\\n       int n=names.size();\\n      vector<pair<int,string>>p;\\n        for(int i=0;i<n;i++){\\n           p.push_back({h[i],names[i]});\\n        }\\n        sort(p.begin(),p.end(), greater<pair<int,string>>());\\n    vector<string>res;\\n     for(int i=0;i<n;i++){\\n         res.push_back(p[i].second);\\n     }\\n     return res;\\n        }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818017,
                "title": "c-hashmap-sort-easy-solution-with-least-time-complexity",
                "content": "```\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        unordered_map<int,string> mp;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[heights[i]]=names[i];\\n        }\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            ans.push_back(mp[heights[i]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        unordered_map<int,string> mp;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            mp[heights[i]]=names[i];\\n        }\\n        sort(heights.begin(),heights.end(),greater<int>());\\n        vector<string> ans;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            ans.push_back(mp[heights[i]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804691,
                "title": "python-fast-o-n-log-n-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(N log N)\\n- Space complexity:\\nO(N)\\n# Code\\n```python []\\nclass Solution:\\n    def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\\n        l = zip(names, heights)\\n        l = sorted(l, key=lambda x: x[1], reverse=True)\\n        return [i[0] for i in l]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python []\\nclass Solution:\\n    def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\\n        l = zip(names, heights)\\n        l = sorted(l, key=lambda x: x[1], reverse=True)\\n        return [i[0] for i in l]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747659,
                "title": "using-java",
                "content": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n     \\n        \\n        //using bubble sort\\n        for (int i=0;i< heights.length-1;i++){\\n            for (int j=0;j< heights.length-1-i;j++){\\n                if (heights[j]<heights[j+1]){\\n                    int temp = heights[j];\\n                    heights[j]=heights[j+1];\\n                    heights[j+1]=temp;\\n\\n                    //in names string\\n                    String temps = names[j];\\n                    names[j]=names[j+1];\\n                    names[j+1]=temps;\\n                }\\n            }\\n        }\\n             return names;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n     \\n        \\n        //using bubble sort\\n        for (int i=0;i< heights.length-1;i++){\\n            for (int j=0;j< heights.length-1-i;j++){\\n                if (heights[j]<heights[j+1]){\\n                    int temp = heights[j];\\n                    heights[j]=heights[j+1];\\n                    heights[j+1]=temp;\\n\\n                    //in names string\\n                    String temps = names[j];\\n                    names[j]=names[j+1];\\n                    names[j+1]=temps;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2728071,
                "title": "swift-solution",
                "content": "```\\n// Sort the people\\n// Sort the people by age in descending order\\n// LeetCode: https://leetcode.com/problems/sort-the-people/\\n\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] \\n    {\\n        var people = [(name: String, height: Int)]()\\n        for i in 0..<names.count {\\n            people.append((names[i], heights[i]))\\n        }\\n        people.sort(by: { $0.height > $1.height })\\n        var result = [String]()\\n        for person in people {\\n            result.append(person.name)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Sort the people\\n// Sort the people by age in descending order\\n// LeetCode: https://leetcode.com/problems/sort-the-people/\\n\\nclass Solution {\\n    func sortPeople(_ names: [String], _ heights: [Int]) -> [String] \\n    {\\n        var people = [(name: String, height: Int)]()\\n        for i in 0..<names.count {\\n            people.append((names[i], heights[i]))\\n        }\\n        people.sort(by: { $0.height > $1.height })\\n        var result = [String]()\\n        for person in people {\\n            result.append(person.name)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683383,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis problem seems trivial at first, the only thing we need to consider is that there could be duplicate names, so using a hashmap on the names -> heights will not work. The problem gives you the constraint that heights will be unique for each person, so we can just use that as the key instead! Once you realize this, the problem is trivial.\\n\\n### Solution\\n```\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String[] res = new String[heights.length];\\n\\n        \\n        for (int i = 0; i < heights.length; i++)\\n            map.put(heights[i], names[i]);\\n        \\n        Arrays.sort(heights);\\n        \\n        for (int i = 0; i < res.length; i++)\\n            res[i] = map.get(heights[res.length - 1 - i]);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        String[] res = new String[heights.length];\\n\\n        \\n        for (int i = 0; i < heights.length; i++)\\n            map.put(heights[i], names[i]);\\n        \\n        Arrays.sort(heights);\\n        \\n        for (int i = 0; i < res.length; i++)\\n            res[i] = map.get(heights[res.length - 1 - i]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675785,
                "title": "bubblesort-2-for-loops-c",
                "content": "```\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int i, j;\\n        for (i = 0; i < heights.size(); i++)\\n\\n            // Last i elements are already\\n            // in place\\n            for (j = 0; j < heights.size() - i - 1; j++)\\n                if (heights[j] < heights[j + 1]){\\n                    swap(heights[j], heights[j + 1]);\\n                    swap(names[j], names[j + 1]);\\n                }\\n        return names;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        int i, j;\\n        for (i = 0; i < heights.size(); i++)\\n\\n            // Last i elements are already\\n            // in place\\n            for (j = 0; j < heights.size() - i - 1; j++)\\n                if (heights[j] < heights[j + 1]){\\n                    swap(heights[j], heights[j + 1]);\\n                    swap(names[j], names[j + 1]);\\n                }\\n        return names;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666128,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n\\n//  taken a vector of pair(int , string)data type to store heights corresponding to names of the person\\n   vector<pair<int,string>>v;\\n\\t\\t\\n        int i;\\n        int n = names.size();\\n        for(i=0;i<n;i++)\\n        {\\n            v.push_back({heights[i],names[i]});\\n        }\\n\\t\\t// sort the vector according to heights and reverse the vector so that the person with the maximum height comes first. \\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n\\t\\t// take another vector of string ans store the name of the person in same order \\n        vector<string>ans;\\n        for(i=0;i<n;i++)\\n        {\\n            ans.push_back(v[i].second);\\n        }\\n\\t\\t// return the vector\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n\\n\\n//  taken a vector of pair(int , string)data type to store heights corresponding to names of the person\\n   vector<pair<int,string>>v;\\n\\t\\t\\n        int i;\\n        int n = names.size();\\n        for(i=0;i<n;i++)\\n        {\\n            v.push_back({heights[i],names[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2663720,
                "title": "c-solution-time-complexity-o-n-log-n-space-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        vector<string> sortedPeople;\\n        unordered_map<int,int> height;\\n        \\n        for (int i = 0; i < heights.size(); i++) \\n            height[heights[i]] = i;\\n        \\n        sort(heights.begin(), heights.end());\\n        \\n        for (int i = heights.size() - 1 ; i >=0; i--) \\n            sortedPeople.push_back(names[height[heights[i]]]);\\n        \\n        return sortedPeople;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n        vector<string> sortedPeople;\\n        unordered_map<int,int> height;\\n        \\n        for (int i = 0; i < heights.size(); i++) \\n            height[heights[i]] = i;\\n        \\n        sort(heights.begin(), heights.end());\\n        \\n        for (int i = heights.size() - 1 ; i >=0; i--) \\n            sortedPeople.push_back(names[height[heights[i]]]);\\n        \\n        return sortedPeople;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2661636,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public string[] SortPeople(string[] names, int[] heights) \\n    {\\n        Dictionary<int, string> dict = new Dictionary<int, string>();\\n        for (int i=0; i<heights.Length; i++)\\n        {\\n            dict.Add(heights[i], names[i]);\\n        }\\n\\n        return dict.OrderByDescending(x=>x.Key).Select(x=>x.Value).ToArray();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string[] SortPeople(string[] names, int[] heights) \\n    {\\n        Dictionary<int, string> dict = new Dictionary<int, string>();\\n        for (int i=0; i<heights.Length; i++)\\n        {\\n            dict.Add(heights[i], names[i]);\\n        }\\n\\n        return dict.OrderByDescending(x=>x.Key).Select(x=>x.Value).ToArray();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657329,
                "title": "python3-item-index-pair-sorting",
                "content": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        c = {heights[i]: i for i in range(len(heights))}\\n        heights.sort()\\n        res = []\\n        for i in range(len(heights)-1, -1, -1):\\n            res.append(names[c[heights[i]]])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        c = {heights[i]: i for i in range(len(heights))}\\n        heights.sort()\\n        res = []\\n        for i in range(len(heights)-1, -1, -1):\\n            res.append(names[c[heights[i]]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657098,
                "title": "java-solution-using-treemap-with-o-n-time-and-space-complexity",
                "content": "public class Solution {\\n\\n    public static String[] sortPeople(String[] names, int[] heights) {\\n        String[] result = new String[names.length];\\n        Map<Integer, String> map = new TreeMap<>();\\n        for (int i = 0; i < heights.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        int size = heights.length - 1;\\n        for (Map.Entry<Integer, String> set : map.entrySet()) {\\n            result[size] = set.getValue();\\n            size--;\\n        }\\n\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n\\n    public static String[] sortPeople(String[] names, int[] heights) {\\n        String[] result = new String[names.length];\\n        Map<Integer, String> map = new TreeMap<>();\\n        for (int i = 0; i < heights.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2656636,
                "title": "java-solution-very-easy-using-hashmap",
                "content": "# java\\n\\n    class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String ans[]=new String[names.length];\\n        HashMap<Integer,String>map=new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            map.put(heights[i],names[i]);\\n            \\n        }\\n        Arrays.sort(heights);\\n        \\n         for(int i=ans.length-1,j=0;i>=0;i--,j++){\\n           \\n            ans[j]=map.get(heights[i]);\\n        }\\n        return ans;\\n    }\\n     }",
                "solutionTags": [],
                "code": "class Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        String ans[]=new String[names.length];\\n        HashMap<Integer,String>map=new HashMap<>();\\n        for(int i=0;i<names.length;i++){\\n            map.put(heights[i],names[i]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2652080,
                "title": "two-method-to-solve-java-solution-faster",
                "content": "```\\n //Method 1 : Using a pair\\n    private static class Pair{\\n        String name;\\n        int height;\\n        Pair(String name, int height){\\n            this.name = name;\\n            this.height = height;\\n        }\\n        \\n    }\\n    \\n    public String[] sortPeople(String[] names, int[] heights) {\\n        List<Pair> ans = new ArrayList<>();\\n        \\n        //adding pair into the list\\n        for(int i = 0; i < heights.length; i++){\\n            ans.add(new Pair(names[i], heights[i]));\\n        }\\n        \\n        //sorting the list according to decending order of the height -- custom sorting order\\n        ans.sort((a,b)->{\\n            return b.height - a.height;\\n        });\\n        \\n\\t\\t//to store the result and return \\n        String [] str = new String[ans.size()];\\n        \\n        for(int i = 0; i < ans.size(); i++){\\n            str[i] = ans.get(i).name;\\n        }\\n        \\n        return str;\\n        \\n    }\\n    \\n    //method 2 :\\n    private void reverseArray(int [] heights){\\n        int i = 0;\\n        int j = heights.length - 1;\\n        while(i < j){\\n            int temp = heights[i];\\n            heights[i] = heights[j];\\n            heights[j] = temp;\\n            i++; j--;\\n        }\\n    }\\n\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for(int i= 0 ; i < names.length; i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        \\n\\t\\t//default sorting behaviour\\n        Arrays.sort(heights);\\n\\t\\t//just reverse the sorted element to get the sorted in decending order\\n        this.reverseArray(heights);\\n        \\n        \\n        String [] res = new String[names.length];\\n        \\n        for(int i= 0; i < heights.length; i++){\\n            res[i] = map.get(heights[i]);\\n        }\\n        \\n        return res;\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n //Method 1 : Using a pair\\n    private static class Pair{\\n        String name;\\n        int height;\\n        Pair(String name, int height){\\n            this.name = name;\\n            this.height = height;\\n        }\\n        \\n    }\\n    \\n    public String[] sortPeople(String[] names, int[] heights) {\\n        List<Pair> ans = new ArrayList<>();\\n        \\n        //adding pair into the list\\n        for(int i = 0; i < heights.length; i++){\\n            ans.add(new Pair(names[i], heights[i]));\\n        }\\n        \\n        //sorting the list according to decending order of the height -- custom sorting order\\n        ans.sort((a,b)->{\\n            return b.height - a.height;\\n        });\\n        \\n\\t\\t//to store the result and return \\n        String [] str = new String[ans.size()];\\n        \\n        for(int i = 0; i < ans.size(); i++){\\n            str[i] = ans.get(i).name;\\n        }\\n        \\n        return str;\\n        \\n    }\\n    \\n    //method 2 :\\n    private void reverseArray(int [] heights){\\n        int i = 0;\\n        int j = heights.length - 1;\\n        while(i < j){\\n            int temp = heights[i];\\n            heights[i] = heights[j];\\n            heights[j] = temp;\\n            i++; j--;\\n        }\\n    }\\n\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new HashMap<>();\\n        for(int i= 0 ; i < names.length; i++){\\n            map.put(heights[i], names[i]);\\n        }\\n        \\n\\t\\t//default sorting behaviour\\n        Arrays.sort(heights);\\n\\t\\t//just reverse the sorted element to get the sorted in decending order\\n        this.reverseArray(heights);\\n        \\n        \\n        String [] res = new String[names.length];\\n        \\n        for(int i= 0; i < heights.length; i++){\\n            res[i] = map.get(heights[i]);\\n        }\\n        \\n        return res;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2649953,
                "title": "c-easy-solution-using-o-n-t-c",
                "content": "\\n\\n     class Solution {\\n     public:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>m;\\n        for(int i=0;i<names.size();i++){\\n            m[heights[i]]=names[i];  // here key is heights \\n        }\\n        vector<string>ns;\\n        for(auto it: m){\\n            ns.push_back(it.second);}  // storing the name according to the assending key orders\\n            reverse(ns.begin(),ns.end());  // reverse it to get the desending order\\n        return ns;\\n    }\\n     };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        map<int,string>m;\\n        for(int i=0;i<names.size();i++){\\n            m[heights[i]]=names[i];  // here key is heights \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2649847,
                "title": "c-solution-without-pair",
                "content": "![image](https://assets.leetcode.com/users/images/41321702-c119-460e-b25e-5b5ef9e72154_1664695305.3992112.png)\\n# Make unordered_map of \\'<int ,string>\\' that\\'s all  then sort \\'int\\' vector and get ans accordingly \\n\\n\\n        unordered_map<int,string>mp;\\n        for(int i = 0;i<names.size();i++)\\n        {\\n            mp[heights[i]] = names[i];\\n        }\\n        // sort(names.begin(),names.end());\\n        // reverse(names.begin(),names.end());\\n        vector<string>ans;\\n        sort(heights.begin(),heights.end());\\n        reverse(heights.begin(),heights.end());\\n        for(int i = 0 ; i < heights.size();i++)\\n        {\\n           string str  = mp[heights[i]];\\n            ans.push_back(str);\\n        }\\n        \\n       \\n        return ans;",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/41321702-c119-460e-b25e-5b5ef9e72154_1664695305.3992112.png)\\n# Make unordered_map of \\'<int ,string>\\' that\\'s all  then sort \\'int\\' vector and get ans accordingly \\n\\n\\n        unordered_map<int,string>mp;\\n        for(int i = 0;i<names.size();i++)\\n        {\\n            mp[heights[i]] = names[i];\\n        }\\n        // sort(names.begin(),names.end());\\n        // reverse(names.begin(),names.end());\\n        vector<string>ans;\\n        sort(heights.begin(),heights.end());\\n        reverse(heights.begin(),heights.end());\\n        for(int i = 0 ; i < heights.size();i++)\\n        {\\n           string str  = mp[heights[i]];\\n            ans.push_back(str);\\n        }\\n        \\n       \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2645045,
                "title": "python-using-zip-simplest-approach",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\t\\t\\t\\theights,names=zip(*sorted(zip(heights,names),reverse=True))\\n\\t\\t\\t\\treturn names",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n\\t\\t\\t\\theights,names=zip(*sorted(zip(heights,names),reverse=True))\\n\\t\\t\\t\\treturn names",
                "codeTag": "Java"
            },
            {
                "id": 2644906,
                "title": "python-easy-to-understand-simplest-approach-one-liner",
                "content": "\\t height,name=zip(*sorted(zip(heights,names),reverse=True))\\n\\t\\t\\treturn name\\n    \\n",
                "solutionTags": [],
                "code": "\\t height,name=zip(*sorted(zip(heights,names),reverse=True))\\n\\t\\t\\treturn name\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2643182,
                "title": "easy-solution-using-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsorting and map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntreemap in java\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nna\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        TreeMap <Integer,String> h = new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<names.length;i++){\\n            h.put(heights[i],names[i]);\\n        }\\n        return h.values().toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        TreeMap <Integer,String> h = new TreeMap<>(Collections.reverseOrder());\\n        for(int i=0;i<names.length;i++){\\n            h.put(heights[i],names[i]);\\n        }\\n        return h.values().toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642169,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       vector<pair<int,string>>v;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        vector<string>ans;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n       vector<pair<int,string>>v;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            v.push_back({heights[i],names[i]});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        vector<string>ans;\\n        for(int i=0;i<names.size();i++)\\n        {\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641660,
                "title": "c-one-line-solution",
                "content": "```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) {\\n        return names.Select((item, index) => new \\n                     {\\n                         name = item,\\n                         height = heights[index]\\n                     }).OrderByDescending(o => o.height).Select(o => o.name).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string[] SortPeople(string[] names, int[] heights) {\\n        return names.Select((item, index) => new \\n                     {\\n                         name = item,\\n                         height = heights[index]\\n                     }).OrderByDescending(o => o.height).Select(o => o.name).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640836,
                "title": "java-treemap-solution",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>();\\n        int n = names.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        int i = names.length - 1;\\n        for (Map.Entry<Integer, String> e : map.entrySet()) {\\n            String name = e.getValue();\\n            names[i--] = name;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n        Map<Integer, String> map = new TreeMap<>();\\n        int n = names.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(heights[i], names[i]);\\n        }\\n        int i = names.length - 1;\\n        for (Map.Entry<Integer, String> e : map.entrySet()) {\\n            String name = e.getValue();\\n            names[i--] = name;\\n        }\\n        return names;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640818,
                "title": "c-tuple-linq",
                "content": "**Method 1: LINQ**\\n```\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n       return Enumerable.Range(0, heights.Length).OrderByDescending(a => heights[a]).Select(i => names[i]).ToArray();\\n    }\\n```\\n\\n**Method 2: Tuple**\\n```\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n        List<(string, int)> namesHeights = new List<(string, int)>();\\n        for (int i = 0; i < names.Length; i++)\\n            namesHeights.Add((names[i], heights[i]));\\n        return namesHeights.OrderByDescending(a => a.Item2).Select(a => a.Item1).ToArray();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n       return Enumerable.Range(0, heights.Length).OrderByDescending(a => heights[a]).Select(i => names[i]).ToArray();\\n    }\\n```\n```\\n    public string[] SortPeople(string[] names, int[] heights)\\n    {\\n        List<(string, int)> namesHeights = new List<(string, int)>();\\n        for (int i = 0; i < names.Length; i++)\\n            namesHeights.Add((names[i], heights[i]));\\n        return namesHeights.OrderByDescending(a => a.Item2).Select(a => a.Item1).ToArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640194,
                "title": "java-hashmap-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n      \\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String[] sortPeople(String[] names, int[] heights) {\\n      \\n        Map<Integer, String> map = new HashMap<>();\\n        for (int i = 0; i < names.length; i++) {\\n            map.put(heights[i], names[i]);\\n        }        \\n        Arrays.sort(heights);\\n        String[] result = new String[heights.length];\\n        int index = 0;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            result[index] = map.get(heights[i]);\\n            index++;\\n        }\\n        return result;\\n   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639934,
                "title": "kotlin-2-solutions-treemap-and-fp",
                "content": "```\\nclass Solution {\\n    fun sortPeople(names: Array<String>, heights: IntArray): Array<String> {\\n        val map = TreeMap<Int,String>(compareByDescending { it })\\n        \\n        heights.forEachIndexed { i, height ->\\n            map[height] = names[i]\\n        }\\n                \\n        return map.values.toTypedArray()\\n    }\\n    \\n    fun sortPeople2(names: Array<String>, heights: IntArray): Array<String> =\\n        names.withIndex()\\n            .sortedByDescending { heights[it.index] }\\n            .map { it.value }\\n            .toTypedArray()\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun sortPeople(names: Array<String>, heights: IntArray): Array<String> {\\n        val map = TreeMap<Int,String>(compareByDescending { it })\\n        \\n        heights.forEachIndexed { i, height ->\\n            map[height] = names[i]\\n        }\\n                \\n        return map.values.toTypedArray()\\n    }\\n    \\n    fun sortPeople2(names: Array<String>, heights: IntArray): Array<String> =\\n        names.withIndex()\\n            .sortedByDescending { heights[it.index] }\\n            .map { it.value }\\n            .toTypedArray()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639306,
                "title": "1-line-using-map-and-regex-explained",
                "content": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\n var sortPeople = function(names, heights) {\\n    return names.map((e, i) => e + heights[i]).sort((a, b) => b.match(/\\\\d+/) - a.match(/\\\\d+/)).join(\\' \\').replace(/[0-9]/g, \\'\\').split(\" \")\\n};\\n\\n//with comments : \\nvar sortPeople = function(names, heights) {\\n    // merge both arrays at same index\\n    return names.map((e, i) => e + heights[i])\\n    //sort the merged array in decresing order \\n        .sort((a, b) => b.match(/\\\\d+/) - a.match(/\\\\d+/))\\n    // convert to string\\n        .join(\\' \\')\\n    //use regex to remove integers from string\\n        .replace(/[0-9]/g, \\'\\')\\n    //move back into array \\n        .split(\" \")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} names\\n * @param {number[]} heights\\n * @return {string[]}\\n */\\n var sortPeople = function(names, heights) {\\n    return names.map((e, i) => e + heights[i]).sort((a, b) => b.match(/\\\\d+/) - a.match(/\\\\d+/)).join(\\' \\').replace(/[0-9]/g, \\'\\').split(\" \")\\n};\\n\\n//with comments : \\nvar sortPeople = function(names, heights) {\\n    // merge both arrays at same index\\n    return names.map((e, i) => e + heights[i])\\n    //sort the merged array in decresing order \\n        .sort((a, b) => b.match(/\\\\d+/) - a.match(/\\\\d+/))\\n    // convert to string\\n        .join(\\' \\')\\n    //use regex to remove integers from string\\n        .replace(/[0-9]/g, \\'\\')\\n    //move back into array \\n        .split(\" \")\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1757478,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1795918,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1844654,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1713281,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 2056033,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1995953,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1995770,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1946050,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1881448,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1874677,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1757478,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1795918,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1844654,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1713281,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 2056033,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1995953,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1995770,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1946050,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1881448,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            },
            {
                "id": 1874677,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "lmao people assume this to be solutions section \\uD83D\\uDC80"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "Can someone suggest why this approach is not working?\n\n class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        int n=names.length;\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                if(heights[i]<heights[j])\n                {\n                    String temp=names[i];\n                    names[i]=names[j];\n                    names[j]=temp;\n                }\n            }\n        }\n        return names;\n    }\n}"
                    },
                    {
                        "username": "dibyajyoti_giri",
                        "content": "[@nikhatparveen148](/nikhatparveen148) I was  not sorting the heights array.. fixed now\\nfor(int j=i+1;j<n;j++)\\n            {\\n                if(heights[i]<heights[j])\\n                {\\n                    int temp1=heights[i];\\n                    heights[i]=heights[j];\\n                    heights[j]=temp1;\\n                    String temp2=names[i];\\n                    names[i]=names[j];\\n                    names[j]=temp2;\\n                }\\n            }"
                    },
                    {
                        "username": "nikhatparveen148",
                        "content": "I am also facing the same issue!!!!..\\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\\n        d = {}\\n        for i in range(len(names)):\\n            d[heights[i]] = names[i]\\n        i = 0\\n        l = []\\n        while len(d) >0:\\n            l.append(d[max(d.keys())])\\n            del d[max(d.keys())]\\n            i+=1\\n        return l```\\n"
                    },
                    {
                        "username": "clashkingjeet",
                        "content": " \\nclass Solution {\\npublic:\\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\\n        \\n      map<int,string, greater<int>> mp;\\n\\n      for(int i=0;i<heights.size();i++)\\n      {\\n          mp[heights[i]]=names[i];\\n      }\\n      int i=0;\\n      for(auto it: mp)\\n      {   \\n          names[i]=it.second;\\n          i++;\\n      }\\n      return names;\\n\\n\\n    }\\n};\\n\\n\\n "
                    },
                    {
                        "username": "__-vishal-__",
                        "content": "solution using QuickSort Algorithm beats 100% users in java\n\n`class Solution {\n    public String[] sortPeople(String[] names, int[] heights) {\n        quickSort(names, heights, 0, heights.length-1);\n        return names;\n    }\n\n    private static void quickSort(String[] names, int[] heights, int lowerBound, int upperBound) {\n        if(lowerBound < upperBound) {\n            int pivotIndex = partition(names, heights, lowerBound, upperBound);\n            quickSort(names, heights, lowerBound, pivotIndex-1);\n            quickSort(names, heights, pivotIndex+1, upperBound);\n        }\n    }\n\n    private static int partition(String[] names, int[] heights, int lowerBound, int upperBound) {\n\n        int pivot = heights[lowerBound];\n        int start = lowerBound;\n        int end = upperBound;\n\n        while(start < end) {\n\n            while (heights[start] >= pivot && start < end) {\n                start++;\n            }\n\n            while (heights[end] < pivot) {\n                end--;\n            }\n\n            if(start < end) {\n                swap(heights, start, end);\n                swap(names, start, end);\n            }\n        }\n\n        swap(heights, lowerBound, end);\n        swap(names, lowerBound, end);\n        return end;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void swap(String[] array, int i, int j) {\n        String temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n} `"
                    },
                    {
                        "username": "Tiago14",
                        "content": "```\\nvar sortPeople = function(names, heights) {\\n    const people = new Map()\\n    for(let i = 0; i < names.length; i ++) {\\n        people.set(heights[i],i)\\n    }\\n    const heightsSorted = [...people.keys()].sort((a,b) => b - a)\\n    const result = []\\n    for(const height of heightsSorted) {\\n        result.push(names[people.get(height)])\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "Shiv_45",
                        "content": "why it showing error using insertion sort technique?"
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "which approach is better? solving it with maxheap or hashMap?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Brought back memories of school"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "why there is no priority_Queue tag ?i got accepted with maxheap"
                    }
                ]
            }
        ]
    }
]