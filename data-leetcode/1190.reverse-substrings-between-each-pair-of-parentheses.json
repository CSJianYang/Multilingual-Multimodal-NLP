[
    {
        "title": "Shortest Distance to a Character",
        "question_content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\n&nbsp;\nExample 1:\n\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n\nExample 2:\n\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts[i] and c are lowercase English letters.\n\tIt is guaranteed that c occurs at least once in s.",
        "solutions": [
            {
                "id": 125788,
                "title": "c-java-python-2-pass-with-explanation",
                "content": "# Solution 1: Record the Position\\n\\nInitial result array.\\nLoop twice on the string `S`.\\nFirst forward pass to find shortest distant to character on left.\\nSecond backward pass to find shortest distant to character on right.\\n<br>\\n\\nIn python solution,  I merged these two `for` statement.\\nWe can do the same in C++/Java by:\\n```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\\nBut it will become less readable.\\n<br>\\n\\nTime complexity `O(N)`\\nSpace complexity `O(N)` for output\\n<br>\\n\\n**C++**\\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\\n<br><br>\\n\\n# Solution 2: DP\\nAnother idea is quite similar and has a sense of DP.\\n<br>\\n**C++:**\\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126116,
                "title": "concise-java-solution-with-detailed-explanation-easy-understand",
                "content": "```\\n/** \"loveleetcode\" \"e\"\\n *  1. put 0 at all position equals to e, and max at all other position\\n *     we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]\\n *  2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]), \\n *     we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]\\n *  3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])\\n *     we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] \\n */\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            if (dist[i] == Integer.MAX_VALUE) continue;\\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\\n        }\\n        for (int i = n-1; i > 0; i--) {\\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\\n        }\\n        return dist; \\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054410,
                "title": "c-two-pass-o-n-0ms-beats-100-easy-explanation",
                "content": "**EXPLANATION**\\n- First, iterate the string **\\'s\\'** and store the **indexes** of **\\'c\\'** present in \\'s\\' into an array or vector ( here **```vector<int>ioc```** ) .\\n- Make a **left** variable for storing the index of **left nearest \\'c\\'** in **```ioc```**  and a **right** variable for storing the index of **right nearest \\'c\\'** in **```ioc```**. Initially, **```left=0```** and **```right=0```**, that is keeping the first index of **```ioc```**.\\n- Then, iterate string **\\'s\\'** again and at each iteration check if *current index* crosses **```ioc[right]```** ( that is *index of \\'c\\' present in ioc pointed by right* ) then we need to make **```left = right```** and **```right=right+1```**.\\n- Also, at each iteration find the **minimum** value between the *following two* and store it in **```ans[i]```**.\\n\\t-  **absolute value of (right nearest \\'c\\' - current index)** represented by **``` abs(ioc[right]-i)```** \\n\\t-   **absolute value of (left nearest \\'c\\' - current index)** represented by **``` abs(ioc[left]-i)```**\\n- Return **ans**.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nConsidering *\\'n\\'* to be the size of the maximum size of the string *\\'s\\'*.\\n\\n**TIME COMPLEXITY**\\nO(n+n)=**O(n)** [ *For iterating the string two times* ]\\n\\n**SPACE COMPLEXITY**\\n**O(n)** [ *In worst case, all characters of \\'s\\' is \\'c\\', at that time ( number of \\'c\\' in \\'s\\' = size of \\'s\\' )* ]",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector<int>ioc```\n```ioc```\n```ioc```\n```left=0```\n```right=0```\n```ioc```\n```ioc[right]```\n```left = right```\n```right=right+1```\n```ans[i]```\n``` abs(ioc[right]-i)```\n``` abs(ioc[left]-i)```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054301,
                "title": "python-o-n-solution-explained",
                "content": "What we need to do in this problem is to iterate our data two times: one time from left to right and second time from right to left. Let us use auxilary function `letter_get(letter, dr)`, where `dr` is direction: `+1` for left->right traversal and `-1` for right -> left traversal.\\n\\nHow this function will work? We initialize it with zeroes first and we keep `cur` value, which represents the last place where we meet symbol `letter`. We traverse string, check each symbol and if it is equal to `letter`, we update `cur` place. We put `abs(i - cur)` to result: this is distance between current place and last place where we meet symbol `letter`.\\n\\nFinally, we apply our function twice for two directions and choose the smallest distance. Note also that we initialized `curr = -n`, because in this case we will have distances `>=n` for symbols for places, where we do not have elements equal to `letter` before, and this value is bigger than all possible values in answer, so it works as infinity here.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well.\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054366,
                "title": "javascript-2-pass-simple-solution-with-explanation",
                "content": "The problem becomes really simple if we consider the example.\\n```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\\nWhat is the shortest distance for index `9` if the character is `e`?\\nThe closest `e` from the left side has the index `6`.\\n`9 - 6 = 3`\\nThe closest `e` from the right side has the index `11`.\\n`11 - 9 = 2`\\nThe minimum distance between them is 2, so the answer is 2. Can we do it for any index?\\nYes we can, all we need to do is to keep track of the previous character index while iterating from the left to the right and vice versa. The only edge case here is that initially we could possibly don\\'t have a previous index, so to mitigate it for such indecies we can put the shortest distance for them as Infinity and once we complete 2 passes at least one non-Infinity value for each index should exist.\\nLet\\'s consider the example again.\\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\\n\\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173687,
                "title": "c-solution-simple-easy-understanding",
                "content": "**Explanation:**\\n* create two vectors :- `position` and `answer`.\\n* Traverse the string and collect all the position of given char using the `position` vector.\\n* Now traverse the string and find the shortest distance from the given char to all given positions.\\n* Keep pushing the distance to the `answer` vector and at last return it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054179,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527161,
                "title": "python-o-n-by-propagation-85-w-diagram",
                "content": "Python O(n) by propagation\\n\\n---\\n\\n**Hint**:\\n\\nImagine parameter C as a flag on the line.\\n\\nThink of propagation technique:\\n**1st-pass** iteration **propagates distance** from C on the **left hand side**\\n**2nd-pass** iteration **propagates distance** from C on the **right hand side** with min( 1st-pass result, 2nd-pass propagation distance ) in order to update with shortest path.\\n\\n---\\n\\n**Abstract Model**:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583205184.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854034,
                "title": "python-99-92-faster-two-pointers-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343839,
                "title": "java-98-100",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131816,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125850,
                "title": "java-single-pass-with-trailing-pointer-concise",
                "content": "Idea is exactly the same as other solutions using stack or two pointers. Keep track of the last seen target character C as well as a left pointer pointing to the last non C character. \\n\\nIf you hit a nonC character and have not seen any C yet, max out that value.\\n\\nIf you hit a nonC character and have seen a C, the current distance to C is the current position i minus the index of the last seen C.\\n\\nIf you hit a C, update all entries from the left pointer up until the current index with the correct value. This is the minimum between the distance to the current C and the previous distance to another C. Finally, update the last seen C index to the current index.\\n\\n```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055960,
                "title": "intuition-leads-to-approach-java-optimize-intuition-to-get-effective-solution",
                "content": "**Intuition:**\\n**Simple intuition**: \\n\\n* Suppose the answer is stored ans array.\\n* ans[i] is minimum of distances from all the positions of character C in string S\\nEx : Input: s = \"loveleetcode\", c = \"e\"\\nIndices of e = {3, 5, 6, 12}\\n* To get the shortest distance, we need to check the nearest from both sides.\\n* Run 2 loops from both end, updating the min value.\\n\\n**Solution**:\\n* We have to traverse the array two times, one from left to right & right to left.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N) ~ O(N)\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n**Intuition 2**: \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Optimization**: \\nWhile traversing the string, \\n* ans[i] = 0 for all i where s.charAt(i) == c\\n* start filling from the index of character to both ends.\\n1. For forward: start filling {1, 2, 3... } from j = i+1 till we reach to another c or end of the string.\\n2. For backward : From j = i -1 till we reach to another c or start of the string.\\n\\t\\t\\t\\t\\t\\t\\tFill minimum of ans[j] &  i - j (distance of j from i).\\n* If at any point if ans[j] is less than & equal to i-j, for all the elements before jth index i-j is greater than ans[j]\\n\\n**Solution**:\\n* We have to traverse the array from one end, if there is a character c, update in backward too.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N/2) ~ O(N) where N is number of string.\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264608,
                "title": "c-basic-easy-implementaion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965854,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054376,
                "title": "java-2-solutions-self-explained-easy-to-read-2-iterations",
                "content": "1- Using DP\\n* going from left to right, at each position i ans[i] = ans[i-1] + 1\\n* going from right to left, at each position i ans[i] = ans[i+1] + 1\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\\n\\n2- keep track of last appearance of C\\n* pos = last appearance of c\\n* going from left to right, dist[i] = i - pos\\n* going from right to left, dist[i] = pos - i\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054157,
                "title": "javascript-simple-1-pass-beats-100",
                "content": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170593,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){ \\n        int mn=INT_MAX;\\n        for(int j=0;j<position.size();j++){\\n            mn=min(mn,abs(i-position[j]));\\n        }\\n             ans.push_back(mn);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 514955,
                "title": "javascript-solution-with-comments",
                "content": "> Runtime: **92 ms**, faster than *51.38%* of JavaScript online submissions\\n> Memory Usage: **40.8 MB**, less than *58.84%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511187,
                "title": "javascript-2-passes",
                "content": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300191,
                "title": "java-do-check-out-for-explanation-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nThe idea is to find the minimum char say c index from right for all position.\\nAnd again find the minimum char say c index from left for all position.\\nNow, whichever (left or right) gives you the minimum that is the minimum distance for char c for that position.\\n\\n```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226696,
                "title": "python3-any-improvement",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090998,
                "title": "2-line-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055497,
                "title": "c-two-pass-easy-to-understand-solution",
                "content": "**Approach 1 : Using BFS for shortest distance** \\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(n) \\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 :  Without extra space , two traversals -one from start , another from end**\\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHave doubts , please let me know in comments.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914650,
                "title": "python3-100-faster-100-less-memory-20ms-14mb",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596450,
                "title": "c-easiest-o-n-time-100-fastest",
                "content": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557360,
                "title": "easy-java-o-n-soution",
                "content": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226939,
                "title": "easiest-python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007025,
                "title": "python-3-solution-brute-force-and-two-pointers-2-solutions",
                "content": "Brute Force:\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\\n\\nTwo Pointers, O(n) Time and Space\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054414,
                "title": "java-2-pointer-o-n-1ms-beats-97",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1054364,
                "title": "2-pass-but-different-and-intuitive-comments-included",
                "content": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054208,
                "title": "shortest-distance-to-a-character-simple-dp-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nSince this problem is asking us to reference characters both ahead and behind the current charcter, this should bring to mind a two-pass **dynamic programming** solution. We can iterate through the input string (**S**) once and fill our answer array (**ans**) with the distance from the preceeding occurrence of **C**.\\n\\nThen we can iterate backwards through **S** again so that we can pick the best result between the value we obtained in the first pass with the distance from the preceeding **C** going the opposite direction.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 39.0MB** (beats 99% /100%).\\n```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python3 Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 99% / 86%).\\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.8MB** (beats 97% / 93%).\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms /6.5MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054175,
                "title": "c-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}\\n\\t\\t\\tfor (i = lastC; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = min(ans[i], lastC - i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 687583,
                "title": "java-two-pointers-one-pass-time-o-n-optimal-faster-than-98-5",
                "content": "Approach:\\n\\nMaintain two pointers (one for the current character in S (sIndex) and the other (cIndex) to track the next occurence of C in S). Also have another variable to hold the previous occurence of C in S (prevCIndex) which is initially set to -1.\\n\\nFirstly, as it\\'s guaranteed to have at least one C in S, find the first occurence of C in S by incrementing C pointer (cIndex). Now, until the S pointer (sIndex) reaches C pointer (cIndex), calculate the shortest distance which is (cIndex - sIndex). Remember at this stage there is no previous occurrence of C in S. Therefore, `result[i] = cIndex - sIndex;`\\n\\nMoving on, there are two cases: \\n1) You might\\'ve a next of occurrence of C in S\\n2) You might not have any more occurrences of C (in the case which cIndex is beyond String length). \\n\\nIn the former, you get the minimum of the previous C Index and the current C Index to the current character in S (`Math.min(cIndex - sIndex, sIndex - prevCIndex)`)\\n& in the latter you just calculate the distance from the previous C Index to the current character in S (`sIndex - prevCIndex`).\\n\\nRefer to the below code for better understanding.\\n\\n```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```\\n\\n\\nTime: O(n)\\nSpace: O(1) (Excluding the result array to be returned)",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420683,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686262,
                "title": "java-easy-to-understand",
                "content": "# Happy Coding\\u270C\\uFE0F\\u270C\\uFE0F\\u270C\\uFE0F\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656937,
                "title": "java-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318807,
                "title": "simple-javascript-solution-faster-than-80-only-1-loop",
                "content": "You just push a 0 if the char is the c, and if not you calculate the min between the distance of the last 0 and the next c in the string using indexOf and lastIndexOf\\n\\n````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541999,
                "title": "java-98-faster-only-one-loop-simple-efficient",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056605,
                "title": "c-o-n-easy-to-understand",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote if found helpful**",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055763,
                "title": "python-shortest-distance-to-a-character-runtime-32ms-memory-usage-14-200-kb",
                "content": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "codeTag": "Unknown"
            },
            {
                "id": 1055141,
                "title": "any-language-two-pass-o-n-0ms-very-easy-with-detailed-explanation-example-on-golang",
                "content": "How to find a minimal distance? We need to take into consideration only distance from closest letters from left and right side. No need to count distance from far remote letters.\\n\\n\\nNext, when we see a part of a string like here and suppose we want to calculate distance from `o` to closest `e`\\'s.\\n```\\nleetcode\\n     ^\\n```\\nLet\\'s split a task into 2 symmetrical ones: distance from left letter and distance from right letter.\\n\\nHow to calculate and store distance from left `e`? Just walk through the string and check - if we see letter `e` then its distance is 0, and with any another letter distance increments by 1.\\n\\nSo distances between letters `e` will be (I\\'ve added extra space between letters for readibility):\\n\\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\\n\\nNext, go from right with the same distance calculation. But this time check if there\\'s a closer letter `e` from another side.\\n\\nWe may code this using any language only with standard operators and arrays. \\nHere\\'s an example on Golang.\\n\\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nleetcode\\n     ^\\n```\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054648,
                "title": "java-solution-linear-time",
                "content": "```\\nclass Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }\\n            \\n            if(r == -1)\\n                ans[i] = i-l;\\n            else if(l == -1)\\n                ans[i] = r-i;\\n            else if(r != -1 && l != -1)\\n                ans[i] = Math.min(i - l , r - i);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054131,
                "title": "python-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 872326,
                "title": "declarative-javascript-solution-using-array-reduce-and-array-map",
                "content": "Modern declarative JavaScript use of string destructuring and array methods.\\n\\nPlease keep in mind, this is an example of declarative JavaScript programming vs imperative solutions.\\nThe solution won\\'t be the fastest or the most memory efficient.\\n\\nHere\\'s some references if you\\'re more interested about what reduce and map can do:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 605819,
                "title": "2-solutions-easy-to-understand-faster-binary-search-python-solution",
                "content": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 465841,
                "title": "javascript-solution",
                "content": "Probably not the best solution but it\\'s straightforward and works \\n\\nSteps:\\n- initialize an array \\n- Loop through the string\\n- find the closest character C with a helper function \\n\\n- at each letter, calculate and return the distance of the closest C \\n- push that value distance to the array \\n\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444317,
                "title": "python-with-comments",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 125798,
                "title": "c-simplest-solution-o-n",
                "content": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3590757,
                "title": "very-easy-to-understand",
                "content": "# PLEASE UPVOTE IF YOU ANYWAY LIKE IT\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481559,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287751,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103959,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091201,
                "title": "c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747153,
                "title": "runs-100-faster-cpp-soln-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }\\n        for(int i = n-1 ; i >= 0 ;i--){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(min(abs(last-i) , ans[i]));\\n       }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2566014,
                "title": "c-fast-and-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552819,
                "title": "js-easy-solution-100",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394618,
                "title": "easiest-approach-5-ms-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281644,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183851,
                "title": "python3-o-n-o-n-runtime-53ms-78-92-memory-13-9mb-91-60",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094832,
                "title": "nice-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984164,
                "title": "shortest-distance-to-a-character",
                "content": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738902,
                "title": "easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718249,
                "title": "beats-100-runtime-optimal-2-pass-in-python",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505571,
                "title": "easy-solution-using-c",
                "content": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1262329,
                "title": "easy-to-understand-o-n-c-java",
                "content": "Implementation\\n\\n**1st Approach in C++**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\\n\\n\\n**2nd Approach in Java**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063474,
                "title": "c-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054837,
                "title": "easier-to-understand-python-solution",
                "content": "idea is to traverse from left to right and check the distance of character c and in second iteration we traverse from right to left and update the min(right side,  left side)\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1054586,
                "title": "shortest-distance-to-character-c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054571,
                "title": "c-solution",
                "content": "```public class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                res[i] = 0;\\n                distLeft = i;\\n            }\\n            else\\n            {\\n                if (distLeft != -1 && Math.Abs(i - distLeft) < res[i])\\n                    res[i] = Math.Abs(i - distLeft);\\n            }\\n            \\n            int j = sLength - i - 1;\\n            if (s[j] == c)\\n            {\\n                res[j] = 0;\\n                distRight = j;\\n            }\\n            else\\n            {\\n                if (distRight != -1 && Math.Abs(j - distRight) < res[j])\\n                    res[j] = Math.Abs(j - distRight);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054128,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989004,
                "title": "easy-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922852,
                "title": "c-easy-100-memory",
                "content": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 728595,
                "title": "sharing-most-elegant-cpp-solution-12-ms",
                "content": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 619508,
                "title": "rust-100-with-iterators",
                "content": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604194,
                "title": "c-beats-all",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }\\n        auto fe = find(f+1,S.end(),c);\\n        while(i!=S.end())\\n        {\\n            if(*i==c)\\n            {\\n                v.push_back(0);\\n                f = i;\\n                fe = find(f+1,S.end(),c);\\n                i++;\\n            }\\n            else\\n            {\\n                if(fe!=S.end())\\n                    v.push_back(min(abs(fe-i),abs(f-i)));\\n                else\\n                    v.push_back(abs(f-i));\\n                i++;\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 600909,
                "title": "simple-cpp-100-100",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n\\t\\t\\tvector<int> idx,res;\\n\\t\\t\\tbool first = true;\\n\\t\\t\\t//this is just to maintain a  vector to maintain values\\n\\t\\t\\tfor(int  i = 0 ; i < S.size();i++){\\n\\t\\t\\t\\tif(S[i]==C&&first){\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tfirst=false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(S[i]==C){\\n\\t\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n        //the below function is the main logic\\n      \\n\\t  int temp = 1 ; \\n        for(int i = 0 ; i  <S.size();i++){\\n            if(S[i]!=C)res.push_back(min(abs(idx[temp-1]-i),abs(idx[temp]-i)));\\n            else{\\n             res.push_back(0);\\n                if(temp!=idx.size()-1) temp++;\\n                else continue;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506937,
                "title": "easy-to-understand-c-solution-8ms",
                "content": "Runtime: 8 ms, faster than 98.14% of C++ online submissions for Shortest Distance to a Character.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Shortest Distance to a Character.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < S.size(); i++)\\n        {\\n            int index = lower_bound(pos.begin(), pos.end(), i) - pos.begin();\\n            int prevDiff = (index - 1 >= 0 ? i - pos[index - 1] : INT_MAX);\\n            int nextDiff = (index < pos.size()  ? pos[index] - i : INT_MAX);\\n            \\n            int minDiff = min(prevDiff, nextDiff);\\n            res.push_back(minDiff);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429615,
                "title": "python-easy-solution",
                "content": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "codeTag": "Java"
            },
            {
                "id": 416688,
                "title": "simple-intuitive-solution-c",
                "content": "Just keep a check on places of occurences of \\'C\\' and greedily choose the shortest (to left or right)\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411160,
                "title": "python-3-o-1-auxiliary-space-one-traversal-algorithm",
                "content": "Instead of keeping O(2N) minimum distance list by traversing twice, I just kept the length of the substring that exists between the character C or edge and output the distance.\\n```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363065,
                "title": "python-bfs-on-graph-commented-and-explained",
                "content": "**Idea**\\n- Shortest distance to a character === Shortest distance from a character\\n- build uniform graph and run a BFS algo\\n- keep a variable r outside the loop to keep track of raduis\\n\\n**## initial ##**\\n- Not aware that the special char could occur multiple times in the string, I intilaly built a graph in which each node is simply a char in S and did a BFS. This approach of building a graph would work only if the characters in the string were unique (duplicates not allowed)\\n\\n**## Modified ##**\\n- In order to count for duplicates, now we must allow duplictaes in the graph. So, Instead of building a graph of chars where a node = char, we make a graph in which each node represents a (char, index) pair. Now we need to run BFS as many times as C occures in S and \\n\\n**Steps**\\n- Build a graph that allows duplicates - node = (char, index) pair\\n- Iterate iver the string S and for every encounter of the desired char C -> run a BFS on the graph with C as the starting point in the queue\\n- keep track of min distance of every char from C in a dictionary\\n\\n**Example to demonstarte idea:**\\nS = \"lovely\", C = \"L\"\\n\\nl   o   v   e   l   y\\n0  1  2   3  4  5  -> distances from C when C = the first incident of l at index 0\\n4  3  2   1  0  1  -> distances from C when C = second incident of l at index 4\\n0  1  2   1  0  1  -> the smaller of the two distances above is the final distance we need to return\\n\\n**Visuals**\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317520.png)\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317527.png)\\n\\n**Code**\\n\\n```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359339,
                "title": "java-sliding-window-2-pass-full-details",
                "content": "The 1st pattern that came to mind was to use a **Sliding Window**. We can do it T:O(n), S:O(n) like the accepted solution. The below Java code runs in 1ms. It uses 2 pointers to check for the closest occurence of C from i and the second closest occurence of C (if it exists) from i. Here, we also get the *Mininimum Absolute Distance* between *(curr - i)* and *(next - i)*. As soon as i is closer to next that it is to curr, we update curr with next and next with the next occurene of C (if it exists) in the list of occurences we created earlier.\\n\\n**Algo:**\\n\\n1.  Store all occurences of C in S into a list\\n2.  Go through S once by checking for Min_Absolute_Distance(curr - i, next - i)\\n3.  Update curr and next accordingly as soon as i is closer to next than curr\\n\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\\nCompact version:\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325759,
                "title": "c-solution-o-n",
                "content": "C# solution. o(n)\\n```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324885,
                "title": "python-easy-two-passes-solution",
                "content": "99.7% speed\\n```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285409,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205746,
                "title": "python-easy-to-understand",
                "content": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 156216,
                "title": "2-pass-solution-in-c-beats-100-submissions",
                "content": "For a given element at position `i`, it\\'s shortest distance to the `C` is `min(shortest_distance_to_left_occuence[i], shortest_distance_to_right_occurence[i])`, where `shortest_distance_to_left_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i-1] + 1`. Similarly `shortest_distance_to_right_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i+1] + 1`.\\n\\nFirst pass keeps track of the shortest distance to the left occurence of the `C` and second pass takes into account right occurences of `C`.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128296,
                "title": "python-solution-from-a-beginner",
                "content": "I am new to Python, I know it is not the most efficient way...but hope you enjoy. :)\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125801,
                "title": "python-o-n-solution",
                "content": "* Idea is to move from left to right, right to left and update distance related to seen character\\n``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034738,
                "title": "best-java-solution-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899350,
                "title": "simple-solution-using-two-pointers-o-n-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using two pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We need to store previous and next closest occurrence of the character `c` in both the sides of the current index, `i`.\\n- `previous` will have the closest occurrence of `c` to the left side of `i`.\\n- `next` will have the closest occurrence of `c` to the right side of `i`. \\n- Everytime `i` moves past `next`, the following operations will be made\\n  * `prev = next` \\n  * `next` moves forward in searching the next occurrence of `c` \\n- At every index, the absolute minumum of `next - i` and `i - previous` gives the shortest distance to `c` \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (for result array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765194,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566001,
                "title": "two-pointer-o-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using two pointer approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->We will have two pointers, and change them over when the right one will be more closer, the right one will become left pointer , and we\\'ll get a  new right pointer if there exists one.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) {for solution array only}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317704,
                "title": "c-unique-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316847,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316820,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149079,
                "title": "best-explained-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901189,
                "title": "javascript-js-simple-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874523,
                "title": "python3-long-but-fast-faster-than-97-10",
                "content": "# Code\\n```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/821d480c-a58b-418b-8032-8aec83439aa7_1670107858.6099043.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632244,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592295,
                "title": "python-simplest-solution",
                "content": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533533,
                "title": "o-1-space-prefix-suffix-with-comments",
                "content": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "codeTag": "Python3"
            },
            {
                "id": 2497968,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467922,
                "title": "c-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }\\n            ans[i]=i-pos;\\n        }\\n        for(int i=pos-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                pos=i;\\n            ans[i]=min(ans[i],pos-i);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2460480,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429280,
                "title": "2-simple-and-concise-python-solutions-with-in-depth-explanation",
                "content": "Solution 1:\\nWe will create a list called indices or storing the indices of c. Then we will find the closest absolute distance\\nbetween the current character and the c. We will use another list named res to store the result. Now we will run a for loop from i=0 to i=len(s). Every time we put minIndex to some random large number let\\'s say 99999. We have to choose this random number such that it is always greater than the len(s). In this for loop if s[i]==c i.e if currecnt character in s is equal to c then we know that the closest distacnce is obviously 0. If s[i] !=c , then we will run a for loop from the indices list which we got previously. This for loop checks for the minimum index among all the available indices. At last we will return our res list.  \\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\\nSolution 2:\\nThis is same as solution 1 except that we use one liner for creating indices list and checking the minimum Index in the else part of for loop.\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```\\nPlease upvote if you like the solution. \\nConnect with me at https://www.linkedin.com/in/podilichaitanyaakhilkumar/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416137,
                "title": "easy-javascript-solution-beats-92",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379300,
                "title": "c-solution-easy-to-understand",
                "content": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "solutionTags": [],
                "code": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2283509,
                "title": "python-simple-solution-explained",
                "content": "Hello,\\n\\nI did submit my simple solution.\\n\\nI try to find all the **indexes** of the **character** and then i loop over the string again to calculate the shortest distance based of the **indexes**. \\n\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260097,
                "title": "two-pass-technique-c-o-n-o-1",
                "content": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207577,
                "title": "easy-o-n",
                "content": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go"
                ],
                "code": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117263,
                "title": "javascript-infinity-solution-2-pointers-v-s-2-pass",
                "content": "**2 Pointers**\\n\\nRecord all indexes of `c`, then determine the **NEAREST distance from BOTH SIDES** for each `s[i]`.\\n> Note: for BOUNDARY condition, I add `-Infinity` and `Infinity` at both ends.\\n\\n```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\\n\\n**2 Pass**\\n\\nLoop from left to get **NEAREST distance from LEFT**.\\nThen loop from right again, update the **MINIMUM of two**.\\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2107104,
                "title": "821-shortest-distance-to-a-character-array-java-solution",
                "content": "Hi, in this problem i follow below steps :------>\\n\\n*First create a list to store the location of character c in given array.\\n*Create an array for result and the traverse again the array and calculate the minimum distance using created list. See Below Code ---->\\n\\nHappy Coding :)\\n\\nCODE ------>\\n\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }\\n        }\\n        list.add(10000);\\n        \\n        int first = list.get(0);\\n        int second = list.get(1);\\n        int j = 2;\\n        int[] res = new int[n];\\n        \\n        for (int i=0; i<n; i++){\\n            if(s.charAt(i)!=c){\\n                res[i] = Math.min(i-first, second-i);\\n            }else{\\n                first = second;\\n                second = list.get(j++);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2078271,
                "title": "java-1ms-99-09",
                "content": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025617,
                "title": "java-too-easy-solution",
                "content": "//do upvote :)\\n\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2022757,
                "title": "it-s-beginner-s-thinking",
                "content": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "codeTag": "Unknown"
            },
            {
                "id": 1973716,
                "title": "scan-twice-easy-to-read",
                "content": "Below was my thought process although I could not find optimized solution at once\\n\\nto find closet distance\\n1. init array with maximum distance of len(n)\\n2. scan left to right find distance and store previous occurence index\\n3. scan right to left and store previous occurence index\\n\\n```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929483,
                "title": "c-simple-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830996,
                "title": "javascript-straight-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816678,
                "title": "c-simple-solution",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748946,
                "title": "c-two-pointer-approach",
                "content": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715270,
                "title": "java-solution",
                "content": "```class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        int j=0;\\n        int k=0;\\n        List<Integer> list2=new ArrayList<>();\\n        while(j < s.length()){\\n            if(k==0){\\n                list2.add(Math.abs(list.get(k)-j));\\n            }\\n            else{\\n                int val1=Math.abs(list.get(k-1)-j);\\n                int val2=Math.abs(list.get(k)-j);\\n                if(val1 < val2)\\n                    list2.add(val1);\\n                else\\n                    list2.add(val2);\\n            }\\n            if(j==list.get(k) && k < list.size()-1)\\n                k++;\\n            j++;\\n        }\\n        int[] result=new int[list2.size()];\\n        int i=0;\\n        for(int ele:list2)\\n            result[i++]=ele;\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1706047,
                "title": "java-using-a-list-to-store-indexes-of-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704001,
                "title": "java-simple-easy",
                "content": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678713,
                "title": "cpp-soln",
                "content": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }\\n      \\n      \\n      \\n      for(int j=0;j<s.size();j++)\\n      {\\n        int t,l=100000;\\n        for(int k=0;k<v.size();k++)\\n        {\\n          \\n          t=abs(j-v[k]);\\n          l=min(l,t);\\n          \\n        }\\n        ans.push_back(l);\\n        \\n      }\\n      \\n   return ans;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1650522,
                "title": "100-fast-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643399,
                "title": "c-faster-than-100-of-solutions",
                "content": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619364,
                "title": "python-simple-solution-with-help-of-list-comprehension",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618164,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616196,
                "title": "c-two-pointer-easy-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please don\\'t forget to upvote.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603964,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596687,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525508,
                "title": "c-easy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456750,
                "title": "two-pass-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }\\n            else if (pos != -1 && chars[i] != c) {\\n                res[i] = Math.abs(i - pos);\\n            }\\n        }\\n        // before each c, update distance\\n        for (int i = chars.length - 1; i >= 0; i--) {\\n            if (chars[i] == c) {\\n                pos = i;\\n            }\\n            else {\\n                res[i] = Math.min(res[i], Math.abs(i - pos));\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1431570,
                "title": "java-easy-solution-o-n-time",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1430002,
                "title": "intuitive-approach-c",
                "content": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1402373,
                "title": "java-2-pass-solution-o-n-time",
                "content": "**Runtime: 2 ms\\nMemory Usage: 39.8 MB**\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**Time Complexity : 2*O(N) -> O(N)\\nSpace Complexity : O(N) (for output)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394746,
                "title": "2-pointers-java-scan-for-occurrences-easy",
                "content": "**Flow**\\n1. scan for occurrences of char c\\n2. Then init pointer current \\n3. Compare abs for pointer and nextPointer for each char a \\n4. If next is smaller then increase pointer\\n! Also check for out of bounds if so just place asb for current pointer no need for the next one \\n\\n\\n ```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382699,
                "title": "cpp-solution-faster-than-97-cpp-solutions-and-memory-consumption-less-than-98-8-cpp-solutions",
                "content": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1379201,
                "title": "c-binary-search-o-nlogm-0ms-beats-100",
                "content": "Make an array store all the presence of c in it,after that use binary search to find the shortest distance\\n```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352511,
                "title": "100-faster-java-2-pass-solution",
                "content": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349618,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }\\n            }\\n            else\\n                ans.push_back(abs(i- v[iB]));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1337089,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332255,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302503,
                "title": "c-2-approaches-using-map-without-map-2-pass",
                "content": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291395,
                "title": "solution-for-slow-learner-like-me-o-n2-solution-intuitive",
                "content": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "solutionTags": [],
                "code": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1265996,
                "title": "java-solution-in-10-lines-with-explanation",
                "content": "**Explanation** - We first create a TreeSet containing the positions of character c in string s. Then we iterate through all the indices of string s and find the nearest two values from the current position in the string using this set. One of these two values is less than the current position and the other greater. We calculate the difference of both from the current position. The lower one is the answer. We do this for all positions in the string.\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237231,
                "title": "python-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231753,
                "title": "c-1-o-n-optimized-brute-force-2-dp-based-o-n",
                "content": "**1. O(n) based optimized**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. DP BASED**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1810314,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1972844,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1568015,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1662769,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2053090,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1955192,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1790666,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Substrings Between Each Pair of Parentheses",
        "question_content": "<p>You are given a string <code>s</code> that consists of lower case English letters and brackets.</p>\n\n<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>\n\n<p>Your result should <strong>not</strong> contain any brackets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(abcd)&quot;\n<strong>Output:</strong> &quot;dcba&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(u(love)i)&quot;\n<strong>Output:</strong> &quot;iloveu&quot;\n<strong>Explanation:</strong> The substring &quot;love&quot; is reversed first, then the whole string is reversed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(ed(et(oc))el)&quot;\n<strong>Output:</strong> &quot;leetcode&quot;\n<strong>Explanation:</strong> First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> only contains lower case English characters and parentheses.</li>\n\t<li>It is guaranteed that all parentheses are balanced.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 383670,
                "title": "java-c-python-tenet-o-n-solution",
                "content": "# **Solution 1: Brute Force**\\nHere is the **brute force** solution, which seems really easy to write.\\nNothing more to talk about.\\n\\nTime `O(N^2)`, Space `O(N)`\\n<br>\\n\\n**Python**\\n```py\\n    def reverseParentheses(self, s):\\n        res = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                res.append(\\'\\')\\n            elif c == \\')\\':\\n                res[len(res) - 2] += res.pop()[::-1]\\n            else:\\n                res[-1] += c\\n        return \"\".join(res)\\n```\\n\\n**C++**\\n```cpp\\n    string reverseParentheses(string s) {\\n        vector<int> opened;\\n        string res;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(res.length());\\n            else if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                reverse(res.begin() + j, res.end());\\n            } else {\\n                res += s[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n<br>\\n\\n# **Solution 2: Wormholes**\\n\\n## **Intuition**\\nNice. I got a green accpeted with solution 1.\\nNow before move on, let us check the solutions in the discuss.\\n\\nHey hey hey wait, `ALL` solutions are **BRUTE FORCE** ?\\nHmmmm... why not `O(N)`?\\n\\nFine fine fine, here comes an easy `O(N)` solution.\\n\\n## **Explanation**\\n\\nIn the first pass,\\nuse a stack to find all paired parentheses,\\nI assume you can do this.\\n\\nNow just imgine that all parentheses are wormholes.\\nAs you can see in the diagram,\\nthe paired parentheses are connected to each other.\\n\\n![image](https://assets.leetcode.com/users/lee215/image_1571315420.png)\\n\\nFirst it follows the left green arrrow,\\ngo into the left wormhole and get out from the right wormhole.\\nThen it iterates the whole content between parentheses.\\nFinally it follows the right arrow,\\ngo into the left wormhole,\\nget out from the right wormhole and finish the whole trip.\\n\\nSo in the second pass of our solution,\\nit traverses through the paired parentheses\\nand generate the result string `res`.\\n\\n`i` is the index of current position.\\n`d` is the direction of traversing.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)` for two passes\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        Stack<Integer> opened = new Stack<>();\\n        int[] pair = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'(\\')\\n                opened.push(i);\\n            if (s.charAt(i) == \\')\\') {\\n                int j = opened.pop();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\') {\\n                i = pair[i];\\n                d = -d;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        vector<int> opened, pair(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(i);\\n            if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        string res;\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\')\\n                i = pair[i], d = -d;\\n            else\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def reverseParentheses(self, s):\\n        opened = []\\n        pair = {}\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                opened.append(i)\\n            if c == \\')\\':\\n                j = opened.pop()\\n                pair[i], pair[j] = j, i\\n        res = []\\n        i, d = 0, 1\\n        while i < len(s):\\n            if s[i] in \\'()\\':\\n                i = pair[i]\\n                d = -d\\n            else:\\n                res.append(s[i])\\n            i += d\\n        return \\'\\'.join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def reverseParentheses(self, s):\\n        res = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                res.append(\\'\\')\\n            elif c == \\')\\':\\n                res[len(res) - 2] += res.pop()[::-1]\\n            else:\\n                res[-1] += c\\n        return \"\".join(res)\\n```\n```cpp\\n    string reverseParentheses(string s) {\\n        vector<int> opened;\\n        string res;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(res.length());\\n            else if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                reverse(res.begin() + j, res.end());\\n            } else {\\n                res += s[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        Stack<Integer> opened = new Stack<>();\\n        int[] pair = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'(\\')\\n                opened.push(i);\\n            if (s.charAt(i) == \\')\\') {\\n                int j = opened.pop();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\') {\\n                i = pair[i];\\n                d = -d;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```cpp\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        vector<int> opened, pair(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(i);\\n            if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        string res;\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\')\\n                i = pair[i], d = -d;\\n            else\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def reverseParentheses(self, s):\\n        opened = []\\n        pair = {}\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                opened.append(i)\\n            if c == \\')\\':\\n                j = opened.pop()\\n                pair[i], pair[j] = j, i\\n        res = []\\n        i, d = 0, 1\\n        while i < len(s):\\n            if s[i] in \\'()\\':\\n                i = pair[i]\\n                d = -d\\n            else:\\n                res.append(s[i])\\n            i += d\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382775,
                "title": "python3-straightforward-easiest-on-discussion",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(\\'\\')\\n            elif c == \\')\\':\\n                add = stack.pop()[::-1]\\n                stack[-1] += add\\n            else:\\n                stack[-1] += c\\n        return stack.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(\\'\\')\\n            elif c == \\')\\':\\n                add = stack.pop()[::-1]\\n                stack[-1] += add\\n            else:\\n                stack[-1] += c\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382367,
                "title": "simple-stack-and-queue-solution",
                "content": "```\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray()){\\n            if( c == \\')\\'){\\n                Queue<Character> p = new LinkedList<>();\\n                while(!st.isEmpty() && st.peek() != \\'(\\') p.add(st.pop());\\n                if(!st.isEmpty()) st.pop();\\n                while(!p.isEmpty()) st.push(p.remove());\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()) sb.append(st.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray()){\\n            if( c == \\')\\'){\\n                Queue<Character> p = new LinkedList<>();\\n                while(!st.isEmpty() && st.peek() != \\'(\\') p.add(st.pop());\\n                if(!st.isEmpty()) st.pop();\\n                while(!p.isEmpty()) st.push(p.remove());\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()) sb.append(st.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382422,
                "title": "0-ms-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string res;\\n        for (int i = 0; i < s.size(); i ++) {\\n            if (s[i] == \\'(\\') {\\n                st.push(i);    \\n            } else if (s[i] == \\')\\') {\\n                int top = st.top();\\n                st.pop();\\n                reverse(s.begin() + top + 1, s.begin() + i);\\n            }\\n        }\\n        for (auto it: s) {\\n            if (it != \\'(\\' && it != \\')\\') {\\n                res.push_back(it);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string res;\\n        for (int i = 0; i < s.size(); i ++) {\\n            if (s[i] == \\'(\\') {\\n                st.push(i);    \\n            } else if (s[i] == \\')\\') {\\n                int top = st.top();\\n                st.pop();\\n                reverse(s.begin() + top + 1, s.begin() + i);\\n            }\\n        }\\n        for (auto it: s) {\\n            if (it != \\'(\\' && it != \\')\\') {\\n                res.push_back(it);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382358,
                "title": "simple-java-sol-recursion",
                "content": "```\\npublic String reverseParentheses(String s) {\\n        int begin = 0;\\n        int end;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\')\\n                begin = i;\\n            if(s.charAt(i) == \\')\\'){\\n                end = i;\\n                String temp = s.substring(begin + 1, end);\\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\\n            }\\n        }\\n        return s;\\n    }\\n\\n    String reverseString(String s){\\n        char[] temp = s.toCharArray();\\n        StringBuilder r = new StringBuilder();\\n        for (int i = temp.length-1; i>=0; i--)\\n            r.append(temp[i]);\\n\\n        return r.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) {\\n        int begin = 0;\\n        int end;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\')\\n                begin = i;\\n            if(s.charAt(i) == \\')\\'){\\n                end = i;\\n                String temp = s.substring(begin + 1, end);\\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\\n            }\\n        }\\n        return s;\\n    }\\n\\n    String reverseString(String s){\\n        char[] temp = s.toCharArray();\\n        StringBuilder r = new StringBuilder();\\n        for (int i = temp.length-1; i>=0; i--)\\n            r.append(temp[i]);\\n\\n        return r.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382421,
                "title": "java-python-3-iterative-short-o-n-2-codes-w-comment-and-analysis",
                "content": "E.g, `s` = `\"(ed(et(oc))el)\"`, output = `\"leetcode\"`\\nPlease refer to the following vivid picture drawn by **@dragonfire** for the code logic.\\n\\n![image](https://assets.leetcode.com/users/rock/image_1568917464.png)\\n**Java**\\nUse a StringBuilder to save substring in a pair of matched brackets and a Deque to save StringBuilders. \\n\\n```\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> dq = new ArrayDeque<>();\\n        dq.push(new StringBuilder()); // In case the first char is NOT \\'(\\', need an empty StringBuilder.\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') { // need a new StringBuilder to save substring in brackets pair\\n                dq.offer(new StringBuilder());\\n            }else if (c == \\')\\') { // found a matched brackets pair and reverse the substring between them.\\n                StringBuilder end = dq.pollLast();\\n                dq.peekLast().append(end.reverse());\\n            }else { // append the char to the last StringBuilder.\\n                dq.peekLast().append(c);\\n            } \\n        }\\n        return dq.pollLast().toString();\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\nUse a List to save substring in a pair of matched brackets and a stack to save Lists. \\n```\\n    def reverseParentheses(self, s: str) -> str:\\n        stk = [[]]\\n        for c in s:\\n            if c == \\'(\\':\\n                stk.append([])\\n            elif c == \\')\\':\\n                end = stk.pop()\\n                stk[-1].extend(reversed(end))\\n            else:\\n                stk[-1].append(c)    \\n        return \\'\\'.join(stk.pop())\\n```\\n\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(n), where n = s.length().",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> dq = new ArrayDeque<>();\\n        dq.push(new StringBuilder()); // In case the first char is NOT \\'(\\', need an empty StringBuilder.\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') { // need a new StringBuilder to save substring in brackets pair\\n                dq.offer(new StringBuilder());\\n            }else if (c == \\')\\') { // found a matched brackets pair and reverse the substring between them.\\n                StringBuilder end = dq.pollLast();\\n                dq.peekLast().append(end.reverse());\\n            }else { // append the char to the last StringBuilder.\\n                dq.peekLast().append(c);\\n            } \\n        }\\n        return dq.pollLast().toString();\\n    }\\n```\n```\\n    def reverseParentheses(self, s: str) -> str:\\n        stk = [[]]\\n        for c in s:\\n            if c == \\'(\\':\\n                stk.append([])\\n            elif c == \\')\\':\\n                end = stk.pop()\\n                stk[-1].extend(reversed(end))\\n            else:\\n                stk[-1].append(c)    \\n        return \\'\\'.join(stk.pop())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382530,
                "title": "simple-stack-java-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                str += s.charAt(i);\\n            }else if(s.charAt(i) == \\'(\\'){\\n                st.push(str);\\n                str = \"\";\\n            }else{\\n                String p = st.pop();\\n                String r = new StringBuilder(str).reverse().toString();\\n                str = p + r;               \\n            }                \\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                str += s.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 834725,
                "title": "c-4ms-clean-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<string> st;\\n        string cur = \"\";\\n        for(int i=0;i<s.size();++i){\\n            if(s[i] == \\'(\\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n            }\\n            else if(s[i] == \\')\\'){\\n                reverse(cur.begin(),cur.end());\\n                cur = st.back()+cur;\\n                st.pop_back();\\n            }else cur += s[i];\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<string> st;\\n        string cur = \"\";\\n        for(int i=0;i<s.size();++i){\\n            if(s[i] == \\'(\\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n            }\\n            else if(s[i] == \\')\\'){\\n                reverse(cur.begin(),cur.end());\\n                cur = st.back()+cur;\\n                st.pop_back();\\n            }else cur += s[i];\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010219,
                "title": "java-using-stack-character",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n    Stack<Character> stack = new Stack<>();\\n\\n    for (char symbol : s.toCharArray()) {\\n      if (symbol == \\')\\')\\n        reverseLast(stack);\\n      else\\n        stack.push(symbol);\\n    }\\n\\n    return stackToString(stack);\\n  }\\n\\n  private void reverseLast(Stack<Character> stack) {\\n    StringBuilder reversed = new StringBuilder();\\n    while (!stack.isEmpty() && stack.peek() != \\'(\\') \\n      reversed.append(stack.pop());\\n\\n    stack.pop();\\n\\n    for (char symbol : reversed.toString().toCharArray()) \\n      stack.push(symbol);\\n  }\\n\\n  private String stackToString(Stack<Character> stack) {\\n    StringBuilder result = new StringBuilder();\\n    \\n    while (!stack.isEmpty()) \\n      result.insert(0, stack.pop());\\n\\n    return result.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n    Stack<Character> stack = new Stack<>();\\n\\n    for (char symbol : s.toCharArray()) {\\n      if (symbol == \\')\\')\\n        reverseLast(stack);\\n      else\\n        stack.push(symbol);\\n    }\\n\\n    return stackToString(stack);\\n  }\\n\\n  private void reverseLast(Stack<Character> stack) {\\n    StringBuilder reversed = new StringBuilder();\\n    while (!stack.isEmpty() && stack.peek() != \\'(\\') \\n      reversed.append(stack.pop());\\n\\n    stack.pop();\\n\\n    for (char symbol : reversed.toString().toCharArray()) \\n      stack.push(symbol);\\n  }\\n\\n  private String stackToString(Stack<Character> stack) {\\n    StringBuilder result = new StringBuilder();\\n    \\n    while (!stack.isEmpty()) \\n      result.insert(0, stack.pop());\\n\\n    return result.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055548,
                "title": "java-stack-3ms",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n       for(char c : s.toCharArray()){\\n           if(c == \\')\\'){\\n               StringBuilder stringBuilder = new StringBuilder();\\n               while (stack.peek() != \\'(\\'){\\n                   stringBuilder.append(stack.pop());\\n               }\\n               stack.pop();\\n               int i = 0;\\n               while (i < stringBuilder.length()){\\n                   stack.push(stringBuilder.charAt(i++));\\n               }\\n           }\\n           else\\n               stack.push(c);\\n       }\\n       StringBuilder stringBuilder = new StringBuilder();\\n       while (!stack.empty()){\\n           stringBuilder.append(stack.pop());\\n       }\\n       return stringBuilder.reverse().toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n       for(char c : s.toCharArray()){\\n           if(c == \\')\\'){\\n               StringBuilder stringBuilder = new StringBuilder();\\n               while (stack.peek() != \\'(\\'){\\n                   stringBuilder.append(stack.pop());\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 382766,
                "title": "python-stack-solution-faster-than-100",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        reverse = []\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\')\\':  # pop the substring between nearest parentheses\\n                p = stack.pop()\\n                while p != \\'(\\':\\n                    reverse.append(p)\\n                    p = stack.pop()\\n                stack += reverse\\n                reverse = []\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        reverse = []\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\')\\':  # pop the substring between nearest parentheses\\n                p = stack.pop()\\n                while p != \\'(\\':\\n                    reverse.append(p)\\n                    p = stack.pop()\\n                stack += reverse\\n                reverse = []\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742862,
                "title": "java-straightforward-stack-vs-o-n",
                "content": "StraightForward Stack:\\n\\n```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(sb);\\n                sb = new StringBuilder();\\n            } else if (c == \\')\\') {\\n                String str = sb.reverse().toString();\\n                sb = st.pop();\\n                sb.append(str);\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\nsolution O(n);\\nref: https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/383670/JavaC%2B%2BPython-Why-not-O(N)\\n```\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') st.push(i);\\n            else if (c == \\')\\') {\\n                int j = st.pop();\\n                map.put(i, j);\\n                map.put(j, i);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < s.length(); i += d) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\' || c == \\')\\') {\\n                i = map.get(i);\\n                d = -d;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(sb);\\n                sb = new StringBuilder();\\n            } else if (c == \\')\\') {\\n                String str = sb.reverse().toString();\\n                sb = st.pop();\\n                sb.append(str);\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```\n```\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') st.push(i);\\n            else if (c == \\')\\') {\\n                int j = st.pop();\\n                map.put(i, j);\\n                map.put(j, i);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < s.length(); i += d) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\' || c == \\')\\') {\\n                i = map.get(i);\\n                d = -d;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382353,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    std::string reverseParentheses(std::string s) {\\n        int n=s.size();\\n        int begin=0, end=n-1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\')\\n                begin = i;\\n            if(s[i] == \\')\\'){\\n                end = i;\\n                string temp = s.substr(begin + 1, end - begin - 1);\\n                reverse(temp.begin(),temp.end());\\n                return reverseParentheses(s.substr(0, begin) + temp + s.substr(end + 1));\\n             }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::string reverseParentheses(std::string s) {\\n        int n=s.size();\\n        int begin=0, end=n-1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\')\\n                begin = i;\\n            if(s[i] == \\')\\'){\\n                end = i;\\n                string temp = s.substr(begin + 1, end - begin - 1);\\n                reverse(temp.begin(),temp.end());\\n                return reverseParentheses(s.substr(0, begin) + temp + s.substr(end + 1));\\n             }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393124,
                "title": "straightforward-iterative-solution-java-99-runtime-100-memory",
                "content": "#### Intuition\\n\\nBasicaly for each character in string, we need to consider the three following cases:\\n- every `\\'(\\'` starts a new level to be reversed;\\n- and `\\')\\'` will pop that level, then we do reverse on the popped level, and append it to its parent level;\\n- and for any other characters, we simply append it to current level.\\n\\n#### Analysis\\n\\nSpace: `O(n)` to store all characters other than brackets\\nTime: best case `O(n)` to worst case `O(n^2)`\\n- `O(n)`to loop through the string\\n- each `StringBuilder.append` takes an amortized constant time, so best case will be `O(n)`, e.g. for `\"abcd\"`\\n- each `StringBuilder.reverse` takes linear time, so worst case will be `O(n^2)`, e.g. for `\"((abcd))\"`\\n\\n#### Optimization [TODO]\\n\\nIn this solution, even levels will be reversed even number of times back to its original form, so they do not need to be reversed, and we can omit reversing these levels by adding them directly to odd levels between the reversed head and tail. Thus reversal wil be reduced to minimum, and time complexity wil be on average `O(n)` (constant time append and at most one constant time swap for each character other than brackets).\\n\\n```java\\npublic String reverseParentheses(String s) {\\n    Deque<StringBuilder> levels = new ArrayDeque<>();\\n    levels.push(new StringBuilder());  // level 0\\n    for (int i = 0; i < s.length(); i++) {\\n        char ch = s.charAt(i);\\n        if (ch == \\'(\\') {\\n            // add level on \\'(\\'\\n            levels.push(new StringBuilder());\\n        } else if (ch == \\')\\') {\\n            // reverse deeper level and append to current level on \\')\\'\\n            StringBuilder deeperLevel = levels.pop().reverse();\\n            levels.peek().append(deeperLevel);\\n        } else {\\n            // simply append chars to current level\\n            levels.peek().append(ch);\\n        }\\n    }\\n    return levels.pop().toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic String reverseParentheses(String s) {\\n    Deque<StringBuilder> levels = new ArrayDeque<>();\\n    levels.push(new StringBuilder());  // level 0\\n    for (int i = 0; i < s.length(); i++) {\\n        char ch = s.charAt(i);\\n        if (ch == \\'(\\') {\\n            // add level on \\'(\\'\\n            levels.push(new StringBuilder());\\n        } else if (ch == \\')\\') {\\n            // reverse deeper level and append to current level on \\')\\'\\n            StringBuilder deeperLevel = levels.pop().reverse();\\n            levels.peek().append(deeperLevel);\\n        } else {\\n            // simply append chars to current level\\n            levels.peek().append(ch);\\n        }\\n    }\\n    return levels.pop().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642951,
                "title": "python3-stack-buffer-w-trace-t-m-98-69",
                "content": "See the comment lines in the code. Looking at the trace of stack and buffer may be the best way to understand the process.\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n    \\n        stack, buffer = [], \\'\\'\\n      \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)               \\n\\n            else:\\n                buffer = \\'\\'\\n                while stack[-1] != \\'(\\':\\n                    buffer+= stack.pop()\\n                stack.pop()\\n                    \\n                for ss in buffer:\\n                    stack.append(ss)\\n\\n            # remove the # below to see a trace of the stack and buffer\\n            #print(\\'\\\\tch: \\',ch, \\'\\\\tbuffer: \\', buffer, \\'\\\\tstack: \\', stack)\\n\\n        return \\'\\'.join(stack)\\n```\\n\\n[https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/](http://)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n    \\n        stack, buffer = [], \\'\\'\\n      \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)               \\n\\n            else:\\n                buffer = \\'\\'\\n                while stack[-1] != \\'(\\':\\n                    buffer+= stack.pop()\\n                stack.pop()\\n                    \\n                for ss in buffer:\\n                    stack.append(ss)\\n\\n            # remove the # below to see a trace of the stack and buffer\\n            #print(\\'\\\\tch: \\',ch, \\'\\\\tbuffer: \\', buffer, \\'\\\\tstack: \\', stack)\\n\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464852,
                "title": "c-0ms-100-faster-using-stack",
                "content": "```\\nstring reverseParentheses(string str)\\n{\\n    stack<int> s;\\n\\n    for (int i = 0; i < str.size(); i++){\\n        if (str[i] == \\'(\\') s.push(i);\\n        else if (str[i] == \\')\\'){\\n            int beg = s.top() + 1;\\n            int end = i;\\n            reverse(str.begin() + beg, str.begin() + end);\\n            s.pop(); \\n\\t\\t\\t}}\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < str.size(); i++){ \\n        if (str[i] == \\'(\\' || str[i] == \\')\\') continue;\\n        else ans.push_back(str[i]);\\n        }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nstring reverseParentheses(string str)\\n{\\n    stack<int> s;\\n\\n    for (int i = 0; i < str.size(); i++){\\n        if (str[i] == \\'(\\') s.push(i);\\n        else if (str[i] == \\')\\'){\\n            int beg = s.top() + 1;\\n            int end = i;\\n            reverse(str.begin() + beg, str.begin() + end);\\n            s.pop(); \\n\\t\\t\\t}}\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < str.size(); i++){ \\n        if (str[i] == \\'(\\' || str[i] == \\')\\') continue;\\n        else ans.push_back(str[i]);\\n        }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787034,
                "title": "runtime-0-ms-faster-than-100-00-easy-understanding-c",
                "content": "\\n      class Solution {\\n      public:\\n          string reverseParentheses(string s) {\\n              stack<char> st;\\n              for(int i=0;i<s.size();i++){\\n                  if(s[i]!=\\')\\'){\\n                      st.push(s[i]);\\n                  }else{\\n                      string w=\"\";\\n                      while(!st.empty()&&st.top()!=\\'(\\'){\\n                          w+=st.top();\\n                          st.pop();\\n                      }\\n                      st.pop();\\n                      for(int j=0;j<w.size();j++){\\n                          st.push(w[j]);\\n                      }\\n                  }\\n              }\\n              s.clear();\\n              while(!st.empty()){\\n                  s+=st.top();\\n                  st.pop();\\n              }\\n              reverse(s.begin(),s.end());\\n              return s;\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n      public:\\n          string reverseParentheses(string s) {\\n              stack<char> st;\\n              for(int i=0;i<s.size();i++){\\n                  if(s[i]!=\\')\\'){\\n                      st.push(s[i]);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 382373,
                "title": "nostack-recursive-method-in-java",
                "content": "```\\n0 <= s.length <= 2000\\n```\\nThis BruteForce will work as length of S is less\\n```\\npublic static String reverseParentheses(String S) {\\n        StringBuilder res = new StringBuilder(S);\\n        int s = -1, e = -1;\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res.charAt(i) == \\'(\\')\\n                s = i;\\n            if (res.charAt(i) == \\')\\') {\\n                e = i;\\n                break;\\n            }\\n        }\\n        if (s == -1)\\n            return res.toString();\\n        StringBuilder temp = new StringBuilder(res.substring(s + 1, e)).reverse();\\n        res = new StringBuilder(res.substring(0, s) + temp + res.substring(e + 1));\\n        return reverseParentheses(res.toString());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n0 <= s.length <= 2000\\n```\n```\\npublic static String reverseParentheses(String S) {\\n        StringBuilder res = new StringBuilder(S);\\n        int s = -1, e = -1;\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res.charAt(i) == \\'(\\')\\n                s = i;\\n            if (res.charAt(i) == \\')\\') {\\n                e = i;\\n                break;\\n            }\\n        }\\n        if (s == -1)\\n            return res.toString();\\n        StringBuilder temp = new StringBuilder(res.substring(s + 1, e)).reverse();\\n        res = new StringBuilder(res.substring(0, s) + temp + res.substring(e + 1));\\n        return reverseParentheses(res.toString());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570657,
                "title": "c-simplest-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nstring reverseParentheses(string s) \\n    {\\n        stack<int> st;\\n        string answer=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!= \\'(\\' && s[i]!=\\')\\')\\n                answer=answer+s[i];\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring reverseParentheses(string s) \\n    {\\n        stack<int> st;\\n        string answer=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!= \\'(\\' && s[i]!=\\')\\')\\n                answer=answer+s[i];\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290806,
                "title": "python-sol-recursion-and-stack-sol-detailed-explanation-with-pictrue",
                "content": "# PICTURE EXPLANATION\\n![image](https://assets.leetcode.com/users/images/c39bab87-d055-4d70-b1fe-39b1eddb38c0_1657984760.4599788.png)\\n\\n\\n\\n\\n\\n# RECURSION BASED CODE\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        def solve(string):\\n            n = len(string)\\n            word = \"\"\\n            i = 0\\n            while i <n:\\n                if string[i] == \\'(\\':\\n                    new = \"\"\\n                    count = 0\\n                    while True:\\n                        count += 1 if string[i] == \\'(\\' else -1 if string[i] == \\')\\' else 0\\n                        if count == 0: break\\n                        new += string[i]\\n                        i += 1\\n                    i += 1\\n                    word += solve(new[1:])\\n                else:\\n                    word += string[i]\\n                    i += 1\\n            return word[::-1]\\n        return solve(s)[::-1]\\n    \\n```\\n\\n# STACK BASED CODE \\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if i == \\')\\':\\n                tmp = \"\"\\n                while stack[-1] != \\'(\\':\\n                    tmp += stack.pop()\\n                stack.pop()\\n                for j in tmp: stack.append(j)\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        def solve(string):\\n            n = len(string)\\n            word = \"\"\\n            i = 0\\n            while i <n:\\n                if string[i] == \\'(\\':\\n                    new = \"\"\\n                    count = 0\\n                    while True:\\n                        count += 1 if string[i] == \\'(\\' else -1 if string[i] == \\')\\' else 0\\n                        if count == 0: break\\n                        new += string[i]\\n                        i += 1\\n                    i += 1\\n                    word += solve(new[1:])\\n                else:\\n                    word += string[i]\\n                    i += 1\\n            return word[::-1]\\n        return solve(s)[::-1]\\n    \\n```\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if i == \\')\\':\\n                tmp = \"\"\\n                while stack[-1] != \\'(\\':\\n                    tmp += stack.pop()\\n                stack.pop()\\n                for j in tmp: stack.append(j)\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811247,
                "title": "actual-o-n-solution-for-humans-using-dfs-explanation-with-pictures",
                "content": "Out of all of the current posts, there is exactly **one** that is actually `O(n)`, which is Lee\\'s amazing post using wormholes. Every other claimed `O(n)` solution is either a copy of Lee\\'s code, or not a real `O(n)` solution (they all assume that reversing a string can be done in constant time, which is false). \\n\\nHere, I want to present a true `O(n)` solution for mortal humans, that you or I could actually come up with in an interview. The idea is to build an n-ary tree to represent our string. Each \\'level\\' of the tree represents one layer of nested parentheses.\\n\\nThe top level tree-nodes are either: \\n1.  A letter that is not contained in parentheses\\n\\n2.  A tree-node representing a pair of parentheses at the outermost layer of our string.\\n\\n\\n\\nAs an example:\\n\\n```python\\ns = \"(ED(ET(OC))EL)\"\\n```\\n\\n![image](https://assets.leetcode.com/users/images/38d079d5-dc97-4b06-a208-1e337f3a3b1a_1646185360.2967298.png)\\n\\n\\n\\nThere is one node for each set of parentheses, and one node for each letter. Therefore there are `O(n)` nodes in our tree. \\n\\nTo get the effect of reversals, we can traverse the tree in a **depth-first** way recursively. Besides knowing our current node, we just need to know if we\\'re in \\'reverse mode\\': a boolean to tell us whether to visit our node\\'s children from left to right, or right to left. **Every time we go down a level in our tree, whether we\\'re in reverse mode or not is flipped**.\\n\\n\\nTraversal Order:\\n\\n![image](https://assets.leetcode.com/users/images/8218de26-f09f-445b-9292-344d8c506e89_1646186056.9728265.png)\\n\\n\\n****\\n**Python code**:\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, parent=None):\\n        self.parent = parent\\n        self.children = []\\n\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        root_node = TreeNode()\\n        curr_node = root_node\\n\\n        for let in s:\\n            if let == \\'(\\':\\n                new_child = TreeNode(parent=curr_node)\\n                curr_node.children.append(new_child)\\n                curr_node = new_child\\n            elif let == \\')\\':\\n                curr_node = curr_node.parent\\n            else:\\n                curr_node.children.append(let)\\n\\n        answer = []\\n\\n        def dfs(node, is_reversed: bool):\\n            nonlocal answer\\n            num_children = len(node.children)\\n            \\n            if is_reversed:\\n                range_start, range_end, range_step = num_children-1, -1, -1\\n            else:\\n                range_start, range_end, range_step = 0, num_children, 1\\n                \\n            for i in range(range_start, range_end, range_step):\\n                if isinstance(node.children[i], str):\\n                    answer.append(node.children[i])\\n                else:\\n                    dfs(node.children[i], not is_reversed)\\n\\n        dfs(root_node, False)\\n\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\ns = \"(ED(ET(OC))EL)\"\\n```\n```python\\nclass TreeNode:\\n    def __init__(self, parent=None):\\n        self.parent = parent\\n        self.children = []\\n\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        root_node = TreeNode()\\n        curr_node = root_node\\n\\n        for let in s:\\n            if let == \\'(\\':\\n                new_child = TreeNode(parent=curr_node)\\n                curr_node.children.append(new_child)\\n                curr_node = new_child\\n            elif let == \\')\\':\\n                curr_node = curr_node.parent\\n            else:\\n                curr_node.children.append(let)\\n\\n        answer = []\\n\\n        def dfs(node, is_reversed: bool):\\n            nonlocal answer\\n            num_children = len(node.children)\\n            \\n            if is_reversed:\\n                range_start, range_end, range_step = num_children-1, -1, -1\\n            else:\\n                range_start, range_end, range_step = 0, num_children, 1\\n                \\n            for i in range(range_start, range_end, range_step):\\n                if isinstance(node.children[i], str):\\n                    answer.append(node.children[i])\\n                else:\\n                    dfs(node.children[i], not is_reversed)\\n\\n        dfs(root_node, False)\\n\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489765,
                "title": "easy-to-understand-code-in-c-stack",
                "content": "class Solution {\\npublic:\\n\\n\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        for (int i = 0; i < s.size(); i++){\\n        if (s[i] == \\'(\\') {\\n\\t\\t   st.push(i);\\n\\t\\t }\\n        else if (s[i] == \\')\\'){\\n            int beg = st.top();\\n            int end = i;\\n            reverse(s.begin() + beg, s.begin() + end);\\n            st.pop();\\n        }\\n    }\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < s.size(); i++){ \\n        if (s[i] == \\'(\\' || s[i] == \\')\\'){\\n\\t\\t    continue;\\n\\t\\t}\\n        else ans.push_back(s[i]);\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        for (int i = 0; i < s.size(); i++){\\n        if (s[i] == \\'(\\') {\\n\\t\\t   st.push(i);\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1167670,
                "title": "100-efficient-solution-using-stack",
                "content": "**Approach**:  As we have to reverse the substring beween every pair, so we store the index whenever we get an open parenthesis and since it is given that it is balanced means if we encounter any closed parenthesis then the we must have a index of its matching open \\'(\\' parenthesis at the tos. we pop it and reverse from the index at tos and \\nthe current index we are on and the process repeats.\\n\\n**Time** : O(n^2) **space** : O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n          \\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                int j=st.top();\\n                st.pop();\\n                s[i]=\\'$\\',s[j]=\\'$\\';\\n                reverse(s.begin()+j+1,s.begin()+i);\\n            }\\n        }\\n        string res=\"\";\\n        for(auto x:s){\\n            if(x!=\\'$\\') res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n          \\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                int j=st.top();\\n                st.pop();\\n                s[i]=\\'$\\',s[j]=\\'$\\';\\n                reverse(s.begin()+j+1,s.begin()+i);\\n            }\\n        }\\n        string res=\"\";\\n        for(auto x:s){\\n            if(x!=\\'$\\') res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968285,
                "title": "c-code-that-is-faster-than-100-online-users-and-runtime-0ms",
                "content": "<h2>Solution using Stack data structure </h2>\\n<hr>\\n\\nI used stack to store the index of previous paranthesis and then just reverse the string in the range of the open and close paranthesis.\\nThen just remove the paranthesis and return the string .\\n<hr>\\n\\n## C++ Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size())\\n                {\\n                    int idx = st.top();\\n                    st.pop();\\n                    reverse(s.begin() + idx+1 , s.begin() + i);\\n                }\\n            }\\n        }\\n        string s1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                s1.push_back(s[i]);\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```\\n\\n<code>C++</code>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size())\\n                {\\n                    int idx = st.top();\\n                    st.pop();\\n                    reverse(s.begin() + idx+1 , s.begin() + i);\\n                }\\n            }\\n        }\\n        string s1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                s1.push_back(s[i]);\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785690,
                "title": "0ms-c-using-stack-commented-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        //Stack to hold all the strings when \\'(\\' comes;\\n        stack<string> st;\\n        //intially assume current string empty\\n        string curr_s = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if somewhere u find \\'(\\' store curr_s into stack\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(curr_s);\\n                curr_s = \"\";\\n            }\\n            //as brackets are closed reverse the curr_s and concatenate with stack top value\\n            else if(s[i] == \\')\\')\\n            {\\n                reverse(curr_s.begin(), curr_s.end());\\n                string top = st.top();\\n                st.pop();\\n                top.append(curr_s);\\n                curr_s = top;\\n            }\\n            else\\n                curr_s.push_back(s[i]);\\n        }\\n        //return the curr_s\\n        return curr_s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        //Stack to hold all the strings when \\'(\\' comes;\\n        stack<string> st;\\n        //intially assume current string empty\\n        string curr_s = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if somewhere u find \\'(\\' store curr_s into stack\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(curr_s);\\n                curr_s = \"\";\\n            }\\n            //as brackets are closed reverse the curr_s and concatenate with stack top value\\n            else if(s[i] == \\')\\')\\n            {\\n                reverse(curr_s.begin(), curr_s.end());\\n                string top = st.top();\\n                st.pop();\\n                top.append(curr_s);\\n                curr_s = top;\\n            }\\n            else\\n                curr_s.push_back(s[i]);\\n        }\\n        //return the curr_s\\n        return curr_s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395921,
                "title": "c-stack-o-n-lazy-reversals-with-explanation-100-runtime-memory",
                "content": "I maintain a stack of tuples, where each tuple consists of a string and a boolean value (a reverse bit). So, the moment I see the first \\'(\\' single parenthesis, I set the reverse bit to 1 for it and for subsequent characters until I either come across a single \\')\\' parenthesis or another single \\'(\\' parenthesis. A \\')\\' denotes that the characters between the last seen pair of parentheses are to be \\'reversed\\'. Also, such a setup guarantees that all the strings between a pair of parentheses will have the same reverse bit.\\n\\nIf I come across another single \\'(\\' parenthesis, I flip the reverse bit for it and for subsequent characters until interrupted like explained above. However, if I come across a single \\')\\' parenthesis, I decide to build the substring that lies between this last seen pair of parentheses, which would mean popping off entries from the stack.\\n\\nNow, the direction of concatenation is key too. If the reverse bit is set for such a sequence of characters, I try to produce a reversed sequence of characters, which means I append each popped element to the right of the string I build. Otherwise, I append it to the left to build a string that reads normal. Once I reach the end of this sequence, I put this built  string, which is just a substring of the result (probably reversed too) back onto the stack and set its reverse bit to the complement of the reverse bits of all its characters from before. \\n\\nHere\\'s an example where I breakdown my process upon encountering each single \\')\\' parenthesis :\\n\\nInput : s = \"(ed(et(oc))el)\"\\n\\n- Stack = Top -> {\"c\",T} {\"o\",T} {\"(\",T} {\"t\",F} {\"e\",F} {\"(\",F} {\"d\",T} {\"e\",T} {\"(\",T}\\nPopping until I get rid of the corresponding \\'(\\' from the stack and building a substring too.\\nGrowth of the substring with each pop until \\'(\\' is popped : \"c\" -> \"co\"\\nNote that all of them had their reverse bit set to the same value of true.\\n\\nPutting this substring back on the stack with the reverse bit complemented. So now the stack looks as follows :\\n- Stack = Top -> {\"co\",F} {\"t\",F} {\"e\",F} {\"(\",F} {\"d\",T} {\"e\",T} {\"(\",T}\\nThe next character in the string is another single \\')\\' parenthesis. So we repeat our process of popping and building the substring.\\nGrowth of the substring with each pop until \\'(\\' is popped : \"co\" -> \"tco\" -> \"etco\"\\nNote that all of the popped entries had their reverse bit set to the same value of false.\\n\\nPutting this substring back on the stack with the reverse bit complemented. So now the stack looks as follows :\\n- Stack = Top -> {\"etco\",T} {\"d\",T} {\"e\",T} {\"(\",T}\\nBy the time we come across the last single \\')\\' parenthesis, the stack looks as follows :\\n- Stack = Top -> {\"l\",T} {\"e\",T} {\"etco\",T} {\"d\",T} {\"e\",T} {\"(\",T}\\nPopping and building the substring :\\n\"l\" -> \"le\" -> \"leetco\" -> \"leetcod\" -> \"leetcode\"\\n\\nSo we have \"leetcode\" as the final output string.\\n\\nThis solution did show to beat 100% of C++ solutions, both in terms of time and memory used. Although, I am not a 100% certain about the O(n) complexity claim because of all the string concatenations. Any thoughts or possible confirmation of this would be great. This was a fun question and I hope you guys would enjoy reading through my solution and solving it too. Cheers!\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        bool curr = false;\\n        string ans = \"\", temp;\\n        stack<pair<string,bool> > st;\\n        for (auto &x : s) {\\n            temp = x;\\n            if (x == \\'(\\') {\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n            else if (x != \\')\\')\\n                st.push({temp,curr});\\n            else {\\n                temp = \"\";\\n                while(st.top().first != \"(\") {\\n                    if (curr)\\n                        temp = temp + st.top().first;\\n                    else\\n                        temp = st.top().first + temp;\\n                    st.pop();\\n                }\\n                st.pop();\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n        }\\n        while (!st.empty()) {\\n            if (st.top().second)\\n                ans = ans + st.top().first;\\n            else\\n                ans = st.top().first + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        bool curr = false;\\n        string ans = \"\", temp;\\n        stack<pair<string,bool> > st;\\n        for (auto &x : s) {\\n            temp = x;\\n            if (x == \\'(\\') {\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n            else if (x != \\')\\')\\n                st.push({temp,curr});\\n            else {\\n                temp = \"\";\\n                while(st.top().first != \"(\") {\\n                    if (curr)\\n                        temp = temp + st.top().first;\\n                    else\\n                        temp = st.top().first + temp;\\n                    st.pop();\\n                }\\n                st.pop();\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n        }\\n        while (!st.empty()) {\\n            if (st.top().second)\\n                ans = ans + st.top().first;\\n            else\\n                ans = st.top().first + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382364,
                "title": "easy-python-t-o-n-2-s-o-n",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        st = [collections.deque([])]               \\n        for i in s:            \\n            if i==\\'(\\':\\n                st.append(collections.deque([]))\\n            elif i==\\')\\':        \\n                last = st.pop()\\n                st[-1].extendleft(last)\\n            else:\\n                st[-1].appendleft(i)\\n        \\n        return \\'\\'.join(st[-1])[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        st = [collections.deque([])]               \\n        for i in s:            \\n            if i==\\'(\\':\\n                st.append(collections.deque([]))\\n            elif i==\\')\\':        \\n                last = st.pop()\\n                st[-1].extendleft(last)\\n            else:\\n                st[-1].appendleft(i)\\n        \\n        return \\'\\'.join(st[-1])[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489526,
                "title": "best-solution-easy-to-understand-cpp-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing stack data structure\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nopertions on string like push pop..\\n\\n# Complexity\\n- time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        string ans,temp;\\n        stack<char>stack;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            else\\n            {\\n                temp=\"\";\\n                while(stack.top()!=\\'(\\')\\n                {\\n                    temp+=stack.top();\\n                    stack.pop();\\n                }\\n                stack.pop();\\n                for(int j=0;j<temp.size();j++)\\n                {\\n                    stack.push(temp[j]);\\n                }\\n            }\\n        }\\n        ans=\"\";\\n        while(!stack.empty())\\n        {\\n            ans+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        string ans,temp;\\n        stack<char>stack;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            else\\n            {\\n                temp=\"\";\\n                while(stack.top()!=\\'(\\')\\n                {\\n                    temp+=stack.top();\\n                    stack.pop();\\n                }\\n                stack.pop();\\n                for(int j=0;j<temp.size();j++)\\n                {\\n                    stack.push(temp[j]);\\n                }\\n            }\\n        }\\n        ans=\"\";\\n        while(!stack.empty())\\n        {\\n            ans+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768062,
                "title": "runtime-0-ms-faster-than-100-00-memory-usage-6-5-mb-less-than-35-59-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        vector<string> v;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(ans);\\n                ans=\"\";\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(ans.begin(),ans.end());\\n                ans=v.back()+ans;\\n                v.pop_back();\\n            }\\n            else\\n                ans+=s[i];\\n        }\\n   return ans; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        vector<string> v;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(ans);\\n                ans=\"\";\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(ans.begin(),ans.end());\\n                ans=v.back()+ans;\\n                v.pop_back();\\n            }\\n            else\\n                ans+=s[i];\\n        }\\n   return ans; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003420,
                "title": "c-stacks-100-fastest",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>index;\\n        stack<char>brackets;\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                brackets.push(s[i]);\\n                index.push(i+1);\\n            }\\n            if(s[i]==\\')\\' && brackets.top()==\\'(\\')\\n            {\\n                int ind=i-1;\\n                reverse(s.begin() + index.top(), s.begin() + ind+1);\\n                index.pop();\\n                brackets.pop();\\n            }   \\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n                ans+=s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>index;\\n        stack<char>brackets;\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                brackets.push(s[i]);\\n                index.push(i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1610773,
                "title": "c-beats-100-reverse-substrings-between-each-pair-of-parentheses-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> stk;\\n        string st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')stk.push(s[i]);\\n            else {\\n                while(stk.top()!=\\'(\\'){\\n                    st+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                int i=0;\\n                while(i<st.size()){\\n                    stk.push(st[i]);\\n                    i++;\\n                } \\n                    st.clear();\\n            }\\n            \\n        }\\n        while(stk.size()>0){\\n            st+=stk.top();\\n                    stk.pop();\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```\\nupvote if get ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> stk;\\n        string st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')stk.push(s[i]);\\n            else {\\n                while(stk.top()!=\\'(\\'){\\n                    st+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                int i=0;\\n                while(i<st.size()){\\n                    stk.push(st[i]);\\n                    i++;\\n                } \\n                    st.clear();\\n            }\\n            \\n        }\\n        while(stk.size()>0){\\n            st+=stk.top();\\n                    stk.pop();\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464844,
                "title": "c-0ms-beats-100-submissions-can-it-be-done-in-even-less-space-10-line",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\'(\\')\\n                st.push(index);\\n            else if(s[index] == \\')\\'){\\n                reverse(s.begin() + st.top() , s.begin() + index);\\n                st.pop();\\n            }\\n        }\\n         s.erase(remove(s.begin(), s.end(), \\'(\\'),s.end());\\n         s.erase(remove(s.begin(), s.end(), \\')\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\'(\\')\\n                st.push(index);\\n            else if(s[index] == \\')\\'){\\n                reverse(s.begin() + st.top() , s.begin() + index);\\n                st.pop();\\n            }\\n        }\\n         s.erase(remove(s.begin(), s.end(), \\'(\\'),s.end());\\n         s.erase(remove(s.begin(), s.end(), \\')\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869064,
                "title": "very-easy-js-solution",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    let stack = [[]];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') stack.push([]);    \\n        else if (s[i] === \\')\\') {\\n            let cur = stack.pop().reverse();\\n            stack[stack.length-1].push(...cur);\\n        }\\n        else stack[stack.length-1].push(s[i]);    \\n    }\\n    return stack[0].join(\"\");\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    let stack = [[]];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') stack.push([]);    \\n        else if (s[i] === \\')\\') {\\n            let cur = stack.pop().reverse();\\n            stack[stack.length-1].push(...cur);\\n        }\\n        else stack[stack.length-1].push(s[i]);    \\n    }\\n    return stack[0].join(\"\");\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765616,
                "title": "1ms-java-solution-with-stringbuilder-and-stack",
                "content": "```\\npublic String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: s.toCharArray()){\\n            if(c ==\\'(\\'){\\n                stack.push(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(c ==\\')\\'){\\n                sb = sb.reverse();\\n                sb.insert(0,stack.pop());\\n            } else {\\n                sb.append(c);\\n            } \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: s.toCharArray()){\\n            if(c ==\\'(\\'){\\n                stack.push(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(c ==\\')\\'){\\n                sb = sb.reverse();\\n                sb.insert(0,stack.pop());\\n            } else {\\n                sb.append(c);\\n            } \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683940,
                "title": "java-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char c : s.toCharArray()) {\\n            // Find an inner word between two ( ) needs to be reversed.\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t// Reverse it in a StringBuilder until you reach (\\n                while(stack.peek() != \\'(\\') {\\n                    sb.append(stack.pop());\\n                }\\n                // Pop ( we donot needed it anymore\\n                stack.pop();\\n                // Push the reversed word again inside the stack.\\n                for(char insideC : sb.toString().toCharArray()){\\n                    stack.push(insideC);\\n                }\\n            } else {\\n                // Any character simply push to Stack.\\n                stack.push(c);\\n            }\\n        }\\n        // Here I\\'m done but my word is inside the stack, needs one more reverse. \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            result.insert(0, stack.pop());\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char c : s.toCharArray()) {\\n            // Find an inner word between two ( ) needs to be reversed.\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t// Reverse it in a StringBuilder until you reach (\\n                while(stack.peek() != \\'(\\') {\\n                    sb.append(stack.pop());\\n                }\\n                // Pop ( we donot needed it anymore\\n                stack.pop();\\n                // Push the reversed word again inside the stack.\\n                for(char insideC : sb.toString().toCharArray()){\\n                    stack.push(insideC);\\n                }\\n            } else {\\n                // Any character simply push to Stack.\\n                stack.push(c);\\n            }\\n        }\\n        // Here I\\'m done but my word is inside the stack, needs one more reverse. \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            result.insert(0, stack.pop());\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570144,
                "title": "c-beats-100-in-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n    string res;\\n    stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                res=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    res+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<res.length();j++)\\n                    st.push(res[j]);\\n            }\\n        }\\n        res=\"\";\\n        while(!st.empty())\\n        {\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n    string res;\\n    stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                res=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    res+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<res.length();j++)\\n                    st.push(res[j]);\\n            }\\n        }\\n        res=\"\";\\n        while(!st.empty())\\n        {\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382499,
                "title": "c-using-stack-and-reverse-function",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void reverse(std::string& s,int i,int j)\\n    {\\n        while(i <= j)\\n        {\\n            std::swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        std::string ret;\\n        if(s.empty())\\n            return \"\";\\n        std::stack<int> stack;\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stack.push(i);\\n            }else if(s[i] == \\')\\')\\n            {\\n                auto top = stack.top();\\n                stack.pop();\\n                reverse(s,top+1,i-1);\\n            }\\n        }\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                ret += s[i];\\n            }\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void reverse(std::string& s,int i,int j)\\n    {\\n        while(i <= j)\\n        {\\n            std::swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 382379,
                "title": "python3-regex-find",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        while \\'(\\' in s:\\n            posopen=s.rfind(\\'(\\')\\n            posclose=s.find(\\')\\',posopen+1)\\n            s=s[:posopen]+s[posopen+1:posclose][::-1]+s[posclose+1:]\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        while \\'(\\' in s:\\n            posopen=s.rfind(\\'(\\')\\n            posclose=s.find(\\')\\',posopen+1)\\n            s=s[:posopen]+s[posopen+1:posclose][::-1]+s[posclose+1:]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282686,
                "title": "easy-to-understand-for-beginners-with-approach",
                "content": "1. Create a Stack to store characters that are not within parentheses.\\n2. Iterate through each character in the input string s.\\n3. If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n4. If the current character is not a parentheses, push it onto the Stack.\\n5. After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n6. Return the result StringBuilder in reverse order.\\n```\\npublic String reverseParentheses(String s) {\\n   Stack<Character> stack = new Stack<>();\\n   // Iterate through each character in the string\\n   for (char c : s.toCharArray()) {\\n       // If the character is a closing parentheses, reverse the string within the parentheses\\n       if (c == \\')\\') {\\n           StringBuilder sb = new StringBuilder();\\n           // Pop characters from the stack until an opening parentheses is found\\n           while (!stack.isEmpty() && stack.peek() != \\'(\\') {\\n               sb.append(stack.pop());\\n           }\\n           // Pop the opening parentheses\\n           stack.pop();\\n           // Add the reversed string within parentheses back to the stack\\n           while (!sb.isEmpty()) {\\n               stack.add(sb.charAt(0));\\n               sb.deleteCharAt(0);\\n           }\\n       }\\n       // If the character is not a closing parentheses, add it to the stack\\n       else {\\n           stack.add(c);\\n       }\\n   }\\n   // Create a StringBuilder to store the final output\\n   StringBuilder ans = new StringBuilder();\\n   // Pop all the characters from the stack and add them to the StringBuilder\\n   while (!stack.isEmpty()) {\\n       ans.append(stack.pop());\\n   } \\n   // Reverse the StringBuilder and convert it to a String\\n   return ans.reverse().toString();\\n}\\n```\\n# UpVoting is Much Appreciated",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic String reverseParentheses(String s) {\\n   Stack<Character> stack = new Stack<>();\\n   // Iterate through each character in the string\\n   for (char c : s.toCharArray()) {\\n       // If the character is a closing parentheses, reverse the string within the parentheses\\n       if (c == \\')\\') {\\n           StringBuilder sb = new StringBuilder();\\n           // Pop characters from the stack until an opening parentheses is found\\n           while (!stack.isEmpty() && stack.peek() != \\'(\\') {\\n               sb.append(stack.pop());\\n           }\\n           // Pop the opening parentheses\\n           stack.pop();\\n           // Add the reversed string within parentheses back to the stack\\n           while (!sb.isEmpty()) {\\n               stack.add(sb.charAt(0));\\n               sb.deleteCharAt(0);\\n           }\\n       }\\n       // If the character is not a closing parentheses, add it to the stack\\n       else {\\n           stack.add(c);\\n       }\\n   }\\n   // Create a StringBuilder to store the final output\\n   StringBuilder ans = new StringBuilder();\\n   // Pop all the characters from the stack and add them to the StringBuilder\\n   while (!stack.isEmpty()) {\\n       ans.append(stack.pop());\\n   } \\n   // Reverse the StringBuilder and convert it to a String\\n   return ans.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3126635,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\')\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                while(stack.peek()!=\\'(\\'){\\n                ans+=stack.pop();\\n                }\\n                stack.pop();\\n                // if(!stack.isEmpty()){\\n                    for(int j=0;j<ans.length();j++){\\n                        stack.push(ans.charAt(j));\\n                    }\\n                    ans=\"\";\\n                // }\\n                \\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\')\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                while(stack.peek()!=\\'(\\'){\\n                ans+=stack.pop();\\n                }\\n                stack.pop();\\n                // if(!stack.isEmpty()){\\n                    for(int j=0;j<ans.length();j++){\\n                        stack.push(ans.charAt(j));\\n                    }\\n                    ans=\"\";\\n                // }\\n                \\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920435,
                "title": "c-easy-to-understand-well-explained",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n       \\n\\t   // initalize a stack\\n\\t\\t\\n        stack<int>st;\\n        int i;\\n        int n = s.size();\\n\\t// the main logic is that every time we encounter \\'(\\' open bracket we will store it index in the stack\\n\\t// when we encounter \\')\\' close bracket then we will reverse the string from st.top()+1 to current index \\'i\\'.\\n\\t\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int start = st.top() + 1;\\n                int end = i;\\n\\t\\t\\t\\t// will reverse the string  and pop the top index stored in stack.\\n                reverse(s.begin()+start,s.begin()+end);\\n                st.pop();\\n            }\\n        }\\n\\t\\t// at last we will initalize a new string and store all characters except open and close bracket and will return the final string.\\n        string v = \"\";\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\' || s[i] == \\')\\')\\n            {\\n                continue;\\n            }\\n            v.push_back(s[i]);\\n        }\\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n       \\n\\t   // initalize a stack\\n\\t\\t\\n        stack<int>st;\\n        int i;\\n        int n = s.size();\\n\\t// the main logic is that every time we encounter \\'(\\' open bracket we will store it index in the stack\\n\\t// when we encounter \\')\\' close bracket then we will reverse the string from st.top()+1 to current index \\'i\\'.\\n\\t\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2912845,
                "title": "reverse-substrings-between-each-pair-of-parentheses-beats-100-time-complexity",
                "content": "# Intuition\\njust observer the position of opening and closing index in the string \\n\\n\\n# Approach\\non observing the position you can see that betweeen each opening and closing bracket we can use reverse function just by storing the indec of opening bracket and when we find cloasing bracket we have to reverse the string.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\nless than  o(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            continue;\\n                 ans+=s[i];\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            continue;\\n                 ans+=s[i];\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756606,
                "title": "python-o-n-2-solution-one-pass-very-easy",
                "content": "First, I was so obsessed about keeping the order of the parentheses while solving the problem. But after solving it, I have found out that the problem does not necessarily demand for ordering, do it? Anyways, I will post it.\\n# Algorithm\\nThe problem can easily be solved using **stack**. The algorithm is a **one-pass** algorithm and is a piece of cake.\\n1. We will push the indices of open brackets, ``(``\\n2. Whenever we have found a closed bracket, ``)``, we will:\\n\\t* pop the last index in the stack\\n\\t* reverse the substring from popped index to the current index\\n\\t* Then, the whole input string becomes the subarray until the popped index plus the reversed subarray plus the remaining subarray after, but not including, the current index. This step is **in-place**, meaning the input string is completely changed.\\n\\t* Finally, we will substract two from the running index, ``i=i-2 ``, this is because we have removed two brackets from the running string.\\n\\nI don\\'t think you need a better explanation than this, do you? Well, I have one, a visual explanation :)\\n\\n**Testcase1:** s = \"(ed(et(oc))el)\"\\n\\n![image](https://assets.leetcode.com/users/images/71436d06-b7dd-4a5a-a009-20bfaef3f3c2_1667058442.120432.png)\\nWhen index is 8, we have ``stack = [0, 3, 6]``\\n\\n![image](https://assets.leetcode.com/users/images/ea4eb560-81fa-4fe2-85f6-c987087e464a_1667060514.6186016.png)\\n\\n\\nWhen index `i=9`, we have found a closed bracket, so:\\n\\t* pop the last index in the stack, 6\\n\\t* reverse the string from `i=6` to `i=9`, meaning reverse the string `co` to `oc`\\n\\t* now, the input string becomes `s=(ed(etco)el)`\\n\\t* index becomes, `i=i-2`, `i=9-2`, `i=7`\\nThis process continues while the index is less than length of the string, more formally `while i < len(s)` \\n\\n# Implementation in Python\\n**Time Complexity:** `O(n^2)`\\n**Space Complexity:** `O(stack)`*\\n\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(s):\\n            c = s[i]\\n            if c == \\'(\\':\\n                stack.append(i)\\n            elif c == \\')\\':\\n                p = stack.pop()\\n                s = s[:p] + s[i-1:p:-1] + s[i+1:]\\n                i -= 2\\n            i += 1\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(s):\\n            c = s[i]\\n            if c == \\'(\\':\\n                stack.append(i)\\n            elif c == \\')\\':\\n                p = stack.pop()\\n                s = s[:p] + s[i-1:p:-1] + s[i+1:]\\n                i -= 2\\n            i += 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583722,
                "title": "python-easy-to-understand-approach-using-a-while-and-for-loop",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        while \\'(\\' in s:\\n            indeks = 0\\n            for i in range(len(s)):\\n                if s[i] == \\'(\\':\\n                    indeks = i\\n                elif s[i] == \\')\\':\\n                    s = s.replace(s[indeks:i+1], s[indeks+1:i][::-1])\\n                    break\\n        return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        while \\'(\\' in s:\\n            indeks = 0\\n            for i in range(len(s)):\\n                if s[i] == \\'(\\':\\n                    indeks = i\\n                elif s[i] == \\')\\':\\n                    s = s.replace(s[indeks:i+1], s[indeks+1:i][::-1])\\n                    break\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 2297815,
                "title": "java-stack-linear-time-with-explanation",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack<>();\\n        \\n        int j = 0;\\n        while(j < s.length()){\\n            /*\\n                We need to keep on adding whatever comes\\n                as long as it is not a \\')\\'.\\n            */\\n            if(s.charAt(j) != \\')\\')\\n                stack.push(s.charAt(j)+\"\");\\n            \\n            /*\\n                Now that we have encountered an \\')\\', its time\\n                to start popping from top of stack unless we find an opening\\n                parenthesis\\n                \\n                then we just need to reverse the string formed by popping\\n                and put it back on stack. \\n                \\n                Try dry running and it will all make sense\\n            */\\n            else{\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && !stack.peek().equals(\"(\")){\\n                    sb.append(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                stack.push(sb.reverse().toString());\\n            }\\n            j++;\\n        }\\n        \\n        /*\\n            We have our result string in the stack now,\\n            we just need to pop it and return the reverse of it.\\n        */\\n        StringBuilder res = new StringBuilder();\\n        while(!stack.isEmpty())\\n            res.append(stack.pop());\\n        \\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack<>();\\n        \\n        int j = 0;\\n        while(j < s.length()){\\n            /*\\n                We need to keep on adding whatever comes\\n                as long as it is not a \\')\\'.\\n            */\\n            if(s.charAt(j) != \\')\\')\\n                stack.push(s.charAt(j)+\"\");\\n            \\n            /*\\n                Now that we have encountered an \\')\\', its time\\n                to start popping from top of stack unless we find an opening\\n                parenthesis\\n                \\n                then we just need to reverse the string formed by popping\\n                and put it back on stack. \\n                \\n                Try dry running and it will all make sense\\n            */\\n            else{\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && !stack.peek().equals(\"(\")){\\n                    sb.append(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                stack.push(sb.reverse().toString());\\n            }\\n            j++;\\n        }\\n        \\n        /*\\n            We have our result string in the stack now,\\n            we just need to pop it and return the reverse of it.\\n        */\\n        StringBuilder res = new StringBuilder();\\n        while(!stack.isEmpty())\\n            res.append(stack.pop());\\n        \\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203392,
                "title": "stack-simple-solution-cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring reverseParentheses(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tstring tmp,str;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\' || (s[i]>=\\'a\\' && s[i]<=\\'z\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttmp=\"\";\\n\\t\\t\\t\\t\\twhile(st.top()!=\\'(\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttmp+=st.top();\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tfor(int j=0;j<tmp.size();j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tst.push(tmp[j]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstr=\"\";\\n\\t\\t\\twhile(!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tstr+=(st.top());\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\treverse(str.begin(),str.end());\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring reverseParentheses(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tstring tmp,str;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\' || (s[i]>=\\'a\\' && s[i]<=\\'z\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2150424,
                "title": "java-solution-using-stacks-o-n",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                // push the pre string to the stack. works if we have nested brackets\\n                st.push(sb.toString());\\n                sb.setLength(0);\\n            } else if (c == \\')\\') {\\n                // reverse the String if we get close ) bracket\\n                sb = sb.reverse();\\n                // insert the before(pre) string to sb from the stack\\n                sb.insert(0, st.pop());\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n/* for eg: \"(u(love)i)\"\\n1) st - \\n   sb - u\\n2) st - u\\n   sb - love.reverse() -> evol\\n   st - \\n   sb - u + evol\\n3) st - \\n   sb - uevol + i\\n   st - \\n   sb - uevoli.reverse() -> iloveu\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                // push the pre string to the stack. works if we have nested brackets\\n                st.push(sb.toString());\\n                sb.setLength(0);\\n            } else if (c == \\')\\') {\\n                // reverse the String if we get close ) bracket\\n                sb = sb.reverse();\\n                // insert the before(pre) string to sb from the stack\\n                sb.insert(0, st.pop());\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n/* for eg: \"(u(love)i)\"\\n1) st - \\n   sb - u\\n2) st - u\\n   sb - love.reverse() -> evol\\n   st - \\n   sb - u + evol\\n3) st - \\n   sb - uevol + i\\n   st - \\n   sb - uevoli.reverse() -> iloveu\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132645,
                "title": "easiest-ever-using-stack-queue-python-list",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        Q = []\\n        for c in s : \\n            if c!=\\')\\' :\\n                stack.append(c)\\n            else:\\n                d= stack.pop()\\n                while d!=\\'(\\':\\n                    Q.append(d)\\n                    d=stack.pop()\\n                while  Q :\\n                    stack.append(Q.pop(0))       \\n        rev_s = \"\".join(stack)\\n        return rev_s",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        Q = []\\n        for c in s : \\n            if c!=\\')\\' :\\n                stack.append(c)\\n            else:\\n                d= stack.pop()\\n                while d!=\\'(\\':\\n                    Q.append(d)\\n                    d=stack.pop()\\n                while  Q :\\n                    stack.append(Q.pop(0))       \\n        rev_s = \"\".join(stack)\\n        return rev_s",
                "codeTag": "Java"
            },
            {
                "id": 2109884,
                "title": "very-easy-method-stack-sol-c",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n      stack<pair<int,int>> st;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\'(\\')\\n          st.push({s[i],i});\\n        else if(s[i]==\\')\\')\\n        {\\n          reverse(s.begin()+st.top().second,s.begin()+i);\\n          st.pop();\\n        }\\n      }\\n      \\n      string ans;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\')\\' || s[i]==\\'(\\')\\n          continue;\\n        ans+=s[i];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n      stack<pair<int,int>> st;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\'(\\')\\n          st.push({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1619670,
                "title": "java-simple-stack-one-pass-solution",
                "content": "Simple stack one pass solution\\n```\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Deque<StringBuilder> dq=new ArrayDeque<>();\\n        dq.offerLast(new StringBuilder());\\n        \\n        for(int i=0; i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(x==\\'(\\'){\\n                dq.offerLast(new StringBuilder());\\n            }else if(x==\\')\\'){\\n                StringBuilder curr=dq.pollLast().reverse();\\n                dq.peekLast().append(curr);\\n            }else{\\n                dq.peekLast().append(x);\\n            }\\n            \\n        }\\n        return dq.pollLast().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Deque<StringBuilder> dq=new ArrayDeque<>();\\n        dq.offerLast(new StringBuilder());\\n        \\n        for(int i=0; i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(x==\\'(\\'){\\n                dq.offerLast(new StringBuilder());\\n            }else if(x==\\')\\'){\\n                StringBuilder curr=dq.pollLast().reverse();\\n                dq.peekLast().append(curr);\\n            }else{\\n                dq.peekLast().append(x);\\n            }\\n            \\n        }\\n        return dq.pollLast().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546686,
                "title": "c-solution-0ms-100-faster-80-73-less-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(s[i],i+1));\\n            }\\n            else if(s[i]==\\')\\'){\\n                int x=st.top().second;\\n                reverse(s.begin()+x,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'(\\'&&s[i]!=\\')\\')\\n                res+=s[i];\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(s[i],i+1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1498122,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<int>m;\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                m.push(i);\\n                \\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n               \\n                int r = m.top();\\n                m.pop();\\n                reverse(s.begin()+r,s.begin()+i);\\n               \\n            }\\n            else\\n                ans+=s[i];\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<int>m;\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                m.push(i);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1473257,
                "title": "java-easy-solution-o-n-2",
                "content": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        ArrayList<Character> list=new ArrayList<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\')\\'){\\n               while(st.size()!=0 && st.peek()!=\\'(\\'){\\n                   list.add(st.pop());\\n               } \\n               if(st.size()!=0){\\n                   st.pop();\\n               }\\n               Collections.reverse(list);\\n              for(int a =list.size()-1;a>=0;a--){\\n                //   System.out.print(list.get(a)+\"\\\\t\");\\n                  st.push(list.remove(a));\\n              }\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        String str=\"\";\\n      while(st.size()!=0){\\n          str+=st.pop();\\n      }\\n       char[] try1 = str.toCharArray();\\n       String ss=\"\";\\n        for (int i = try1.length - 1; i >= 0; i--)\\n            ss+=try1[i];\\n        return ss;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        ArrayList<Character> list=new ArrayList<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\')\\'){\\n               while(st.size()!=0 && st.peek()!=\\'(\\'){\\n                   list.add(st.pop());\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1435776,
                "title": "python-for-beginners",
                "content": "\\tdef reverseParentheses(s):\\n    while \"(\" in s:  \\n        for i in range(len(s)-1,-1,-1):            \\n            if s[i]==\")\":\\n                j=i              \\n            elif s[i]==\"(\":\\n                ans=s[i+1:j][::-1]\\n                break\\n        s=s[:i]+ans+s[j+1:]\\n    return s",
                "solutionTags": [],
                "code": "\\tdef reverseParentheses(s):\\n    while \"(\" in s:  \\n        for i in range(len(s)-1,-1,-1):            \\n            if s[i]==\")\":\\n                j=i              \\n            elif s[i]==\"(\":\\n                ans=s[i+1:j][::-1]\\n                break\\n        s=s[:i]+ans+s[j+1:]\\n    return s",
                "codeTag": "Python3"
            },
            {
                "id": 1418917,
                "title": "java-deque-based",
                "content": "**Steps:**\\n1. Create a `Stack` s\\n2. For each `char` in input:\\n\\t1.  if it is not `)`: push to `s`\\n\\t2.  else \\n\\t\\t1. reverse Stack `s` content from latest `(` to current stack top\\n3. ans = reverse of `s`\\n\\n\\n**DRY-RUN**:\\nInput: **(ed(et(oc))el)**\\n\\n1.  First `)`\\n\\t1. Before reverse: stack : `(ed(et(oc`\\n\\t2. After reverse: stack : `(ed(etco`\\n2. Second `)`\\n\\t1. Before reverse: stack : `(ed(etco`\\n\\t2. After reverse: stack : `(edocte`\\n3. Third `)`\\n\\t1. Before reverse: stack : `(edocteel`\\n\\t2. After reverse: stack : `leetcode`\\n\\nBelow is the implementation of above approach:\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n        Queue<Character> reverseHelper = new LinkedList<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\')\\') {\\n                reverse(stack,reverseHelper);\\n            } else {\\n                stack.push(ch);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t/*\\n\\t\\tAt this point, we use stack as a deque to avoid extra reverse of stack content\\n\\t\\tKeep popping from the rear of deque\\n\\t\\t*/\\n        Deque<Character> deque = stack;\\n        \\n        while(deque.size() > 0) {\\n            sb.append(deque.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/*\\n\\tPush everything to queue and push it back to stack\\n\\t*/\\n    void reverse(Deque<Character> st, Queue<Character> q) {\\n        while(st.peek() != \\'(\\') {\\n            q.offer(st.pop());\\n        }\\n        st.pop();\\n        \\n        while(q.size() > 0) {\\n            st.push(q.poll());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n        Queue<Character> reverseHelper = new LinkedList<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\')\\') {\\n                reverse(stack,reverseHelper);\\n            } else {\\n                stack.push(ch);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t/*\\n\\t\\tAt this point, we use stack as a deque to avoid extra reverse of stack content\\n\\t\\tKeep popping from the rear of deque\\n\\t\\t*/\\n        Deque<Character> deque = stack;\\n        \\n        while(deque.size() > 0) {\\n            sb.append(deque.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/*\\n\\tPush everything to queue and push it back to stack\\n\\t*/\\n    void reverse(Deque<Character> st, Queue<Character> q) {\\n        while(st.peek() != \\'(\\') {\\n            q.offer(st.pop());\\n        }\\n        st.pop();\\n        \\n        while(q.size() > 0) {\\n            st.push(q.poll());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412218,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        for i in range(n):\\n            if s[i] != \\')\\':\\n                stack.append(s[i])\\n            else:\\n                temp = \\'\\'\\n                while stack and stack[-1] != \\'(\\':\\n                    cur = stack.pop()\\n                    temp += str(cur)\\n                stack.pop()\\n                for j in temp:\\n                    stack.append(j)\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        for i in range(n):\\n            if s[i] != \\')\\':\\n                stack.append(s[i])\\n            else:\\n                temp = \\'\\'\\n                while stack and stack[-1] != \\'(\\':\\n                    cur = stack.pop()\\n                    temp += str(cur)\\n                stack.pop()\\n                for j in temp:\\n                    stack.append(j)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207911,
                "title": "c-easy-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                   st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                    \\n                \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1083877,
                "title": "java-1ms-stack-iterative-stringbuffer",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<StringBuffer> st = new Stack();\\n        st.push(new StringBuffer(\"\"));\\n        for(char ch : s.toCharArray()) {\\n            \\n            if( ch == \\'(\\' ) {\\n                st.push(new StringBuffer(\"\"));\\n            }\\n            else if( ch == \\')\\') {\\n                StringBuffer sb = st.pop(); \\n                sb.reverse();\\n                StringBuffer temp = st.pop();\\n                temp.append(sb);\\n                st.push(temp);\\n            }\\n            else {\\n                st.peek().append(ch);\\n            }\\n            \\n        }\\n        return st.pop().toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<StringBuffer> st = new Stack();\\n        st.push(new StringBuffer(\"\"));\\n        for(char ch : s.toCharArray()) {\\n            \\n            if( ch == \\'(\\' ) {\\n                st.push(new StringBuffer(\"\"));\\n            }\\n            else if( ch == \\')\\') {\\n                StringBuffer sb = st.pop(); \\n                sb.reverse();\\n                StringBuffer temp = st.pop();\\n                temp.append(sb);\\n                st.push(temp);\\n            }\\n            else {\\n                st.peek().append(ch);\\n            }\\n            \\n        }\\n        return st.pop().toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082417,
                "title": "1-ms-java-solution-with-stack-and-stringbuilder-properly-explained-comments",
                "content": "Here\\'s the solution:\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int l = s.length();\\n        /* If length is 0 means there is no character so empty string is returned\\n           if length is 1 means there is no parentheses(since parentheses are balanced) so the string is returned*/\\n        if(l==0||l==1){return s;}\\n        \\n        /* If length is 2 either there will be 2 parentheses or 2 characters */\\n        if(l==2){\\n            if(s.charAt(0)==\\'(\\'){return \"\";}\\n            return s;\\n        }\\n        \\n        String subs;\\n        \\n        /* StringBuilder is used since string is immutable*/\\n        StringBuilder str = new StringBuilder(s), substr;\\n        \\n        /* This stack is used to store the indices of opening brackets */\\n        Stack<Integer> st = new Stack<>();\\n        int x;\\n        Character ch;\\n        \\n        /* Idea here is quite simple: \\n        - Find the matching closing bracket (by help of stack)\\n        - Get index of opening bracket (from stack)\\n          and index of closing bracket (from str)\\n        - Replace the substring from opening bracket index to closing bracket index(both inclusive) by the reverse of substring from opening bracket index + 1 to closing bracket index-1(both inclusive) \\n        - Repeat above process for every pair of matching parantheses\\n        */\\n        \\n        for(int i=0;i<str.length();i++){\\n            ch = str.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(ch==\\')\\'){\\n                x = st.pop();\\n                subs = str.substring(x+1,i);\\n                substr = new StringBuilder(subs);\\n                str.replace(x,i+1, substr.reverse().toString());\\n                i-=2;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```\\n\\nDo let me know in comments if there is any suggestions/queries.\\nThanks",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int l = s.length();\\n        /* If length is 0 means there is no character so empty string is returned\\n           if length is 1 means there is no parentheses(since parentheses are balanced) so the string is returned*/\\n        if(l==0||l==1){return s;}\\n        \\n        /* If length is 2 either there will be 2 parentheses or 2 characters */\\n        if(l==2){\\n            if(s.charAt(0)==\\'(\\'){return \"\";}\\n            return s;\\n        }\\n        \\n        String subs;\\n        \\n        /* StringBuilder is used since string is immutable*/\\n        StringBuilder str = new StringBuilder(s), substr;\\n        \\n        /* This stack is used to store the indices of opening brackets */\\n        Stack<Integer> st = new Stack<>();\\n        int x;\\n        Character ch;\\n        \\n        /* Idea here is quite simple: \\n        - Find the matching closing bracket (by help of stack)\\n        - Get index of opening bracket (from stack)\\n          and index of closing bracket (from str)\\n        - Replace the substring from opening bracket index to closing bracket index(both inclusive) by the reverse of substring from opening bracket index + 1 to closing bracket index-1(both inclusive) \\n        - Repeat above process for every pair of matching parantheses\\n        */\\n        \\n        for(int i=0;i<str.length();i++){\\n            ch = str.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(ch==\\')\\'){\\n                x = st.pop();\\n                subs = str.substring(x+1,i);\\n                substr = new StringBuilder(subs);\\n                str.replace(x,i+1, substr.reverse().toString());\\n                i-=2;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818312,
                "title": "javascript-beats-98-of-the-runtime-with-comments",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    while (s.includes(\"(\")) { // Check if s has parentheses;\\n        s = s.replace(/\\\\([^\\\\(\\\\)]+\\\\)|\\\\(\\\\)/g, (match) => { \\n\\t\\t\\n\\t\\t\\t// If parentheses are detected, remove them and reverse all of the content inside \\n            return match.slice(1, -1).split(\"\").reverse().join(\"\");\\n        })\\n    }\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    while (s.includes(\"(\")) { // Check if s has parentheses;\\n        s = s.replace(/\\\\([^\\\\(\\\\)]+\\\\)|\\\\(\\\\)/g, (match) => { \\n\\t\\t\\n\\t\\t\\t// If parentheses are detected, remove them and reverse all of the content inside \\n            return match.slice(1, -1).split(\"\").reverse().join(\"\");\\n        })\\n    }\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784049,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stk = new Stack();\\n        String ans =\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                while(stk.peek()!=\\'(\\')\\n                    ans+=stk.pop();\\n                stk.pop();\\n                for(int j=0;j<ans.length();j++)\\n                    stk.push(ans.charAt(j));\\n                ans=\"\";\\n            }\\n           else{\\n               stk.push(s.charAt(i));\\n           }\\n        }\\n        while(!stk.isEmpty())\\n            ans=stk.pop()+ans;\\n        return ans;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stk = new Stack();\\n        String ans =\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                while(stk.peek()!=\\'(\\')\\n                    ans+=stk.pop();\\n                stk.pop();\\n                for(int j=0;j<ans.length();j++)\\n                    stk.push(ans.charAt(j));\\n                ans=\"\";\\n            }\\n           else{\\n               stk.push(s.charAt(i));\\n           }\\n        }\\n        while(!stk.isEmpty())\\n            ans=stk.pop()+ans;\\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774385,
                "title": "simple-c-solution-0ms-solution-with-explanation",
                "content": "The order of reversal doesnt matter. So we first reverse the inner most bracket and then the outer ones. Brute force would be to find the inner brackets first and then the outer ones and so on. Better approach will be to use stack. \\nWhenever we encounter an opening bracket, we push the current string to stack. We will use this string when the inner brackets are reversed. \\nClosing bracket means the current string needs to be reversed. So just reverse it and append the older string from stack\\'s top to front of it. Dry the process on the given examples to understand better. Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <string> st;\\n        string curr=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(curr);\\n                curr=\"\";\\n                continue;\\n            }\\n            if(s[i]==\\')\\')\\n            {\\n                reverse(curr.begin(),curr.end());\\n                curr= st.top()+curr;\\n                st.pop();\\n                continue;\\n            }\\n            curr+=s[i];\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <string> st;\\n        string curr=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(curr);\\n                curr=\"\";\\n                continue;\\n            }\\n            if(s[i]==\\')\\')\\n            {\\n                reverse(curr.begin(),curr.end());\\n                curr= st.top()+curr;\\n                st.pop();\\n                continue;\\n            }\\n            curr+=s[i];\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515988,
                "title": "simple-python-solution-using-dict-faster-than-91-84",
                "content": "```from collections import defaultdict\\nclass Solution:\\n    def reverseParentheses(self, string: str) -> str:\\n        level = 0\\n        words = defaultdict(str)\\n        for s in string:\\n            if s== \"(\":\\n                level += 1\\n            elif s==\")\":\\n                level -= 1\\n                words[level] += words[level+1][::-1]\\n                del words[level+1]\\n            else:\\n                words[level] += s\\n                \\n        return words[0]\\n    ```",
                "solutionTags": [],
                "code": "```from collections import defaultdict\\nclass Solution:\\n    def reverseParentheses(self, string: str) -> str:\\n        level = 0\\n        words = defaultdict(str)\\n        for s in string:\\n            if s== \"(\":\\n                level += 1\\n            elif s==\")\":\\n                level -= 1\\n                words[level] += words[level+1][::-1]\\n                del words[level+1]\\n            else:\\n                words[level] += s\\n                \\n        return words[0]\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 500492,
                "title": "simple-stack-solution-o-n-space",
                "content": "```\\npublic String reverseParentheses(String s) \\n    {\\n        Stack<Character> stack = new Stack<>();        \\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')  sb.append(stack.pop());                \\n                stack.pop();\\n                \\n                for(char c1 : sb.toString().toCharArray()) stack.push(c1);                                \\n                continue;\\n            } \\n            \\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) \\n    {\\n        Stack<Character> stack = new Stack<>();        \\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')  sb.append(stack.pop());                \\n                stack.pop();\\n                \\n                for(char c1 : sb.toString().toCharArray()) stack.push(c1);                                \\n                continue;\\n            } \\n            \\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402234,
                "title": "java-easy-solution-with-stack",
                "content": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> stack = new Stack();\\n        stack.push(new StringBuilder());\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                stack.push(new StringBuilder());\\n            }\\n            else if(c==\\')\\'){\\n                String inside = stack.pop().reverse().toString();\\n                stack.peek().append(inside);\\n            }\\n            else{\\n                stack.peek().append(c);\\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> stack = new Stack();\\n        stack.push(new StringBuilder());\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                stack.push(new StringBuilder());\\n            }\\n            else if(c==\\')\\'){\\n                String inside = stack.pop().reverse().toString();\\n                stack.peek().append(inside);\\n            }\\n            else{\\n                stack.peek().append(c);\\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386179,
                "title": "easy-and-clean-code-java-o-n-2-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> stack = new ArrayDeque<>();\\n\\t\\t// put a empty stringbuilder as place holder to avoid empty stack.\\n        stack.push(new StringBuilder());\\n        char[] arr = s.toCharArray();\\n        for (char c : arr) {\\n            if (c == \\'(\\') {\\n                stack.push(new StringBuilder());\\n            } else if (c == \\')\\') {\\n                StringBuilder curr = stack.pop();\\n                stack.peek().append(curr.reverse().toString());   \\n            } else {\\n                stack.peek().append(c);          \\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> stack = new ArrayDeque<>();\\n\\t\\t// put a empty stringbuilder as place holder to avoid empty stack.\\n        stack.push(new StringBuilder());\\n        char[] arr = s.toCharArray();\\n        for (char c : arr) {\\n            if (c == \\'(\\') {\\n                stack.push(new StringBuilder());\\n            } else if (c == \\')\\') {\\n                StringBuilder curr = stack.pop();\\n                stack.peek().append(curr.reverse().toString());   \\n            } else {\\n                stack.peek().append(c);          \\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383244,
                "title": "javascript-easy-to-understand-48ms-using-stack",
                "content": "- Loop the whole string and push into a stack for non-\")\" character.\\n- If we get a \")\" in the loop, we pop all characters until meets \"(\", and push them into stack again in sequence to reverse them.\\n\\n```js\\nconst reverseParentheses = s => {\\n  const stack = [];\\n  for (let char of s) {\\n    if (char !== \")\") {\\n      stack.push(char);\\n      continue;\\n    }\\n    let c = stack.pop();\\n    let queue = [];\\n    while (c !== \"(\") {\\n      queue.push(c);\\n      c = stack.pop();\\n    }\\n    while (queue.length) {\\n      stack.push(queue.shift());\\n    }\\n  }\\n  return stack.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst reverseParentheses = s => {\\n  const stack = [];\\n  for (let char of s) {\\n    if (char !== \")\") {\\n      stack.push(char);\\n      continue;\\n    }\\n    let c = stack.pop();\\n    let queue = [];\\n    while (c !== \"(\") {\\n      queue.push(c);\\n      c = stack.pop();\\n    }\\n    while (queue.length) {\\n      stack.push(queue.shift());\\n    }\\n  }\\n  return stack.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382985,
                "title": "python-solution-without-stack",
                "content": "```\\n\\n\\ndef reverseParentheses(self, s: str) -> str:\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \"(\":\\n\\t\\t\\tstart = i\\n\\t\\tif s[i] == \")\":\\n\\t\\t\\tend = i\\n\\t\\t\\treturn self.reverseParentheses(s[:start] + s[start+1:end][::-1] + s[end+1:])\\n\\treturn s\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\n\\ndef reverseParentheses(self, s: str) -> str:\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \"(\":\\n\\t\\t\\tstart = i\\n\\t\\tif s[i] == \")\":\\n\\t\\t\\tend = i\\n\\t\\t\\treturn self.reverseParentheses(s[:start] + s[start+1:end][::-1] + s[end+1:])\\n\\treturn s\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382649,
                "title": "my-stack-javascript-solution-52-ms",
                "content": "This algorithm can be used for bunch of similar problems with some minor modifications:\\n```\\nvar reverseParentheses = function(s) {\\n    var data = [\"\"];\\n    var from;\\n    var to;\\n    var next;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push(\"\");\\n        } else if (s[i] === \")\") {\\n            data[data.length - 2] += data.pop().split(\"\").reverse().join(\"\");\\n        } else {\\n            from = i;\\n            to = i;\\n            while ((next = to + 1) < s.length && s[next] !== \"(\" && s[next] !== \")\") {\\n                to++;\\n            }\\n            i = to;\\n            data[data.length - 1] += s.substring(from, to + 1);\\n        }\\n    }\\n    \\n    return data[0]; \\n};\\n```\\nOr using arrays (without string concatenation):\\n```\\nvar reverseParentheses = function(s) {\\n    var data = [[]];\\n    var index;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push([]);\\n        } else if (s[i] === \")\") {\\n            index = data.length - 2;\\n            data.pop().reverse().forEach(o => data[index].push(o));\\n        } else {\\n            data[data.length - 1].push(s[i]);\\n        }\\n    }\\n    \\n    return data[0].join(\"\"); \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    var data = [\"\"];\\n    var from;\\n    var to;\\n    var next;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push(\"\");\\n        } else if (s[i] === \")\") {\\n            data[data.length - 2] += data.pop().split(\"\").reverse().join(\"\");\\n        } else {\\n            from = i;\\n            to = i;\\n            while ((next = to + 1) < s.length && s[next] !== \"(\" && s[next] !== \")\") {\\n                to++;\\n            }\\n            i = to;\\n            data[data.length - 1] += s.substring(from, to + 1);\\n        }\\n    }\\n    \\n    return data[0]; \\n};\\n```\n```\\nvar reverseParentheses = function(s) {\\n    var data = [[]];\\n    var index;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push([]);\\n        } else if (s[i] === \")\") {\\n            index = data.length - 2;\\n            data.pop().reverse().forEach(o => data[index].push(o));\\n        } else {\\n            data[data.length - 1].push(s[i]);\\n        }\\n    }\\n    \\n    return data[0].join(\"\"); \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382346,
                "title": "simplest-python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = collections.deque([])\\n        temp = \"\"\\n        for i in s:\\n            if i == \"(\":\\n                stack += temp,\\n                temp = \"\"\\n            elif i == \")\":\\n                temp = stack.pop() + temp[::-1]\\n            else:\\n                temp += i\\n        return temp",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = collections.deque([])\\n        temp = \"\"\\n        for i in s:\\n            if i == \"(\":\\n                stack += temp,\\n                temp = \"\"\\n            elif i == \")\":\\n                temp = stack.pop() + temp[::-1]\\n            else:\\n                temp += i\\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 4060724,
                "title": "easy-to-understand-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        for(int i =0; i< s.size(); i++){\\n            st.push(s[i]);\\n            if(s[i] == \\')\\'){\\n                st.pop();\\n                string temp = \"\";\\n                while(st.top() != \\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j = 0; j<temp.size(); j++){\\n                    st.push(temp[j]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        for(int i =0; i< s.size(); i++){\\n            st.push(s[i]);\\n            if(s[i] == \\')\\'){\\n                st.pop();\\n                string temp = \"\";\\n                while(st.top() != \\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j = 0; j<temp.size(); j++){\\n                    st.push(temp[j]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981189,
                "title": "simple-solution-using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            char ch =s[i];\\n            if(ch==\\'(\\' ||  ch!=\\')\\'){\\n                st.push(ch);\\n            }\\n\\n            if(ch==\\')\\' && !st.empty()){\\n                string temp =\"\";\\n                while(st.top()!=\\'(\\'){\\n                     temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                if(st.empty() && i==s.length()-1){\\n                    return temp;\\n                }else{\\n                    for(int i=0;i<temp.length();i++){\\n                        st.push(temp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        string ans =\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            if(st.top()==\\'(\\' || st.top()==\\')\\'){\\n                return \"\";\\n            }\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            char ch =s[i];\\n            if(ch==\\'(\\' ||  ch!=\\')\\'){\\n                st.push(ch);\\n            }\\n\\n            if(ch==\\')\\' && !st.empty()){\\n                string temp =\"\";\\n                while(st.top()!=\\'(\\'){\\n                     temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                if(st.empty() && i==s.length()-1){\\n                    return temp;\\n                }else{\\n                    for(int i=0;i<temp.length();i++){\\n                        st.push(temp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        string ans =\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            if(st.top()==\\'(\\' || st.top()==\\')\\'){\\n                return \"\";\\n            }\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889104,
                "title": "stack-easy-c-o-n-short-and-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple, When you find a **close bracket** then **reverse** the **substring** from the **last open bracket position** to the **current position**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\') \\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(auto c : s) if(c!=\\')\\' && c!=\\'(\\') ans+=c;\\n        return ans;\\n\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/c70146ba-e292-438d-b36a-37841c9159d8_1691647409.4300852.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\') \\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(auto c : s) if(c!=\\')\\' && c!=\\'(\\') ans+=c;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630615,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans = \"\";\\n\\n        stack<char> st;\\n\\n        for (char ch : s){\\n            if (ch != \\')\\'){\\n                st.push(ch);\\n            }\\n            else{\\n                string w = \"\";\\n                while (st.top() != \\'(\\'){\\n                    w += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                for (char i : w)\\n                    st.push(i);\\n            }\\n        } \\n\\n        while (!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans = \"\";\\n\\n        stack<char> st;\\n\\n        for (char ch : s){\\n            if (ch != \\')\\'){\\n                st.push(ch);\\n            }\\n            else{\\n                string w = \"\";\\n                while (st.top() != \\'(\\'){\\n                    w += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                for (char i : w)\\n                    st.push(i);\\n            }\\n        } \\n\\n        while (!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608701,
                "title": "c-o-n-stack",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince it is given that the parantheses are balanced, it is only required to know the where each valid parantheses\\' pair exists. Use a stack to keep track of this, similar to problems where the task is to determine whether the given string is a valid parantheses arrangement or not.\\n\\nMaintain a stack```s```of integers that stores the indices of all```(```characters. Iterate through the input string```t```. Let the iterator be```i```.\\nIf```t[i]==\\'(\\'```push ```i```to the stack. If```t[i]==\\')\\'```reverse the string from the index```s.top()```to the index```i```.\\nFinally, copy all alphabet characters to a new output string and return the so-obtained string.\\n\\n## Complexity\\n- Time complexity\\n    - Given the length of the input string is *n*: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - Given the length of the input string is *n*: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    string reverseParentheses(string t) {\\n        int n = t.length();\\n        string out = \"\";\\n        stack<int> s;\\n\\n        for(int i=0; i<n; i++){\\n            if(t[i]==\\'(\\') s.push(i);\\n            else if(t[i]==\\')\\'){\\n                reverse(t.begin()+s.top()+1,t.begin()+i);\\n                s.pop();\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) if(t[i]!=\\'(\\' && t[i]!=\\')\\') out = out + t[i];\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```s```\n```(```\n```t```\n```i```\n```t[i]==\\'(\\'```\n```i```\n```t[i]==\\')\\'```\n```s.top()```\n```i```\n```cpp []\\nclass Solution {\\npublic:\\n    string reverseParentheses(string t) {\\n        int n = t.length();\\n        string out = \"\";\\n        stack<int> s;\\n\\n        for(int i=0; i<n; i++){\\n            if(t[i]==\\'(\\') s.push(i);\\n            else if(t[i]==\\')\\'){\\n                reverse(t.begin()+s.top()+1,t.begin()+i);\\n                s.pop();\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) if(t[i]!=\\'(\\' && t[i]!=\\')\\') out = out + t[i];\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295291,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        return reverseParenthesis(s);\\n    }\\n    public static String reverseParenthesis(String str){\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            //if it\\'s not a closing parenthesis push it to stack\\n            char ch = str.charAt(i);\\n            if(ch != \\')\\'){\\n                stack.push(ch);\\n                continue;\\n            }\\n            //when ever we get a closing bracket\\n            //pop out all the elements until we get opening\\n            String popped = \"\";\\n            while (!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                popped += stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                stack.pop();\\n            }\\n            if(popped.length() > 0){\\n                //push the character back to stack\\n                //one by one\\n                for (int j = 0; j < popped.length(); j++) {\\n                    stack.push(popped.charAt(j));\\n                }\\n            }\\n        }\\n        //now pop out all the characters from stack\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()){\\n            res.append(stack.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        return reverseParenthesis(s);\\n    }\\n    public static String reverseParenthesis(String str){\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            //if it\\'s not a closing parenthesis push it to stack\\n            char ch = str.charAt(i);\\n            if(ch != \\')\\'){\\n                stack.push(ch);\\n                continue;\\n            }\\n            //when ever we get a closing bracket\\n            //pop out all the elements until we get opening\\n            String popped = \"\";\\n            while (!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                popped += stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                stack.pop();\\n            }\\n            if(popped.length() > 0){\\n                //push the character back to stack\\n                //one by one\\n                for (int j = 0; j < popped.length(); j++) {\\n                    stack.push(popped.charAt(j));\\n                }\\n            }\\n        }\\n        //now pop out all the characters from stack\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()){\\n            res.append(stack.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290732,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverse(string &s,int i,int j){\\n        while(i<j){\\n            swap(s[i],s[j]) ;\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        stack<int> st ;\\n        int n = s.length() , i ;\\n        i = 0 ;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i) ;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                int ind = st.top() ;\\n                st.pop() ;\\n                reverse(s,ind+1,i-1) ;\\n                cout<<\"s = \"<<s<<\" \" ;\\n                s.erase(s.begin()+ind) ;\\n                s.erase(s.begin()+i-1) ;\\n                i-=2 ;\\n            }\\n            i++ ;\\n        }\\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(string &s,int i,int j){\\n        while(i<j){\\n            swap(s[i],s[j]) ;\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        stack<int> st ;\\n        int n = s.length() , i ;\\n        i = 0 ;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i) ;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                int ind = st.top() ;\\n                st.pop() ;\\n                reverse(s,ind+1,i-1) ;\\n                cout<<\"s = \"<<s<<\" \" ;\\n                s.erase(s.begin()+ind) ;\\n                s.erase(s.begin()+i-1) ;\\n                i-=2 ;\\n            }\\n            i++ ;\\n        }\\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3150196,
                "title": "0ms-runtime-beats-100-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')st.pop();\\n                for(int i=0;i<temp.length();i++){\\n                    st.push(temp[i]);\\n                }\\n                \\n            }\\n        }\\n        while(!st.empty()){\\n            res+=st.top();st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')st.pop();\\n                for(int i=0;i<temp.length();i++){\\n                    st.push(temp[i]);\\n                }\\n                \\n            }\\n        }\\n        while(!st.empty()){\\n            res+=st.top();st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994965,
                "title": "c-using-stack",
                "content": "# Approach\\nIterate over string once found balanced parenthesis start reversal from opening bracket index till closing bracket index\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string ReverseParentheses(string s)\\n    {\\n        Stack<int> bracketsStack = new();\\n        char[] result = s.ToCharArray();\\n        \\n        for (int i = 0; i < s.Length; i++){\\n            var c = s[i];\\n            if (c == \\'(\\') bracketsStack.Push(i);\\n            else if (c == \\')\\'){\\n                // Reverse\\n                for(int l= bracketsStack.Pop()+1,r=i-1; l<r;l++,r--){\\n                    var tmp = result[l];\\n                    result[l] = result[r];\\n                    result[r] = tmp;\\n                }\\n            }\\n        }\\n\\n        return new string(result.Where(c=>c!=\\')\\' && c!=\\'(\\').ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseParentheses(string s)\\n    {\\n        Stack<int> bracketsStack = new();\\n        char[] result = s.ToCharArray();\\n        \\n        for (int i = 0; i < s.Length; i++){\\n            var c = s[i];\\n            if (c == \\'(\\') bracketsStack.Push(i);\\n            else if (c == \\')\\'){\\n                // Reverse\\n                for(int l= bracketsStack.Pop()+1,r=i-1; l<r;l++,r--){\\n                    var tmp = result[l];\\n                    result[l] = result[r];\\n                    result[r] = tmp;\\n                }\\n            }\\n        }\\n\\n        return new string(result.Where(c=>c!=\\')\\' && c!=\\'(\\').ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909786,
                "title": "beats-100-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse string reverse function and when you find a balanced paranthesis reverse only that part .\\n\\nhint-->use pair in stack and store with index of opening bracket\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# please upvote if you find it helpful!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});\\n            }\\n            else if(!st.empty() && s[i]==\\')\\' && st.top().first==\\'(\\')\\n            {\\n                reverse(s.begin()+st.top().second,s.begin()+i);\\n                st.pop();\\n            }\\n\\n        }\\n        string  str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n            continue;\\n            else\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});\\n            }\\n            else if(!st.empty() && s[i]==\\')\\' && st.top().first==\\'(\\')\\n            {\\n                reverse(s.begin()+st.top().second,s.begin()+i);\\n                st.pop();\\n            }\\n\\n        }\\n        string  str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n            continue;\\n            else\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637754,
                "title": "java-stringbuilder-easy-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int index1=-1,index2=-1;\\n        while(s.contains(\"(\")){\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                if(ch==\\'(\\')\\n                    index1=i;\\n                if(ch==\\')\\'){\\n                    index2=i;\\n                    String str1 = s.substring(0,index1);\\n                    String str2 = s.substring(index2+1);\\n                    StringBuilder sb = new StringBuilder(s.substring(index1+1,index2));\\n                    s=str1+sb.reverse().toString()+str2;\\n                    break;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int index1=-1,index2=-1;\\n        while(s.contains(\"(\")){\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                if(ch==\\'(\\')\\n                    index1=i;\\n                if(ch==\\')\\'){\\n                    index2=i;\\n                    String str1 = s.substring(0,index1);\\n                    String str2 = s.substring(index2+1);\\n                    StringBuilder sb = new StringBuilder(s.substring(index1+1,index2));\\n                    s=str1+sb.reverse().toString()+str2;\\n                    break;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448284,
                "title": "golang-simple-stack-based-solution",
                "content": "```go\\nfunc reverseParentheses(s string) string {\\n  var stack [][]byte\\n  var top []byte\\n  stack = append(stack, []byte{}) // Initial segment in case we have any before the first parentheses\\n  for i := 0; i < len(s); i++ {\\n    if s[i] == \\'(\\' { // start the next segment\\n      stack = append(stack, []byte{})\\n    } else if s[i] == \\')\\' { // end of a segment; pop it, reverse it, and append it to the previous segment\\n      top, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n      rev(top)\\n      stack[len(stack)-1] = append(stack[len(stack)-1], top...)\\n    } else { // append to current segment\\n      stack[len(stack)-1] = append(stack[len(stack)-1], s[i])\\n    }\\n  }\\n  return string(stack[0])\\n}\\n\\nfunc rev(seg []byte) {\\n  i, j := 0, len(seg)-1\\n  for i < j {\\n    seg[i], seg[j] = seg[j], seg[i]\\n    i++\\n    j--\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```go\\nfunc reverseParentheses(s string) string {\\n  var stack [][]byte\\n  var top []byte\\n  stack = append(stack, []byte{}) // Initial segment in case we have any before the first parentheses\\n  for i := 0; i < len(s); i++ {\\n    if s[i] == \\'(\\' { // start the next segment\\n      stack = append(stack, []byte{})\\n    } else if s[i] == \\')\\' { // end of a segment; pop it, reverse it, and append it to the previous segment\\n      top, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n      rev(top)\\n      stack[len(stack)-1] = append(stack[len(stack)-1], top...)\\n    } else { // append to current segment\\n      stack[len(stack)-1] = append(stack[len(stack)-1], s[i])\\n    }\\n  }\\n  return string(stack[0])\\n}\\n\\nfunc rev(seg []byte) {\\n  i, j := 0, len(seg)-1\\n  for i < j {\\n    seg[i], seg[j] = seg[j], seg[i]\\n    i++\\n    j--\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379161,
                "title": "c-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    void revString(string& s, int start, int end) {\\n        while(start < end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> startIdx;\\n        string ans = \"\";\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (s[i] == \\'(\\') {\\n                startIdx.push(i);\\n            }\\n            \\n            if (s[i] == \\')\\') {\\n                revString(s, startIdx.top(), i);\\n                startIdx.pop();\\n            }\\n        }\\n        \\n        for (auto ch : s) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void revString(string& s, int start, int end) {\\n        while(start < end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> startIdx;\\n        string ans = \"\";\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (s[i] == \\'(\\') {\\n                startIdx.push(i);\\n            }\\n            \\n            if (s[i] == \\')\\') {\\n                revString(s, startIdx.top(), i);\\n                startIdx.pop();\\n            }\\n        }\\n        \\n        for (auto ch : s) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333034,
                "title": "c-easy-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<n;i++){\\n           if(s[i]!=\\')\\')\\n               st.push(s[i]);\\n            else{\\n                string temp=\"\";\\n                \\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<temp.size();j++)\\n                st.push(temp[j]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<n;i++){\\n           if(s[i]!=\\')\\')\\n               st.push(s[i]);\\n            else{\\n                string temp=\"\";\\n                \\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<temp.size();j++)\\n                st.push(temp[j]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227686,
                "title": "o-n-stack-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st ;\\n        int i = 0;\\n        string ans = \"\" ; \\n        while(i < s.size()) // Very similar to balanced parentheses problem \\n        {\\n            if (s[i] != \\')\\')\\n                st.push(s[i]) ;\\n            else\\n            {\\n                string temp = \"\" ;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top()) ;\\n                    st.pop() ; \\n                }\\n                st.pop() ; \\n                for(auto c : temp) // string gets reversed, and pushed back into the stack \\n                    st.push(c) ; \\n            }\\n            i ++ ; \\n        }\\n        while(st.empty() == false) \\n        {\\n            ans.push_back(st.top()) ; \\n            st.pop() ;\\n        }\\n        reverse(ans.begin(), ans.end()) ; // popped from stack, so ans needs to be reversed \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st ;\\n        int i = 0;\\n        string ans = \"\" ; \\n        while(i < s.size()) // Very similar to balanced parentheses problem \\n        {\\n            if (s[i] != \\')\\')\\n                st.push(s[i]) ;\\n            else\\n            {\\n                string temp = \"\" ;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top()) ;\\n                    st.pop() ; \\n                }\\n                st.pop() ; \\n                for(auto c : temp) // string gets reversed, and pushed back into the stack \\n                    st.push(c) ; \\n            }\\n            i ++ ; \\n        }\\n        while(st.empty() == false) \\n        {\\n            ans.push_back(st.top()) ; \\n            st.pop() ;\\n        }\\n        reverse(ans.begin(), ans.end()) ; // popped from stack, so ans needs to be reversed \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147681,
                "title": "how-to-calculate-time-complexity-of-this-solution-in-worst-case",
                "content": "\\n    def reverseParentheses(self, s: str) -> str:\\n        \"\"\"\\n        if it is opening bracket or char we will push it into the stack\\n        if it is closing bracket then we will pop elements\\n        and will push into the queue untill there is opening bracket\\n        \\n        then pop the opening bracket\\n        and push all the elements from the queue to the stack\\n        \"\"\"\\n        from collections import deque\\n        q = deque()\\n        stack = []\\n        \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    q.append(stack.pop())\\n                stack.pop()\\n                while q:\\n                    front = q.popleft()\\n                    stack.append(front)\\n        return \\'\\'.join(stack)",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "\\n    def reverseParentheses(self, s: str) -> str:\\n        \"\"\"\\n        if it is opening bracket or char we will push it into the stack\\n        if it is closing bracket then we will pop elements\\n        and will push into the queue untill there is opening bracket\\n        \\n        then pop the opening bracket\\n        and push all the elements from the queue to the stack\\n        \"\"\"\\n        from collections import deque\\n        q = deque()\\n        stack = []\\n        \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    q.append(stack.pop())\\n                stack.pop()\\n                while q:\\n                    front = q.popleft()\\n                    stack.append(front)\\n        return \\'\\'.join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2118082,
                "title": "c-simple-solution-100-faster-with-comments",
                "content": "Approach: Recursion without stack\\n\\n```\\nstring reverseParentheses(string s) {\\n\\tint l=s.length();\\n\\tif(l<=1)\\n\\t\\treturn s;\\n\\tstring ans,temp;\\n\\tint i=0,par_count=0;   //index and parentheses count to avoid stack\\n\\n\\twhile(i<l){\\n\\t\\tif(s[i]==\\'(\\'){      // substring between this and it\\'s closing bracket will be sent into recursion\\n\\t\\t\\tpar_count=1,i++;\\n\\t\\t\\ttemp.clear();    // temp is the substring\\n\\t\\t\\twhile(i<l&&par_count){    // When par_count is 0 means we found the substring till the closing bracket \\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t\\tpar_count++;\\n\\t\\t\\t\\tif(s[i]==\\')\\')\\n\\t\\t\\t\\t\\tpar_count--;\\n\\t\\t\\t\\ttemp+=s[i++];\\n\\t\\t\\t}\\n\\t\\t\\ttemp.pop_back();          //remove closing bracket at the end\\n\\t\\t\\ttemp= reverseParentheses(temp);      \\n\\t\\t\\treverse(temp.begin(),temp.end());     // reverse the result\\n\\t\\t\\tans+=temp;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans+=s[i++];\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstring reverseParentheses(string s) {\\n\\tint l=s.length();\\n\\tif(l<=1)\\n\\t\\treturn s;\\n\\tstring ans,temp;\\n\\tint i=0,par_count=0;   //index and parentheses count to avoid stack\\n\\n\\twhile(i<l){\\n\\t\\tif(s[i]==\\'(\\'){      // substring between this and it\\'s closing bracket will be sent into recursion\\n\\t\\t\\tpar_count=1,i++;\\n\\t\\t\\ttemp.clear();    // temp is the substring\\n\\t\\t\\twhile(i<l&&par_count){    // When par_count is 0 means we found the substring till the closing bracket \\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t\\tpar_count++;\\n\\t\\t\\t\\tif(s[i]==\\')\\')\\n\\t\\t\\t\\t\\tpar_count--;\\n\\t\\t\\t\\ttemp+=s[i++];\\n\\t\\t\\t}\\n\\t\\t\\ttemp.pop_back();          //remove closing bracket at the end\\n\\t\\t\\ttemp= reverseParentheses(temp);      \\n\\t\\t\\treverse(temp.begin(),temp.end());     // reverse the result\\n\\t\\t\\tans+=temp;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans+=s[i++];\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067890,
                "title": "simple-stack-approach-c",
                "content": "**Approach :** \\nSince the string is balanced , we can use stack to keep a record of encountered ```open and close brackets``` and reverse the substring in between ```each corresponding pair of open - close bracket.```\\nWe keep pushing ```index of open brackets``` in the stack till we face our first ```close``` bracket.\\nAs soon as we find our first ```close``` bracket , this means we can reverse substring between ```this close bracket and its corresponding open bracket``` (the index of this corresponding open bracket is the top of the stack).\\nAlso , alongside this , we keep changing all the brackets ( open and closed both ) to any single common character so that at the end we can simply erase this common character from the whole string.\\n\\n**STL :**\\n--> ```reverse(s.begin()+st.top()+1,s.begin()+i); // to reverse the substring between a pair of open and close bracket```\\n--> ```s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end()); // to erase every \\'*\\' from the string```\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                s[st.top()] = \\'*\\';\\n                s[i] = \\'*\\';\\n                st.pop();\\n            }\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```\\n\\nTHANK YOU!!\\n\\nOther related problems :\\nLC. 1249 https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nLC. 1963 https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/\\nLC. 1541 https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```open and close brackets```\n```each corresponding pair of open - close bracket.```\n```index of open brackets```\n```close```\n```close```\n```this close bracket and its corresponding open bracket```\n```reverse(s.begin()+st.top()+1,s.begin()+i); // to reverse the substring between a pair of open and close bracket```\n```s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end()); // to erase every \\'*\\' from the string```\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                s[st.top()] = \\'*\\';\\n                s[i] = \\'*\\';\\n                st.pop();\\n            }\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036658,
                "title": "simple-c-code",
                "content": "# Please help me by increasing my reputation. By clicking the up arrow on the left of my image.\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\')\\')\\n            {\\n                while(st.back() != \\'(\\')\\n                {\\n                    ans += st.back();\\n                    st.pop_back();\\n                }\\n                st.pop_back();\\n                for(char &ch : ans)\\n                {\\n                    st.push_back(ch);\\n                }\\n                ans = \"\";\\n            }\\n            else\\n            {\\n                st.push_back(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.front();\\n            st.pop_front();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\')\\')\\n            {\\n                while(st.back() != \\'(\\')\\n                {\\n                    ans += st.back();\\n                    st.pop_back();\\n                }\\n                st.pop_back();\\n                for(char &ch : ans)\\n                {\\n                    st.push_back(ch);\\n                }\\n                ans = \"\";\\n            }\\n            else\\n            {\\n                st.push_back(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.front();\\n            st.pop_front();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008916,
                "title": "python-stack-approach",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        stack = []\\n        result = \"\"\\n        for i in range(len(s)):\\n            if s[i] != \")\":\\n                stack.append(s[i])\\n            else:\\n                temp = \"\"\\n                while stack[-1] != \"(\":\\n                    temp = stack.pop() + temp\\n                stack.pop()    \\n                temp = temp[::-1]\\n                    \\n                for i in range(len(temp)):\\n                    stack.append(temp[i])\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        stack = []\\n        result = \"\"\\n        for i in range(len(s)):\\n            if s[i] != \")\":\\n                stack.append(s[i])\\n            else:\\n                temp = \"\"\\n                while stack[-1] != \"(\":\\n                    temp = stack.pop() + temp\\n                stack.pop()    \\n                temp = temp[::-1]\\n                    \\n                for i in range(len(temp)):\\n                    stack.append(temp[i])\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008194,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'*\\');\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(st.top() == \\'*\\') st.pop();\\n                else{\\n                    string str;\\n                    while(st.top() != \\'*\\'){\\n                       str = str + st.top();\\n                       st.pop();\\n                    }\\n                    st.pop();\\n                    for(int k = 0; k<str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n            }\\n            else{\\n               st.push(s[i]);\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'*\\');\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(st.top() == \\'*\\') st.pop();\\n                else{\\n                    string str;\\n                    while(st.top() != \\'*\\'){\\n                       str = str + st.top();\\n                       st.pop();\\n                    }\\n                    st.pop();\\n                    for(int k = 0; k<str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n            }\\n            else{\\n               st.push(s[i]);\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987312,
                "title": "c-simple-solution-easy-to-understand-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string str;\\n        stack<char> a;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(a.top()!=\\'(\\')\\n                {\\n                    str+=a.top();\\n                    a.pop();\\n                }\\n                a.pop();\\n                for(int j=0;j<str.size();j++)\\n                {\\n                    a.push(str[j]);\\n                }\\n                str.clear();\\n            }\\n            else\\n            {\\n                a.push(s[i]);\\n            }\\n        }\\n        while(!a.empty())\\n        {\\n            str+=a.top();\\n            a.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string str;\\n        stack<char> a;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(a.top()!=\\'(\\')\\n                {\\n                    str+=a.top();\\n                    a.pop();\\n                }\\n                a.pop();\\n                for(int j=0;j<str.size();j++)\\n                {\\n                    a.push(str[j]);\\n                }\\n                str.clear();\\n            }\\n            else\\n            {\\n                a.push(s[i]);\\n            }\\n        }\\n        while(!a.empty())\\n        {\\n            str+=a.top();\\n            a.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955588,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        z=[]\\n        for i,j in enumerate(s):\\n            if j==\"(\":\\n                z.append(i)\\n            elif j==\")\":\\n                s=s[:z[-1]]+s[z[-1]:i][::-1]+s[i:]\\n                z.pop()\\n        s=s.replace(\"(\",\"\")\\n        s=s.replace(\")\",\"\")\\n        return s",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        z=[]\\n        for i,j in enumerate(s):\\n            if j==\"(\":\\n                z.append(i)\\n            elif j==\")\":\\n                s=s[:z[-1]]+s[z[-1]:i][::-1]+s[i:]\\n                z.pop()\\n        s=s.replace(\"(\",\"\")\\n        s=s.replace(\")\",\"\")\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 1939925,
                "title": "easy-soln-stacks-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> org;\\n        stack<char> cpy;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')\\n                org.push(s[i]);\\n            else if(s[i]==\\')\\'){\\n                while(org.top()!=\\'(\\'){\\n                    cpy.push(org.top());\\n                    org.pop(); \\n                }\\n                org.pop();\\n                stack<char> reverse;\\n                while(!cpy.empty()){\\n                    reverse.push(cpy.top());\\n                    cpy.pop();\\n                }\\n                while(!reverse.empty()){\\n                    org.push(reverse.top());\\n                    reverse.pop();\\n                }\\n            }\\n        }\\n        string rev=\"\";\\n        while(!org.empty()){\\n            if(org.top()!=\\'(\\')\\n                rev+=org.top();\\n            org.pop();\\n        }\\n        int i=0,j=rev.size()-1;\\n        while(i<j){\\n            swap(rev[i],rev[j]);\\n            i++;j--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> org;\\n        stack<char> cpy;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')\\n                org.push(s[i]);\\n            else if(s[i]==\\')\\'){\\n                while(org.top()!=\\'(\\'){\\n                    cpy.push(org.top());\\n                    org.pop(); \\n                }\\n                org.pop();\\n                stack<char> reverse;\\n                while(!cpy.empty()){\\n                    reverse.push(cpy.top());\\n                    cpy.pop();\\n                }\\n                while(!reverse.empty()){\\n                    org.push(reverse.top());\\n                    reverse.pop();\\n                }\\n            }\\n        }\\n        string rev=\"\";\\n        while(!org.empty()){\\n            if(org.top()!=\\'(\\')\\n                rev+=org.top();\\n            org.pop();\\n        }\\n        int i=0,j=rev.size()-1;\\n        while(i<j){\\n            swap(rev[i],rev[j]);\\n            i++;j--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935433,
                "title": "c-intuitions-explained-stack-clean-code-similar-to-q-decode-string",
                "content": "## ****Intuitions : - \\n## ********Take the stack data structure , stores the \\'(\\' and letters ,  while(s[i]!=\\')\\' ).\\n## Start popping the element from stack and stores in the string str=\"\" variable .\\n## Now we will again push back it into the stack , characters from string str . but this time it will be reversed , each time we taking all the string till it found \\'(\\' in the stack .\\n\\n## Push back again to stack , it will be reversed of their previous versions , as for if we operating it even times it will give same string as newest one , if having odd no. of brackets outside leads to reverse in this way .\\n\\n## finally the answer will be the reversed version of string stored in stack .\\n```\\n string reverseParentheses(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else\\n            {\\n                string str=\"\";\\n                while(!stk.empty() && stk.top()!=\\'(\\')\\n                {\\n                    str+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop(); // pop the \\'(\\' element from the stack\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    stk.push(str[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top() + ans;\\n            stk.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n string reverseParentheses(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else\\n            {\\n                string str=\"\";\\n                while(!stk.empty() && stk.top()!=\\'(\\')\\n                {\\n                    str+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop(); // pop the \\'(\\' element from the stack\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    stk.push(str[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top() + ans;\\n            stk.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910468,
                "title": "java-easy-clean-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n    \\tfor(char ch : s.toCharArray()) {\\n    \\t\\tif(ch != \\')\\')\\n    \\t\\t\\tst.push(ch);\\n    \\t\\telse {\\n    \\t\\t\\tQueue<Character> que = new ArrayDeque<>();\\n    \\t\\t\\twhile(st.peek() != \\'(\\')\\n    \\t\\t\\t\\tque.add(st.pop());\\n    \\t\\t\\tst.pop();\\n    \\t\\t\\twhile(que.size() > 0)\\n    \\t\\t\\t\\tst.push(que.remove());\\n    \\t\\t}\\n    \\t}\\n    \\tchar[] ans = new char[st.size()];\\n    \\tfor(int i = ans.length - 1; i >= 0; i--)\\n    \\t\\tans[i] = st.pop();\\n    \\treturn new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n    \\tfor(char ch : s.toCharArray()) {\\n    \\t\\tif(ch != \\')\\')\\n    \\t\\t\\tst.push(ch);\\n    \\t\\telse {\\n    \\t\\t\\tQueue<Character> que = new ArrayDeque<>();\\n    \\t\\t\\twhile(st.peek() != \\'(\\')\\n    \\t\\t\\t\\tque.add(st.pop());\\n    \\t\\t\\tst.pop();\\n    \\t\\t\\twhile(que.size() > 0)\\n    \\t\\t\\t\\tst.push(que.remove());\\n    \\t\\t}\\n    \\t}\\n    \\tchar[] ans = new char[st.size()];\\n    \\tfor(int i = ans.length - 1; i >= 0; i--)\\n    \\t\\tans[i] = st.pop();\\n    \\treturn new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848592,
                "title": "using-string-as-stack-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                "content": "Not really I believe , incase we have inputs like (((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)))))\\nthis code will probably be o(n^2) then .\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string stk;\\n        for(auto c:s){\\n            if(c==\\')\\'){\\n               string t;\\n               while(stk.back()!=\\'(\\'){\\n                   t+=stk.back();\\n                   stk.pop_back();\\n               }\\n               stk.pop_back();\\n               stk+=t;\\n            }\\n            else{\\n                stk.push_back(c);\\n            }\\n        }\\n        return stk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string stk;\\n        for(auto c:s){\\n            if(c==\\')\\'){\\n               string t;\\n               while(stk.back()!=\\'(\\'){\\n                   t+=stk.back();\\n                   stk.pop_back();\\n               }\\n               stk.pop_back();\\n               stk+=t;\\n            }\\n            else{\\n                stk.push_back(c);\\n            }\\n        }\\n        return stk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827439,
                "title": "c-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                int top=st.top();\\n                 st.pop();\\n                reverse(s.begin()+top+1,s.begin()+i);\\n               \\n            }\\n        } \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\' )\\n                ans+=s[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                int top=st.top();\\n                 st.pop();\\n                reverse(s.begin()+top+1,s.begin()+i);\\n               \\n            }\\n        } \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\' )\\n                ans+=s[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814759,
                "title": "java-solution-with-recursion",
                "content": "```\\n\\n\\tint index = 0;\\n    public String reverseParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length()){\\n            char c = s.charAt(index++);\\n            if(c == \\'(\\'){\\n                sb.append(reverseParentheses(s));\\n            }else if(c ==\\')\\'){\\n                return sb.reverse().toString();\\n            }else{\\n                sb.append(c);\\n            }  \\n        }\\n        return sb.toString();\\n    }\\n```\\n\\nSame method used to deal with parenthesis pair \\n224.https://leetcode.com/problems/basic-calculator/\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\n\\tint index = 0;\\n    public String reverseParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length()){\\n            char c = s.charAt(index++);\\n            if(c == \\'(\\'){\\n                sb.append(reverseParentheses(s));\\n            }else if(c ==\\')\\'){\\n                return sb.reverse().toString();\\n            }else{\\n                sb.append(c);\\n            }  \\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709099,
                "title": "java-stack-99-easy",
                "content": "We use a stack to keep track of indices we want to swap within. The rest of the code is pretty self explanatory\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n\\n            if (c == \\'(\\') \\n                stack.push(i);\\n            else if (c == \\')\\')\\n                reverseSubstring(arr, stack.pop(), i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : arr) {\\n            if (c != \\'(\\' && c != \\')\\')\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static void reverseSubstring(char[] arr, int start, int end) {\\n        int l = start;\\n        int h = end;\\n\\n        while (l <= h) {\\n            char t = arr[l];\\n            arr[l] = arr[h];\\n            arr[h] = t;\\n            l++;\\n            h--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n\\n            if (c == \\'(\\') \\n                stack.push(i);\\n            else if (c == \\')\\')\\n                reverseSubstring(arr, stack.pop(), i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : arr) {\\n            if (c != \\'(\\' && c != \\')\\')\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static void reverseSubstring(char[] arr, int start, int end) {\\n        int l = start;\\n        int h = end;\\n\\n        while (l <= h) {\\n            char t = arr[l];\\n            arr[l] = arr[h];\\n            arr[h] = t;\\n            l++;\\n            h--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626022,
                "title": "python3-with-1-pass-runtime-beats-89-82",
                "content": "\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str: \\n        return reverse(s)[0] \\n\\ndef reverse(s, i=0): \\n    new_word = \\'\\' \\n    while i < len(s): \\n        if s[i] == \\'(\\': \\n            result, i = reverse(s, i+1) \\n            new_word += result \\n        elif s[i] == \\')\\': \\n            new_word = reversed(new_word)\\n            new_word = \\'\\'.join([char for char in new_word])\\n            return new_word, i+1\\n        else: \\n            new_word += s[i] \\n            i += 1 \\n    return new_word, i  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str: \\n        return reverse(s)[0] \\n\\ndef reverse(s, i=0): \\n    new_word = \\'\\' \\n    while i < len(s): \\n        if s[i] == \\'(\\': \\n            result, i = reverse(s, i+1) \\n            new_word += result \\n        elif s[i] == \\')\\': \\n            new_word = reversed(new_word)\\n            new_word = \\'\\'.join([char for char in new_word])\\n            return new_word, i+1\\n        else: \\n            new_word += s[i] \\n            i += 1 \\n    return new_word, i  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623084,
                "title": "simple-code-in-python-using-stack-75-fast",
                "content": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        st=[]\\n       \\n        for i in s:\\n            \\n            if i!=\\')\\':\\n                st.append(i)\\n                print(st)\\n                \\n            else:\\n                a=\\'\\'\\n                while(st!=[] and st[-1]!=\\'(\\'):\\n                      a+=st.pop()\\n                st.pop()\\n                st.append(a[::-1])\\n       \\n    \\n    \\n        for i in range(len(st)):\\n            st[i]=st[i][::-1]\\n            \\n            \\n        return \"\".join(st)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        st=[]\\n       \\n        for i in s:\\n            \\n            if i!=\\')\\':\\n                st.append(i)\\n                print(st)\\n                \\n            else:\\n                a=\\'\\'\\n                while(st!=[] and st[-1]!=\\'(\\'):\\n                      a+=st.pop()\\n                st.pop()\\n                st.append(a[::-1])\\n       \\n    \\n    \\n        for i in range(len(st)):\\n            st[i]=st[i][::-1]\\n            \\n            \\n        return \"\".join(st)",
                "codeTag": "Java"
            },
            {
                "id": 1539721,
                "title": "faster-than-100-c-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(\"\");\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    string tmp=\"\";\\n                    tmp.push_back(s[i]);\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top().push_back(s[i]);\\n                }\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                string tmp=stk.top();\\n                stk.pop();\\n                reverse(tmp.begin(),tmp.end());\\n                if(stk.empty())\\n                {\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top()+=tmp;\\n                }\\n            }\\n        }\\n        return stk.top();\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(\"\");\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    string tmp=\"\";\\n                    tmp.push_back(s[i]);\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top().push_back(s[i]);\\n                }\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                string tmp=stk.top();\\n                stk.pop();\\n                reverse(tmp.begin(),tmp.end());\\n                if(stk.empty())\\n                {\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top()+=tmp;\\n                }\\n            }\\n        }\\n        return stk.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528874,
                "title": "easy-c-solution-faster-than-100",
                "content": "stack< char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             string str;\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    str.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=\\'(\\' && st.top()!=\\')\\')\\n                ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;",
                "solutionTags": [],
                "code": "stack< char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             string str;\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    str.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=\\'(\\' && st.top()!=\\')\\')\\n                ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1516551,
                "title": "stack-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        queue<char> q;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            if(s[i]==\\')\\'){\\n                while(st.top()!=\\'(\\'){\\n                    q.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                while(!q.empty()){\\n                    st.push(q.front());\\n                    q.pop();\\n                }}\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        queue<char> q;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            if(s[i]==\\')\\'){\\n                while(st.top()!=\\'(\\'){\\n                    q.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                while(!q.empty()){\\n                    st.push(q.front());\\n                    q.pop();\\n                }}\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507107,
                "title": "simplest-and-straightforward",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.push(i);\\n            }\\n            if (arr[i] == \\')\\') {\\n                reverse(arr, stack.pop(), i);\\n            }\\n            \\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : arr) {\\n            if (c == \\'(\\' ||  c == \\')\\') {\\n               continue; \\n            }\\n            else {\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n    \\n    private void reverse(char[] arr, int i, int j) {\\n        while (i < j){\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.push(i);\\n            }\\n            if (arr[i] == \\')\\') {\\n                reverse(arr, stack.pop(), i);\\n            }\\n            \\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : arr) {\\n            if (c == \\'(\\' ||  c == \\')\\') {\\n               continue; \\n            }\\n            else {\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n    \\n    private void reverse(char[] arr, int i, int j) {\\n        while (i < j){\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448227,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char> st;\\n        for(auto el : s)\\n        {\\n            if(el == \\')\\')\\n            {\\n                string tmp = \"\";\\n                while(st.top() != \\'(\\')\\n                {\\n                    tmp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                for(auto el2 : tmp)\\n                    st.push(el2);\\n            }\\n            else\\n                st.push(el);\\n                 \\n        }\\n        \\n        string ans = \"\";\\n        while(st.size())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char> st;\\n        for(auto el : s)\\n        {\\n            if(el == \\')\\')\\n            {\\n                string tmp = \"\";\\n                while(st.top() != \\'(\\')\\n                {\\n                    tmp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                for(auto el2 : tmp)\\n                    st.push(el2);\\n            }\\n            else\\n                st.push(el);\\n                 \\n        }\\n        \\n        string ans = \"\";\\n        while(st.size())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385145,
                "title": "c-100-fast-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> st;\\n        string g=\"\";\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\')\\'){\\n                string k=\"\";\\n                while (!st.empty() && st.top()!=\\'(\\' ){\\n                    k+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for (auto i : k){\\n                    st.push(i);\\n                }\\n            }\\n            if (s[i]!=\\')\\'){\\n               st.push(s[i]);\\n            }\\n        }\\n        while (!st.empty()){\\n            g+=st.top();\\n            st.pop();\\n        }\\n        reverse(g.begin(),g.end());\\n        return g;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> st;\\n        string g=\"\";\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\')\\'){\\n                string k=\"\";\\n                while (!st.empty() && st.top()!=\\'(\\' ){\\n                    k+=st.top();\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1375927,
                "title": "faster-than-100-space-0-n-c-solution-with-comment",
                "content": "```\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            //If closing means need to reverse the string;\\n        if(s[i]==\\')\\')\\n        {\\n            string tmps;\\n            //pop until ( comes\\n            while(st.top()!=\\'(\\')\\n            {\\n                tmps.push_back(st.top());\\n                st.pop();\\n            }\\n            st.pop();\\n            //now again push the reverse order in stack\\n             for(auto it:tmps)\\n             {\\n                 st.push(it);\\n             }\\n        }\\n        else \\n        {\\n            st.push(s[i]);\\n        }\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse the string as we need the order opposite to what stack stores\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            //If closing means need to reverse the string;\\n        if(s[i]==\\')\\')\\n        {\\n            string tmps;\\n            //pop until ( comes\\n            while(st.top()!=\\'(\\')\\n            {\\n                tmps.push_back(st.top());\\n                st.pop();\\n            }\\n            st.pop();\\n            //now again push the reverse order in stack\\n             for(auto it:tmps)\\n             {\\n                 st.push(it);\\n             }\\n        }\\n        else \\n        {\\n            st.push(s[i]);\\n        }\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse the string as we need the order opposite to what stack stores\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370868,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> stk;\\n        string res = \"\";\\n        int len = s.length();\\n        for(int i=0;i<len;i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else if(s[i] == \\')\\') {\\n                // Reverse substring.\\n                int t = stk.top();\\n                stk.pop();\\n                reverse(s.begin()+t, s.begin()+i);\\n            }\\n        }\\n        for(int i=0;i<len;i++) {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> stk;\\n        string res = \"\";\\n        int len = s.length();\\n        for(int i=0;i<len;i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else if(s[i] == \\')\\') {\\n                // Reverse substring.\\n                int t = stk.top();\\n                stk.pop();\\n                reverse(s.begin()+t, s.begin()+i);\\n            }\\n        }\\n        for(int i=0;i<len;i++) {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368481,
                "title": "python-o-n-faster-than-96-less-space-than-84-easy-stack",
                "content": "```class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        id_stack = []\\n        orig_string = s\\n        for i, ele in enumerate(orig_string):\\n            if ele == \\'(\\':\\n                id_stack.append(i)\\n            if ele == \\')\\':\\n                start = id_stack.pop()\\n                end = i\\n                s = s[0:start+1]+s[start+1:end][::-1]+s[end:]\\n\\n        return \"\".join([ele for ele in s if ele not in [\\'(\\',\\')\\']])",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        id_stack = []\\n        orig_string = s\\n        for i, ele in enumerate(orig_string):\\n            if ele == \\'(\\':\\n                id_stack.append(i)\\n            if ele == \\')\\':\\n                start = id_stack.pop()\\n                end = i\\n                s = s[0:start+1]+s[start+1:end][::-1]+s[end:]\\n\\n        return \"\".join([ele for ele in s if ele not in [\\'(\\',\\')\\']])",
                "codeTag": "Java"
            },
            {
                "id": 1306793,
                "title": "should-be-in-easy-section",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        string s1;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(st.empty() or s[i] == \\'(\\' or isalpha(s[i]))\\n                st.push(s[i]);\\n            else{\\n                string temp;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i = 0; i < temp.size(); i++)\\n                    st.push(temp[i]);\\n            }\\n                \\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        string s1;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(st.empty() or s[i] == \\'(\\' or isalpha(s[i]))\\n                st.push(s[i]);\\n            else{\\n                string temp;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i = 0; i < temp.size(); i++)\\n                    st.push(temp[i]);\\n            }\\n                \\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267825,
                "title": "using-stack-and-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        queue<char> qu;\\n        stack<char> st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    qu.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                while(!qu.empty())\\n                {\\n                    st.push(qu.front());\\n                    qu.pop();\\n                }\\n                \\n\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans = st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        queue<char> qu;\\n        stack<char> st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    qu.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                while(!qu.empty())\\n                {\\n                    st.push(qu.front());\\n                    qu.pop();\\n                }\\n                \\n\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans = st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261798,
                "title": "c-stack-o-n-time-and-space-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n =s.length();\\n        stack<char> st;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\')\\') {\\n                string temp =\"\";\\n                while(!st.empty()&&st.top()!=\\'(\\') {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop(); //remove bracket. \\n                for(int j=0;j<temp.length();j++) {\\n                    st.push(temp[j]);\\n                }\\n            }\\n            else \\n                st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()) {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n =s.length();\\n        stack<char> st;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\')\\') {\\n                string temp =\"\";\\n                while(!st.empty()&&st.top()!=\\'(\\') {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop(); //remove bracket. \\n                for(int j=0;j<temp.length();j++) {\\n                    st.push(temp[j]);\\n                }\\n            }\\n            else \\n                st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()) {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230308,
                "title": "python-stack-only",
                "content": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        stack = []\\n        \\n        \\n        for i in s:\\n            #print(stack)\\n            if(i!=\")\"):\\n                stack.append(i)\\n                continue\\n            \\n            s = \"\"\\n            x = stack.pop()\\n            \\n            while(x!=\"(\"):\\n                s+=x[::-1]\\n                x = stack.pop()\\n            \\n            stack.append(s)\\n        \\n        \\n        return \"\".join(stack)",
                "solutionTags": [],
                "code": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        stack = []\\n        \\n        \\n        for i in s:\\n            #print(stack)\\n            if(i!=\")\"):\\n                stack.append(i)\\n                continue\\n            \\n            s = \"\"\\n            x = stack.pop()\\n            \\n            while(x!=\"(\"):\\n                s+=x[::-1]\\n                x = stack.pop()\\n            \\n            stack.append(s)\\n        \\n        \\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1223343,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    /*\\n    \"(ed(et(oc))el)\"\\n    stack (ed(etco)el\\n    edocteel\\n    */\\n    public String reverseParentheses(String s) {\\n        if(s == null || s.length() == 0)\\n        {\\n            return s;\\n        }\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(char c : s.toCharArray())\\n        {\\n            if(c != \\')\\')\\n            {\\n                stack.push(c);\\n            }\\n            else\\n            {\\n                Queue<Character> queue = new LinkedList<>();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')\\n                {\\n                    queue.add(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                \\n                while(!queue.isEmpty())\\n                {\\n                    stack.push(queue.poll());\\n                }\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty())\\n        {\\n            result.append(stack.pop());\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    /*\\n    \"(ed(et(oc))el)\"\\n    stack (ed(etco)el\\n    edocteel\\n    */\\n    public String reverseParentheses(String s) {\\n        if(s == null || s.length() == 0)\\n        {\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1219626,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char>st;\\n        \\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                \\n                string a=\"\";\\n                while(st.top()!=\\'(\\')\\n                {\\n                    a+=st.top();\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                \\n                for(int i=0;i<a.length();i++)\\n                {\\n                    st.push(a[i]);\\n                }\\n                \\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(st.size())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char>st;\\n        \\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                \\n                string a=\"\";\\n                while(st.top()!=\\'(\\')\\n                {\\n                    a+=st.top();\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                \\n                for(int i=0;i<a.length();i++)\\n                {\\n                    st.push(a[i]);\\n                }\\n                \\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(st.size())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212741,
                "title": "easy-and-simplest-o-n-stack-solution",
                "content": "```\\nstring reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                    st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                                   \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                    st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                                   \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207655,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st=new Stack<StringBuilder>();\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st.push(sb);\\n               sb=new StringBuilder();\\n            }\\n            else if(s.charAt(i)==\\')\\')\\n            {\\n                String rev=sb.reverse().toString();\\n                sb=st.pop();\\n                sb.append(rev);\\n            }\\n            else\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st=new Stack<StringBuilder>();\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st.push(sb);\\n               sb=new StringBuilder();\\n            }\\n            else if(s.charAt(i)==\\')\\')\\n            {\\n                String rev=sb.reverse().toString();\\n                sb=st.pop();\\n                sb.append(rev);\\n            }\\n            else\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201061,
                "title": "java-easy-solution-stack",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\' || s.charAt(i)!=\\')\\'){\\n            stack.push(s.charAt(i));\\n          }\\n          else{\\n            Queue<Character> q=new LinkedList<>();\\n            while(stack.size()>0 && stack.peek()!=\\'(\\'){\\n              q.add(stack.pop());\\n            }\\n            if(stack.size()>0) stack.pop();\\n            while(q.size()>0){\\n              stack.push(q.remove());\\n            }\\n          }\\n            \\n          }\\n         StringBuffer sb=new StringBuffer();\\n         while(stack.size()>0){\\n           sb.append(stack.pop());\\n         }\\n         sb.reverse();\\n      return sb.toString();\\n        \\n          \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\' || s.charAt(i)!=\\')\\'){\\n            stack.push(s.charAt(i));\\n          }\\n          else{\\n            Queue<Character> q=new LinkedList<>();\\n            while(stack.size()>0 && stack.peek()!=\\'(\\'){\\n              q.add(stack.pop());\\n            }\\n            if(stack.size()>0) stack.pop();\\n            while(q.size()>0){\\n              stack.push(q.remove());\\n            }\\n          }\\n            \\n          }\\n         StringBuffer sb=new StringBuffer();\\n         while(stack.size()>0){\\n           sb.append(stack.pop());\\n         }\\n         sb.reverse();\\n      return sb.toString();\\n        \\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199755,
                "title": "faster-than-100-c-solution-think-creative",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void reverse(int i,int j,string &s){\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string str) {\\n        stack<int>s;\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }\\n            else if(str[i]==\\')\\'){\\n                int t = s.top();\\n                s.pop();\\n                reverse(t,i,str);\\n            }\\n        }\\n        string res = \"\";\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'||str[i]==\\')\\') continue;\\n            res+=str[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void reverse(int i,int j,string &s){\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string str) {\\n        stack<int>s;\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }\\n            else if(str[i]==\\')\\'){\\n                int t = s.top();\\n                s.pop();\\n                reverse(t,i,str);\\n            }\\n        }\\n        string res = \"\";\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'||str[i]==\\')\\') continue;\\n            res+=str[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174433,
                "title": "simple-c-solution-using-stack-0ms-100-faster",
                "content": "```class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack < int > v;\\n        \\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push(i);\\n            }\\n            \\n            if(s[i]==\\')\\')\\n            {\\n                int x = v.top();\\n                v.pop();\\n                reverse(s.begin()+x,s.begin()+i);\\n            }\\n        }\\n        \\n        string ans;\\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack < int > v;\\n        \\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1156827,
                "title": "c-solution-with-stack",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\n// Memory Usage: 6.2 MB, less than 64.88% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\nstring reverseParentheses(string s) {\\n\\tstack<int> stPos;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tstPos.push(i);\\n\\t\\telse if (s[i] == \\')\\') {\\n\\t\\t\\treverse(s.begin() + stPos.top() + 1, s.begin() + i);\\n\\t\\t\\tstPos.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = \"\";\\n\\tfor (char c : s)\\n\\t\\tif (c != \\'(\\' && c != \\')\\')\\n\\t\\t\\tresult += c;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\n// Memory Usage: 6.2 MB, less than 64.88% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\nstring reverseParentheses(string s) {\\n\\tstack<int> stPos;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tstPos.push(i);\\n\\t\\telse if (s[i] == \\')\\') {\\n\\t\\t\\treverse(s.begin() + stPos.top() + 1, s.begin() + i);\\n\\t\\t\\tstPos.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = \"\";\\n\\tfor (char c : s)\\n\\t\\tif (c != \\'(\\' && c != \\')\\')\\n\\t\\t\\tresult += c;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156290,
                "title": "easy-to-understand-solution-in-java-beats-97-42-solutions",
                "content": "```\\nclass Solution {\\n    public  String reverseParentheses(String s) {\\n        if(s.length() == 0){\\n            return \"\";\\n        }\\n        \\n        Stack<StringBuilder> stack = new Stack<>();\\n        stack.push(new StringBuilder(\"\"));\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(new StringBuilder(\"\"));\\n            }else {\\n                if(c == \\')\\'){\\n                    StringBuilder ss = stack.pop();\\n                    ss.reverse();\\n                    StringBuilder temp = stack.pop();\\n                    temp.append(ss);\\n                    stack.push(temp);\\n                }else{\\n                    stack.peek().append(c);\\n                }\\n            }\\n        }\\n        \\n      return stack.pop().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public  String reverseParentheses(String s) {\\n        if(s.length() == 0){\\n            return \"\";\\n        }\\n        \\n        Stack<StringBuilder> stack = new Stack<>();\\n        stack.push(new StringBuilder(\"\"));\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(new StringBuilder(\"\"));\\n            }else {\\n                if(c == \\')\\'){\\n                    StringBuilder ss = stack.pop();\\n                    ss.reverse();\\n                    StringBuilder temp = stack.pop();\\n                    temp.append(ss);\\n                    stack.push(temp);\\n                }else{\\n                    stack.peek().append(c);\\n                }\\n            }\\n        }\\n        \\n      return stack.pop().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144452,
                "title": "python-runtime-16-ms-memory-usage-14-3-mb-chupa-chinesada",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n\\n        while \\'(\\' in s:\\n            fim = s.find(\\')\\')+1\\n            inicio = s[:fim].rfind(\\'(\\')\\n            \\n            s = s.replace(s[inicio: fim], s[inicio+1: fim-1][::-1])\\n        \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n\\n        while \\'(\\' in s:\\n            fim = s.find(\\')\\')+1\\n            inicio = s[:fim].rfind(\\'(\\')\\n            \\n            s = s.replace(s[inicio: fim], s[inicio+1: fim-1][::-1])\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142326,
                "title": "simple-javascript-solution-using-stack",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    \\n    // 1. using stack \\n    // create arrays of stack\\n    // for every \\'(\\' initisalise new stack\\n    // return/ pop() the reverse of stack on encountering \\')\\'\\n    \\n    // Time complexity O(N)\\n    // Space complexity O(N) for stacks\\n    \\n    \\n    let stack = [];\\n    // initialise with []\\n    stack.push([]);\\n    \\n    for (let char of s) {\\n        if (char === \\'(\\') {\\n            stack.push([])\\n        } else if (char === \\')\\') {\\n            const reverse = stack.pop().reverse();\\n            stack[stack.length - 1].push(...reverse);\\n        } else {\\n            stack[stack.length - 1].push(char);\\n        }\\n    }\\n    \\n    return stack.pop().join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    \\n    // 1. using stack \\n    // create arrays of stack\\n    // for every \\'(\\' initisalise new stack\\n    // return/ pop() the reverse of stack on encountering \\')\\'\\n    \\n    // Time complexity O(N)\\n    // Space complexity O(N) for stacks\\n    \\n    \\n    let stack = [];\\n    // initialise with []\\n    stack.push([]);\\n    \\n    for (let char of s) {\\n        if (char === \\'(\\') {\\n            stack.push([])\\n        } else if (char === \\')\\') {\\n            const reverse = stack.pop().reverse();\\n            stack[stack.length - 1].push(...reverse);\\n        } else {\\n            stack[stack.length - 1].push(char);\\n        }\\n    }\\n    \\n    return stack.pop().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138216,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        int n=s.size();\\n        vector<int>backet,pair(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                backet.push_back(i);\\n            }\\n           if(s[i]==\\')\\')\\n           {\\n               int val=backet.back();\\n               backet.pop_back();\\n               pair[i]=val;\\n               pair[val]=i;\\n           }\\n        }\\n        string ans=\"\";\\n        for(int i=0,d=1;i<n;i+=d)\\n        {\\n            if(s[i]==\\')\\'||s[i]==\\'(\\')\\n            {\\n                d=-d;\\n                i=pair[i];\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        int n=s.size();\\n        vector<int>backet,pair(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                backet.push_back(i);\\n            }\\n           if(s[i]==\\')\\')\\n           {\\n               int val=backet.back();\\n               backet.pop_back();\\n               pair[i]=val;\\n               pair[val]=i;\\n           }\\n        }\\n        string ans=\"\";\\n        for(int i=0,d=1;i<n;i+=d)\\n        {\\n            if(s[i]==\\')\\'||s[i]==\\'(\\')\\n            {\\n                d=-d;\\n                i=pair[i];\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118085,
                "title": "python-solution-28ms-faster-than-88-using-single-stack-with-clear-explanation",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        i, n, stack = 0, len(s), []\\n        \\n        while i < n:\\n            if  s[i] == \\'(\\':  # if its opening parentheses, just append\\n                stack.append(s[i])\\n            elif s[i] == \\')\\': # if its closing parentheses\\n                st = \\'\\'\\n                while stack!=[] and stack[-1]!=\\'(\\': #while stack is not empty and stack\\'s top is NOT an opening parentheses\\n                    st += stack.pop() #pop the element and append to a temporary string\\n                stack.pop() #pop the last remaining ( in some cases\\n                stack += list(st) #append the popped elements to stack\\n            else:\\n                stack.append(s[i]) #pushing all letters into stack\\n            i += 1\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        i, n, stack = 0, len(s), []\\n        \\n        while i < n:\\n            if  s[i] == \\'(\\':  # if its opening parentheses, just append\\n                stack.append(s[i])\\n            elif s[i] == \\')\\': # if its closing parentheses\\n                st = \\'\\'\\n                while stack!=[] and stack[-1]!=\\'(\\': #while stack is not empty and stack\\'s top is NOT an opening parentheses\\n                    st += stack.pop() #pop the element and append to a temporary string\\n                stack.pop() #pop the last remaining ( in some cases\\n                stack += list(st) #append the popped elements to stack\\n            else:\\n                stack.append(s[i]) #pushing all letters into stack\\n            i += 1\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079296,
                "title": "python-faster-than-98-submission-using-stack-and-array",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stk,arr=[],[]\\n        for i in s:\\n            if i!=\\')\\':\\n                stk.append(i)\\n            else:\\n                popele=stk.pop()\\n                while popele!=\\'(\\':\\n                    arr.append(popele)\\n                    popele=stk.pop()\\n\\n                for j in arr:\\n                    stk.append(j)\\n                arr=[]\\n        ans=\\'\\'\\n        for k in stk:\\n            ans+=k\\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stk,arr=[],[]\\n        for i in s:\\n            if i!=\\')\\':\\n                stk.append(i)\\n            else:\\n                popele=stk.pop()\\n                while popele!=\\'(\\':\\n                    arr.append(popele)\\n                    popele=stk.pop()\\n\\n                for j in arr:\\n                    stk.append(j)\\n                arr=[]\\n        ans=\\'\\'\\n        for k in stk:\\n            ans+=k\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1039699,
                "title": "python-easy-to-understand-stack-solution",
                "content": "Simple stack solution.\\n\\n    def reverseParentheses(self, s):\\n\\t\\n        stack=[]\\n        cur_str=\"\"\\n        \\n        for char in s:\\n            if char==\\'(\\':\\n                stack.append(cur_str)\\n                cur_str=\"\"\\n                \\n            elif char==\\')\\':\\n                cur_str=cur_str[::-1]\\n                cur_str=stack.pop()+cur_str\\n                \\n            else:\\n                cur_str+=char\\n        \\n        return cur_str\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple stack solution.\\n\\n    def reverseParentheses(self, s):\\n\\t\\n        stack=[]\\n        cur_str=\"\"\\n        \\n        for char in s:\\n            if char==\\'(\\':\\n                stack.append(cur_str)\\n                cur_str=\"\"\\n                \\n            elif char==\\')\\':\\n                cur_str=cur_str[::-1]\\n                cur_str=stack.pop()+cur_str\\n                \\n            else:\\n                cur_str+=char\\n        \\n        return cur_str\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1026850,
                "title": "javascript-o-n-time-and-space-stack-of-parentheses",
                "content": "Using stack:\\n```\\nvar reverseParentheses = function (s) {\\n\\n  const levelsStack = [[]];\\n  let lastLevelIndex = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\') {\\n      levelsStack.push([]);\\n      lastLevelIndex++;\\n    } else if (s[i] === \\')\\') {\\n      const lastLevel = levelsStack.pop();\\n      lastLevelIndex--;\\n      for (let j = lastLevel.length - 1; j >= 0; j--) {\\n        levelsStack[lastLevelIndex].push(lastLevel[j]);\\n      }\\n    } else {\\n      levelsStack[lastLevelIndex].push(s[i]);\\n    }\\n  }\\n  return levelsStack[lastLevelIndex].join(\\'\\');\\n}\\n```\\n\\nOr using recursion:\\n```\\nvar reverseParentheses = function (s) {\\n\\n  function reversePart(startIndex, firstLevel) {\\n    let part = [];\\n\\n    for (let i = startIndex; i < s.length; i++) {\\n      if (s[i] === \\'(\\') {\\n        const { partToReverse, finishedOn } = reversePart(i + 1, false);\\n        for (let j = partToReverse.length - 1; j >= 0; j--) {\\n          part.push(partToReverse[j]);\\n        }\\n        i = finishedOn;\\n      } else if (s[i] === \\')\\' && !firstLevel) {\\n        return { part: part.join(\\'\\'), finishedOn: i };\\n      } else {\\n        part.push(s[i]);\\n      }\\n    }\\n    return part.join(\\'\\');\\n  }\\n  \\n  return reversePart(0, true);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar reverseParentheses = function (s) {\\n\\n  const levelsStack = [[]];\\n  let lastLevelIndex = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\') {\\n      levelsStack.push([]);\\n      lastLevelIndex++;\\n    } else if (s[i] === \\')\\') {\\n      const lastLevel = levelsStack.pop();\\n      lastLevelIndex--;\\n      for (let j = lastLevel.length - 1; j >= 0; j--) {\\n        levelsStack[lastLevelIndex].push(lastLevel[j]);\\n      }\\n    } else {\\n      levelsStack[lastLevelIndex].push(s[i]);\\n    }\\n  }\\n  return levelsStack[lastLevelIndex].join(\\'\\');\\n}\\n```\n```\\nvar reverseParentheses = function (s) {\\n\\n  function reversePart(startIndex, firstLevel) {\\n    let part = [];\\n\\n    for (let i = startIndex; i < s.length; i++) {\\n      if (s[i] === \\'(\\') {\\n        const { partToReverse, finishedOn } = reversePart(i + 1, false);\\n        for (let j = partToReverse.length - 1; j >= 0; j--) {\\n          part.push(partToReverse[j]);\\n        }\\n        i = finishedOn;\\n      } else if (s[i] === \\')\\' && !firstLevel) {\\n        return { part: part.join(\\'\\'), finishedOn: i };\\n      } else {\\n        part.push(s[i]);\\n      }\\n    }\\n    return part.join(\\'\\');\\n  }\\n  \\n  return reversePart(0, true);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997582,
                "title": "simple-python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = list()\\n        stack.append(\"\")\\n        for c in s:\\n            if c == \"(\":\\n                stack.append(\"\")\\n            elif c == \")\":\\n                tmp = stack.pop()[::-1]\\n                stack[-1] += tmp\\n            else:\\n                stack[-1] += c\\n        \\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = list()\\n        stack.append(\"\")\\n        for c in s:\\n            if c == \"(\":\\n                stack.append(\"\")\\n            elif c == \")\":\\n                tmp = stack.pop()[::-1]\\n                stack[-1] += tmp\\n            else:\\n                stack[-1] += c\\n        \\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986883,
                "title": "java-solution-using-stacks-deque-with-comments",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        StringBuilder str = new StringBuilder(); \\n        Deque<Character> d = new ArrayDeque();\\n        \\n        for(int i=0; i<s.length();i++){\\n            if(s.charAt(i) == \\')\\'){\\n                //reverse the string ( a b c d\\n                \\n                while(!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                       d.add(stack.pop()); //d c b a                    \\n                }\\n                \\n\\t\\t\\t\\t//remove the open bracket\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n                // pollFirst() method of deque remvoes the first element of deque\\n                while(!d.isEmpty()){\\n                    stack.push(d.pollFirst()); // d c b a\\n                }\\n                \\n            } else{\\n                stack.push(s.charAt(i)); // (,a,b,c,d,l\\n            }\\n        }\\n        \\n        // d c b a\\n        while(!stack.isEmpty()){\\n            str.append(stack.pop()); // a b c d\\n        }\\n        \\n        \\n        return str.reverse().toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        StringBuilder str = new StringBuilder(); \\n        Deque<Character> d = new ArrayDeque();\\n        \\n        for(int i=0; i<s.length();i++){\\n            if(s.charAt(i) == \\')\\'){\\n                //reverse the string ( a b c d\\n                \\n                while(!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                       d.add(stack.pop()); //d c b a                    \\n                }\\n                \\n\\t\\t\\t\\t//remove the open bracket\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n                // pollFirst() method of deque remvoes the first element of deque\\n                while(!d.isEmpty()){\\n                    stack.push(d.pollFirst()); // d c b a\\n                }\\n                \\n            } else{\\n                stack.push(s.charAt(i)); // (,a,b,c,d,l\\n            }\\n        }\\n        \\n        // d c b a\\n        while(!stack.isEmpty()){\\n            str.append(stack.pop()); // a b c d\\n        }\\n        \\n        \\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980540,
                "title": "python-simple-and-easy",
                "content": "```\\ndef reverseParentheses(s):\\n\\ts = list(s)\\n\\tstack = []\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \\'(\\':\\n\\t\\t\\tstack.append(i)\\n\\t\\telif s[i] == \\')\\':\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\ts[j+1:i]= s[j+1:i][::-1]\\n\\treturn \\'\\'.join([t for t in s if t != \\'(\\' and t != \\')\\'])\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverseParentheses(s):\\n\\ts = list(s)\\n\\tstack = []\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \\'(\\':\\n\\t\\t\\tstack.append(i)\\n\\t\\telif s[i] == \\')\\':\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\ts[j+1:i]= s[j+1:i][::-1]\\n\\treturn \\'\\'.join([t for t in s if t != \\'(\\' and t != \\')\\'])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972075,
                "title": "only-save-the-position-of-by-stack-c-code-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string reverseParentheses(string str) {\\n        stack<int> s;\\n        string ret;\\n        for (char ch : str) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ret += ch;\\n            } else if (ch == \\'(\\') {\\n                s.push(ret.size());\\n            } else if (ch == \\')\\') {\\n                int pos = s.top();\\n                s.pop();\\n                reverse(ret.begin() + pos, ret.end());\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseParentheses(string str) {\\n        stack<int> s;\\n        string ret;\\n        for (char ch : str) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ret += ch;\\n            } else if (ch == \\'(\\') {\\n                s.push(ret.size());\\n            } else if (ch == \\')\\') {\\n                int pos = s.top();\\n                s.pop();\\n                reverse(ret.begin() + pos, ret.end());\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971970,
                "title": "simple-java-stack-soln",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char present = s.charAt(i);\\n            if(present == \\')\\')\\n            {\\n                String temp = \"\";\\n                while(stack.peek()!=\\'(\\')\\n                {\\n                    temp = temp+stack.pop();\\n                }\\n                stack.pop(); //removing the )\\n                \\n                int j=0;\\n                while(j<temp.length())\\n                {\\n                    stack.push(temp.charAt(j));\\n                    j++;\\n                }\\n            }\\n            else\\n                stack.push(present);\\n        }\\n        \\n        String res = \"\";\\n        while(!stack.isEmpty())\\n            res = stack.pop() + res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char present = s.charAt(i);\\n            if(present == \\')\\')\\n            {\\n                String temp = \"\";\\n                while(stack.peek()!=\\'(\\')\\n                {\\n                    temp = temp+stack.pop();\\n                }\\n                stack.pop(); //removing the )\\n                \\n                int j=0;\\n                while(j<temp.length())\\n                {\\n                    stack.push(temp.charAt(j));\\n                    j++;\\n                }\\n            }\\n            else\\n                stack.push(present);\\n        }\\n        \\n        String res = \"\";\\n        while(!stack.isEmpty())\\n            res = stack.pop() + res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951392,
                "title": "reverse-the-string-using-two-pointers",
                "content": "not much different than https://leetcode.com/problems/reverse-string/discuss/951401/two-pointers\\n```\\ntime = O(n^2),  space = O(n)\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack();    \\n        char[] a = s.toCharArray();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c == \\'(\\') {\\n                st.push(i);\\n            } else if(c==\\')\\') {\\n                int index = st.pop();\\n                reverse(a,index,i);\\n            }\\n        }\\n        \\n        //reversing is done.\\n        //now keep only alphabets.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c != \\'(\\'&&c!=\\')\\') {\\n                sb.append(c);\\n            } \\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void reverse (char[] a, int i, int j) {\\n      //two-pointers\\n        while(i<j) {\\n           while(i<a.length && (a[i]==\\'(\\'||a[i]==\\')\\')) {\\n               i++;\\n           }\\n            while(j>=0 && (a[j]==\\'(\\'||a[j]==\\')\\')) {\\n               j--;\\n           }\\n            if(i>j) break;\\n            \\n            //swap\\n            char temp = a[i];\\n            a[i]  = a[j];\\n            a[j]  = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\ntime = O(n^2),  space = O(n)\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack();    \\n        char[] a = s.toCharArray();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c == \\'(\\') {\\n                st.push(i);\\n            } else if(c==\\')\\') {\\n                int index = st.pop();\\n                reverse(a,index,i);\\n            }\\n        }\\n        \\n        //reversing is done.\\n        //now keep only alphabets.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c != \\'(\\'&&c!=\\')\\') {\\n                sb.append(c);\\n            } \\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void reverse (char[] a, int i, int j) {\\n      //two-pointers\\n        while(i<j) {\\n           while(i<a.length && (a[i]==\\'(\\'||a[i]==\\')\\')) {\\n               i++;\\n           }\\n            while(j>=0 && (a[j]==\\'(\\'||a[j]==\\')\\')) {\\n               j--;\\n           }\\n            if(i>j) break;\\n            \\n            //swap\\n            char temp = a[i];\\n            a[i]  = a[j];\\n            a[j]  = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948644,
                "title": "javascript-recursive-and-stack-solution",
                "content": "```\\nvar reverseParentheses = function(S) {\\n  const open = \\'(\\' , close = \\')\\'\\n  const stack = [], openStack = []\\n  \\n  for(let i=0;i<S.length;i++){\\n    const s = S[i]\\n    if(s === open){\\n      openStack.push(i)\\n      continue\\n    }\\n    if(s === close){\\n      let openIdx = openStack.pop()\\n      let arr = S.slice(openIdx+1, i).split(\\'\\')\\n      const newS = S.slice(0,openIdx) + arr.reverse().join(\\'\\') + S.slice(i+1)\\n      return reverseParentheses(newS)\\n    }\\n  }\\n  return S\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar reverseParentheses = function(S) {\\n  const open = \\'(\\' , close = \\')\\'\\n  const stack = [], openStack = []\\n  \\n  for(let i=0;i<S.length;i++){\\n    const s = S[i]\\n    if(s === open){\\n      openStack.push(i)\\n      continue\\n    }\\n    if(s === close){\\n      let openIdx = openStack.pop()\\n      let arr = S.slice(openIdx+1, i).split(\\'\\')\\n      const newS = S.slice(0,openIdx) + arr.reverse().join(\\'\\') + S.slice(i+1)\\n      return reverseParentheses(newS)\\n    }\\n  }\\n  return S\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941410,
                "title": "c-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        const int n = s.size();\\n        \\n        stack<int> open;\\n        for(int i = 0 ; i < n ; ++i)\\n        {\\n            if(s[i] == \\'(\\') open.push(i);\\n            if(s[i] == \\')\\') \\n            {\\n                int index = open.top();\\n                open.pop();\\n                \\n                reverse(s.begin() + index, s.begin() + i);\\n            }\\n        }\\n        string t;\\n        for(char c: s)\\n        {\\n            if(c == \\'(\\' || c == \\')\\') continue;\\n            t += c;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        const int n = s.size();\\n        \\n        stack<int> open;\\n        for(int i = 0 ; i < n ; ++i)\\n        {\\n            if(s[i] == \\'(\\') open.push(i);\\n            if(s[i] == \\')\\') \\n            {\\n                int index = open.top();\\n                open.pop();\\n                \\n                reverse(s.begin() + index, s.begin() + i);\\n            }\\n        }\\n        string t;\\n        for(char c: s)\\n        {\\n            if(c == \\'(\\' || c == \\')\\') continue;\\n            t += c;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906506,
                "title": "simple-solution-by-using-stack-c-o-n-beat-100",
                "content": "SIMPLE SOLUTION BY USING STACK : C++ O(N) beat 100%\\n```\\n//please upvote if u like this approach.\\n//good understanding of stack data structure is pre-request.\\n//step - 1 : when ever u encounter \\'(\\' store index of that char in stack and reverse the string between \\')\\' char index and top of the stack.\\n//step - 2 : return all char except \\'(\\' and \\')\\' after traversing whole string.\\nstring reverseParentheses(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            } \\n        }\\n        string ans=\"\";\\n        for(auto i : s)\\n        {\\n            if(i!=\\'(\\'&&i!=\\')\\')\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//please upvote if u like this approach.\\n//good understanding of stack data structure is pre-request.\\n//step - 1 : when ever u encounter \\'(\\' store index of that char in stack and reverse the string between \\')\\' char index and top of the stack.\\n//step - 2 : return all char except \\'(\\' and \\')\\' after traversing whole string.\\nstring reverseParentheses(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            } \\n        }\\n        string ans=\"\";\\n        for(auto i : s)\\n        {\\n            if(i!=\\'(\\'&&i!=\\')\\')\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894676,
                "title": "c-with-one-stack",
                "content": "```\\npublic class Solution {\\n    string reverseInParentheses(string inputString) {\\n        if (inputString == null || inputString.Length <= 1) return inputString;\\n        \\n        var stack = new Stack<string>();\\n        string str = \"\";\\n        foreach (var c in inputString) {\\n            if (c <= \\'z\\' && c >= \\'a\\') {\\n                str += c;\\n            } else if (c == \\'(\\') {\\n                stack.Push(str);\\n                str = \"\";\\n            } else {\\n                var p = stack.Pop();\\n                var arr = str.ToCharArray();\\n                Array.Reverse(arr);\\n                var newstr = new string(arr); // reverse current\\n                str = p + newstr;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    string reverseInParentheses(string inputString) {\\n        if (inputString == null || inputString.Length <= 1) return inputString;\\n        \\n        var stack = new Stack<string>();\\n        string str = \"\";\\n        foreach (var c in inputString) {\\n            if (c <= \\'z\\' && c >= \\'a\\') {\\n                str += c;\\n            } else if (c == \\'(\\') {\\n                stack.Push(str);\\n                str = \"\";\\n            } else {\\n                var p = stack.Pop();\\n                var arr = str.ToCharArray();\\n                Array.Reverse(arr);\\n                var newstr = new string(arr); // reverse current\\n                str = p + newstr;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887111,
                "title": "java-solution-4-lines-logic",
                "content": "class Solution {\\n    public String reverseParentheses(String inputString) {\\n        StringBuilder str = new StringBuilder(inputString);\\n    int start, end;\\n    while(str.indexOf(\"(\") != -1){\\n        start = str.lastIndexOf(\"(\");\\n        end = str.indexOf(\")\", start);\\n        str.replace(start, end + 1, new StringBuilder(str.substring(start+1, end)).reverse().toString());\\n    }\\n    return str.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseParentheses(String inputString) {\\n        StringBuilder str = new StringBuilder(inputString);\\n    int start, end;\\n    while(str.indexOf(\"(\") != -1){\\n        start = str.lastIndexOf(\"(\");\\n        end = str.indexOf(\")\", start);\\n        str.replace(start, end + 1, new StringBuilder(str.substring(start+1, end)).reverse().toString());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 881014,
                "title": "super-easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        temp = []\\n        rev  = []\\n        \\n        for c in s:\\n            if c != \")\":\\n                rev.append(c)\\n            else: # c == \")\"\\n                temp_char = \"\"\\n                while(rev and temp_char!=\"(\"):\\n                    temp_char = rev.pop()\\n                    if temp_char!=\"(\":\\n                        temp.append(temp_char)\\n            rev+=temp\\n            temp = []\\n            \\n        return \"\".join(rev)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        temp = []\\n        rev  = []\\n        \\n        for c in s:\\n            if c != \")\":\\n                rev.append(c)\\n            else: # c == \")\"\\n                temp_char = \"\"\\n                while(rev and temp_char!=\"(\"):\\n                    temp_char = rev.pop()\\n                    if temp_char!=\"(\":\\n                        temp.append(temp_char)\\n            rev+=temp\\n            temp = []\\n            \\n        return \"\".join(rev)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866723,
                "title": "simple-recursion",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        int begin =-1, end =-1;\\n        for(int i =0;i<n;i++) { \\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n                begin=i;\\n            if(c==\\')\\') {\\n                end=i;\\n                return reverseParentheses(s.substring(0,begin) + reverse(s.substring(begin+1,end)) + s.substring(end+1,n ));\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    \\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        int begin =-1, end =-1;\\n        for(int i =0;i<n;i++) { \\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n                begin=i;\\n            if(c==\\')\\') {\\n                end=i;\\n                return reverseParentheses(s.substring(0,begin) + reverse(s.substring(begin+1,end)) + s.substring(end+1,n ));\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    \\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844737,
                "title": "swift-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for char in s {\\n            if char == \")\" {\\n                var str = \"\"\\n                while stack.last != \"(\" {\\n                    str.append(stack.removeLast())\\n                }\\n                // Remove \"(\" as well\\n                stack.removeLast()\\n                stack += str\\n            }\\n            else {\\n                stack.append(char)\\n            }\\n        }\\n        \\n        return String(stack)\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for char in s {\\n            if char == \")\" {\\n                var str = \"\"\\n                while stack.last != \"(\" {\\n                    str.append(stack.removeLast())\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 782010,
                "title": "0ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string reverseParentheses(string s) \\n    {\\n     stack<pair<char,int>> bracket;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                bracket.push(make_pair(s[i],i));\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n            reverse(s.begin()+bracket.top().second + 1,s.begin()+i);\\n                bracket.pop();\\n            }\\n        }\\n        string answer=\"\";\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n                    answer.push_back(s[i]);\\n            }\\n        return answer;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string reverseParentheses(string s) \\n    {\\n     stack<pair<char,int>> bracket;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                bracket.push(make_pair(s[i],i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 775472,
                "title": "swift-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for str in s {\\n            if str == \")\" {\\n\\t\\t\\t// as soon as we get a closing bracket, we start popping elements and saving into a new stack until we get an opening bracket\\n\\t\\t\\t// since we\\'re following a stack, removing from a stack and adding into a new, it already reversed the elements for us\\n                var revStr = [Character]()\\n                while stack.last != \"(\" {\\n                    revStr.append(stack.removeLast())\\n                }\\n\\t\\t\\t\\t// we\\'re removing the last because it\\'s an opening bracket and we don\\'t need it anymore\\n                stack.removeLast()\\n\\t\\t\\t\\t// simply adding the reversedString into our main stack\\n                stack += revStr\\n            } else {\\n\\t\\t\\t// appending everything else\\n                stack.append(str)\\n            }\\n        }\\n\\t\\t\\n        return String(stack)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for str in s {\\n            if str == \")\" {\\n\\t\\t\\t// as soon as we get a closing bracket, we start popping elements and saving into a new stack until we get an opening bracket\\n\\t\\t\\t// since we\\'re following a stack, removing from a stack and adding into a new, it already reversed the elements for us\\n                var revStr = [Character]()\\n                while stack.last != \"(\" {\\n                    revStr.append(stack.removeLast())\\n                }\\n\\t\\t\\t\\t// we\\'re removing the last because it\\'s an opening bracket and we don\\'t need it anymore\\n                stack.removeLast()\\n\\t\\t\\t\\t// simply adding the reversedString into our main stack\\n                stack += revStr\\n            } else {\\n\\t\\t\\t// appending everything else\\n                stack.append(str)\\n            }\\n        }\\n\\t\\t\\n        return String(stack)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746527,
                "title": "beat-99-python-easy-time-o-n",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        \\n        for e in s:\\n            if e == \\'(\\':\\n                stack.append(\\'\\')\\n            elif e == \\')\\':\\n                tmp = stack.pop()\\n                stack[-1] += tmp[::-1]\\n            else:\\n                stack[-1] += e\\n        \\n        return stack[-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        \\n        for e in s:\\n            if e == \\'(\\':\\n                stack.append(\\'\\')\\n            elif e == \\')\\':\\n                tmp = stack.pop()\\n                stack[-1] += tmp[::-1]\\n            else:\\n                stack[-1] += e\\n        \\n        return stack[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706428,
                "title": "java-solution",
                "content": "```\\npublic String reverseParentheses(String s) {\\n\\tif (!s.contains(\"(\")) {\\n\\t\\treturn s;\\n\\t}\\n\\n\\t// find the innermost bracket\\n\\tint end = s.indexOf(\\')\\');\\n\\tint start = s.substring(0, end).lastIndexOf(\\'(\\');\\n\\tif (end == s.length()) { // a(123)\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)));\\n\\t} else { // // a(123)b\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)) + s.substring(end + 1));\\n\\t}\\n}\\n\\n// reverse string\\npublic String reverseString(String s) {\\n\\tStringBuilder sb = new StringBuilder(s);\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) {\\n\\tif (!s.contains(\"(\")) {\\n\\t\\treturn s;\\n\\t}\\n\\n\\t// find the innermost bracket\\n\\tint end = s.indexOf(\\')\\');\\n\\tint start = s.substring(0, end).lastIndexOf(\\'(\\');\\n\\tif (end == s.length()) { // a(123)\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)));\\n\\t} else { // // a(123)b\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)) + s.substring(end + 1));\\n\\t}\\n}\\n\\n// reverse string\\npublic String reverseString(String s) {\\n\\tStringBuilder sb = new StringBuilder(s);\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 695027,
                "title": "c-simple-intuitive-using-stacks",
                "content": "This soluting beats 100% in time\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> stk;\\n        vector<pair<int,int>> pos;\\n        //find the index pairs of closing brackets using stacks\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\') stk.push(make_pair(s[i],i));\\n            else if(s[i] == \\')\\'){\\n                pos.push_back(make_pair(stk.top().second,i));\\n                stk.pop();\\n            }\\n        }\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //sort the pos vector acc to the length of the interval\\n        sort(pos.begin(),pos.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            return abs(p1.first - p1.second) < abs(p2.first - p2.second); \\n        });\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //reverse the string(in place) for each interval\\n        for(int i=0;i<pos.size();i++){\\n            //string temp = s.substr(pos[i].first, pos[i].second - pos[i].first + 1);\\n            auto start = s.begin() + pos[i].first;\\n            auto end = start + pos[i].second - pos[i].first;\\n            reverse(start, end);\\n            cout<<s<<\"\\\\n\";\\n        }\\n        //form the final result string\\n        string res = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] != \\'(\\' && s[i] != \\')\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> stk;\\n        vector<pair<int,int>> pos;\\n        //find the index pairs of closing brackets using stacks\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\') stk.push(make_pair(s[i],i));\\n            else if(s[i] == \\')\\'){\\n                pos.push_back(make_pair(stk.top().second,i));\\n                stk.pop();\\n            }\\n        }\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //sort the pos vector acc to the length of the interval\\n        sort(pos.begin(),pos.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            return abs(p1.first - p1.second) < abs(p2.first - p2.second); \\n        });\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //reverse the string(in place) for each interval\\n        for(int i=0;i<pos.size();i++){\\n            //string temp = s.substr(pos[i].first, pos[i].second - pos[i].first + 1);\\n            auto start = s.begin() + pos[i].first;\\n            auto end = start + pos[i].second - pos[i].first;\\n            reverse(start, end);\\n            cout<<s<<\"\\\\n\";\\n        }\\n        //form the final result string\\n        string res = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] != \\'(\\' && s[i] != \\')\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1751760,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1793963,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1568212,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1776456,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1573007,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1959093,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1828830,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1828809,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            }
        ]
    }
]